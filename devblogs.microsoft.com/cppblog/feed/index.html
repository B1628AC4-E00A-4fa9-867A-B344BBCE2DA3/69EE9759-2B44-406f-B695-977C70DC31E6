<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Mon, 25 Apr 2022 19:21:18 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Customizing GitHub Codespaces for C++ Projects</title>
		<link>https://devblogs.microsoft.com/cppblog/customizing-github-codespaces-for-cpp-projects/</link>
					<comments>https://devblogs.microsoft.com/cppblog/customizing-github-codespaces-for-cpp-projects/#respond</comments>
		
		<dc:creator><![CDATA[Michael Price]]></dc:creator>
		<pubDate>Mon, 25 Apr 2022 16:57:46 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Containers]]></category>
		<category><![CDATA[GitHub]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30481</guid>

					<description><![CDATA[<p>A walkthrough for creating a GitHub Codespace, customizing the Codespace development container, and configuring Visual Studio Code for developing in a C++ project such as microsoft/vcpkg-tool.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/customizing-github-codespaces-for-cpp-projects/">Customizing GitHub Codespaces for C++ Projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<blockquote><p>&#8220;There&#8217;s no worse punishment than worthless, hopeless labor.&#8221; — <em>The Myth of Sisyphus</em> by Albert Camus</p></blockquote>
<p>Configuring a development environment for a non-trivial C++ project is a process that can be error-prone, tedious, and time-consuming. For would-be contributors to projects, struggling with these initial steps can be a frustrating introduction to a project. Even seasoned developers may run into issues with their existing development environments when working on projects that have different, and sometimes conflicting, dependencies.</p>
<p>A <a href="https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/">GitHub Codespace</a> provides a cloud-hosted development container that can be customized specifically for a project, even permitting different customizations for different branches. In this walkthrough, you&#8217;ll learn how to create a codespace, customize the development container, and configure Visual Studio Code&#8217;s C++ extensions by walking through the steps for the <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a> repository.</p>
<p>&nbsp;</p>
<h2 id="preparation">Preparation</h2>
<p>&nbsp;</p>
<h3 id="availability-of-github-codespaces">Availability of GitHub Codespaces</h3>
<p>GitHub Codespaces are currently available to GitHub accounts that are members of organizations on a <a href="https://docs.github.com/en/get-started/learning-about-github/githubs-products#github-team">GitHub Team</a> or <a href="https://docs.github.com/en/get-started/learning-about-github/githubs-products#github-enterprise">GitHub Enterprise Cloud</a> plan. Access for individual users is currently in <a href="https://github.com/features/codespaces/signup">beta</a> testing. An organization owner can <a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/enabling-codespaces-for-your-organization">enable or disable codespaces for an organization</a> and <a href="https://docs.github.com/en/billing/managing-billing-for-github-codespaces/managing-spending-limits-for-codespaces">set spending limits</a> with only a few clicks. Organization owners can also apply policies that <a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/restricting-access-to-machine-types">restrict what machine types</a> are available to repositories in order to prevent excessive resource usage. If you are a C++ developer that currently does not have access to this feature, we&#8217;d like to <a href="https://www.surveymonkey.com/r/QLCBY56">learn more (survey link)</a> about your environment and interest in the feature.</p>
<h3 id="preparing-your-vcpkg-tool-repository">Preparing your vcpkg-tool repository</h3>
<p>vcpkg-tool is the repository for the front-end executable of the <a href="https://vcpkg.io/">vcpkg dependency manager</a>, which helps you manage C and C++ libraries for your project. The vcpkg ecosystem currently has around 2000 distinct <a href="https://vcpkg.io/en/packages.html">packages</a> in its catalog. You can learn more about vcpkg at the <a href="https://devblogs.microsoft.com/cppblog/category/vcpkg/">Microsoft C++ Blog</a>. Since you are unlikely to have permissions to modify the <a href="https://github.com/microsoft/vcpkg-tool">microsoft/vcpkg-tool</a> directly, you should use GitHub&#8217;s fork feature to obtain a copy of the repository into an account that you control. Navigate to <a href="https://github.com/microsoft/vcpkg-tool">https://github.com/microsoft/vcpkg-tool</a>, login, and click the <strong>Fork</strong> button for the repository. On the following page, click the <strong>Create fork</strong> button.</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/github-fork-vcpkg-tool.png" alt="Screenshot of page to create a fork for the microsoft/vcpkg-tool repository." /></p>
<p>After a few seconds, you should have a vcpkg-tool repository that you control and from which you can submit pull requests to the upstream repository. Since this is an active repository, the requirements for building it might have changed since this was written. So that you can reliably follow along, you should create a branch from commit <code>48006ab</code> and work from that point in history. To create a branch from that specific commit, append <code>/tree/48006ab</code> to the URL for your forked vcpkg-tool repository to browse the repository at that point in history, then click the dropdown branch button on the left of the page (it should show the commit hash <code>48006ab73a</code>), type in the desired name for your branch, and then click <strong>Create branch: &lt;your-branch-name-here&gt; from &#8216;48006ab&#8217;</strong>. Now, let&#8217;s explore the repository some to get an understanding of what is required to be able to build and test the project.</p>
<p>&nbsp;</p>
<h2 id="using-github-dev-to-explore-a-repository-with-visual-studio-code">Using github.dev to Explore a Repository with Visual Studio Code</h2>
<p><a href="https://github.dev">github.dev</a> is an instance of Visual Studio Code running in the browser, with no backing computation or storage behind it. It allows you to use many of the editor features of Visual Studio Code, including source control operations and many extensions, without requiring a clone of the repository or any tools beyond a web browser. It is a great way to explore a repository or to make simple changes that do not require building or testing your code. We&#8217;ll use it to explore our newly created repository so that we know what we need to do to properly set up a build and test environment for our codespace later on. This allows us to do a lot of the &#8220;busy work&#8221; without incurring charges for a codespace environment.</p>
<p>Press the <strong>.</strong> (period) key on your keyboard to open up github.dev for that repository. Alternatively, you can change the <code>github.com</code> domain for the URL to <code>github.dev</code> and load that web page. This works for any GitHub repository. After Visual Studio Code loads in the browser, you should notice that the Remote &#8220;Quick Access&#8221; status bar button in the lower left will indicate that you are connected directly to GitHub.</p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/github-dev-remote-quick-access.png" alt="Screenshot of the Remote &quot;Quick Access&quot; status bar showing a connection to GitHub" width="418" height="63" /></p>
<p>Feel free at this time to familiarize yourself with the features of Visual Studio Code by opening up the Command Palette by pressing <strong>Ctrl+Shift+P</strong> (<strong>Cmd+Shift+P</strong> on macOS) and running the <strong>Get Started: Open Walkthrough.</strong>.. command and selecting a walkthrough. Once you feel comfortable progressing, continue on with our exploration of the repository.</p>
<h3 id="build-and-test-prerequisites">Build and Test Prerequisites</h3>
<p>If you read through the Markdown (<code>.md</code>) files in the root of the repository and in the <code>docs/</code> directory, you&#8217;ll find a handful of tools that will need to be installed in order to build and test the repository. You may find further requirements in the root <code>CMakeLists.txt</code> file, such as requiring a C++17-capable compiler. The collection of things that must exist on the system in order to work in the project are:</p>
<ul>
<li>A C++17-capable compiler that CMake recognizes</li>
<li>CMake 3.15 or higher</li>
<li>A build system that CMake can generate files for (e.g. Ninja)</li>
<li>A copy of the <a href="https://github.com/microsoft/vcpkg">primary vcpkg repository</a>, and an environment variable <code>VCPKG_ROOT</code> that you&#8217;ve set to its location</li>
<li>clang-format for formatting source code according to the style provided by the <code>.clang-format</code> file</li>
</ul>
<p>Now we are ready to create our codespace!</p>
<p>&nbsp;</p>
<h2 id="creating-and-managing-your-codespace">Creating and Managing Your Codespace</h2>
<p>There are several ways you can create a new codespace for your newly forked vcpkg-tool repository.</p>
<ul>
<li>On the default page for your repository on github.com, you can click the <strong>&lt;&gt; Code</strong> button, click the <strong>Codespaces</strong> tab, and click the <strong>Create codespace on <em>&lt;branch-name&gt;</em></strong> button where <strong><em>&lt;branch-name&gt;</em></strong> is the name of the currently selected branch.. This button is actually a <a href="https://docs.microsoft.com/windows/win32/windowsribbon/windowsribbon-controls-splitbutton">split button</a>, that allows you to select customizations for your codespace environment such as the checked-out branch, the machine type, the region to use for the the GitHub-managed cloud instance, and the development container (i.e. devcontainer) configuration file to use.</li>
<li>At <a href="https://github.com/codespaces">https://github.com/codespaces</a>, you can click the <strong>New codespace</strong> button and select the repository and the customization options you&#8217;d like (as described above).</li>
<li>From within Visual Studio Code, you can create a codespace in two ways:
<ul>
<li>Open the Command Palette and run the <strong>Codespaces: Create New Codespace</strong> command and follow the prompts to provide the repository and customization options you&#8217;d like.</li>
<li>If you have the GitHub Codespaces extension installed, you can open the Remote Explorer in the side bar, hovering your mouse over the <strong>GITHUB CODESPACES</strong> section and clicking the <strong>+</strong> icon. You will be prompted for options similar to those if you ran the command from the Command Palette.</li>
</ul>
</li>
<li>You can create, manage, and connect to a codespace by using the <a href="https://cli.github.com/">GitHub CLI tool</a> and the <code>gh codespaces create</code> <a href="https://cli.github.com/manual/gh_codespace_create">command</a>.</li>
</ul>
<p>Because we should already have our default page for the newly forked repository open, we&#8217;ll use that method. Click the <strong>&lt;&gt; Code</strong> button, click the <strong>Codespaces</strong> tab, and click the selection arrow on the <strong>Create codespace&#8230;</strong> split button and select <strong>Configure and create codespace</strong>. Now click the split button to load the page where we can select our customizations.</p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/github-new-codespace-ext.png" alt="Screenshot of creating a codespace from within the repository on github.com" /></p>
<p>On the next page, select the options you&#8217;d like. Make sure that the branch you created earlier is selected, so that the codespace loads with the correct branch already checked out. Normally, you should let <strong>Region</strong> remain the default unless you know that you want your devcontainer virtual machine to be created in a specific cloud region. We&#8217;ll come back to <strong>Dev container configuration</strong> later on in the walkthrough.</p>
<h3 id="selecting-a-machine-type">Selecting a Machine Type</h3>
<p>The most impactful option to choose when you are creating a new codespace is the machine type. The machine type is the combination of virtualized hardware resources that will be available to your codespace, including number of CPU cores, amount of RAM, and the size of filesystem storage. The machine types that are allowed for a codespace are controlled by a combination of organization and account settings and constraints specified by the repository for which the codespace is being created. Currently, the available machine types and their <a href="https://docs.github.com/en/billing/managing-billing-for-github-codespaces/about-billing-for-codespaces">costs</a> (storage is an additional $0.07/GB-month) are*:</p>
<ul>
<li>2-core, 4GB RAM, 32GB disk &#8211; $0.18/hour</li>
<li>4-core, 8GB RAM, 32GB disk &#8211; $0.36/hour</li>
<li>8-core, 16GB RAM, 64GB disk &#8211; $0.72/hour</li>
<li>16-core, 32GB RAM, 128GB disk &#8211; $1.44/hour</li>
<li>32-core, 64GB RAM, 128GB disk &#8211; $2.88/hour</li>
</ul>
<p><sub>* Monetary units are in USD</sub></p>
<p>We&#8217;ll choose the cheapest available machine type while we work to get the codespace and the development container created and customized. Select the <strong>2-core</strong> option from the <strong>Machine type</strong> drop-down button and click <strong>Create codespace</strong>.</p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/github-create-codespace-dialog-vcpkg-tool.png" alt="Screenshot of codespace creation dialog" /></p>
<p>You should see a new page load in the browser that shows status information on the starting of the codespace and the initiation of a connection to the codespace. Once the codespace is ready to go, an instance of Visual Studio Code will load in the browser, remotely connected to the codespace.</p>
<h3 id="managing-your-codespace">Managing Your Codespace</h3>
<p>Your cloud-hosted codespace is available for you to connect to for as long as it exists. In order to control costs, a codespace will automatically shut down after a period of no activity, meaning you don&#8217;t have to worry about running up a large bill because you forgot to stop it before ending your workday. When you restart the codespace and reconnect, it will be in the same state it was when it shut down. Any non-committed or not-yet-pushed changes are still present, just as you left them.</p>
<p>You can manage your codespace directly from within Visual Studio Code by choosing one of the <strong>Codespaces:</strong> commands in the Command Palette, or you can execute the fundamental commands (starting, stopping, etc&#8230;) from the <a href="https://github.com/codespaces">GitHub Codespaces web page</a>. You can also use the GitHub CLI to manage your codespaces if you prefer working from a terminal window or scripting actions. A subset of the Command Palette commands are also available if you click on the Remote &#8220;Quick Access&#8221; status bar button, which now shows you that you are connected to a codespace.</p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/github-codespaces-remote-quick-access.png" alt="Screenshot of the Remote &quot;Quick Access&quot; status bar showing a connection to a codespace" width="471" height="59" /></p>
<p>Let&#8217;s go ahead and stop your newly created codespace and reconnect, so that you are comfortable with the experience. Run the <strong>Codespaces: Stop Current Codespace</strong> from the Command Palette. You could restart the codespace by clicking on the <strong>Restart codespace</strong> button, but let&#8217;s see what the experience is like from the main GitHub Codespaces web page. Navigate in your browser to <a href="https://github.com/codespaces">https://github.com/codespaces</a>. There, you should see your new codespace listed. If you click on the <strong>&#8230;</strong> to the right of your codespace entry, you&#8217;ll get a menu of management commands. If you would like to try out Visual Studio Code outside of the browser, and have it installed, click on <strong>Open in Visual Studio Code</strong>. Otherwise, click <strong>Open in browser</strong> to restart and connect to the codespace.</p>
<p>After you start your codespace, you can see a change on the GitHub Codespaces web page: your codespace has the <em>Active</em> label applied to it, and there&#8217;s a new <strong>Stop codespace</strong> action available. Now that you know how to start and stop your codespace and connect to it in different ways, let&#8217;s customize the development container used for it so that we can build the vcpkg-tool repository.</p>
<p>&nbsp;</p>
<h2 id="customizing-your-development-container">Customizing Your Development Container</h2>
<p>Development containers, or <em>devcontainers</em>, are customized environments capable of building a specific project, delivered using a container technology like Docker. Codespaces uses devcontainers for customizing the codespace environment, but the idea and tools are distinct and can be used for local container environments as well. In order to enable the use of devcontainers by the tools that recognize them, you have to add certain files into your repository. This allows the definition of your devcontainer to evolve along with the project itself, including tracking evolving requirements along different branches of your repository. Let&#8217;s add a <a href="https://code.visualstudio.com/docs/remote/create-dev-container">devcontainer specification</a> to our vcpkg-tool fork. GitHub recently added the ability to have <a href="https://github.blog/2022-04-20-codespaces-multi-repository-monorepo-scenarios/">multiple devcontainer definitions in your repository</a>. If you have multiple devcontainer definitions, you will be prompted for which one to use whenever you initially create a codespace.</p>
<p>From within your codespace, run the <strong>Codespaces: Add Development Container Configuration Files&#8230;</strong> command from the Command Palette. Follow the prompts and select the <strong>C++</strong> container configuration definition, the <strong>ubuntu21.04</strong> operating system version, and any of the <em>additional features to install</em> that you want (you won&#8217;t strictly need them for this walkthrough). Visual Studio Code will create a <code>.devcontainer</code> directory in the root of your project and it will contain a <code>devcontainer.json</code> file, a <code>Dockerfile</code> file, and a <code>reinstall-cmake.sh</code> file. The <code>reinstall-cmake.sh</code> file is just a helper file used by <code>Dockerfile</code> to help customize the version of CMake that gets installed on the system, and we can ignore its contents. You may also notice two notifications from Visual Studio Code asking whether you&#8217;d like to install recommended extensions for Docker or if you&#8217;d like to rebuild the container. Ignore them for now. Let&#8217;s take a look at the two relevant files and how we need to change them.</p>
<h3 id="the-dockerfile">The Dockerfile</h3>
<p><code>Dockerfile</code> is the file that Docker uses to assemble a container image. The syntax is <a href="https://docs.docker.com/engine/reference/builder/">well documented</a> by Docker and is fairly straightforward to understand. The Dockerfile that was created for us specifies the base container image to use, copies the CMake helper script to it, and optionally runs it on the container that is being built. The Dockerfile also has commented-out commands that would use vcpkg to install specific libraries and another set of commented-out commands that would install additional packages provided by the operating system&#8217;s package manager.</p>
<p>For our case, you&#8217;ll want to make the following changes (shown in &#8220;diff&#8221; format) to make sure that we are using a capable version of CMake, <code>clang-format</code> is installed, and that we have a copy of the vcpkg repository with the <code>VCPKG_ROOT</code> environment variable set. If you have additional packages you&#8217;d like installed, you can add them to the command after <code>clang-format</code>. After you make the changes, save the file.</p>
<pre><code class="language-diff">diff --git a/.devcontainer/Dockerfile b/.devcontainer/Dockerfile
index 7072fc9..4c8e31a 100644
--- a/.devcontainer/Dockerfile
+++ b/.devcontainer/Dockerfile
@@ -6,7 +6,7 @@ FROM mcr.microsoft.com/vscode/devcontainers/cpp:0-${VARIANT}

 # [Optional] Install CMake version different from what base image has already installed. 
 # CMake reinstall choices: none, 3.21.5, 3.22.2, or versions from https://cmake.org/download/
-ARG REINSTALL_CMAKE_VERSION_FROM_SOURCE="none"
+ARG REINSTALL_CMAKE_VERSION_FROM_SOURCE="3.23"

 # Optionally install the cmake for vcpkg
 COPY ./reinstall-cmake.sh /tmp/
@@ -19,5 +19,9 @@ RUN if [ "${REINSTALL_CMAKE_VERSION_FROM_SOURCE}" != "none" ]; then 
 # RUN su vscode -c "${VCPKG_ROOT}/vcpkg install &lt;your-port-name-here&gt;"

 # [Optional] Uncomment this section to install additional packages.
-# RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive 
-#     &amp;&amp; apt-get -y install --no-install-recommends &lt;your-package-list-here&gt;
 No newline at end of file
+RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive 
+    &amp;&amp; apt-get -y install --no-install-recommends clang-format
+
+# Obtain vcpkg repository and set VCPKG_ROOT
+RUN git clone --depth 1 https://github.com/microsoft/vcpkg /vcpkg
+ENV VCPKG_ROOT="/vcpkg"
 No newline at end of file</code></pre>
<h3 id="devcontainer-json">devcontainer.json</h3>
<p><code>devcontainer.json</code> is the file that the tools use to drive the devcontainer creation process. It has an <a href="https://github.com/microsoft/dev-container-spec">open and evolving specification</a> and should soon have a <a href="https://github.com/microsoft/dev-container-spec/issues/9">published reference implementation</a> as well. Currently, the syntax for the JSON is documented by Visual Studio Code <a href="https://code.visualstudio.com/docs/remote/devcontainerjson-reference">documentation</a>.</p>
<p>We&#8217;ll want to make the following change (shown in &#8220;diff&#8221; format) to our devcontainer.json file. This change will tweak the Visual Studio Code extensions that are installed. Feel free to add any additional extensions to the list that you are interested in using. After you make the change, save the file.</p>
<pre><code class="language-diff">diff --git a/.devcontainer/devcontainer.json b/.devcontainer/devcontainer.json
index 60ce4dc..11560db 100644
--- a/.devcontainer/devcontainer.json
+++ b/.devcontainer/devcontainer.json
@@ -15,8 +15,8 @@

        // Add the IDs of extensions you want installed when the container is created.
        "extensions": [
-               "ms-vscode.cpptools",
-               "ms-vscode.cmake-tools"
+               "ms-azuretools.vscode-docker",      // Tools for working with Dockerfiles
+               "ms-vscode.cpptools-extension-pack" // Collection of C and C++ extensions, including CMake
        ],

        // Use 'forwardPorts' to make a list of ports inside the container available locally.</code></pre>
<p>Now that we&#8217;ve modified our container configuration files, we need to rebuild the codespace container for the changes to apply. If the notification from Visual Studio Code about rebuilding the devcontainer is still visible, you can click <strong>Rebuild Now</strong> on that notification, otherwise, you can rebuild the container by clicking the Remote &#8220;Quick Access&#8221; status bar button and selecting <strong>Rebuild Container</strong> or by running the <strong>Codespaces: Rebuild Container</strong> command from the Command Palette.</p>
<p>Since a new Docker container image has to be created, this could take a short while. GitHub offers the ability to use GitHub Actions to <a href="https://docs.github.com/en/codespaces/prebuilding-your-codespaces/about-codespaces-prebuilds">generate prebuilt images</a> if it turns out that you might need to create these custom container images regularly.</p>
<p>Once the codespace is restarted and Visual Studio Code has reconnected, we should check and make sure that we have suitable C++ compilers installed on the system. We can do that by running some commands in the Terminal pane, which you can open up by pressing <strong>Ctrl+`</strong> (<em>note: that is a &#8216;backtick&#8217;</em>). The commands and your results should look like:</p>
<pre><code class="language-bash">@michaelbprice ➜ /workspaces/vcpkg-tool (main ✗) $ which g++ &amp;&amp; g++ -dumpversion &amp;&amp; g++ -std=c++17
/usr/bin/g++
10
g++: fatal error: no input files
compilation terminated.
@michaelbprice ➜ /workspaces/vcpkg-tool (main ✗) $ which clang++ &amp;&amp; clang++ -dumpversion &amp;&amp; clang++ -std=c++17
/usr/bin/clang++
12.0.0
clang: error: no input files
@michaelbprice ➜ /workspaces/vcpkg-tool (main ✗) $</code></pre>
<p>You will also notice that on the Activity Bar on the left side of Visual Studio Code, we now have icons for Docker and CMake, just as we expected. Next, we&#8217;ll configure the extensions in the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack</a> so that we can build, test, and work with the C++ code in the project.</p>
<p>&nbsp;</p>
<h2 id="configuring-visual-studio-code-for-c">Configuring Visual Studio Code for C++</h2>
<p>We have been consistently making improvements to the C++ experience in Visual Studio Code, much of which we&#8217;ve documented in <a href="https://devblogs.microsoft.com/cppblog/category/visual-studio-code/">blog posts on the Microsoft C++ Blog</a>. This section will describe the changes you need to make, but won&#8217;t go into a lot of the details. We suggest exploring our other blog posts and <a href="https://code.visualstudio.com/docs/cpp/introvideos-cpp">documentation</a> to get a better understanding.</p>
<h3 id="configuring-cmake-with-cmakepresets-json">Configuring CMake with CMakePresets.json</h3>
<p>CMake introduced a <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html?highlight=presets#manual:cmake-presets(7)">presets</a> feature in version 3.19 which has continued to evolve in subsequent releases. This feature allows for the definition of idiomatic configuration, build, and test command lines for a project. This increases consistency for developers and reduces the startup overhead for new contributors. It also provides a useful way to document the common patterns in a way that is &#8220;live&#8221; and is less likely to become stale documentation. In addition to all of those benefits for individual users, it also simplifies automated systems like continuous integration systems.</p>
<p>For our purposes, you should add the following <code>CMakePresets.json</code> file in the root of the repository. It must live directly beside the project&#8217;s root <code>CMakeLists.txt</code> file in order for CMake to locate it. You can do this via the Command Palette by making sure the root of the repository is selected in the Explorer and running the command <strong>File: New File</strong>. Then provide the name <code>CMakePresets.json</code> and copy the contents from here into the open JSON file in the source editor.</p>
<pre><code class="language-json">{
    "version": 3,
    "configurePresets": [
        {
            "name": "base",
            "hidden": true,
            "generator": "Ninja",
            "binaryDir": "${workspaceRoot}/out",
            "cacheVariables": {
                "CMAKE_INSTALL_PREFIX": "${workspaceRoot}/out/install/${presetName}"
            }
        },
        {
            "name": "benchmark-base",
            "hidden": true,
            "cacheVariables": { "VCPKG_BUILD_BENCHMARKING": "On" }
        },
        {
            "name": "debug",
            "displayName": "Debug",
            "cacheVariables": { "CMAKE_BUILD_TYPE": "Debug" }
        },
        {
            "name": "release",
            "displayName": "Release",
            "cacheVariables": { "CMAKE_BUILD_TYPE": "Release" }
        },
        {
            "name": "debug-benchmarks",
            "displayName": "Debug + Benchmarks",
            "inherits": [ "debug", "benchmark-base"]
        },
        {
            "name": "release-benchmarks",
            "displayName": "Release + Benchmarks",
            "inherits": [ "release", "benchmark-base" ]
        }
    ]
}</code></pre>
<p>After saving that file, delete the existing CMake cache and reconfigure by running the <strong>CMake: Delete Cache and Reconfigure</strong> command from the Command Palette. Select whichever configuration you are interested in. After configuration completes you should now be able to build the project! Click the <strong>Build</strong> button in the status bar or press the <strong>F7</strong> key.</p>
<h3 id="configuring-intellisense-for-visual-studio-code">Configuring IntelliSense for Visual Studio Code</h3>
<p>Congratulations! Because this project is using CMake and we are using the Visual Studio Code CMake extension, IntelliSense was set up based on the information that the CMake extension determined. There&#8217;s nothing additional you need to do in order to enable IntelliSense and use all of its great productivity features.</p>
<p>&nbsp;</p>
<h2 id="summary">Summary</h2>
<p>Using GitHub Codespaces and Visual Studio Code makes it easy to set up a repeatable, isolated, and accessible development environment for your C++ projects on GitHub. You can configure your environment to have all of the tools and features that a new contributor would need to get started quickly and be productive. Say goodbye to the days of new contributors struggling through hours or days of trying to get a system working, and bid farewell to having to push your not-yet-ready changes just so you can work from a different system.</p>
<h3 id="call-to-action">Call to Action</h3>
<p>If you are a member of an organization using GitHub Team or GitHub Enterprise Cloud, contact your organization owner today to <a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/enabling-codespaces-for-your-organization">get started</a>. If you aren&#8217;t a member of such an organization, <a href="https://github.com/features/codespaces/signup">sign up</a> for the GitHub Codespaces beta program now and optionally <a href="https://www.surveymonkey.com/r/QLCBY56">fill out our survey</a> to help us understand the demand from the C++ community. Once you have access, use this walkthrough to guide you to setting up your first codespace for C++ and then try it out on your own projects!</p>
<p>The vcpkg ecosystem is currently an <a href="https://devblogs.microsoft.com/cppblog/vcpkg-april-2022-release-is-now-available/">active, open-source community</a>. If you are interested in contributing to the vcpkg or vcpkg-tool projects, we&#8217;d love to have your help (<a href="https://twitter.com/vcpkg_io/status/1515008498458931200">we are also currently hiring</a>), and we encourage you to read and carefully follow the contribution sections of the respective repositories. We want to hear about your experiences with GitHub Codespaces and C++ in Visual Studio Code. Please let us know more what you liked and what improvements you&#8217;d like to see by contacting us on Twitter <a href="https://twitter.com/visualc">@VisualC</a> or by using the <a href="https://twitter.com/search?q=%23CodespacePlusPlus">#CodespacePlusPlus</a> hashtag. You can also email us at <a href="mailto://visualcpp@microsoft.com">visualcpp@microsoft.com</a>. If you have specific features to request or bugs to report, you can open a <a href="https://github.com/github/feedback/discussions/categories/codespaces-feedback">discussion on GitHub Codespaces</a> or you can file bugs with us at the <a href="https://developercommunity.visualstudio.com/search?space=62&amp;q=%5Bvs-cpp-roadmap&amp;stateGroup=active">Microsoft Developer Community site</a>.</p>
<p><strong>Happy Coding!</strong></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/customizing-github-codespaces-for-cpp-projects/">Customizing GitHub Codespaces for C++ Projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/customizing-github-codespaces-for-cpp-projects/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Pure Virtual C++ 2022 Pre-Conference Sessions Available</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-pre-conference-sessions-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-pre-conference-sessions-available/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Fri, 22 Apr 2022 15:00:57 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30461</guid>

					<description><![CDATA[<p>Our pre-conference sessions for Pure Virtual C++ 2022 are now online. Find them here, and hope to see you at the main event on 26th April!<br />
Session list:</p>
<p>MSVC C++20/23 update &#8211; Stephan T. Lavavej<br />
Indexed Find in Files &#8211; Christian Gunderman<br />
Dependent Breakpoints &#8211;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-pre-conference-sessions-available/">Pure Virtual C++ 2022 Pre-Conference Sessions Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png"><img class="aligncenter wp-image-27841 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png" alt="Pure Virtual C++ logo" width="640" height="168" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>Our pre-conference sessions for <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">Pure Virtual C++ 2022</a> are now online. Find them <a href="https://aka.ms/purevirtualcpp/ondemand">here</a>, and hope to see you at the main event on 26th April!</p>
<p>Session list:</p>
<ul type="disc">
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/msvc-cpp-20-23-update/">MSVC C++20/23 update</a> &#8211; Stephan T. Lavavej</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/indexed-find-in-files">Indexed Find in Files</a> &#8211; Christian Gunderman</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/dependent-breakpoints/">Dependent Breakpoints</a> &#8211; Sy Brand</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/stay-calm-and-stress-free-by-using-a-package-manager-an-overview-of-vcpkg/">Stay calm and stress-free by using a package manager: an overview of vcpkg</a> &#8211; Augustin Popa</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/targeting-macos-from-visual-studio/">Targeting macOS from Visual Studio</a> &#8211; Sinem Akinci</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/data-breakpoints-in-visual-studio-code/">Data Breakpoints in Visual Studio Code</a> &#8211; Julia Reid</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/hot-reload-for-cpp/">Hot Reload for C++</a> &#8211; David Li</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/productivity-in-visual-studio/">Productivity in Visual Studio</a> &#8211; Kyle Reed</li>
<li lang="en-US"><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/clang-tidy-in-visual-studio-code/">clang-tidy in Visual Studio Code</a> &#8211; Julia Reid</li>
</ul>
<p>There&#8217;s one session on Visual Studio for Unreal Engine and Game Developers which will be uploaded soon.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-pre-conference-sessions-available/">Pure Virtual C++ 2022 Pre-Conference Sessions Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-pre-conference-sessions-available/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg April 2022 Release is Now Available</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-april-2022-release-is-now-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-april-2022-release-is-now-available/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Fri, 22 Apr 2022 01:35:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30452</guid>

					<description><![CDATA[<p>The April 2022 release of the vcpkg package manager is available. This blog post summarizes changes from March 1st, 2022 to March 30th, 2022 for the microsoft/vcpkg and microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>24 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-april-2022-release-is-now-available/">vcpkg April 2022 Release is Now Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.04.12">April 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from March 1<sup>st</sup>, 2022 to March 30<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.04.12">microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/pull/441">microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>24 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>272 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,926 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are <strong>9,431 versioned ports</strong>. Vcpkg continues to maintain the largest C/C++ open-source catalog on the market.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.04.12">April release of the main vcpkg repo</a> includes <strong>281 merged PRs</strong> by <strong>83 people</strong>.</li>
<li>The main vcpkg repo has <strong>4.5k forks</strong> and <strong>15.5k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<h4 id="vcpkg-artifacts-merged-into-microsoft-vcpkg-tool-repo">vcpkg artifacts merged into Microsoft/vcpkg-tool repo</h4>
<p>vcpkg artifacts is our preview experience for acquiring binary packages, intended for developer tools like compilers, platform SDKs, and debuggers. This is a major step towards accepting external contributions for the vcpkg artifacts feature.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/428">Microsoft/vcpkg-tool#428</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-can-use-tar-exe-from-windows-10">vcpkg can use tar.exe from Windows 10</h4>
<p>To reduce our external dependency count for better reliability and performance, vcpkg now uses the Windows 10 in-box copy of tar to unzip our core dependencies. This removes the need for msiexec.exe during core operation on Windows 10 (though certain ports may still require it).</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/406">Microsoft/vcpkg-tool#406</a></p>
<p>&nbsp;</p>
<h4 id="anonymous-aws-s3-access-added-for-binary-caching-experience">Anonymous AWS S3 access added for binary caching experience</h4>
<p>This works via a new x-aws-config option in vcpkg.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/434">Microsoft/vcpkg-tool#434</a> (thank you <a href="https://github.com/AenBleidd">@AenBleidd</a>!)</p>
<p>&nbsp;</p>
<h4 id="improved-port-installation-error-logging-in-vcpkg-ci-system">Improved port installation error logging in vcpkg CI system</h4>
<p>When modifying a port, vcpkg builds not only the port itself, but all other ports depending on it or that are dependencies of the port. This is handled by our CI system, which must successfully complete this operation to accept PRs. We have improved the logging of which ports are being broken by a PR so that port maintainers have an easier time diagnosing what went wrong.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/468">Microsoft/vcpkg-tool#468</a></p>
<p>&nbsp;</p>
<h4 id="general-object-storage-interface-for-binary-caching">General object storage interface for binary caching</h4>
<p>Provides a consistent interface for using binary caching with different cloud providers.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/456">Microsoft/vcpkg-tool#456</a> (thank you <a href="https://github.com/day253">@day253</a>!)</p>
<p>&nbsp;</p>
<h4 id="progress-with-visual-studio-integration-experience">Progress with Visual Studio integration experience</h4>
<p>We have not yet finished our improved Visual Studio integration experience for vcpkg, but progress was made this release, including signed PowerShell scripts and a packaging step that was added to the tool.</p>
<p>PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/451">Microsoft/vcpkg-tool#451</a> &amp; <a href="https://github.com/microsoft/vcpkg-tool/pull/399">Microsoft/vcpkg-tool#399</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-tool-no-longer-depends-on-ninja">vcpkg tool no longer depends on ninja</h4>
<p>Ninja is no longer a dependency of the vcpkg tool, reducing the overhead of installing 3<sup>rd</sup> party tools for vcpkg to function. Some individual ports may still require Ninja and it will be acquired in these circumstances as part of their build scripts.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/372">Microsoft/vcpkg-tool#372</a> (thank you <a href="https://github.com/Neumann-A">@Neumann-A</a>!)</p>
<p>&nbsp;</p>
<h4 id="git_askpass-support">GIT_ASKPASS support</h4>
<p>An environment variable has been added for GIT_ASKPASS. This is used to point git toward a binary that implements git’s credential manager interface and can be used for private repository authentication.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/441">Microsoft/vcpkg-tool/#441</a> (thank you <a href="https://github.com/horenmar">@horenmar</a>!)</p>
<p>&nbsp;</p>
<h4 id="removed-many-uses-of-stdregex-in-the-vcpkg-code">Removed many uses of std::regex in the vcpkg code</h4>
<p>We’ve been removing uses of <code>std::regex</code> throughout the code to improve vcpkg performance.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/427">Microsoft/vcpkg-tool/#427</a></p>
<p>&nbsp;</p>
<h4 id="instructions-for-using-vcpkg-in-arch-linux">Instructions for using vcpkg in Arch Linux</h4>
<p>Added user <a href="https://github.com/microsoft/vcpkg/pull/23676">instructions for Arch Linux</a> during vcpkg bootstrap.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/23676">Microsoft/vcpkg/#23676</a> (thank you <a href="https://github.com/bwrsandman">@bwrsandman</a>!).</p>
<p>&nbsp;</p>
<h4 id="vcpkg-works-again-with-cmake-versions-3-19">vcpkg works again with CMake versions &lt;= 3.19</h4>
<p>Fixed a bug that was breaking the vcpkg CMake toolchain file for CMake versions 3.19 and earlier.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/23410">Microsoft/vcpkg/#23410</a> (thank you <a href="https://github.com/dg0yt">@dg0yt</a>!)</p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,731</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,776</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,667</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,691</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>880</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,315</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>826</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,641</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,713</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is routinely tested to ensure updated ports don’t break other ports in the catalog.</p>
<p><em>Fun fact:</em> we have so many x64-windows ports now that it takes over 24 hours to build them as part of our package testing process. We had to <a href="https://github.com/microsoft/vcpkg/pull/23601">increase the timeout on these builds</a> to compensate for the added time.</p>
<p>&nbsp;</p>
<h3 id="documentation">Documentation</h3>
<p>Minor documentation changes were made for several vcpkg functions. We also want to thank our community contributor <a href="https://github.com/zhangfuwen">@zhangfuwen</a> for <a href="https://github.com/microsoft/vcpkg/pull/23690">updating our Android usage documentation</a> as well.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos between March 1 – March 30, 2022:</p>
<ul>
<li>autoantwort (22 commits)</li>
<li>dg0yt (17 commits)</li>
<li>Thomas1664 (12 commits)</li>
<li>Neumann-A (11 commits)</li>
<li>coryan (4 commits)</li>
<li>horenmar (3 commits)</li>
<li>Ryan-rsm-McKenzie (3 commits)</li>
<li>RT222 (3 commits)</li>
<li>chausner (3 commits)</li>
<li>Pospelove (2 commits)</li>
<li>hkaiser (1 commit)</li>
<li>ZeeWanderer (1 commit)</li>
<li>cenit (1 commit)</li>
<li>Hoikas (1 commit)</li>
<li>mathisloge (1 commit)</li>
<li>day253 (1 commit)</li>
<li>xvitaly (1 commit)</li>
<li>bhardwajs (1 commit)</li>
<li>AenBleidd (1 commit)</li>
<li>mprather (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.04.12">full April release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-april-2022-release-is-now-available/">vcpkg April 2022 Release is Now Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-april-2022-release-is-now-available/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s new for C++ Debugging in Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-c-debugging-in-visual-studio-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-c-debugging-in-visual-studio-code/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Wed, 20 Apr 2022 20:20:17 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30425</guid>

					<description><![CDATA[<p>It’s been a minute since our last blog post about C++ in VS Code, but we’ve been working hard on new features and bug fixes! Today, we’re excited to fill you in on the latest and greatest C++ debugger improvements in VS Code,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-debugging-in-visual-studio-code/">What’s new for C++ Debugging in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>It’s been a minute since our last blog post about C++ in VS Code, but we’ve been working hard on new features and bug fixes! Today, we’re excited to fill you in on the latest and greatest C++ debugger improvements in VS Code, including support for the Apple M1 chip, data breakpoints, and a new run/debug play button!</p>
<h1 id="apple-silicon-arm64-m1-chip">Apple Silicon ARM64 (M1 chip)</h1>
<p>Last year, we enabled language server support for Apple Silicon ARM64 architecture, which meant you could run the C++ extension’s language server (responsible for things like IntelliSense, code navigation, and autocomplete) natively on the Apple M1 chip. At the time, the C++ extension’s debugger binaries did not run natively on the M1 chip. Now, they do!</p>
<p>With <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/v1.9.7">this latest release</a> of the C++ extension, you can seamlessly debug C++ programs when running VS Code on the M1 chip. Give it a try and let us know what you think! If you run into any issues, please follow up on the <a href="https://github.com/microsoft/vscode-cpptools/issues/7035">GitHub tracking issue (#7035)</a>.</p>
<h1 id="data-breakpoints">Data breakpoints</h1>
<p>In case you missed it, version 1.8.4 of the C++ extension brought support for <a href="https://github.com/microsoft/vscode-cpptools/issues/1410">data breakpoints (#1410)</a> while debugging C++ programs with GDB in VS Code. Data breakpoints break execution when a value stored at a specified memory address changes.</p>
<p>To set a data breakpoint while debugging in VS Code, right click on a variable in the debug pane and select <strong>Break on Value Change</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change.png"><img class="alignnone size-full wp-image-30430" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change.png" alt="Screenshot of the context menu that appears when a user right clicks on a local variable in the Debug pane. The Break on Value Change menu item is selected." width="2626" height="1808" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change.png 2626w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change-300x207.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change-1024x705.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change-768x529.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change-1536x1058.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/break-on-value-change-2048x1410.png 2048w" sizes="(max-width: 2626px) 100vw, 2626px" /></a></p>
<p>Immediately, you’ll see the data breakpoint listed in the <strong>Breakpoints</strong> section of the debug pane.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-in-window.png"><img class="alignnone size-full wp-image-30429" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-in-window.png" alt="Screenshot of the data breakpoint listed in the Breakpoints section of the Debug pane" width="948" height="304" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-in-window.png 948w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-in-window-300x96.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-in-window-768x246.png 768w" sizes="(max-width: 948px) 100vw, 948px" /></a></p>
<p>In this example, if we continue running the program, the next time it breaks will be when local variable <code>i</code> changes value. Use the debug control panel to continue running the program.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/debug-continue.png"><img class="alignnone size-full wp-image-30427" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/debug-continue.png" alt="screenshot of the debug control panel, hovering over the continue button." width="598" height="144" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/debug-continue.png 598w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/debug-continue-300x72.png 300w" sizes="(max-width: 598px) 100vw, 598px" /></a></p>
<p>Sure enough, execution breaks when <code>i</code> changes value from 1 to 2.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed.png"><img class="alignnone size-full wp-image-30428" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed.png" alt="Screenshot of the debugger pausing when local variable i changes value" width="2308" height="1630" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed.png 2308w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed-300x212.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed-1024x723.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed-768x542.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed-1536x1085.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/broke-when-i-changed-2048x1446.png 2048w" sizes="(max-width: 2308px) 100vw, 2308px" /></a></p>
<h2 id="troubleshooting-data-breakpoints">Troubleshooting data breakpoints</h2>
<p>In this same example program, if you set a data breakpoint on <code>msg</code> of type string, you might see an error message in the Debug Console that says: <code>Unable to set data breakpoint: Value does not fall within the expected range. (Parameter ‘size’)</code>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error.png"><img class="alignnone size-full wp-image-30426" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error.png" alt="Screenshot of the error message seen when a user tries to set a data breakpoint on a data type that is too large, like string." width="3030" height="1878" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error.png 3030w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error-300x186.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error-1024x635.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error-768x476.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error-1536x952.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/data-breakpoint-size-error-2048x1269.png 2048w" sizes="(max-width: 3030px) 100vw, 3030px" /></a></p>
<p>This is because the string type is 32 bytes, and there’s a limitation on the size we can set data breakpoints on. This limitation comes from the fact that the architecture that your program runs on has a limited number of hardware data breakpoints it can use. The table below shows how many registers are available to use per architecture.</p>
<table width="613">
<thead>
<tr>
<td colspan="3"><strong>DATA BREAKPOINT HARDWARE LIMITATIONS</strong></td>
</tr>
<tr>
<td><strong>Architecture</strong></td>
<td><strong>Number of hardware supported data breakpoints</strong></td>
<td><strong>Max byte size</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td>x86</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>x64</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>ARM</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>ARM64</td>
<td>2</td>
<td>8</td>
</tr>
</tbody>
</table>
<h1 id=""></h1>
<h1 id="quick-run-debug-play-button">Quick run/debug play button</h1>
<p>We know that setting up tasks.json and launch.json to run and debug C++ files isn’t always fun. We’re excited to announce that, thanks to this latest release, running and debugging C++ files in VS Code has never been easier!</p>
<p>With the <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/v1.9.7">1.9.7 update</a>, you’ll see a play button in the top right corner of the editor whenever a C or C++ file is active. It’s the same play button used by the Python extension, Java extension, and Code Runner extension.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button.png"><img class="alignnone size-full wp-image-30433" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button.png" alt="Screenshot of helloworld.cpp active in the editor with the run and debug play button in the title bar" width="3188" height="1996" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button.png 3188w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button-300x188.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button-1024x641.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button-768x481.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button-1536x962.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-play-button-2048x1282.png 2048w" sizes="(max-width: 3188px) 100vw, 3188px" /></a></p>
<p>The play button has two modes: “Run C/C++ File” and “Debug C/C++ File.” The default mode is “Run C/C++ File,” and you can use the drop-down to switch modes.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-debug-drop-down.png"><img class="alignnone size-full wp-image-30432" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-debug-drop-down.png" alt="Screenshot of the drop-down menu in the run and debug play button" width="446" height="270" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-debug-drop-down.png 446w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/run-debug-drop-down-300x182.png 300w" sizes="(max-width: 446px) 100vw, 446px" /></a></p>
<p>If you already have a launch.json file in your workspace, the play button will read from it when figuring out how to run and debug your C++ file. If you don’t have launch.json, the play button will create a temporary “quick debug” configuration on the fly, eliminating the need for launch.json altogether!</p>
<p>We also simplified <strong>F5</strong> (<strong>Run &gt; Start Debugging</strong>) to use the same temporary “quick debug” configurations as the play button when your project doesn’t have launch.json. If you need to create launch.json to customize debugging, select <strong>Run &gt; Add Configuration&#8230; </strong>from the main menu.</p>
<p><strong>Note: </strong>We&#8217;re still rolling out the run/debug play button, so you might not see it by default, but you can opt in by enabling <strong>C_Cpp: Debug Shortcut</strong> in User settings.</p>
<h1 id="what-do-you-think">What do you think?</h1>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>. We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-debugging-in-visual-studio-code/">What’s new for C++ Debugging in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-c-debugging-in-visual-studio-code/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Pure Virtual C++ 2022 Schedule Available</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Wed, 13 Apr 2022 15:00:26 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30411</guid>

					<description><![CDATA[<p>Pure Virtual C++ 2022 is a free, one-day virtual conference for the whole C++ community. The schedule is now available. You can find the full set of abstracts, alongside calendar files to download on the website.<br />
All times UTC on the 26th April.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/">Pure Virtual C++ 2022 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png"><img class="wp-image-27841 size-large aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png" alt="Pure Virtual C++ logo" width="640" height="168" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>Pure Virtual C++ 2022 is a free, one-day virtual conference for the whole C++ community. The schedule is now available. You can find the full set of abstracts, alongside calendar files to download <a tabindex="0" href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/" data-cke-saved-href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">on the website</a>.</p>
<p>All times UTC on the 26th April.</p>
<ul>
<li>14:04 &#8211; What&#8217;s New In C++23, Sy Brand</li>
<li>14:37 &#8211; Cute C++ Tricks, Part 2 of N: More code you should learn from and never write, Daisy Hollman</li>
<li>15:12 &#8211; Embedded development with VS and VS Code, Marc Goodner</li>
<li>15:47 &#8211; Everything I learned about static analysis and program safety in C++, Sunny Chatterjee</li>
<li>16:22 &#8211; Persistent Representation of C++ for Fun and Profit, Gabriel Dos Reis</li>
</ul>
<p>Yes, I know the times look a bit weird, it&#8217;ll work out on the day!</p>
<p>Look forward to seeing you there!</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/">Pure Virtual C++ 2022 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>New Enumeration Checks in Visual Studio 2022 version 17.2 Preview 3</title>
		<link>https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/</link>
					<comments>https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Tue, 12 Apr 2022 15:00:43 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30396</guid>

					<description><![CDATA[<p>New Enumeration Checks in Visual Studio 2022</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/">New Enumeration Checks in Visual Studio 2022 version 17.2 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/search?space=62">C++ Developer Community </a>page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the detailed overview of some new code analysis checks that can detect enumeration misuse errors, along with some improvements to an existing enumeration check.</p>
<h2 id="overview">Overview</h2>
<p>We introduced three new checks to find potential misuse of enumerations with bitwise operations. These checks were inspired by real bugs found in production code. We also improved a check that suggests using the C++11 scoped <code>enum</code> instead of its legacy counterpart. See the <a href="https://docs.microsoft.com/cpp/build/reference/analyze-code-analysis">documentation</a> on how to enable code analysis for your project.</p>
<h2 id="bitwise-enumerations">Bitwise enumerations</h2>
<p>Some enumerations hold values that are powers of two. Most of these are flags used to represent non-exclusive states that can be combined and queried using bitwise operations. The new checks are trying to detect wrong uses of such enumerations. Unfortunately, there is no clear definition of what enumerations should be considered bitwise, so our checks rely on a set of heuristics to infer the intent from the source code. First of all, let us consider an <code>enum</code> with only two elements:</p>
<pre><code class="language-cpp">enum E
{
    A = 1,
    B = 2
};</code></pre>
<p>It is not clear whether <code>E</code>&#8216;s values are intended to form the start of a sequence of powers of two <code>(1,2,4,8,...)</code>, or are simply intended to increment by 1 <code>(1,2,3,4,...)</code>. Without additional context, we therefore cannot tell whether <code>E</code> is a bitwise <code>enum</code>, intended to be used with bitwise operations, or if it is just a regular <code>enum</code>.</p>
<pre><code class="language-cpp">enum E
{
    A = 1,
    B = 2,
    C = 4,
    D = 8,
    ALL = 15
};</code></pre>
<p>Here, the last <code>enum</code> constant is not a power of two. It is a common idiom to define a constant where all of the relevant bits are set. These constants usually have a value of <code>2^k-1</code> for some positive <code>k</code>. Our checks will consider <code>enum</code>s of this shape as bitwise. We have to be careful with the interplay of these two heuristics.</p>
<pre><code class="language-cpp">enum E1
{
    A = 1,
    B = 2,
    C = 3
};

enum E2
{
    A = 1,
    B = 2,
    C = 4
};</code></pre>
<p>In the above example, we do not want to consider <code>E1</code> bitwise, despite its last element having the value of <code>2^2-1</code>. On the other hand, we definitely want to consider <code>E2</code> a bitwise <code>enum</code>.</p>
<p>These heuristics worked reasonably well for the projects we tested our checks on. In case you encounter any false positives or false negatives, please let us know.</p>
<h2 id="c26813">C26813</h2>
<p><a href="https://aka.ms/cpp/warnings/C26813">C26813</a> will find code patterns where a bitwise enumeration&#8217;s value is being tested using <code>operator==</code>.
In most cases, a variable holding values from a bitwise enumeration represents a bitfield. To query whether a particular enumerator value was set in this variable, bitwise operations should be used. Failing to do so will yield incorrect results:</p>
<pre><code class="language-cpp">enum BitWise
{
    A = 1,
    B = 2,
    C = 4
};

void useEqualsWithBitwiseEnum(BitWise a) 
{
    BitWise a = A; // turn on flag A
    a |= B; // turn on flag B

    /*
    *  Attempt to query if flag 'B' was set.
    */

    if (a == B) // Warning C26813: Use 'bitwise and' to check if a flag is set
    {
        foo(); // never reached, since a != B
    }

    if (a &amp; B)
    {
        bar(); // the branch is taken, as expected
    }
}</code></pre>
<p>After running this check on some real world code we also encountered cases where the <code>enum</code> had power of two values, but was never used with bitwise operations. In those cases it might be good idea to change the values of the <code>enum</code> constants to make the intent clearer in the code.</p>
<h2 id="c26827">C26827</h2>
<p><a href="https://aka.ms/cpp/warnings/C26827">C26827</a> can help detect enumerator constants in bitwise enumerations where we forgot to add an initializer. Consider the following example:</p>
<pre><code class="language-cpp">enum class AlmostBitWise
{
    A = 1,
    B = 2,
    C = 4,
    D
};

int almostBitwiseEnums(AlmostBitWise a) 
{
    return (int)a|(int)AlmostBitWise::A; // Warning C26827: Did you forget to initialize an enum, or intend to use another type?
}</code></pre>
<p>Here, we use an <code>enum</code> constant in a bitwise operation while not all of its constants have the form of <code>2^k</code> or <code>2^k-1</code>. In fact, one of its constants <code>D</code> has the form of <code>2^k+1</code>. This pattern can happen when we add a new constant without defining its value.</p>
<p>Unfortunately, there is a limitation of this check. It will only work with scoped <code>enum</code>s as the compiler will desugar regular enums into integers before the static analysis phase. We are looking into ways to improve our internal representation of the code to have a higher fidelity representation of how the code was written, and this will enable better diagnostics in the future.</p>
<h2 id="c26828">C26828</h2>
<p><a href="https://aka.ms/cpp/warnings/C26828">C26828</a> will flag bitwise expressions where values from different enumerations are mixed. Consider the following example:</p>
<pre><code class="language-cpp">
enum BitWiseA
{
    A = 1,
    B = 2,
    C = 4
};

enum class BitWiseB
{
    AA = 1,
    BB = 2,
    CC = 4,
    All = 7
};

int overlappingBitwiseEnums(BitWiseA a) 
{
    return (int)a|(int)BitWiseB::AA; // Warning C26828: Different enum types have overlapping values. Did you want to use another enum constant here?
}</code></pre>
<p>Here <code>BitWiseA</code> and <code>BitWiseB</code> have overlapping values. It is unlikely that we wanted to use both in the same bitwise expression. It can be the result of a typo.</p>
<p>This check has similar limitations to <code>C26827</code>.</p>
<h2 id="improvements-to-c26812">Improvements to C26812</h2>
<p><a href="https://aka.ms/cpp/warnings/C26812">C26812</a> suggests to use the new C++11 scoped <code>enum</code>s over legacy <code>enum</code>s. This check has been the part of our offerings for a really long time but had room for improvement. Previously, it diagnosed legacy <code>enum</code>s at their use-sites instead of at their declarations. This had several consequences:</p>
<ul>
<li>We did not emit a warning for unused enumerations.</li>
<li>It was not possible to suppress all instances of this warning at the declaration. This was also reported by our users as a <a href="https://developercommunity.visualstudio.com/t/Warning-C26812-is-not-suppressible-at-en/1448578">Developer Community ticket</a>.</li>
<li>It did not work well with the new <a href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">/external</a> feature. See the corresponding <a href="https://developercommunity.visualstudio.com/t/Code-Analysis-warning-C26812-is-reported/1637803">Developer Community ticket</a> for details.</li>
<li>The location of the diagnostic is potentially far from the declaration, which makes it harder to address the warning.</li>
</ul>
<p>The new version of this check will emit the diagnostic on the declarations instead of the uses. This should improve the user experience in most cases. We also realized that addressing this check is sometimes costly or not possible at all (e.g., a library might need to be backward compatible). To address this, we removed this rule from the <code>NativeRecommendedRules</code> ruleset and created a new ruleset named <code>CppCoreCheckEnumRules</code> to include all 4 of the rules we mentioned in this blog post.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The upcoming Visual Studio 2022 17.2 Preview 3 will feature new checks to find hard-to-find misuses of enumerations. It will also include some quality of life improvements for the existing check that can help migrate a code base to scoped enums. The three new <code>enum</code> related checks are part of the <code>NativeRecommendedRules</code> ruleset and the updated warning was moved to <code>CppCoreCheckEnumRules</code>.</p>
<h2 id="try-it-out-and-let-us-know-what-you-think">Try it out and let us know what you think:</h2>
<p>The work that we do is heavily influenced by feedback we receive on <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check. Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/">New Enumeration Checks in Visual Studio 2022 version 17.2 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Sign Up for the Pure Virtual C++ 2022 Conference</title>
		<link>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/</link>
					<comments>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Fri, 08 Apr 2022 18:52:39 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30382</guid>

					<description><![CDATA[<p>In the last couple of years we have run Pure Virtual C++, a free one-day virtual conference for the whole C++ community. This month we&#8217;re doing it again! Sign-up for free on the website to be the first to hear about our program schedule,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/">Sign Up for the Pure Virtual C++ 2022 Conference</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><img width="1376" height="362" class="wp-image-27841" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w" sizes="(max-width: 1376px) 100vw, 1376px" /></p>
<p>In the last couple of years we have run Pure Virtual C++, a free one-day virtual conference for the whole C++ community. This month we&#8217;re doing it again! <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">Sign-up for free on the website</a> to be the first to hear about our program schedule, access our extra on-demand C++ demos, and get more virtual surprises.</p>
<p>The live event will run <strong>April 26th 14:00-17:00 UTC</strong> on <a href="https://docs.microsoft.com/en-us/learn/tv/">Microsoft Learn TV</a>. It will also be streamed to YouTube and videos will be available to watch after the event.</p>
<p>The full program will be announced soon, but expect content on C++23, modules, static analysis, embedded C++, and some fun C++ corners you might not know about. In addition to the live sessions, we&#8217;ll be releasing on-demand content in the run-up to the conference.</p>
<p>The Pure Virtual C++ conference is organized by Microsoft and will be run under the <a href="https://docs.microsoft.com/en-gb/legal/learntv/codeofconduct">Learn TV Code of Conduct</a>.</p>
<p>Get involved in the conversation on Twitter using the #purevirtualcpp hashtag.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/">Sign Up for the Pure Virtual C++ 2022 Conference</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Using GitHub Codespaces and Visual Studio Code for C++ Development</title>
		<link>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/#comments</comments>
		
		<dc:creator><![CDATA[Michael Price]]></dc:creator>
		<pubDate>Mon, 04 Apr 2022 22:22:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Containers]]></category>
		<category><![CDATA[GitHub]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30359</guid>

					<description><![CDATA[<p>GitHub Codespaces and Visual Studio Code lower the barrier to entry for developing C++-based applications and libraries.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/">Using GitHub Codespaces and Visual Studio Code for C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Whether you are just learning the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1000r4.pdf">quickly evolving C++ programming language</a>, an open-source developer patching a zero-day vulnerability in a low-level C++ library, or an experienced professional writing software in C or C++ for <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">embedded devices</a> or enterprise applications, <a href="https://github.com/features/codespaces">GitHub Codespaces</a> and <a href="https://code.visualstudio.com/">Visual Studio Code</a> combine to significantly lower the costs associated with configuring your environment, building, and testing your code. It doesn&#8217;t matter whether your computer&#8217;s operating system is Microsoft Windows, Apple macOS, or your favorite Linux distribution, Visual Studio Code works on them all. You can even work from the web browser of your mobile iOS or Android device.</p>
<h2 id="visual-studio-code-and-github-dev">Visual Studio Code and github.dev</h2>
<p>GitHub offers built-in support for Visual Studio Code developers via <a href="https://github.dev">github.dev</a>. For any repository hosted on GitHub, you can nearly instantly open an instance of Visual Studio Code directly in your web browser. In this environment, many of Visual Studio Code&#8217;s <a href="https://code.visualstudio.com/docs/editor/codebasics">navigation and editing features</a> are fully functional. You can search for strings in your repository or edit files and commit them to new branches. You can even install many of the great Visual Studio Code extensions from the <a href="https://marketplace.visualstudio.com/VSCode">Visual Studio Code Marketplace</a>.</p>
<h2 id="visual-studio-code-and-github-codespaces">Visual Studio Code and GitHub Codespaces</h2>
<p>Once you push changes to your repository using <a href="https://github.dev">github.dev</a>, any <a href="https://docs.github.com/en/actions">GitHub Actions</a> that are registered for your branch will execute, including any build or test actions such as the <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions">Microsoft C++ Code Analysis action</a>. But you might want to build and test your changes before pushing your changes up to GitHub. For this, you can
<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/creating-a-codespace">create</a> or <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/developing-in-a-codespace">connect</a> to an existing GitHub Codespace directly from Visual Studio Code (including the in-browser instance loaded by github.dev) or from the normal GitHub web page for the repository. <em>NOTE: GitHub Codespaces is currently only available to members of eligible organizations. See <a href="#known-limitations">Known Limitations</a> for more information.</em></p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/vscode-remotes-codespaces.png" alt="Screenshot of Visual Studio Code showing available Codespaces. A popout is displaying properties of the selected codespace." /></p>
<h3 id="visual-studio-code-is-a-first-class-editor-for-c-and-c">Visual Studio Code is a <a href="https://code.visualstudio.com/docs/languages/cpp">First-Class Editor for C and C++</a></h3>
<p>The extensibility model for Visual Studio Code is one of its most powerful features. It enables developers across the globe to produce terrific extensions. Microsoft has bundled many of the best extensions for C and C++ development into the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack</a>, which makes developing for one of the world&#8217;s most versatile programming languages as easy as it&#8217;s ever been. From extensions for build systems like <a href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code">Make</a> and build system generators like <a href="https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code">CMake</a>, to debugging and C++ static analysis tools and rich editor features like syntax highlighting and <a href="https://code.visualstudio.com/docs/editor/intellisense">IntelliSense</a> code completion, Visual Studio Code has what you need to get the job done, and it continues to improve with every release. Combining Visual Studio Code&#8217;s terrific support for C++ development with GitHub Codespaces&#8217; ease-of-use and portability, means that it&#8217;s easier than ever before to deliver your product or solution.</p>
<h3 id="true-portability-with-codespaces">True Portability with Codespaces</h3>
<p>Since Codespaces are development environments in the cloud, they are accessible from practically any system or device with a web browser and an Internet connection. And when you disconnect from your Codespace, its state is saved so that when you reconnect, potentially from a different device in potentially a very different location, you&#8217;ll be right back where you left off. When you are <a href="https://www.bing.com/images/search?q=beach+images">relaxing on the white sands of a beach resort</a>, you no longer need to run back to your office (or home office) in order to fix that critical zero-day bug that just read about on Reddit.</p>
<h3 id="managing-your-codespace-instances">Managing Your Codespace Instances</h3>
<p>Managing your Codespace instances can be done <a href="https://github.com/codespaces">directly from GitHub</a> or from within the Visual Studio Code Remote Explorer. From there, you can see the properties of your Codespaces or create, delete, or connect to your Codespaces. You can even change the machine type of an existing Codespace from the GitHub page or via the Command Palate in Visual Studio Code after connecting to a Codespace.</p>
<p>A machine type is a system configuration specifying the number of CPU cores, memory capacity, and storage capacity for a Codespace. GitHub Codespaces are provisioned in the cloud with the machine type you select. Depending on the organizations you are a member of, the repository a Codespace is being created for, and details about your GitHub account, different machine types might be available to you. To start, don&#8217;t worry about selecting the perfect machine type for your Codespace. You can always change your machine type later and retain all of your code changes without having to stash or commit them into the repository. Since less powerful machine types are <a href="https://docs.github.com/en/billing/managing-billing-for-github-codespaces/about-billing-for-codespaces#codespaces-pricing">billed at a lower rate</a>, you can leverage this to really optimize the tradeoff between time and cost as you see fit. For instance, you might choose a powerful machine type in order to complete an initial build of your project, then switch to a less powerful machine type while you are only making changes that cause smaller, incremental builds, only to switch back to a more powerful machine when you&#8217;d like to run a compute intensive task like running a static analysis tool.</p>
<p>The creation of your Codespaces are also customizable with <a href="https://code.visualstudio.com/docs/remote/create-dev-container">devcontainer</a> configuration files checked directly into your repository. You can provide a custom Dockerfile to use when spinning up your Codespace, pre-install Visual Studio Code extensions, forward ports from your Codespace instance to your local machine, or even run a tool every time a connection is made to the Codespace. You can even <a href="https://docs.github.com/en/codespaces/prebuilding-your-codespaces/about-codespaces-prebuilds">pre-build your Codespace containers using GitHub Actions</a> to make Codespace startup very fast!</p>
<h2 id="known-limitations">Known Limitations</h2>
<ul>
<li>Access to GitHub Codespaces feature is limited to users who are members of organizations on a GitHub Teams or GitHub Enterprise Cloud plan. Organization owners can <a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/enabling-codespaces-for-your-organization">enable the feature</a> in only a few steps. Access for individual users is currently in beta, to <a href="https://github.com/features/codespaces/signup">which you can easily request access</a>.</li>
<li>All GitHub Codespace instances run various <a href="https://github.com/github/feedback/discussions/9977">Linux distributions</a>.</li>
<li>The largest available machine type is: 32 cores, 64 GB RAM, 128 GB storage.</li>
<li>Changing machine type is only allowed between types that have the same amount of storage capacity.</li>
</ul>
<h2 id="call-to-action">Call to Action</h2>
<p>Try out the combination of Visual Studio Code and GitHub today, by going to your favorite C or C++ project on GitHub, and press the <strong>.</strong> (period) key to open up <a href="https://github.dev">github.dev</a>. Browse around. Experiment with the editor features of Visual Studio Code. When you&#8217;re ready to try compiling some code get started with GitHub Codespaces by accessing the Command Palate by pressing <strong>Ctrl+Shift+P</strong> (<strong>Cmd+Shift+P</strong> on macOS) and run the <strong>Codespaces: Create New Codespace</strong> command. Install the C/C++ Extension Pack and find out just how easy C++ development can be with Visual Studio Code and GitHub Codespaces. You can also follow the instructions in our <a href="https://github.com/microsoft/vscode-remote-try-cpp">example repository</a> that demonstrates Visual Studio Code&#8217;s remote container capabilities for a quick tour of the features.</p>
<h2 id="send-us-your-feedback">Send us your feedback</h2>
<p>We are always interested in your feedback. If you have a use case that we haven&#8217;t thought of, we&#8217;d love to hear from you. Want to complain that something isn&#8217;t working as you expected? We want to hear that too! Already using the product and want to tell us your successes? We definitely want to hear your story! You can comment below, and you can reach us via email at <a href="mailto://visualcpp@microsoft.com">visualcpp@microsoft.com</a> or on Twitter <a href="https://twitter.com/visualc">@VisualC</a>. For issues with the GitHub Codespaces service, you can also provide <a href="https://github.com/github/feedback/discussions/categories/codespaces-feedback">feedback directly to the GitHub Codespaces team</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/">Using GitHub Codespaces and Visual Studio Code for C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Enhancing Game Developer Productivity with Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/</link>
					<comments>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Thu, 31 Mar 2022 16:18:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[game dev]]></category>
		<category><![CDATA[productivity]]></category>
		<category><![CDATA[unreal engine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30338</guid>

					<description><![CDATA[<p>In this blog, we will discuss how much faster you can get to code with speedier C++ IntelliSense ready and opening a file. Learn how search improved with faster with C++ Find All References and indexed Find in Files.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/">Enhancing Game Developer Productivity with Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Since the launch of Visual Studio 2022, we have been continuously making performance improvements to enhance game developer productivity. In my <a href="https://www.youtube.com/watch?v=y8kt5842PT4">Microsoft Game Dev talk for GDC</a>, I shared why Visual Studio is the ultimate IDE for game developers. I also partnered with the folks at Double Fine Productions to <a href="https://developer.microsoft.com/en-us/games/events/gdc/psychonauts2">demonstrate their most loved features when developing the Award-winning Psychonauts 2.</a> Next, I shared features that Double Fine is most excited for in VS2022. Lastly, <a href="https://developer.microsoft.com/en-us/games/blog/microsoft-perforce-reimagining-game-production/">Microsoft Game Dev announced</a> that a set of GitHub Actions for Perforce Helix Core on Azure, authored directly by Perforce, is now available.</p>
<p>In this blog, I will show you some amazing speed improvements when searching and getting to code by discussing our measurements from large codebases such as Unreal Engine and Chromium. See how much faster you can get to code with speedier C++ IntelliSense ready and opening a file. Search faster with C++ Find All References and indexed Find in Files.</p>
<p>While game developers and developers with large codebases will benefit from these improvements the most, all C++ developers will gain increased productivity with these changes.</p>
<h1 id="testing-methodology">Testing Methodology</h1>
<p>We tested using an Unreal Engine 4 sample project on a desktop with an Intel Core i7-9700 @ 3Ghz, 64GB RAM, and an SSD. The tests took place on Visual Studio 2019 16.11 and Visual Studio 2022 17.1. The results were averaged over 3 runs. For Find in Files, we benchmarked using the Chromium repo, with more than 300,000 files.</p>
<h1 id="results">Results</h1>
<h2 id="getting-to-code">Getting to Code</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png"><img class="aligncenter size-full wp-image-30340" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png" alt="Image gettocodevs2022" width="1652" height="992" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png 1652w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-1536x922.png 1536w" sizes="(max-width: 1652px) 100vw, 1652px" /></a></p>
<p>When opening a file on Visual Studio 2019, it took 2.02 seconds for code to show up. In Visual Studio 2022, you can see the same action completing in only 0.82 seconds, resulting in a 2.44X speed up. In Visual Studio 2019, the time it took for semantic colorization to show up after opening a file was 12.9 seconds. You will experience that the same action is 2.22X faster in VS2022, taking 5.8 seconds.</p>
<p>For Unreal Engine projects, you will experience additional speed up for IntelliSense readiness. <a href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">Learn more in this blog post.</a></p>
<h2 id="code-search">Code Search</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png"><img class="aligncenter size-full wp-image-30341" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png" alt="Image searchvs2022" width="1652" height="992" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png 1652w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-1536x922.png 1536w" sizes="(max-width: 1652px) 100vw, 1652px" /></a></p>
<p>In Visual Studio 2022, you will see a speed up of 1.74X when using C++ Find All References (Shift + F12). The action was completed in 17.36 seconds; compared to Visual Studio 2019, the action took a little over half a minute.
For Find in Files in Visual Studio 2019, searching through 300,000 files in the Chromium repo took 30 seconds. In Visual Studio 2022, you will notice that the same action will take 1.5 seconds, a 20X improvement!</p>
<h1 id="analysis">Analysis</h1>
<p>You will notice several optimizations to the IntelliSense engine that created more efficiency in getting to code scenarios. Find All References was also enhanced by eliminating inefficiencies during search.</p>
<p>For Find in Files, you can now take advantage of indexed search. To enable indexed searching, go to <em>Tools &gt; Options &gt; Environment &gt; Preview Features</em> and ensure “Enable indexing for faster find experience” is checked. For more details, <a href="https://devblogs.microsoft.com/visualstudio/code-search-in-visual-studio-is-about-to-get-much-faster/">please see this blog post.</a></p>
<h1 id="feedback-wanted">Feedback Wanted!</h1>
<p>Your feedback through <a href="https://developercommunity.visualstudio.com/">Developer Community</a>, surveys, and social media channels has made these improvements possible. We thank you for your valuable comments.
These enhancements are a continuation of our focus on improving productivity for game developers. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like ones detailed in this blogpost. If you are a game developer, <a href="http://aka.ms/VSGameDevSurvey">let us know your thoughts in our 2022 Visual Studio Game Developer Survey</a>.</p>
<p>In addition, please continue to help shape the development of Visual Studio by talking to us in the comments below, on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h1 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h1>
<p><a href="https://visualstudio.microsoft.com/downloads/">Download the latest version of Visual Studio 2022</a> to take advantage of these productivity benefits today!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/">Enhancing Game Developer Productivity with Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>C++ Modules in CMake with Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/#comments</comments>
		
		<dc:creator><![CDATA[Will Buik]]></dc:creator>
		<pubDate>Thu, 17 Mar 2022 22:31:30 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30295</guid>

					<description><![CDATA[<p>We’ve seen a lot of excitement around C++ modules since we announced support in the Microsoft C++ compiler and Visual Studio. Ever since, the community has been asking us when CMake support was coming. I am happy to announce that Visual Studio 2022 17.2 Preview 2 has experimental support for C++ modules in CMake projects.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/">C++ Modules in CMake with Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We’ve seen a lot of excitement around C++ modules since we announced support in the Microsoft C++ compiler and Visual Studio. Ever since, the community has been asking us when CMake support was coming. I am happy to announce that Visual Studio 2022 17.2 Preview 2 has experimental support for C++ modules in CMake projects. One caveat for this early support, is that you must use the Visual Studio (MSBuild) generator. If you want to try it out, you can <a href="https://visualstudio.com/preview">download the latest preview of Visual Studio</a> today. We are looking forward to hearing your feedback about how modules work in your CMake projects.</p>
<p><a href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp">C++ modules</a> are a new feature in C++20. They can help you compartmentalize your code, speed up build times, and they work seamlessly, side-by-side with your existing code. To learn more, I would recommend checking <a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/">A Tour of C++ Modules in Visual Studio</a>. That post explores the details of how and when to use modules and some of the ways Visual Studio can help you do it.</p>
<p>For an even deeper dive into modules, you can also explore the following series:</p>
<ul>
<li><a href="https://devblogs.microsoft.com/cppblog/standard-c20-modules-support-with-msvc-in-visual-studio-2019-version-16-8/">Standard C++20 Modules support with MSVC</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">Moving a project to C++ named Modules</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</a></li>
</ul>
<h3 id="getting-started-with-modules-and-cmake">Getting Started with Modules and CMake</h3>
<p>While CMake support for modules in Visual Studio is still experimental, it is straightforward to start using it. You don’t need to do anything special in your CMake project files. Just make sure you have enabled the C++20 language standard. Starting in this preview, our CMake project template will do that for you, but if you are working with an existing project you will need to add this to your CMakeLists.txt:</p>
<p><code>set_property(TARGET $TargetName PROPERTY CXX_STANDARD 20)</code></p>
<p><strong><em>Note:</em></strong><em> Enabling C++20 requires CMake 3.12 or higher. Visual Studio ships with the latest version of CMake, but this may be a consideration if you use this project across operating systems or need to use an older version of CMake.</em></p>
<p>You will also need to make sure you are using the Visual Studio generator with CMake. Support for other generators, such as Ninja, is planned but it isn’t available yet. Ninja is the default generator when working with CMake projects in Visual Studio so you will need to modify your project’s <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-170">CMakePresets.json</a> or <a href="https://docs.microsoft.com/en-us/cpp/build/customize-cmake-settings?view=msvc-170">CMakeSettings.json</a> file to change this.</p>
<p><strong><em>CMake Presets:</em></strong></p>
<p>If your project is using CMake Presets, in CMakePresets.json, find the “windows-base” configure preset. It will have a “generator” property that is most likely set to “Ninja”. Update it to this:</p>
<pre>{
  "version": 3,
  "configurePresets": [ {
    "name": "windows-base",
    "hidden": true,
    "generator": "Visual Studio 17 2022",
    //…
  }]
}</pre>
<p><strong><em>CMake Settings:</em></strong></p>
<p>If your project is using CMake Settings, you can open the CMakeSettings.json editor and change the Generator setting (under Advanced) to “Visual Studio 17 2022:”</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png"><img class="alignnone size-full wp-image-30300" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png" alt="CMake Settings &gt; Advanced &gt; CMake generator" width="1425" height="826" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png 1425w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-300x174.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-1024x594.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-768x445.png 768w" sizes="(max-width: 1425px) 100vw, 1425px" /></a></p>
<p>You will need to do this for each of your project’s configurations.</p>
<p>And that’s it, once the Visual Studio generator is selected and the C++20 language standard is enabled for your target you can use modules in your project.</p>
<h3 id="creating-modules-in-a-cmake-project">Creating Modules in a CMake Project</h3>
<p>To add a module to your project, just right click on any folder and select “Add New Item:”</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png"><img class="alignnone size-full wp-image-30301" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png" alt="CMake Context Menu &gt; Add &gt; Add New Item..." width="1972" height="665" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png 1972w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-300x101.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-1024x345.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-768x259.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-1536x518.png 1536w" sizes="(max-width: 1972px) 100vw, 1972px" /></a></p>
<p>And select the “C++ Module Interface Unit (.ixx)” template in in the “Visual C++” category:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png"><img class="alignnone size-full wp-image-30302" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png" alt="New File &gt; Visual C++ &gt; C++ Module Interface Unit (.ixx)" width="1253" height="490" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png 1253w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-300x117.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-1024x400.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-768x300.png 768w" sizes="(max-width: 1253px) 100vw, 1253px" /></a></p>
<p>If you are using the <a href="https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/#cmake-targets-view">Targets View</a>, it is even easier. Just click “Add -&gt; New Module…” in the context menu on any target:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png"><img class="alignnone size-full wp-image-30303" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png" alt="CMake Targets View Context Menu &gt; Add &gt; New Module..." width="1232" height="667" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png 1232w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-300x162.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-1024x554.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-768x416.png 768w" sizes="(max-width: 1232px) 100vw, 1232px" /></a></p>
<h3 id="exporting-and-using-modules">Exporting and Using Modules</h3>
<p>Once you have created a Module interface (.ixx) file, you can export functions, classes, and structs. The example below defines a simple module called <code>Printers</code> and exports a single struct:</p>
<pre>// Printers.ixx
// 
// The .ixx extension lets the build system know this file contains
// a module interface.

// Begin global module fragment.
module;

// Headers included in the global module fragment (between "module;" and
// "export module Printers;") can be used by the module implementation but
// are not exported. These included headers are invisible to translation
// units that import the Printers module.
#include &lt;iostream&gt;

// Creates the Printers module. This can be imported into other translation
// units with "import Printers;" Any items marked with the export keyword
// will be available in translation units that import the Printers module.
export module Printers;

// This only applies to this module's translation unit. It does not leak
// into translation units that import the Printers module.
using namespace std;

// These constants are not exported, they are invisible from translation
// units that import the Printer module.
const string default_spacer = " ";
const string default_separator = ",\n";

// SimplePrinter is exported and accessible to any code that imports the
// Printers module.
export struct SimplePrinter
{
    string element_spacer;
    string separator;

    void print_element(int e)
    {
        std::cout &lt;&lt; e &lt;&lt; element_spacer;
    }

    void print_separator()
    {
        std::cout &lt;&lt; separator;
    }
};

// Exports the function get_default_printer.
// This is accessible from translation units that import the Printers module.
export SimplePrinter get_default_printer()
{
    return SimplePrinter {
        .element_spacer = default_spacer,
        .seperator = default_seperator
    };
}</pre>
<p>Once you define the module, other source files and module interfaces can consume it with the <code>import</code> keyword. It is possible to import any modules declared in the current target or any of its imports. For example, “PrintVector.cpp” below uses the <code>Printers</code> module we defined above:</p>
<pre>// PrintVector.cpp

// Conventional #includes and module imports can be freely mixed.
#include &lt;vector&gt;

// Import the Printers module defined in Printers.ixx.
import Printers;

using namespace std;

void print_vector(const vector &amp;list)
{
    // SimplePrinter and get_default_printer are imported from the
    // Printers module.
    SimplePrinter printer = get_default_printer();

    for (auto i : list) {
        printer.print_element(i);
    }
    printer.print_separator();
}</pre>
<p>You can do a lot with C++ modules. To learn more, I would recommend reading <a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/">A Tour of C++ Modules in Visual Studio</a> which goes into much more detail about how to use modules. For instance, it is possible to split module interfaces from their implementations. That post has been updated with some of the latest details about using modules with CMake.</p>
<h3 id="feedback">Feedback</h3>
<p>If you are interested in trying out C++ modules in your own CMake projects, please <a href="https://visualstudio.com/preview">download the latest Visual Studio Preview</a>. Try it out and let us know if you have any questions or feedback. If you find any issues or have a suggestion, the best way to reach out to us is to <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio">Report a Problem</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/">C++ Modules in CMake with Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
	</channel>
</rss>
