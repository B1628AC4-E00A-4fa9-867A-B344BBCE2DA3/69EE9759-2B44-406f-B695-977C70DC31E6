<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Fri, 08 Oct 2021 18:50:59 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</title>
		<link>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Fri, 08 Oct 2021 18:50:59 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29173</guid>

					<description><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/">Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">C++ Developer Community</a> page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the detailed overview of a new experimental <a href="https://docs.microsoft.com/cpp/build/reference/analyze-code-analysis">code analysis</a> check that can detect null pointer dereference errors, along with a comparison to an existing check that has the same purpose.</p>
<h2 id="overview">Overview</h2>
<p>Internally, we have multiple analysis engines. This is opaque from the users’ point of view; warnings are surfaced identically regardless of the engine we used to implement them. One of our code analysis tools, has a number of checks to catch null pointer dereference errors. These include <a href="https://aka.ms/cpp/warnings/C6011">C6011</a>, <a href="https://aka.ms/cpp/warnings/C6387">C6387</a>, and <a href="https://aka.ms/cpp/warnings/C28196">C28196</a>. While these warnings have historically been successful and prevented many errors, they do not work well with some aspects of modern C++. Moreover, the data flow framework they are written in has its limitations. EspXEngine was created to solve most of these problems. We already ship many analyses that are based on EspXEngine’s powerful path-sensitive data flow analysis including <a href="https://devblogs.microsoft.com/cppblog/concurrency-code-analysis-in-visual-studio-2019/">Concurrency Check</a> and <a href="https://devblogs.microsoft.com/cppblog/new-code-analysis-checks-in-visual-studio-2019-use-after-move-and-coroutine/">Use After Move Check</a>. The success of these checks convinced us to port null pointer analysis to EspXEngine. We are excited to make the new version available to try which introduces many improvements compared to the old one. The rest of the blog post is an in-depth overview of some of the improvements and gives some hints how to use power-user features like annotations.</p>
<h2 id="path-sensitive-analysis">Path-sensitive analysis</h2>
<p>Both analysis engines are capable of path-sensitive analysis. Let’s consider the example below to understand what this means:</p>
<pre><code class="language-c++">void path_sensitive(int *p, bool cond) { 
    int state = 0; 

    // branch 1  
    if (p != nullptr) { 
        state = 1; 
    } 

    // branch 2 
    if (cond) { 
        state = 2; 
        p = nullptr; 
    } 

    // branch 3 
    if (state == 1) { 
        *p = 42; // Null dereference? 
    } 
} </code></pre>
<p>The code above has multiple branches. Some of those branches are correlated, but flow-sensitive analyses will not reason about these correlations. For instance, a flow-sensitive analysis might conclude that the code is unsafe due to a potential null-dereference, since <code>p</code> is set to <code>nullptr</code> in branch 2, and then dereferenced in branch 3. However, this would be a false positive because branch 3 <strong>cannot</strong> be reached if branch 2 has been taken. Path-sensitive analyses, on the other hand, do reason about these types of reachability conditions, and would therefore conclude that the code above is safe. As a result, path-sensitive analyses are more precise. But, this precision comes at the cost of analysis time and memory. Both engines have identical behavior on this code snippet.</p>
<h2 id="local-analysis">Local analysis</h2>
<p>Both engines are doing intraprocedural analysis. They cannot see across function boundaries and rely on types, type extensions, models and contracts to bridge the gap.</p>
<pre><code class="language-c++">void local_analysis(int *p, int *q, bool cond) { 
    if (p == nullptr) 
        return; 
    q = nullptr; 
    std::swap(p, q); 
    *p = 42; // Null dereference 
} </code></pre>
<p>The code above has a bug. The pointer <code>p</code> is <code>nullptr</code> due to the call to swap. This bug is not found by the current check. However, EspXEngine models some common APIs. As a result, it can figure out the bug and report a warning to the user.</p>
<p>Unfortunately, when we call our own APIs, EspXEngine will not know the semantics of the called function. In those cases, we can use types or <a href="https://docs.microsoft.com/cpp/code-quality/understanding-sal?view=msvc-160">SAL annotations</a> to describe the pre- and postconditions of our functions:</p>
<pre><code class="language-c++">_Notnull_ int *get_my_ptr(); 
gsl::not_null&lt;int *&gt; get_my_ptr2(); 
void local_analysis(int *p) { 
    _Analysis_assume_(p != nullptr); 
    *p = 42; 
} </code></pre>
<p>In the code above, we use the <code>_Notnull_</code> and <code>_Analysis_assume_</code> SAL annotations to describe the constraints on the values of some pointers. This is supported by both engines. A more modern approach is to use rich types to express these contracts. This is only supported in EspXEngine. Moreover, it will flag code where a null pointer is stored into a <a href="https://github.com/microsoft/GSL"><code>gsl::not_null</code></a> pointer:</p>
<pre><code class="language-c++">void assign_to_gsl_notnull() { 
    int* p = nullptr; 
    auto q = gsl::make_not_null(p); // C26822 warning 
} </code></pre>
<p>While types are great to encode our expectations, SAL has the power to express a wider range of contracts. Consider the example below:</p>
<pre><code class="language-c++">void postcondition_conditional(bool b, _When_(b == true, _Outptr_) int** p)  { 
    if (b == true) 
        *p = nullptr; // C26824 warning 
} </code></pre>
<p>This function has a complex postcondition. Whenever the first argument is true, the value at location <code>*p</code> must be not-<code>null</code> when the function exists. These contracts are understood by both engines (although the support in EspXEngine is more sophisticated) and many Windows APIs are annotated to describe their behavior. We would love to use a standard language facility, but the contracts proposal was not accepted for C++20 and we need a solution that work both for C and C++ APIs.</p>
<h2 id="some-problems-with-our-existing-null-pointer-checks">Some problems with our existing null pointer checks</h2>
<p>I wanted to showcase some examples where the null pointer check based on EspXEngine has better behavior than the current one. First of all, there are some low easy to catch null pointer dereferences that are not found by the current checks:</p>
<pre><code class="language-c++">void nullptr_constant_dereference() { 
    *(int*)nullptr = 5; // Previously, it was not found. 
} </code></pre>
<p>There are also cases where they were noisier:</p>
<pre><code class="language-c++">struct Node { 
    int number; 
    Node* next; 
}; 

void add_number(Node*&amp; head, Node*&amp; tail, int data) { 
    if (head != nullptr) { 
        tail-&gt;next = (Node*)malloc(sizeof(Node)); 
        tail = tail-&gt;next; 
    } else { 
        head = (Node*)malloc(sizeof(Node)); 
        tail = head; 
    } 
    tail-&gt;number = data; // C6011 warning 
    tail-&gt;next = nullptr; 
} </code></pre>
<p>In the code above the current version will give a null pointer dereference warning on the line with the comment. Technically, this warning could be a true positive when <code>malloc</code> fails and returns a <code>nullptr</code>. This is a scenario that is irrelevant for many applications. EspXEngine has both low and high confidence warnings and will only emit a low confidence warning in this case. Most users are probably only interested in the high confidence warnings that are expected to have less noise and turn the low confidence warnings off.</p>
<p>Moreover, we decided to make EspXEngine stricter detecting various undefined behavior:</p>
<pre><code class="language-c++">void method_null_dereference(Foo* p, Foo* q) { 
    if (p || q) 
        return; 

    p-&gt;method();            // C26822 warning 
    q-&gt;static_method(42);   // OK, not UB.  
} </code></pre>
<p>In the code above, contrary to EspXEngine, the current warning will not warn when we call a method on a null pointer. Strictly speaking, this code has undefined behavior, but many implementations will work fine when <code>method</code> does not dereference the <code>this</code> pointer.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The upcoming Visual Studio 2022 17.0 Preview 4 will feature new, experimental checks to find null pointer dereference errors. These checks are intended to be better versions of the current ones with improved precision and additional features. These new checks are doing in-depth analysis and are expected to increase the analysis time. They are off by default and can be enabled by using the <code>CppCoreCheckExperimentalRules</code> ruleset.</p>
<h2 id="try-it-out-and-let-us-know-what-you-think">Try it out and let us know what you think:</h2>
<p>The work that we do is heavily influenced by feedback we receive on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check. Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/">Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Static Analysis Fixes in Visual Studio 2019 version 16.11</title>
		<link>https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/</link>
					<comments>https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Mon, 13 Sep 2021 15:00:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28697</guid>

					<description><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/">Static Analysis Fixes in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/search?space=62">C++ Developer Community page</a>. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the compilation of bug fixes that were made from Visual Studio 2019 version 16.10 to 16.11 for code analysis.  Note that 16.11 is the last non-servicing release of Visual Studio 2019, so the focus was on stabilization and minor improvements rather than new features (stay tuned for updates in 17.0). We also found time to improve the performance of certain checks. The changes are summarized below:</p>
<ul>
<li>Clarified the warning message for <a href="https://aka.ms/cpp/warnings/C26445">C26445</a>. The old message implied that there is a lifetime problem. The new message is: “Do not assign <code>gsl::span</code> or <code>std::string_view</code> to a reference. They are cheap to construct and are not owners of the underlying data. (gsl.view)”</li>
<li>Fixed false positive due to not considering lifetime extension rules in <a href="https://aka.ms/cpp/warnings/C26444">C26444</a>. See the code example below:</li>
</ul>
<pre class="prettyprint">struct MyStruct { int i; }; 
void example() { 
  const MyStruct&amp; s = {}; // Previously, false positive C26444 was emitted. 
}</pre>
<ul>
<li>Fixed using <code>ALL_CPPCORECHECK_WARNINGS</code> in suppression would not suppress <a href="https://aka.ms/cpp/warnings/C26457">C26457</a>.</li>
<li>Fixed a problem where certain control flows could trick Concurrency Check into emitting false positive warnings.</li>
<li>Fixed a false positive in Concurrency Check due to incorrect modelling of unwinding paths (for exceptions). This fixed the false positive below. Previously, analysis would proceed along the exception path of the constructor call (no lock is acquired in the exception path), leading to a false warning.</li>
</ul>
<pre class="prettyprint">mutex mtx; 
mutex&amp; mutexRef() { return mtx; } 
void test() { 
  lock_guard&lt;mutex&gt; lock(mutexRef()); // No C26110 (failing to hold lock) 
}</pre>
<ul>
<li>Fixed a compilation failure of code snippets relying on guaranteed copy elision during code analysis.</li>
</ul>
<pre class="prettyprint">struct S { 
  S(const S&amp; o) = delete; 
  S&amp; operator=(const S&amp; o) = delete; 
  S(const S&amp;&amp; o) = delete; 
  S&amp; operator=(const S&amp;&amp; o) = delete; 
  static const S foo(); 
};

void bar() {
  S s = S::foo(); // Used to trigger compilation failure.
}

</pre>
<ul>
<li>Fixed a <a href="https://developercommunity.visualstudio.com/t/Codeanalysis-warning-C6285-in-STL-functi/1429721">bug</a> that caused the <a href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">/external</a> options for specifying external headers to override CAExcludePath and generate warnings for external files.</li>
<li>Performance improvements to the checker that reports warnings on misuse of `VARIANT`s (warnings <a href="https://docs.microsoft.com/cpp/code-quality/c33001?view=msvc-160">C33001</a>, <a href="https://docs.microsoft.com/cpp/code-quality/c33004?view=msvc-160">C33004</a>, and <a href="https://docs.microsoft.com/cpp/code-quality/c33005?view=msvc-160">C33005</a>). Please refer to &#8220;<a href="https://devblogs.microsoft.com/cppblog/new-safety-rules-in-c-code-analysis/">New Safety Rules for in C++ Code Analysis</a>&#8221; for more information on these warnings.</li>
<li>Performance improvements to the checker that reports warnings on misuse of enum values as an index (warnings <a href="https://docs.microsoft.com/cpp/code-quality/c33010?view=msvc-160">C33010</a> and <a href="https://docs.microsoft.com/cpp/code-quality/c33011?view=msvc-160">C33011</a>). Please refer to “<a href="https://devblogs.microsoft.com/cppblog/even-more-new-safety-rules-in-c-code-analysis/">Even More Safety Rules in C++ Code Analysis</a>” for more information on these warnings. Improved the performance of pointer safety related C++ Core Guidelines checks. See <code>OWNER_POINTER</code>, <code>RAW_POINTER</code>, <code>UNIQUE_POINTER</code>, and <code>SHARED_POINTER</code> groups here.</li>
<li>Fixed some memory leaks in some checks when multiple translation units are analyzed in a single compiler invocation.</li>
</ul>
<h2 id="fixes-in-16-11-1-to-16-11-3-servicing-releases">Fixes in 16.11.1 to 16.11.3 servicing releases</h2>
<ul>
<li>Fixed a crash when <code>__uuidof </code>was used in a template argument a certain way.</li>
<li>Fixed a rare crash when SAL annotations refer to fields of unnamed <code>struct</code>s.</li>
</ul>
<h2 id="try-it-out%e2%80%afand-let-us-know-what-you-think">Try it out and let us know what you think</h2>
<p>The work that we do is heavily influenced by feedback we receive on <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check.   Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or @VisualC on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/">Static Analysis Fixes in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC C++20 and the /std:c++20 Switch</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Griffing]]></dc:creator>
		<pubDate>Thu, 02 Sep 2021 21:18:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28674</guid>

					<description><![CDATA[<p>We are excited to announce that in Visual Studio 2019 version 16.11, we have added the /std:c++20 switch to the set of language mode switches available. The addition of this switch indicates that we’ve reached a point of sufficient stabilization of the MSVC C++20 feature set for it be used in production,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">MSVC C++20 and the /std:c++20 Switch</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are excited to announce that in Visual Studio 2019 version 16.11, we have added the <code>/std:c++20</code> switch to the set of language mode switches available. The addition of this switch indicates that we’ve reached a point of sufficient stabilization of the MSVC C++20 feature set for it be used in production, with full support in VS servicing updates.</p>
<p>This blog post focuses on describing our level of C++20 feature support, compiler-supported extensions, and the remaining feature set differences between MSVC and the ISO C++ standard as of Visual Studio 2019 version 16.11 and Visual Studio 2022 version 17.0</p>
<h2 id="c-language-modes-and-compatibility-guarantees"><span style="font-size: 18pt;">C++ Language Modes and Compatibility Guarantees</span></h2>
<p>First <a href="https://devblogs.microsoft.com/cppblog/standards-version-switches-in-the-compiler/">introduced in Visual Studio 2015</a>, the MSVC compiler has included C++ language mode switches to indicate the targeted level of standard conformance and we now support three stable language modes: <code>/std:c++14</code>, <code>/std:c++17</code>, <code>/std:c++20</code> (as of VS 2019 v16.11) and one preview mode (<code>/std:c++latest</code>).</p>
<p>The stable modes indicate that features under those modes are ready for production use and have ABI compatibility guarantees. The <code>/std:c++latest</code> mode contains ISO C++ features without strong guarantees for compatibility, allowing iteration based upon issues identified in testing, ISO C++ standard changes, and community feedback which may impact ABI stability of those features. Once stabilized, features under /std:c++latest will be moved under an applicable stable mode.</p>
<table>
<tbody>
<tr>
<td width="105"><strong>Language Mode</strong></td>
<td width="219"><strong>Language Mode enables strict-conformance (/permissive-)</strong></td>
<td width="91"><strong>ABI Stable</strong></td>
<td width="208"><strong>Notes</strong></td>
</tr>
<tr>
<td width="105">/std:c++14</td>
<td width="219">No</td>
<td width="91">Yes</td>
<td width="208">See <strong>**<em>Note A</em></strong></td>
</tr>
<tr>
<td width="105">/std:c++17</td>
<td width="219">No</td>
<td width="91">Yes</td>
<td width="208">See <strong>**<em>Note A</em></strong></td>
</tr>
<tr>
<td width="105">/std:c++20</td>
<td width="219">Yes</td>
<td width="91">Yes</td>
<td width="208">See <strong>**<em>Note B</em></strong></td>
</tr>
<tr>
<td width="105">/std:c++latest</td>
<td width="219">Yes</td>
<td width="91">No</td>
<td width="208">See <strong>**<em>Note B</em></strong></td>
</tr>
</tbody>
</table>
<p><strong><em>**</em></strong><strong><em>Note A</em></strong><em>: Strict conformance mode is opt-in via the /permissive- compiler switch</em></p>
<p><strong><em>**Note B</em></strong><em>: Some functionality such as C++20 Modules require strict-conformance mode to be enabled due to strong dependency on ISO C++ semantic behaviors. Compatibility mode (/permissive) is supported as an opt-in switch  with some C++20 functionality disabled.</em></p>
<h2 id="c20-features-added-in-vs-2019-v16-9-and-later"><span style="font-size: 18pt;">C++20 Features added in VS 2019 v16.9 and later</span></h2>
<p>Below is a summary of language and library C++20 features implemented since the last feature update.</p>
<p>A more detailed <a href="https://github.com/microsoft/STL/wiki/Changelog">changelog</a> is available for <a href="https://github.com/microsoft/STL">the STL on its GitHub repo</a> including information on the awesome community contributors who have provided feature implementations and bug fixes to the STL</p>
<h3 id="vs-2019-v16-9"><span style="font-size: 14pt;">VS 2019 v16.9</span></h3>
<p>C++20 Language Features</p>
<ul>
<li>Implemented <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html">P0634R3</a> Down with typename!</li>
<li>Implemented <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0840r2.html">P0840R2</a> [[no_unique_address]] attribute (<em>please see below for more details</em>)</li>
<li>Implemented <a href="https://wg21.link/P1064R0">P1064R0</a> Allowing virtual function calls in constant expressions</li>
<li>Implemented <a href="https://wg21.link/P1141R2">P1141R2</a> Yet another approach for constrained declarations</li>
<li>Implemented <a href="https://wg21.link/P1327R1">P1327R1</a> Allowing dynamic_cast, polymorphic typeid in constant expressions</li>
<li>Implemented <a href="https://wg21.link/P1668R1">P1668R1</a> Permitting unevaluated inline assembly in constexpr functions</li>
<li>Implemented <a href="https://wg21.link/P0784R7">P0784R7</a> More constexpr containers</li>
</ul>
<p>C++20 Library Features</p>
<ul>
<li>Implemented <a href="https://wg21.link/P0339R6">P0339R6</a> polymorphic_allocator&lt;&gt;</li>
<li>Implemented <a href="https://wg21.link/P0660R10">P0660R10</a> &lt;stop_token&gt; And jthread</li>
<li>Implemented <a href="https://wg21.link/P0768R1">P0768R1</a> Library Support For The Spaceship Comparison Operator &lt;=&gt;</li>
<li>Implemented <a href="https://wg21.link/P1007R3">P1007R3</a> assume_aligned()</li>
<li>Implemented <a href="https://wg21.link/P1020R1">P1020R1</a> Smart Pointer Creation With Default Initialization</li>
<li>Implemented <a href="https://wg21.link/P1771R1">P1771R1</a> [[nodiscard]] For Constructors</li>
</ul>
<h3 id="vs-2019-v16-10-v16-11"><span style="font-size: 14pt;">VS 2019 v16.10 &amp; v16.11</span></h3>
<p>C++20 Language Features</p>
<ul>
<li>Implemented <a href="https://wg21.link/P1073R3">P1073R3</a> Immediate functions</li>
<li>Implemented <a href="https://wg21.link/P1143R2">P1143R2</a> constinit</li>
<li>Implemented <a href="https://wg21.link/P1353R0">P1353R0</a> Missing feature-test macros</li>
</ul>
<p>C++20 Library Features</p>
<ul>
<li>Implemented <a href="https://wg21.link/P0053R7">P0053R7</a>&lt;syncstream&gt;</li>
<li>Implemented <a href="https://wg21.link/P0355R7">P0355R7</a>&lt;chrono&gt; Calendars And Time Zones</li>
<li>Implemented <a href="https://wg21.link/P0408R7">P0408R7</a> Efficient Access To basic_stringbuf&#8217;s Buffer</li>
<li>Implemented <a href="https://wg21.link/P0466R5">P0466R5</a> Layout-Compatibility And Pointer-Interconvertibility Traits</li>
<li>Implemented <a href="https://wg21.link/P0475R1">P0475R1</a> Guaranteed Copy Elision For Piecewise Construction</li>
<li>Implemented <a href="https://wg21.link/P0591R4">P0591R4</a> Utility Functions For Uses-Allocator Construction</li>
<li>Implemented <a href="https://wg21.link/P0608R3">P0608R3</a> Improving variant&#8217;s Converting Constructor/Assignment</li>
<li>Implemented <a href="https://wg21.link/P0645R10">P0645R10</a> &lt;format&gt; Text Formatting</li>
<li>Implemented <a href="https://wg21.link/P0784R7">P0784R7</a> Library Support For More constexpr Containers</li>
<li>Implemented <a href="https://wg21.link/P0896R4">P0896R4</a> Ranges</li>
<li>Implemented <a href="https://wg21.link/P0980R1">P0980R1</a> constexpr std::string</li>
<li>Implemented <a href="https://wg21.link/P1004R2">P1004R2</a> constexpr std::vector</li>
<li>Implemented <a href="https://wg21.link/P1208R6">P1208R6</a> &lt;source_location&gt;</li>
<li>Implemented <a href="https://wg21.link/P1502R1">P1502R1</a> Standard Library Header Units</li>
<li>Implemented <a href="https://wg21.link/P1614R2">P1614R2</a> Adding Spaceship &lt;=&gt; To The Library</li>
</ul>
<h2 id="vs-2022-17-0-still-in-preview"><span style="font-size: 14pt;">VS 2022 17.0 (still in Preview)</span></h2>
<p>C++20 Language Features</p>
<ul>
<li>Completed implementation of <a href="https://wg21.link/P0734R0">P0734R0</a> Concepts</li>
</ul>
<p>C++20 Library DRs</p>
<ul>
<li>Implemented <a href="https://wg21.link/P2325R3">P2325R3</a> Views Should Not Be Required To Be Default Constructible</li>
</ul>
<h2 id="iso-c20-continuing-work-defect-reports-and-clarifications"><span style="font-size: 18pt;">ISO C++20  Continuing Work, Defect Reports, and Clarifications</span></h2>
<p>As part of implementing C++20, there were some late discoveries which required changes to the ISO C++20 standard via the standard committee’s Defect Report (DR) process. This included Existing implementations (pre-DR) for these features are available under the <code>/std:c++latest</code> switch.  We’re also tracking the DRs and are implementing those issue resolutions under <code>/std:c++latest</code>. Our plan is to make these capabilities available under the <code>/std:c++20</code> switch after implementation of the full set of Standard Library DRs has completed. Progress on these features can be tracked on the <a href="https://github.com/microsoft/STL">MSVC STL GitHub site</a> through its <a href="https://github.com/microsoft/STL/projects/9">C++20 DRs project</a>.</p>
<p>In the compiler, we are working with ISO C++ and other toolchain vendors to clarify expectations around allowing virtual functions to be <code>constexpr</code> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1064r0.html">P1064R0</a>). There are a couple of possibilities for implementation, which have significant ABI implications as to whether this is implemented via vtable entry. In the interim, we have implemented two modes, under <code>/experimental:constevalVfuncVtable</code> and <code>/experimental:constevalVfuncNoVtable</code>, which implement the most likely resolutions to this ambiguity. Once a decision is made on how to proceed, we’ll bring that capability under <code>/std:c++20</code> and <code>/std:c++latest</code>.</p>
<p>Additionally, there were some feature areas that were unintentionally partially implemented. We are working to get those areas filled. For VS 2022 v17.0, we have implemented the requires-expression portion of the Concepts feature (<a href="https://wg21.link/P0734R0">P0734R0</a>), which is scheduled to ship in VS 2022 v17.0.  We’re also working to complete implementation of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html">Core Issue 1581</a>: “When are constexpr member functions defined?,” which is tracking towards inclusion in a VS 2022 update after v17.0.</p>
<h2 id="msvc-extensions-and-abi"><span style="font-size: 18pt;">MSVC Extensions and ABI</span></h2>
<h3 id="c20-no_unique_address"><span style="font-size: 14pt;">C++20 <code>[[no_unique_address]]</code></span></h3>
<p>Implementation of C++20 <code>[[no_unique_address]]</code> included a couple of additional challenges due to the ABI-breaking impact (changing object layout) of applying this optimization. This is problematic due to the MSVC compiler ignoring attributes that are not known, as allowed by the standard, resulting in scenarios where MSVC ABI compatibility guarantees would be broken for standard C++ code:</p>
<ul>
<li>Compiling the same header/source under <code>/std:c++17</code> and <code>/std:c++20</code> would result in link-time incompatibilities due to object layout differences resulting in ODR violations.</li>
<li>Linking static libraries built with an older version of the MSVC compiler (VS 2015 through VS 2019 v16.8), within the v14x ABI-compatible family, would result in ODR violations and break our compatibility guarantees.</li>
</ul>
<p>It was decided to hold-off on enabling the optimization for the <code>[[no_unique_address]]</code> attribute in the MSVC compiler until our next ABI breaking revision of the MSVC toolset, where it will be enabled across all language modes.</p>
<p>However, we do recognize that there are some customers who are in a position to take advantage of this optimization without worrying about linking binaries across versions of the MSVC toolset.  For this audience, we have made this optimization available in VS 2019 v16.9 and later through an extension attribute that affects optimization across all compiler language modes, <code>[[msvc::no_unique_address]]</code>.</p>
<ul>
<li>There are portability concerns for customers who require ABI-compatiblity between MSVC and Clang for the STL. Please see <a href="https://github.com/microsoft/STL/issues/1364">https://github.com/microsoft/STL/issues/1364</a> for more details.</li>
<li>This extension attribute enables this optimization under all C++ language modes (e. <code>/std:c++14</code>, <code>/std:c++17</code>, <code>/std:c++20</code>, <code>/std:c++latest</code>.</li>
<li>We strongly recommend that any usage of this attribute is guarded by an MSVC version-check as demonstrated in the below example:</li>
</ul>
<pre class="prettyprint">#include &lt;iostream&gt;

#if _MSC_VER &gt;= 1929 // VS2019 v16.10 and later (_MSC_FULL_VER &gt;= 192829913 for VS 2019 v16.9)
// Works with /std:c++14 and /std:c++17, and performs optimization

#define NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]

#else

// no-op in MSVC v14x ABI
#define NO_UNIQUE_ADDRESS /* [[no_unique_address]] */

#endif


struct Empty {};

struct A
{
    int a;
    NO_UNIQUE_ADDRESS Empty b;
};

int main()
{
    A inst{ 0 };

    // [[msvc::no_unique_address]] : sizeof(inst) == 4.
    // [[no_unique_address]] : sizeof(inst) == 8.
    std::cout &lt;&lt; sizeof(inst) &lt;&lt; "\n";
}</pre>
<h3 id="c20-coroutine-support-for-c14-c17-awaitstrict"><span style="font-size: 14pt;">C++20 Coroutine support for C++14/C++17 (<code>/await:strict</code>)</span></h3>
<p>The <code>/await:strict</code> option can be used in place of <code>/await</code> for C++20 compatible coroutine support in projects that build in C++14 or C++17 mode. In <code>/await:strict</code> mode library support is provided in <code>&lt;coroutine&gt;</code> and in the std namespace. For full clarity, this behavior is on-by-default under <code>/std:c++20</code> without any <code>/await*</code> switch usage.</p>
<p>Strict mode disables language extensions present in <code>/await</code> that were not adopted into the C++20 standard. Use  of such features with <code>/await:strict</code> will result in a compiler error. Strict mode also implements coroutine behaviors such as promise parameter preview that are not available under <code>/await</code> due to binary compatibility issues with older releases.</p>
<p>Note: coroutine state objects obtained from <code>coroutine_handle&lt;T&gt;::address()</code> are not compatible between <code>/await</code> and <code>/await:strict</code> modes. Using <code>coroutine_handle&lt;T&gt;::from_address()</code> on an address obtained from a coroutine handle created in an incompatible mode will result in undefined behavior.</p>
<h2 id="more-information"><span style="font-size: 18pt;">More Information</span></h2>
<p>For Visual Studio changes (beyond the C++ toolset) and download links, see the <a href="https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes">VS 2019 Release Notes</a> and  <a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview">VS 2022 Preview Release Notes</a>. You can report bugs through <a href="https://developercommunity.visualstudio.com/spaces/62/index.html">Developer Community</a>, and you can also report STL bugs via <a href="https://github.com/microsoft/STL/issues">microsoft/STL GitHub issues</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">MSVC C++20 and the /std:c++20 Switch</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>C++20 Coroutine Improvements in Visual Studio 2019 version 16.11</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/#comments</comments>
		
		<dc:creator><![CDATA[Jonathan Emmett]]></dc:creator>
		<pubDate>Tue, 31 Aug 2021 14:32:18 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Coroutine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28354</guid>

					<description><![CDATA[<p>This post includes contributions from Terry Mahaffey and Ramkumar Ramesh.<br />
We last blogged about coroutine support in Visual Studio 2019 version 16.8. In the releases since 16.8 we&#8217;ve introduced several new coroutine features and improvements. This post is a round up of those improvements,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/">C++20 Coroutine Improvements in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><em>This post includes contributions from Terry Mahaffey and Ramkumar Ramesh.</em></p>
<p>We last blogged about coroutine support in <a href="https://devblogs.microsoft.com/cppblog/c-coroutines-in-visual-studio-2019-version-16-8/">Visual Studio 2019 version 16.8</a>. In the releases since 16.8 we&#8217;ve introduced several new coroutine features and improvements. This post is a round up of those improvements, all available in Visual Studio 2019 16.11.</p>
<div>
<h2 id="debugging-improvements">Debugging Improvements</h2>
</div>
<p>Since Visual Studio 2019 version 16.9, stepping into a coroutine call will now land directly in the coroutine body (unless it is set to initially suspend, in which case the step becomes a “step over”). Stepping over a <code>co_await</code> will land in the logical statement following <code>co_await</code> for the coroutine &#8211; which may be in a completely different execution context (even another thread)! This allows stepping through coroutines to seamlessly match the logical flow of the application and skip intermediate implementation details. For the best debugging experience, implementation details of the coroutine state should be marked as <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/just-my-code?view=vs-2019#BKMK_C___Just_My_Code">non-user code</a>. Stepping through coroutines now also shows function parameters as expected in the Locals window so you can see the state of the application, similar to stepping through synchronous functions.</p>
<p>Inspecting the state of a suspended coroutine is now easier with some improvements to the debugging visualizers for standard coroutines. The legacy <code>coroutine_handle</code> visualizers could display special indicators for the initial and final suspend points, but only showed a number for other suspend points. This number was not always easy to map back to a particular point in the original coroutine. The visualizer also showed the name of the coroutine but only as a modified, internal name generated by the implementation with no signature information.</p>
<p><figure id="attachment_28609" aria-describedby="caption-attachment-28609" style="width: 1446px" class="wp-caption aligncenter"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2.png"><img class="wp-image-28609 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2.png" alt="Image of legacy coroutine handle visualizer shows name as &quot;sample_coroutine$_ResumeCoro$1(void)&quot;" width="1446" height="106" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2.png 1446w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2-300x22.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2-1024x75.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2-768x56.png 768w" sizes="(max-width: 1446px) 100vw, 1446px" /></a><figcaption id="caption-attachment-28609" class="wp-caption-text">Legacy visualizer shows the name as &#8220;sample_coroutine$_ResumeCoro$1(void)&#8221;</figcaption></figure></p>
<p>With the new coroutine handle visualizer introduced in Visual Studio 2019 16.10 the function name is now correct and includes full signature information to help distinguish overloaded coroutines. The suspend point information for suspend points other than initial and final suspend also includes the source line number to make it easier to find.</p>
<p><figure id="attachment_28608" aria-describedby="caption-attachment-28608" style="width: 1205px" class="wp-caption aligncenter"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2.png"><img class="wp-image-28608 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2.png" alt="Image of new coroutine handle visualizer with name &quot;sample_coroutine(int)&quot; and suspend point line number" width="1205" height="80" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2.png 1205w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2-300x20.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2-1024x68.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2-768x51.png 768w" sizes="(max-width: 1205px) 100vw, 1205px" /></a><figcaption id="caption-attachment-28608" class="wp-caption-text">New visualizer shows the name as &#8220;sample_coroutine(int)&#8221; and is suspended on line 35</figcaption></figure></p>
<h2 id="awaitstrict">/await:strict</h2>
<p><span style="font-size: 1rem;">The <a href="https://devblogs.microsoft.com/cppblog/c-coroutines-in-visual-studio-2019-version-16-8/">earlier blog post</a> outlines some issues with legacy await mode and the rationale for keeping the <code>/await</code> switch distinct from C++20 coroutine support in <code>/std:c++latest</code>. Legacy mode is useful for users who were early adopters of C++ coroutines, but they are not standard coroutines. </span></p>
<div>
<div>The<code>/await</code> switch predates not only our <code>/std:c++latest</code> and <code>/std:c++20</code> switches but also <code>/std:c++17</code>. Early adopters were able to make use of coroutines long before they became part of the C++ standard. These users could use coroutines without requiring their code to be C++20 conformant or even necessarily C++17 conformant. With standard coroutines available only under C++20 and latest modes, early adopters of coroutines who cannot move their code to a more recent language version were stuck with the legacy implementation of coroutines under<code>/await</code>. They could not take advantage of some new features like symmetric transfer and improved debugger support, even if they were willing to make source changes to the coroutines themselves to bring them in line with the C++20 standard.</div>
<div>
<div>
<div></div>
<div>Starting in Visual Studio 2019 version 16.10 we introduced a new switch to help early coroutine adopters transition to conformant coroutines and use all features available in standard coroutines: <code>/await:strict</code>. Using this switch instead of <code>/await</code> enables the same C++20 coroutine support as standard mode but without all the other requirements of <code>/std:c++20</code>. This includes support for all standard C++20 coroutine features and debugger integration and disables all the legacy extensions still supported under <code>/await</code>. The only difference between <code>/std:c++20</code> coroutines and <code>/await:strict</code> is the latter does not define the spaceship operator for <code>std::coroutine_handle</code>. Instead, it defines individual relational operators.</div>
<div></div>
</div>
<div>
<div>
<div>Migrating from <code>/await</code> to <code>/await:strict</code> may require source changes if your code relies on extensions that were not adopted into C++20. Like Standard mode it uses the <code>&lt;coroutine&gt;</code> header and the <code>std </code>namespace, so your code will be drop-in ready for C++20. Code compiled with <code>/await:strict</code> uses the same coroutine ABI as <code>/std:c++latest</code>, so coroutine objects are compatible between the two modes.</div>
<div></div>
</div>
<div>
<div>
<div>We encourage all users of <code>/await</code> to migrate to <code>/await:strict</code>. You can take advantage of all new coroutine features as well as ensure your coroutine code is ready for C++20 when you can move to a C++ language version that officially supports coroutines. We expect to deprecate and remove the  <code>/await</code> switch at some point in the future.</div>
<div></div>
</div>
<div></div>
</div>
</div>
</div>
<div>
<h2 id="stability-improvements">Stability Improvements</h2>
<p>Visual Studio 2019 version 16.11 also includes several important fixes to improve the stability and reliability of coroutines.</p>
<p>The largest change relates to how the optimizer does what is called “promotion”, which is the algorithm to decide which variables get placed on the coroutine frame and which variables remain on the (traditional) stack. Many coroutine bugs can be traced back to an incorrect decision here. Typically this shows up as a crash, or as a variable having an incorrect or random value after a coroutine resumes execution. This promotion algorithm has been rewritten to be more accurate, and the result is less crashes and a much smaller coroutine frame size overall. The old algorithm is still accessible by passing <code>/d2CoroNewPromotion-</code> to cl.exe.</p>
<p>A related fix concerns how exception objects are stored. The lifetime rules for exceptions can get complicated, and they need to be handled specifically when it comes time to decide variable promotion.</p>
<p>A bug was found and fixed related to catch blocks in coroutines. Under certain circumstances (namely, when the only throwing call in a try block was from a user defined awaiter method) the optimizer could erroneously conclude a catch block was dead, and incorrectly remove it. The compiler is now aware that awaiter methods can throw.</p>
<p>Finally, a serious issue was resolved related to how and when destructors are invoked. This relates to how the construction state is tracked in coroutines for certain objects which are conditionally destroyed when leaving a scope. It comes up most when constructing objects when using the conditional (ternary) operator. The bug manifests itself by a destructor for such temporary objects not being invoked, or in certain cases invoked twice. This has also been fixed in 16.11.</p>
<h2 id="feedback">Feedback</h2>
</div>
<p>We urge you to try out C++ coroutines in Visual Studio, either with C++20 or now with <code>/await:strict</code>, to see how asynchronous functions can help make your code more natural. As always, we welcome feedback on our coroutine implementation either in the comments below, or for bug reports and feature requests directly on <a href="https://developercommunity.visualstudio.com/home">Developer Community</a>.</p>
</div>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/">C++20 Coroutine Improvements in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>New Compiler Warnings for Dynamic Initialization and User Defined Sections</title>
		<link>https://devblogs.microsoft.com/cppblog/new-compiler-warnings-for-dynamic-initialization/</link>
					<comments>https://devblogs.microsoft.com/cppblog/new-compiler-warnings-for-dynamic-initialization/#comments</comments>
		
		<dc:creator><![CDATA[Xiang Fan]]></dc:creator>
		<pubDate>Tue, 24 Aug 2021 14:56:30 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28604</guid>

					<description><![CDATA[<p>We&#8217;ve added two new warnings to MSVC for misuses of binary sections reserved for the compiler. This short post will explain the issues which they warn against, and potential fixes for your code.<br />
The MSVC C++ compiler provides several ways to create sections and place data in them.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-compiler-warnings-for-dynamic-initialization/">New Compiler Warnings for Dynamic Initialization and User Defined Sections</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We&#8217;ve added two new warnings to MSVC for misuses of binary sections reserved for the compiler. This short post will explain the issues which they warn against, and potential fixes for your code.</p>
<p>The MSVC C++ compiler provides several ways to create sections and place data in them. The linker will convert them into the &#8216;sections&#8217; in the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#general-concepts" target="_blank" rel="noopener">PE (Portable Executable) format</a>.</p>
<p>The compiler also creates some sections itself. One example is the section <code>.CRT$XCU</code>, which is used to implement C++ dynamic initialization (there are other sections for this purpose, too). The name of the section is mentioned in articles like <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization" target="_blank" rel="noopener">CRT Initialization</a>.</p>
<p>Some code bases try to emulate what the compiler does, but the syntax they use doesn&#8217;t do the same thing as what the compiler does internally. This often leads to undefined behavior. In Visual Studio 2019 version 16.11, we introduced two off-by-default warnings <a href="https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/c5247" target="_blank" rel="noopener">C5247</a> and <a href="https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/c5248" target="_blank" rel="noopener">C5248</a> to notify the user when this happens.</p>
<p>For example, we find that the following pattern is used in C++ source in some code bases:</p>
<pre class="lang:c++ decode:true">void f();
typedef void (*type)();

#pragma section(".CRT$XCU", read)
__declspec(allocate(".CRT$XCU")) type i = f;
</pre>
<p>There are two major differences.</p>
<ol>
<li>The section created by <code>#pragma section</code> is a regular section and it has different properties from the one created by the compiler for dynamic initialization.</li>
<li>The variable <code>i</code> placed in the section is a regular variable and isn&#8217;t considered as an initializer by the compiler.</li>
</ol>
<p>These differences can lead to many subtle semantics differences. For example,</p>
<ol>
<li><code>i</code> may be optimized out.</li>
<li>The order when <code>f</code> is called relative to other C++ dynamic initializers is unspecified.</li>
<li>The user defined section <code>.CRT$XCU</code> will interfere with the C++ dynamic initialization. This can lead to undefined behavior which includes missing initialization.</li>
</ol>
<p>If the order is not important, it is recommended to use the following instead:</p>
<pre class="lang:c++ decode:true">void f();
struct init_helper {
    init_helper() { f(); }
};
init_helper i;
</pre>
<p>If you need a specific order (like before or after any compiler generated C++ dynamic initializer), there is no standard conformant way to do that. However, you can take advantage of a feature in the linker which sorts sections by the name and avoid the name of any section created by the compiler or used by the CRT library (note that the variable may still be optimized out and there is no guarantee that the linker behavior will remain the same in the future):</p>
<pre class="lang:c++ decode:true">#pragma section(".CRT$XCT", read)
// 'f1' is guaranteed to be called before any compiler generated C++ dynamic initializer
void f1();
__declspec(allocate(".CRT$XCT")) type i1 = f1;

#pragma section(".CRT$XCV", read)
// 'f2' is guaranteed to be called after any compiler generated C++ dynamic initializer
void f2();
__declspec(allocate(".CRT$XCV")) type i2 = f2;
</pre>
<p>Note, while the names <code>.CRT$XCT</code> and <code>.CRT$XCV</code> are not used by either the compiler or the CRT library right now, there is no guarantee that they will remain unused in the future.</p>
<p>If you have any semantics requirements which can’t be implemented using the above, feel free to let us know in the comment section.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-compiler-warnings-for-dynamic-initialization/">New Compiler Warnings for Dynamic Initialization and User Defined Sections</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/new-compiler-warnings-for-dynamic-initialization/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>Attach to a Remote Process with LLDB in Visual Studio 2022 Preview 3</title>
		<link>https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/</link>
					<comments>https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/#comments</comments>
		
		<dc:creator><![CDATA[Erika Sweet]]></dc:creator>
		<pubDate>Wed, 11 Aug 2021 16:21:30 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Clang]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28613</guid>

					<description><![CDATA[<p>You can now use Attach to Process to remote debug processes with GDB or LLDB in Visual Studio. The ability to attach to a process running on a remote system with GDB was added in Visual Studio 2019. The ability to attach to a process with LLDB is new in Visual Studio 2022 Preview 3.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/">Attach to a Remote Process with LLDB in Visual Studio 2022 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>You can now use <strong>Attach to Process</strong> to remote debug processes with GDB or LLDB in Visual Studio. The ability to attach to a process running on a remote system with GDB was added in Visual Studio 2019. The ability to attach to a process with LLDB is new in Visual Studio 2022 Preview 3.</p>
<p>Remote debugging in Visual Studio is especially valuable for teams who write cross-platform C++ code that runs on Windows and Linux or macOS. For example, if you use Windows + Visual Studio as your primary development environment, then you may need to occasionally debug code running on Linux or macOS. Rather than switching platforms and using GDB or LLDB from the command line, you can use Visual Studio to remote debug processes running on Linux and macOS. Visual Studio’s remote C++ support assumes that your source code is located in the Windows file system.</p>
<p>While a native, command driven workflow may be the best choice for your team, we know that some teams:</p>
<ul>
<li>Are unfamiliar with platform specific tools, especially if they use Windows + the Visual Studio debugger as their primary development environment.</li>
<li>Prefer Visual Studio&#8217;s graphical interface and feature set over a command line interface.</li>
<li>Find it unproductive to switch between platforms for native debugging.</li>
<li>Rely on a subset of developers who are comfortable with command line tools to debug all non-Windows errors and are looking to democratize that process.</li>
</ul>
<p>Follow the steps below to get started debugging a remote process with LLDB and Visual Studio 2022.</p>
<h4 id="getting-started-instructions">Getting started instructions</h4>
<p>1. On Windows, <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/">Install Visual Studio 2022 Preview 3 or later.</a></p>
<p>2. On your remote system, acquire LLDB and LLDB-mi. On macOS you can install LLDB with XCode or the XCode Command Line Tools. You can install a build of LLDB-mi maintained by the C/C++ Extension for VS Code.</p>
<p><div style="text-align:center"><a class="cta_button_link" href="https://go.microsoft.com/fwlink/?linkid=2154927" style="text-transform: titlecase; display: inline-block; background-color: #5C2D91; color: white; padding: 10px; margin:10px 0; text-decoration: none;" target="_blank">Install LLDB-mi for macOS</a></div></p>
<p>We don’t currently maintain a LLDB-mi binary for Linux. You can install LLDB and LLDB-mi with the instructions in <a href="https://github.com/microsoft/vscode-cpptools/issues/5415#issuecomment-662603085">this comment</a> from iamWing in the C/C++ Extension for VS Code repository.</p>
<p>3. On your remote system, start SSH (<a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-160#set-up-the-ssh-server-on-the-remote-system">instructions</a>) and the process that you want to debug.</p>
<p>4. On Windows, open Visual Studio 2022 and select <strong>Debug &gt; Attach to Process…</strong></p>
<ul>
<li>Set the <strong>Connection type</strong> to SSH.</li>
<li>Set the <strong>Connection target. </strong>You can select any system that you have added to the Visual Studio <a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-160">Connection Manager</a>, or you can provide a new address with the format <strong>user@host </strong>(e.g., demo@121.121.2.11). You can also add new connections to the Visual Studio Connection Manager with our <a href="https://docs.microsoft.com/en-us/cpp/linux/connectionmanager-reference?view=msvc-160">command line tool</a>.</li>
<li>Set the <strong>code type </strong>to Native (LLDB). If you are remote debugging with GDB, then set the code type to Native (GDB).</li>
</ul>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type.png"><img class="aligncenter size-full wp-image-28614" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type.png" alt="The Visual Studio dialog is labeled &quot;Select Code Type.&quot; The option &quot;Debug these code types&quot; is selected and followed by two options: Native (GDB) and Native (LLDB). Native (LLDB) is selected." width="488" height="383" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type.png 488w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type-300x235.png 300w" sizes="(max-width: 488px) 100vw, 488px" /></a></p>
<ul>
<li>The <strong>list of available processes</strong> will list all processes running on your remote system by process name and ID. Select the process that you want to remote debug and press “Attach” to launch the debugger.</li>
</ul>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1.png"><img class="aligncenter size-full wp-image-28625" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1.png" alt="The Visual Studio dialog is labeled &quot;Attach to Process.&quot; The connection type is SSH, the connection target is &quot;erika@localhost&quot;, and the code type is &quot;Native (LLDB) code&quot;. A list of 3 processes is displayed under &quot;Available processes&quot;, and process &quot;CMakeProject&quot; is selected." width="853" height="604" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1.png 853w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1-300x212.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1-768x544.png 768w" sizes="(max-width: 853px) 100vw, 853px" /></a></p>
<p>5. Visual Studio will attach LLDB to the selected process and start a debugging session. You can pause the debugger to see the current execution point. All the debug windows support by Visual Studio will be populated with data from the remote process.</p>
<h4 id="talk-to-us">Talk to us!</h4>
<p>Attach to Process is the first remote debugging scenario supported by LLDB in Visual Studio. Try it out and give us your feedback, or let us know if there are other remote debugging features that you want to see. The best way to file a bug or suggest a feature is with the <strong>Send Feedback</strong> button in the upper right-hand corner of the IDE. See <a href="https://docs.microsoft.com/en-us/visualstudio/ide/feedback-options?view=vs-2019#:~:text=In%20Visual%20Studio%2C%20choose%20the%20feedback%20icon%20in,information%2C%20see%20Suggest%20a%20feature%20for%20Visual%20Studio.">Visual Studio feedback options</a> for more information.</p>
<p>We’d love to learn how your team is adopting our support for LLDB. If you have feedback or a success story to share, you can contact us at <a href="mailto:vcpp-linux@microsoft.com">vcpp-linux@microsoft.com</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/">Attach to a Remote Process with LLDB in Visual Studio 2022 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>ARM64EC Support in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Moyo Okeremi]]></dc:creator>
		<pubDate>Tue, 10 Aug 2021 19:45:49 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28369</guid>

					<description><![CDATA[<p>ARM64EC (“Emulation Compatible”) is a new application binary interface (ABI) for building apps for Windows 11 on ARM. With ARM64EC, you can build new native apps that can run on ARM or incrementally transition existing x64 apps to native performance on ARM.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/">ARM64EC Support in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>ARM64EC (“Emulation Compatible”) is a new application binary interface (ABI) for building apps for Windows 11 on ARM. With ARM64EC, you can build new native apps that can run on ARM or incrementally transition existing x64 apps to native performance on ARM. For more information about ARM64EC, check out the <a href="https://aka.ms/arm64ecannounceblog">Windows Developer blog</a>.</p>
<h2 id="why-should-developers-target-arm64ec">Why Should Developers Target ARM64EC?</h2>
<p>Applications that are built to run on ARM, give customers the benefit of a great native experience that unlocks the full power of the ARM device. However, from a developer perspective, porting an app to run on ARM can be all-or-nothing, since <strong>all</strong> the binaries within a process need to be rebuilt as ARM before a customer can enjoy the benefits.</p>
<p>With ARM64EC, you can choose to start small and build incrementally. Once you identify the part of your codebase that would benefit most from native performance, you can simply rebuild it as ARM64EC. The rest of the app will remain fully functional as emulated x64, but the recompiled ARM64EC parts will now have native speed.</p>
<p>In addition, the ability to mix and match x64 and ARM64EC makes it possible to build an app on ARM even if it depends on x64 code outside of your control. For example, projects with third-party dependencies that don’t support ARM can leave them as x64. Also, apps with an in-proc plugin ecosystem can build as ARM64EC to get native speed on ARM, while continuing to load and use x64 plugins.</p>
<h2 id="how-to-target-arm64ec-in-visual-studio">How to Target ARM64EC in Visual Studio</h2>
<p>To start using Visual Studio to build your projects as ARM64EC, you&#8217;ll need to install these prerequisites:</p>
<ul>
<li>The latest <a href="https://aka.ms/windowsinsidersdk">Windows Insider SDK build</a> which is available through the Windows Insider program.</li>
<li>The latest <a href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noopener">Visual Studio 2019 Preview</a> or <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/" target="_blank" rel="noopener">Visual Studio 2022 Preview</a></li>
<li>The ARM64EC tools from the Visual Studio Installer:</li>
</ul>
<p style="padding-left: 40px;"><img width="713" height="275" class="wp-image-28370" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-email.png" alt="Graphical user interface, text, application, email Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-email.png 713w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-email-300x116.png 300w" sizes="(max-width: 713px) 100vw, 713px" /></p>
<p>Once you have installed all the prerequisites, you can now target ARM64EC in your MSBuild and CMake Projects as explained in the following sections.</p>
<h3 id="msbuild-projects">MSBuild Projects</h3>
<p>Open your C++ project or solution in Visual Studio. If you don’t have one yet, create a new one by navigating to: <strong>Create a new project &gt; C++ Console App</strong>:</p>
<p><img class="wp-image-28371" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica.png" alt="A screenshot of a computer Description automatically generated with medium confidence" width="858" height="371" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica.png 2552w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-300x130.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1024x443.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-768x332.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1536x664.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-2048x885.png 2048w" sizes="(max-width: 858px) 100vw, 858px" /></p>
<p>Open up the configuration manager by navigating to the tool bar and clicking <strong>build &gt; configuration manager</strong>:</p>
<p><img class="wp-image-28372" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1.png" alt="A screenshot of a computer Description automatically generated" width="409" height="362" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1.png 1118w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1-300x266.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1-1024x908.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1-768x681.png 768w" sizes="(max-width: 409px) 100vw, 409px" /></p>
<p>In the Active solution platform box, select <strong>&lt;New…&gt;</strong> to create a new platform:</p>
<p><img class="wp-image-28373" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word.png" alt="Graphical user interface, text, application, Word, email Description automatically generated" width="683" height="261" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word.png 1709w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-300x115.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-1024x391.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-768x293.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-1536x587.png 1536w" sizes="(max-width: 683px) 100vw, 683px" /></p>
<p>Select <strong>ARM64EC</strong>, Copy settings from <strong>x64</strong>, check the <strong>Create new project platforms</strong> checkbox and click <strong>OK</strong>:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1.png"><img class="alignnone wp-image-28383" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1-300x220.png" alt="Image Picture1" width="378" height="277" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1-300x220.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1.png 624w" sizes="(max-width: 378px) 100vw, 378px" /></a></p>
<p>Finally, ensuring that ARM64EC is the active solution configuration, select <strong>Build </strong>from the menu to successfully build your ARM64EC project.</p>
<p><strong>Note</strong>: By design, not all projects in the ARM64EC solution need to be targeting ARM64EC as they can target x64 instead. Ensure that you configure those x64 projects in the configuration manager to target x64 under the ARM64EC solution build:</p>
<p><img class="wp-image-28375" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description.png" alt="Graphical user interface, application Description automatically generated" width="884" height="345" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description.png 1664w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-300x117.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-1024x399.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-768x300.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-1536x599.png 1536w" sizes="(max-width: 884px) 100vw, 884px" /></p>
<p>For more information on working with MSBuild C++ Projects, see our documentation on <a href="https://docs.microsoft.com/en-us/cpp/build/creating-and-managing-visual-cpp-projects?view=msvc-160">Visual Studio Projects &#8211; C++ | Microsoft Docs</a> and <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging-cpp?view=vs-2019">Remote Debug a C++ Project &#8211; Visual Studio (Windows) | Microsoft Docs</a></p>
<h3 id="cmake-projects">CMake Projects</h3>
<p>If you haven’t already, install the CMake Build tools from the Visual Studio Installer:</p>
<p><img class="wp-image-28376" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr.png" alt="Graphical user interface, text, application Description automatically generated" width="425" height="238" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr.png 800w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-300x168.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-768x430.png 768w" sizes="(max-width: 425px) 100vw, 425px" /></p>
<p>Open your C++ CMake project in Visual Studio. If you don’t have one yet, create a new one by navigating to: <strong>Create a new project &gt; CMake Project</strong>:</p>
<p><img class="wp-image-28377" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall.png" alt="Graphical user interface Description automatically generated" width="704" height="342" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall.png 2468w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-300x146.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-1024x497.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-768x373.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-1536x746.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-2048x994.png 2048w" sizes="(max-width: 704px) 100vw, 704px" /></p>
<p>With <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">CMakePresets.json</a> integration in Visual Studio, the default active configuration of the new project will be the Windows default which targets configuring and building on the local Windows Machine. This is the scenario we are interested in.</p>
<p><img class="wp-image-28378" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1.png" alt="Graphical user interface, text, application Description automatically generated" width="673" height="158" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1.png 1975w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-300x70.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-1024x241.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-768x180.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-1536x361.png 1536w" sizes="(max-width: 673px) 100vw, 673px" /></p>
<p>Open up the CMakePresets.json file by going to the active configuration dropdown and selecting <strong>Manage Configurations</strong>:</p>
<p><img class="wp-image-28379" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa.png" alt="Graphical user interface, text Description automatically generated" width="717" height="230" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa.png 1175w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa-300x96.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa-1024x329.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa-768x246.png 768w" sizes="(max-width: 717px) 100vw, 717px" /></p>
<p>Modify the architecture property under the windows configuration you want for ARM64EC:</p>
<pre class="prettyprint"> "architecture": { 
    "value": "arm64ec", 
    "strategy": "external"
 }</pre>
<p><strong>Note: </strong>The default generator is Ninja. If using the visual studio generator (2019 or 2022), change the strategy field to<strong> set.</strong></p>
<p>If using Ninja generator, you’ll also need to set some environment variables by adding the <strong>environment </strong> object to your CMakePresets configuration:</p>
<pre class="prettyprint"> "environment": { 
    "CXXFLAGS": "/arm64EC",
    "CFLAGS": "/arm64EC" 
 }</pre>
<p>Save the CMakePresets file and make sure the active configuration is set to the arm64ec configuration. From the menu bar, select <strong>project menu, </strong>then select<strong> Configure &lt;Project Name&gt; </strong>in order to generate your CMake cache.</p>
<p>Build your CMake Project targeting ARM64EC like any other CMake project: navigate to the <strong>Build Menu </strong>and select <strong>build all</strong>.</p>
<p>For more information on working with CMake projects and CMakePresets, see our documentation on  <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160">CMake projects in Visual Studio | Microsoft Docs</a> , <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">Configure and build with CMake Presets | Microsoft Docs</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-remote-debugging?view=msvc-160">Tutorial: Debug a CMake project on a remote Windows machine | Microsoft Docs</a>.</p>
<h2 id="give-us-your-feedback">Give us your feedback</h2>
<p>Download the latest <a href="https://visualstudio.microsoft.com/vs/preview/&quot; \t &quot;_blank">Visual Studio 2019 Preview</a> or <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/" target="_blank" rel="noopener">Visual Studio 2022 Preview</a>  today and give it a try. We’d love to hear from you to help us prioritize and build the right features for you. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/spaces/8/index.html" target="_blank" rel="noopener">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>). The best way to file a bug or suggest a feature is via Developer Community.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/">ARM64EC Support in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
		<item>
		<title>Moving a project to C++ named Modules</title>
		<link>https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/</link>
					<comments>https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Tue, 10 Aug 2021 17:23:41 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[C++ language]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[modules]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28553</guid>

					<description><![CDATA[<p>There is a lot of hype (and perhaps restraint) to using modules in projects. The general blocker tends to be build support, but even with good build support there is a distinct lack of useful resources for practices around moving projects to using named modules (not just header units).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">Moving a project to C++ named Modules</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>There is a lot of hype (and perhaps restraint) to using modules in projects. The general blocker tends to be build support, but even with good build support there is a distinct lack of useful resources for practices around moving projects to using named modules (not just header units). In this blog we will take a small project I created, analyze its components, draft up a plan for modularizing it, and execute that plan.</p>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#tools-used">Tools used.</a></li>
<li><a href="#project-description">Project description.</a></li>
<li><a href="#cpp-today">Ball Pit! in C++ without modules.</a></li>
<li><a href="#ungluing">Ungluing from <code>#include</code></a>
<ul>
<li><a href="#starting-small">Starting small&#8230;</a></li>
<li><a href="#visibility">Choosing visibility</a></li>
<li><a href="#3rd-party-pain">3rd party pain.</a></li>
<li><a href="#polish">Polishing with modules.</a></li>
</ul>
</li>
<li><a href="#all-together">All together now.</a></li>
</ul>
<h4><span id="tools-used">Tools used</span></h4>
<p>For the purposes of this project, we will be using the following tools:</p>
<ul>
<li>CMake &#8211; Version: <code>3.20.21032501-MSVC_2</code>. <em>Note:</em> this is the installed version of CMake which comes with Visual Studio 2019.</li>
<li>Visual Studio 2019 &#8211; Version: <code>16.11</code>.</li>
</ul>
<h4><span id="project-description">Project description</span></h4>
<p>I remember when I was younger, I used to love doing kid things like eating terrible fast food, but going to these restaurants had an additional perk: the play places! One of my favorite things to do was go to the ball pit, dive in, and make a giant splash of color.</p>
<p><a style="display: block; margin-left: auto; margin-right: auto; width: 50%;" title="Rachmaninoff, CC BY-SA 4.0 &lt;https://creativecommons.org/licenses/by-sa/4.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ball_pit_with_playground_slide.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Ball_pit_with_playground_slide.jpg/512px-Ball_pit_with_playground_slide.jpg" alt="Ball pit with playground slide" width="512" /></a></p>
<p>I shudder to think of going into one nowadays, but I have not forgotten how much fun they were. I have also recently become very inspired by OneLoneCoder on YouTube and his <a href="https://www.youtube.com/watch?v=LPzyNOHY3A4">series on programming simple physics engines</a>. I decided I would try to take this simple physics engine and make something a little bit fun and a lot more colorful, introducing &#8220;Ball Pit!&#8221;:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/ball-pit.gif"><img class="aligncenter size-full wp-image-28558" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/ball-pit.gif" alt="Image ball pit" width="320" height="240" /></a></p>
<p>&#8220;Ball Pit!&#8221; is a quite simple program built using the following discrete components:</p>
<ul>
<li>OneLoneCoder <a href="https://github.com/OneLoneCoder/olcPixelGameEngine">PixelGameEngine</a> (PGE) &#8211; Drives graphics.</li>
<li>A simple physics engine for managing all the objects on screen.</li>
<li>A data structure related to handling collisions between objects, a <a href="https://en.wikipedia.org/wiki/Quadtree">quad-tree</a>.</li>
<li>A world object to contain our beautiful orbs.</li>
<li>Utilities such as common types and functions on those types.</li>
<li>The main game object which is responsible for the primary game loop and polling user input.</li>
</ul>
<h4><span id="cpp-today">Ball Pit! in C++ without modules</span></h4>
<p>Since we established a basic design layout in the previous section, let us see what we can produce using C++20 without any modules whatsoever. Without further ado, here is the code in all its <code>#include</code> glory: <a href="https://github.com/cdacamar/ball_pit/tree/ce90e45245bf7981fd797d992389693bdd586c0b">Ball Pit! Without modules</a>. The easiest way to build this project is to  use <a href="https://docs.microsoft.com/en-us/cpp/build/open-folder-projects-cpp?view=msvc-160">Visual Studio&#8217;s open folder</a> support.</p>
<p>Alternatively you can do the following (in a VS2019 developer command prompt):</p>
<pre>$ mkdir build &amp; cd build &amp; cmake -G"Visual Studio 16 2019" -Ax64 ..\</pre>
<p>Once CMake has generated the solution for you can open it using Visual Studio 2019, use the familiar F5 loop and off you go!</p>
<h5 id="traditional-c-structure">Traditional C++ Structure</h5>
<p>Let us talk briefly about the traditional project structure of this code. We have the following, familiar, breakdown:</p>
<pre>ball_pit/
├─ include/
├─ src/</pre>
<p>As you might expect the <code>include/</code> directory is almost a mirror of some files under <code>src/</code>. You also end up with a sizeable set of includes in our primary <code>ball-pit.cpp</code> to pull all the pieces together:</p>
<pre>#include "bridges/pge-bridge.h"

#include "physics/physics-ball.h"
#include "physics/physics-engine.h"
#include "physics/quad-tree.h"
#include "util/basic-types.h"
#include "util/enum-utils.h"
#include "util/random-generator.h"
#include "world/world.h"</pre>
<p>You might notice that these includes directly reflect the design we set out to have:</p>
<ul>
<li>PGE for graphics: <code>"bridges/pge-bridge.h"</code></li>
<li>Physics engine: <code>"physics/physics-engine.h"</code></li>
<li>Quad-tree: <code>"physics/quad-tree.h"</code></li>
<li>World object: <code>"world/world.h"</code></li>
<li>Utilities: <code>"util/*</code></li>
<li>Main game: (the current source file: <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/src/ball-pit.cpp"><code>ball-pit.cpp</code></a>)</li>
</ul>
<p>Since we made the decision to use header files you will notice that we get some declarations like this:</p>
<pre>inline RandomNumberGenerator&amp; random_generator()</pre>
<p>Where there is a strong desire not to implement this simple function in its own <code>.cpp</code> file for simplicity&#8217;s sake, but if you forget the critical <code>inline</code> keyword or, even worse, mark it as <code>static</code> you will not get the behavior you expect from this function.</p>
<p>Another thing which I like to do on my projects is separate 3rd party headers from the rest of the project using these &#8220;bridge&#8221; header files. The reason is so that I can easily control warning suppression/isolated requirements for that header. The PGE header is isolated into its own bridge called <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/bridges/pge-bridge.h"><code>pge-bridge.h</code></a>.</p>
<p>Finally, for projects which utilize <code>#include</code> as a code sharing mechanism, I like to employ the idea that each header file should stand completely on its own, meaning that if a header uses something like <code>std::vector</code> it cannot rely on that container being introduced through some other header, it must include it itself. This is good practice; it makes maintaining headers minimal as you move them around and use them in more places.</p>
<h4><span id="ungluing">Ungluing from <code>#include</code></span></h4>
<p>At the beginning it was mentioned that we are using CMake as our configuration system but, as of publishing, CMake&#8217;s support for modules is still experimental. What we <em>can</em> do is generate build system output for a build system which <em>does</em> support modules: MSBuild&#8217;s! All we need to do is tell MSBuild that there are module interfaces in this project and &#8220;Presto!&#8221; we have a modules-compatible project! By default, MSBuild will key off any source files with a <code>.ixx</code> extension to automatically support named modules—exactly what we want! Now, how do we get there?</p>
<p>If we examine the <code>include/</code> tree we get a surprisingly promising idea of what module interfaces we need:</p>
<pre>ball_pit/
├─ include/
│  ├─ bridges/
│  │  ├─ pge-bridge.h
│  ├─ physics/
│  │  ├─ physics-ball.h
│  │  ├─ physics-engine.h
│  │  ├─ physics-utils.h
│  │  ├─ quad-tree.h
│  ├─ util/
│  │  ├─ basic-types.h
│  │  ├─ enum-utils.h
│  │  ├─ random-generator.h
│  │  ├─ stopwatch.h
│  ├─ world/
│  │  ├─ world.h</pre>
<p>It is common for mature projects to have a similar structure and breakdown of components and it makes sense for maintainability reasons. As a goal for modularizing this project let us aim to remove the entire directory tree of <code>include/</code> and take advantage of modules as much as possible. Let us do exactly that by introducing some new files into the directory tree which reflects our header file layout (making them empty for now):</p>
<pre>ball_pit/
├─ modules/
│  ├─ bridges/
│  │  ├─ pge-bridge.ixx
│  ├─ physics/
│  │  ├─ physics-ball.ixx
│  │  ├─ physics-engine.ixx
│  │  ├─ physics-utils.ixx
│  │  ├─ quad-tree.ixx
│  ├─ util/
│  │  ├─ basic-types.ixx
│  │  ├─ enum-utils.ixx
│  │  ├─ random-generator.ixx
│  │  ├─ stopwatch.ixx
│  ├─ world/
│  │  ├─ world.ixx</pre>
<p>Now the process of moving everything over to using modules begins!</p>
<h5><span id="starting-small">Starting small&#8230;</span></h5>
<p>When tackling a project of any size you want to start as small as you possibly can. In the case of &#8220;Ball Pit!&#8221; I started with <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/util/enum-utils.h"><code>include/util/enum-utils.ixx</code></a> because it did not depend on anything besides a STL header. The first thing you need to do is add the content to your module interface:</p>
<pre>module;
#include &lt;type_traits&gt;
export module Util.EnumUtils;

template &lt;typename T&gt;
concept Enum = std::is_enum_v&lt;T&gt;;

template &lt;Enum E&gt;
using PrimitiveType = std::underlying_type_t&lt;E&gt;;

template &lt;Enum E&gt;
constexpr auto rep(E e) { return PrimitiveType&lt;E&gt;(e); }</pre>
<p>This is <em>almost</em> a 1-to-1 copy-paste of the header but with the following exceptions:</p>
<ul>
<li>Our STL headers are injected into the <a href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-160#modules-and-header-files">global module fragment</a> (the region between <code>module;</code> and <code>export module ...)</code>.</li>
<li>We have given a proper name to our module: <code>Util.EnumUtils</code>. <em>Note:</em> the <code>.</code> separated names do not indicate any filesystem structure.</li>
<li>We no longer need header include guards.</li>
</ul>
<p>There is one last thing missing: we did not actually export anything! Since all these names are used around the project, we need to export everything, and the easiest way to export lots of declarations at once is to use the <code>export { ... }</code> syntax. Take a look:</p>
<pre>module;
#include &lt;type_traits&gt;
export module Util.EnumUtils;

export
{

template &lt;typename T&gt;
concept Enum = std::is_enum_v&lt;T&gt;;

template &lt;Enum E&gt;
using PrimitiveType = std::underlying_type_t&lt;E&gt;;

template &lt;Enum E&gt;
constexpr auto rep(E e) { return PrimitiveType&lt;E&gt;(e); }

} // export</pre>
<p>The next logical step for us is to replace any instance of <code>#include "util/enum-utils.h"</code> with <code>import Util.EnumUtils;</code>. This part is largely mechanical and to play off <a href="https://docs.microsoft.com/en-us/cpp/cpp/import-export-module?view=msvc-160#import">guidance around mixing <code>import</code> and <code>#include</code></a> I ensured to place any <code>import</code> after any <code>#include</code>&#8216;s. Finally, we add this new interface to the <code>CMakeLists.txt</code> <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/CMakeLists.txt#L27">here</a>, configure, build and run again. Things should run the same as before except that we are one step closer to modularizing the project!</p>
<h5><span id="visibility">Choosing visibility</span></h5>
<p>Named modules are all about defining the surface area of your API. Now that we have a tool which allows us to hide implementation details that would otherwise be unnecessary for consumers, we can start to think about what the accessible parts of the API should be. Let us look at modularizing <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/util/random-generator.h"><code>include/util/random-generator.h</code></a>. In this file we have the following declarations:</p>
<pre>enum class RandomSeed : decltype(std::random_device{}()) { };

template &lt;std::integral I&gt;
using IntDistribution = std::uniform_int_distribution&lt;I&gt;;

template &lt;std::floating_point I&gt;
using RealDistribution = std::uniform_real_distribution&lt;I&gt;;

class RandomNumberGenerator
{
   ...
};

inline RandomNumberGenerator&amp; random_generator()
{
   ...
}</pre>
<p>Of these declarations the ones we use outside of the header are <code>IntDistribution</code>, <code>RealDistribution</code>, and <code>random_generator()</code> (not even the class name directly). As such we can define the module like so:</p>
<pre>export module Util.RandomGenerator;

import Util.EnumUtils;

enum class RandomSeed : decltype(std::random_device{}()) { };

export
template &lt;std::integral I&gt;
using IntDistribution = std::uniform_int_distribution&lt;I&gt;;

export
template &lt;std::floating_point I&gt;
using RealDistribution = std::uniform_real_distribution&lt;I&gt;;

class RandomNumberGenerator
{
    ...
};

export
RandomNumberGenerator&amp; random_generator()
{
    ...
}</pre>
<p>Notice that we do not even need to export the declaration of the class <code>RandomNumberGenerator</code>. We do not need its name; we only need its functionality, and we can prevent users from creating extra instances of it by allowing its use through <code>random_generator()</code> only.</p>
<p>Furthermore, we no longer need <code>random_generator()</code> to be marked as <code>inline</code> because there is now only one definition in any given translation unit. Do not be afraid to put compiled code in an interface, it is its own translation unit and obeys the rules of compiled code.</p>
<h5><span id="3rd-party-pain">3rd party pain</span></h5>
<p>In C++ we deal with sharing code all the time and a lot of the time that code has a distinctive style, compiler requirements, default warning settings, etc. When we move code into a modules world, and in particular 3rd party code, we need to take some things into consideration: what part of the library do we want to expose? What runtime requirements are in the library if it is header only? Do we want to &#8220;seal&#8221; off bad parts of the library? With modules we start to have answers to these questions based on the requirements of our project. Integrating 3rd party library functionality into modularized projects is one of the most interesting parts of using modules because modules give us tools we never had before to deal with ODR (One Definition Rule) and name resolution. In this section we will focus on modularizing the <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/bridges/pge-bridge.h"><code>include/bridges/pge-bridge.h</code></a>.</p>
<p>The OneLoneCoder PixelGameEngine is a nice library if you are just starting out exploring games programming. It is easy to integrate into projects (because it is a single header file) and the interfaces are simple&#8211;which plays to our advantage in deciding what parts of the library we want to expose. In &#8220;Ball Pit!&#8221; we use the following functionality from PGE:</p>
<ul>
<li><code>olc::PixelGameEngine</code> &#8212; For the main program.</li>
<li><code>olc::Key</code> &#8212; For user input.</li>
<li><code>olc::Pixel</code> &#8212; For coloring pixels.</li>
<li><code>olc::vf2d</code>/<code>olc::vi2d</code> &#8212; Standard vector classes (<code>float</code> and <code>int</code> respectively).</li>
<li><code>olc::BLACK</code>, <code>olc::WHITE</code>, <code>olc::BLUE</code>, and <code>olc::RED</code> &#8212; Color constants.</li>
</ul>
<p>We can, by default, export each of the above with a using-declaration:</p>
<pre>module;
#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used: nameless struct/union
#pragma warning(disable: 4245) // 'argument': conversion from 'int' to 'uint8_t', possible loss of data
#include "olcPixelGameEngine.h"
#pragma warning(pop)
export module Bridges.PGE;

export
namespace olc
{
    // For game.
    using olc::PixelGameEngine;
    using olc::Key;

    // For basic types.
    using olc::Pixel;
    using olc::vf2d;
    using olc::vi2d;

    // Allow using the multiply operator from olc::v2d_generic.
    using olc::operator*;
}</pre>
<p>The reason we use a using-declaration is because we do not want the module to own all these objects/functions. By injecting the names through a using-declaration their linkage remains tied to the global module so we can separately compile them in <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/src/3rd_party/olcPixelGameEngine.cpp"><code>src/3rd_party/olcPixelGameEngine.cpp</code></a> as before.</p>
<p>You will immediately notice that the color constants are mysteriously missing. This is because these constants are defined with <code>static</code> linkage in the header file so we cannot export them directly and the reason is <a href="http://eel.is/c%2B%2Bdraft/basic.link#18">buried in standardese</a>. It is simpler to remember that you cannot export an internal linkage entity (i.e. one declared <code>static</code>). The way to get around this is wrap them in a function which has module linkage:</p>
<pre>export
namespace olc
{
    ...
    // Note: Because these color constants are defined to be static in the header they cannot be
    // directly exported.  Instead we export their values through a module-owned variable.
    namespace ModuleColors
    {
        auto Black()
        {
            return olc::BLACK;
        }

        auto White()
        {
            return olc::WHITE;
        }

        auto Blue()
        {
            return olc::BLUE;
        }

        auto Red()
        {
            return olc::RED;
        }
    }
    ...
}</pre>
<p>Once we have these functions, we need to replace any instance of <code>olc::COLOR</code> with its respective call to our exported color function.</p>
<p>And that is it! We have successfully exported exactly what we need from PGE for our &#8220;Ball Pit!&#8221; app! Just as before, you add this to the <code>CMakeLists.txt</code>, replace <code>#include "bridges/pge-bridge.h"</code> with <code>import Bridges.PGE;</code>.</p>
<h5><span id="polish">Polishing with modules</span></h5>
<p>Once you have gone through the exercise of modularizing more and more of the project you might find that your main program begins to reflect the header file version:</p>
<pre>import Bridges.PGE;

import Physics.Ball;
import Physics.Engine;
import Physics.QuadTree;
import Util.BasicTypes;
import Util.EnumUtils;
import Util.RandomGenerator;
import World;</pre>
<p>Dandy! Modules also give us similar tools as header files do in that we can group common sets of modules together into a &#8220;package&#8221;. To understand what I am talking about let us look at a header file equivalent of grouping common functionality. Here is what a grouping of all the headers under <code>include/physics/*</code> might look like:</p>
<p><code>include/physics/physics.h</code></p>
<pre>#ifndef PHYSICS_H
#define PHYSICS_H

#include "physics/physics-ball.h"
#include "physics/physics-engine.h"
#include "physics/physics-utils.h"
#include "physics/quad-tree.h"

#endif PHYSICS_H</pre>
<p>The problem, of course, is while this is convenient and you do not need to think about which specific file to include for your current project, you end up paying the cost of every header file in the package regardless of if you use it or not. It flies in the face of C++&#8217;s core concept: pay for what you use. With the introduction of C++20 modules we no longer have this problem because modules do next to zero work when you import them, so we can safely create the following interface without negatively impacting the compile time of consumers:</p>
<p><code>modules/physics/physics.ixx</code></p>
<pre>export module Physics;

export import Physics.Ball;
export import Physics.Engine;
export import Physics.QuadTree;
export import Physics.Utils;</pre>
<p>We can also do the same for anything under <code>Util.*</code>. This leads us to a rather, I think, respectable looking <code>ball-pit.cpp</code>:</p>
<pre>import Bridges.PGE;

import Physics;
import Util;
import World;</pre>
<h4><span id="all-together">All together now</span></h4>
<p>It was a little bit of a journey getting here, and there are learnings along the way. I will not dillydally any further, here is the complete, modularized, version of &#8220;Ball Pit!&#8221;: <a href="https://github.com/cdacamar/ball_pit/tree/565e3bff28b78b84ac3765d6c786e96980177867"><code>ball_pit</code></a>. You can check out the code, configure, and build it the same as we <a href="#cpp-today">covered earlier</a> using Visual Studio 2019 version 16.11.</p>
<p>There is one thing I want to mention, because I can all but guarantee it is on everybody&#8217;s mind: what is the build throughput? With modules there is an up-front cost in building our interfaces. With the old inclusion model, we did not have to build our include files explicitly (only implicitly). We end up building more up front, but the result is that we can <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> our main program and its components much, much faster. Here is a snapshot of the difference:</p>
<p>Compiling <code>ball-pit.cpp</code>:</p>
<table>
<tbody>
<tr>
<td>Without modules</td>
<td>With modules</td>
</tr>
<tr>
<td>3.55275s</td>
<td>0.15413s</td>
</tr>
</tbody>
</table>
<p><em>Note:</em> these times were an average of 10 runs. You can see the results yourself by observing the <code>c1xx.dll</code> in the build log (left in for comparisons).</p>
<p>Yep, that is a real ~23x speedup difference. That kind of compile time if you&#8217;re developing a game can make a dramatic difference if you are wanting to quickly test changes to your game or make mistakes, like I often do :).</p>
<h4 id="closing">Closing</h4>
<p>The process of using named modules in complex projects can be time consuming, but this type of refactor pays off in both reducing development costs associated with recompiling and code hygiene. Named modules give us so much more than simply better compile times and in the above we have only scratched the surface of what is possible. Stay tuned for more modules educational content from us in the future!</p>
<p>We urge you to go out and try using Visual Studio 2019/2022 with Modules. Both Visual Studio 2019 and Visual Studio 2022 Preview are available through the <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio downloads</a> page!</p>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow me on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">Moving a project to C++ named Modules</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/feed/</wfw:commentRss>
			<slash:comments>19</slash:comments>
		
		
			</item>
		<item>
		<title>Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/</link>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Thu, 29 Jul 2021 15:59:04 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[debug]]></category>
		<category><![CDATA[debugging]]></category>
		<category><![CDATA[edit and continue]]></category>
		<category><![CDATA[hot reload]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28456</guid>

					<description><![CDATA[<p>Hot Reload support for C++ Applications<br />
In Visual Studio 2022 Preview 2, we are happy to announce that Hot Reload is now supported for C++.<br />
Hot Reload for C++, powered by Edit and Continue, is a new way of editing your code while actively debugging.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/">Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="hot-reload-support-for-c-applications">Hot Reload support for C++ Applications</h1>
<p>In Visual Studio 2022 Preview 2, we are happy to announce that Hot Reload is now supported for C++.</p>
<p>Hot Reload for C++, powered by Edit and Continue, is a new way of editing your code while actively debugging. Hot Reload allows you to apply code changes without stopping at a breakpoint or restarting your app.</p>
<p><span style="font-size: 14pt;"><em>Currently, Hot Reload is only supported for MSBuild C++ projects, but we are working on enabling support for CMake projects in an upcoming preview.</em> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/HRShort.gif"><img class="aligncenter size-full wp-image-28481" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/HRShort.gif" alt="Image Hot reload changing cube spin speed" width="1200" height="675" /></a></p>
<p>To learn more about Hot Reload, please refer to the Visual Studio Blog post: <a href="https://devblogs.microsoft.com/visualstudio/speed-up-your-dotnet-and-cplusplus-development-with-hot-reload-in-visual-studio-2022">Speed up your .NET and C++ development with Hot Reload in Visual Studio 2022</a></p>
<h1 id="we-want-your-feedback-survey">We Want Your Feedback: Survey</h1>
<p>As we are looking at these experiences, please let us know how Hot Reload and/or Edit and Continue support for C++ can be further enhanced to improve your day-to-day productivity. We’re looking forward to your feedback.</p>
<p><strong>Please participate in this 3-minute <a href="https://www.surveymonkey.com/r/B7GRLF6">Hot Reload for C++ Survey</a>.</strong></p>
<p>You can also reach us on Twitter (@VisualC).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/">Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Wed, 28 Jul 2021 16:00:32 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28441</guid>

					<description><![CDATA[<p>The July 2021 update of the C++ extension for Visual Studio Code is here, bringing you brand new features— such as a Disassembly View while debugging, inline macro expansions, and debug support for Windows ARM64 architecture—along with a bunch of enhancements and bug fixes.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/">Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The July 2021 update of <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">the C++ extension for Visual Studio Code</a> is here, bringing you brand new features— such as a Disassembly View while debugging, inline macro expansions, and debug support for Windows ARM64 architecture—along with a bunch of enhancements and bug fixes. To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.5.0">release notes on GitHub.</a></p>
<h2 id="disassembly-view">Disassembly View</h2>
<p>We’re excited to announce that Disassembly View— our #1 upvoted GitHub issue (<a href="https://github.com/microsoft/vscode-cpptools/issues/206">#206</a>)— is publicly available in VS Code Insiders! Disassembly View allows you to debug assembly code corresponding to the instructions created by your compiler. It’ll be available in the 1.59 release of Visual Studio Code in August, but in the meantime you can <a href="https://code.visualstudio.com/insiders/">download VS Code Insiders</a> and try it out!</p>
<p>To open Disassembly View while debugging, right click your source code and select <strong>Open Disassembly View. </strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png"><img class="alignnone size-full wp-image-28452" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png" alt="Image showing the right-click menu option to Open Disassembly View" width="3101" height="1999" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png 3101w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-300x193.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-1024x660.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-768x495.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-1536x990.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-2048x1320.png 2048w" sizes="(max-width: 3101px) 100vw, 3101px" /></a></p>
<p>In the Disassembly View, the yellow hollow marker represents the current instruction. For each instruction, you’ll see the memory address (left column) and the machine language instructions displayed as hex (middle column) and as assembly language (right column). You can navigate between instructions, step over (<strong>F10</strong>) and step in to (<strong>F11</strong>) instructions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png"><img class="alignnone size-full wp-image-28451" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png" alt="Image showing the Disassembly View opened side by side with source code" width="3105" height="1929" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png 3105w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-300x186.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-1024x636.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-768x477.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-1536x954.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-2048x1272.png 2048w" sizes="(max-width: 3105px) 100vw, 3105px" /></a></p>
<p>To set a breakpoint in the Disassembly View, hover over the instruction and click the red filled circle that appears to the left of the memory address.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png"><img class="alignnone wp-image-28450" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png" alt="Image showing the red filled circle that appears on hover to set a breakpoint at an instruction in Disassembly View" width="889" height="203" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png 1265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-300x69.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-1024x234.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-768x175.png 768w" sizes="(max-width: 889px) 100vw, 889px" /></a></p>
<p>Unset the breakpoint by clicking the red dot again, or by unchecking the box in the Breakpoints section of the Debug pane.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png"><img class="alignnone size-full wp-image-28449" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png" alt="Image showing the Breakpoints section of the Debug pane, where users can enable and disable breakpoints" width="530" height="184" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png 530w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1-300x104.png 300w" sizes="(max-width: 530px) 100vw, 530px" /></a></p>
<p>Check out this GIF to see Disassembly View in action:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-view-sidey-by-side.gif"><img class="alignnone size-full wp-image-28447" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-view-sidey-by-side.gif" alt="GIF showing how to open Disassembly View while debugging, navigate between instructions and set breakpoints" width="3116" height="1954" /></a></p>
<h2 id="macro-expansion">Macro Expansion</h2>
<p>With this latest release of the C++ extension, you can expand macros inline (GitHub issue <a href="https://github.com/microsoft/vscode-cpptools/issues/4183">#4183</a>), making it easier to read and understand your code. To expand a macro inline, click on it, select the lightbulb, and then click <strong>Inline macro.</strong></p>
<p><strong><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/macro-expansion.gif"><img class="alignnone size-full wp-image-28448" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/macro-expansion.gif" alt="GIF showing how to expand a macro inline" width="586" height="280" /></a></strong></p>
<h2 id="windows-arm64-debugging">Windows ARM64 Debugging</h2>
<p>Last year, we announced support for running the C++ extension on Windows ARM64 architecture, giving Surface Pro X users access to C++ IntelliSense, code navigation, and build support. With the July 2021 update of the C++ extension, you can debug projects on Windows ARM64, completing the end-to-end Surface Pro X C++ development experience in VS Code.</p>
<h2 id="what-do-you%e2%80%afthink">What do you think?</h2>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>. You can also join our Insiders program and get access to early builds of our release by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/">Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/feed/</wfw:commentRss>
			<slash:comments>11</slash:comments>
		
		
			</item>
	</channel>
</rss>
