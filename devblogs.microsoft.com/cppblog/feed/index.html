<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Wed, 13 Apr 2022 12:16:27 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Pure Virtual C++ 2022 Schedule Available</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Wed, 13 Apr 2022 15:00:26 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30411</guid>

					<description><![CDATA[<p>Pure Virtual C++ 2022 is a free, one-day virtual conference for the whole C++ community. The schedule is now available. You can find the full set of abstracts, alongside calendar files to download on the website.<br />
All times UTC on the 26th April.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/">Pure Virtual C++ 2022 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png"><img class="wp-image-27841 size-large aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png" alt="Pure Virtual C++ logo" width="640" height="168" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>Pure Virtual C++ 2022 is a free, one-day virtual conference for the whole C++ community. The schedule is now available. You can find the full set of abstracts, alongside calendar files to download <a tabindex="0" href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/" data-cke-saved-href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">on the website</a>.</p>
<p>All times UTC on the 26th April.</p>
<ul>
<li>14:04 &#8211; What&#8217;s New In C++23, Sy Brand</li>
<li>14:37 &#8211; Cute C++ Tricks, Part 2 of N: More code you should learn from and never write, Daisy Hollman</li>
<li>15:12 &#8211; Embedded development with VS and VS Code, Marc Goodner</li>
<li>15:47 &#8211; Everything I learned about static analysis and program safety in C++, Sunny Chatterjee</li>
<li>16:22 &#8211; Persistent Representation of C++ for Fun and Profit, Gabriel Dos Reis</li>
</ul>
<p>Yes, I know the times look a bit weird, it&#8217;ll work out on the day!</p>
<p>Look forward to seeing you there!</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/">Pure Virtual C++ 2022 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-schedule-available/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>New Enumeration Checks in Visual Studio 2022 version 17.2 Preview 3</title>
		<link>https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/</link>
					<comments>https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/#respond</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Tue, 12 Apr 2022 15:00:43 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30396</guid>

					<description><![CDATA[<p>New Enumeration Checks in Visual Studio 2022</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/">New Enumeration Checks in Visual Studio 2022 version 17.2 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/search?space=62">C++ Developer Community </a>page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the detailed overview of some new code analysis checks that can detect enumeration misuse errors, along with some improvements to an existing enumeration check.</p>
<h2 id="overview">Overview</h2>
<p>We introduced three new checks to find potential misuse of enumerations with bitwise operations. These checks were inspired by real bugs found in production code. We also improved a check that suggests using the C++11 scoped <code>enum</code> instead of its legacy counterpart. See the <a href="https://docs.microsoft.com/cpp/build/reference/analyze-code-analysis">documentation</a> on how to enable code analysis for your project.</p>
<h2 id="bitwise-enumerations">Bitwise enumerations</h2>
<p>Some enumerations hold values that are powers of two. Most of these are flags used to represent non-exclusive states that can be combined and queried using bitwise operations. The new checks are trying to detect wrong uses of such enumerations. Unfortunately, there is no clear definition of what enumerations should be considered bitwise, so our checks rely on a set of heuristics to infer the intent from the source code. First of all, let us consider an <code>enum</code> with only two elements:</p>
<pre><code class="language-cpp">enum E
{
    A = 1,
    B = 2
};</code></pre>
<p>It is not clear whether <code>E</code>&#8216;s values are intended to form the start of a sequence of powers of two <code>(1,2,4,8,...)</code>, or are simply intended to increment by 1 <code>(1,2,3,4,...)</code>. Without additional context, we therefore cannot tell whether <code>E</code> is a bitwise <code>enum</code>, intended to be used with bitwise operations, or if it is just a regular <code>enum</code>.</p>
<pre><code class="language-cpp">enum E
{
    A = 1,
    B = 2,
    C = 4,
    D = 8,
    ALL = 15
};</code></pre>
<p>Here, the last <code>enum</code> constant is not a power of two. It is a common idiom to define a constant where all of the relevant bits are set. These constants usually have a value of <code>2^k-1</code> for some positive <code>k</code>. Our checks will consider <code>enum</code>s of this shape as bitwise. We have to be careful with the interplay of these two heuristics.</p>
<pre><code class="language-cpp">enum E1
{
    A = 1,
    B = 2,
    C = 3
};

enum E2
{
    A = 1,
    B = 2,
    C = 4
};</code></pre>
<p>In the above example, we do not want to consider <code>E1</code> bitwise, despite its last element having the value of <code>2^2-1</code>. On the other hand, we definitely want to consider <code>E2</code> a bitwise <code>enum</code>.</p>
<p>These heuristics worked reasonably well for the projects we tested our checks on. In case you encounter any false positives or false negatives, please let us know.</p>
<h2 id="c26813">C26813</h2>
<p><a href="https://aka.ms/cpp/warnings/C26813">C26813</a> will find code patterns where a bitwise enumeration&#8217;s value is being tested using <code>operator==</code>.
In most cases, a variable holding values from a bitwise enumeration represents a bitfield. To query whether a particular enumerator value was set in this variable, bitwise operations should be used. Failing to do so will yield incorrect results:</p>
<pre><code class="language-cpp">enum BitWise
{
    A = 1,
    B = 2,
    C = 4
};

void useEqualsWithBitwiseEnum(BitWise a) 
{
    BitWise a = A; // turn on flag A
    a |= B; // turn on flag B

    /*
    *  Attempt to query if flag 'B' was set.
    */

    if (a == B) // Warning C26813: Use 'bitwise and' to check if a flag is set
    {
        foo(); // never reached, since a != B
    }

    if (a &amp; B)
    {
        bar(); // the branch is taken, as expected
    }
}</code></pre>
<p>After running this check on some real world code we also encountered cases where the <code>enum</code> had power of two values, but was never used with bitwise operations. In those cases it might be good idea to change the values of the <code>enum</code> constants to make the intent clearer in the code.</p>
<h2 id="c26827">C26827</h2>
<p><a href="https://aka.ms/cpp/warnings/C26827">C26827</a> can help detect enumerator constants in bitwise enumerations where we forgot to add an initializer. Consider the following example:</p>
<pre><code class="language-cpp">enum class AlmostBitWise
{
    A = 1,
    B = 2,
    C = 4,
    D
};

int almostBitwiseEnums(AlmostBitWise a) 
{
    return (int)a|(int)AlmostBitWise::A; // Warning C26827: Did you forget to initialize an enum, or intend to use another type?
}</code></pre>
<p>Here, we use an <code>enum</code> constant in a bitwise operation while not all of its constants have the form of <code>2^k</code> or <code>2^k-1</code>. In fact, one of its constants <code>D</code> has the form of <code>2^k+1</code>. This pattern can happen when we add a new constant without defining its value.</p>
<p>Unfortunately, there is a limitation of this check. It will only work with scoped <code>enum</code>s as the compiler will desugar regular enums into integers before the static analysis phase. We are looking into ways to improve our internal representation of the code to have a higher fidelity representation of how the code was written, and this will enable better diagnostics in the future.</p>
<h2 id="c26828">C26828</h2>
<p><a href="https://aka.ms/cpp/warnings/C26828">C26828</a> will flag bitwise expressions where values from different enumerations are mixed. Consider the following example:</p>
<pre><code class="language-cpp">
enum BitWiseA
{
    A = 1,
    B = 2,
    C = 4
};

enum class BitWiseB
{
    AA = 1,
    BB = 2,
    CC = 4,
    All = 7
};

int overlappingBitwiseEnums(BitWiseA a) 
{
    return (int)a|(int)BitWiseB::AA; // Warning C26828: Different enum types have overlapping values. Did you want to use another enum constant here?
}</code></pre>
<p>Here <code>BitWiseA</code> and <code>BitWiseB</code> have overlapping values. It is unlikely that we wanted to use both in the same bitwise expression. It can be the result of a typo.</p>
<p>This check has similar limitations to <code>C26827</code>.</p>
<h2 id="improvements-to-c26812">Improvements to C26812</h2>
<p><a href="https://aka.ms/cpp/warnings/C26812">C26812</a> suggests to use the new C++11 scoped <code>enum</code>s over legacy <code>enum</code>s. This check has been the part of our offerings for a really long time but had room for improvement. Previously, it diagnosed legacy <code>enum</code>s at their use-sites instead of at their declarations. This had several consequences:</p>
<ul>
<li>We did not emit a warning for unused enumerations.</li>
<li>It was not possible to suppress all instances of this warning at the declaration. This was also reported by our users as a <a href="https://developercommunity.visualstudio.com/t/Warning-C26812-is-not-suppressible-at-en/1448578">Developer Community ticket</a>.</li>
<li>It did not work well with the new <a href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">/external</a> feature. See the corresponding <a href="https://developercommunity.visualstudio.com/t/Code-Analysis-warning-C26812-is-reported/1637803">Developer Community ticket</a> for details.</li>
<li>The location of the diagnostic is potentially far from the declaration, which makes it harder to address the warning.</li>
</ul>
<p>The new version of this check will emit the diagnostic on the declarations instead of the uses. This should improve the user experience in most cases. We also realized that addressing this check is sometimes costly or not possible at all (e.g., a library might need to be backward compatible). To address this, we removed this rule from the <code>NativeRecommendedRules</code> ruleset and created a new ruleset named <code>CppCoreCheckEnumRules</code> to include all 4 of the rules we mentioned in this blog post.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The upcoming Visual Studio 2022 17.2 Preview 3 will feature new checks to find hard-to-find misuses of enumerations. It will also include some quality of life improvements for the existing check that can help migrate a code base to scoped enums. The three new <code>enum</code> related checks are part of the <code>NativeRecommendedRules</code> ruleset and the updated warning was moved to <code>CppCoreCheckEnumRules</code>.</p>
<h2 id="try-it-out-and-let-us-know-what-you-think">Try it out and let us know what you think:</h2>
<p>The work that we do is heavily influenced by feedback we receive on <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check. Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/">New Enumeration Checks in Visual Studio 2022 version 17.2 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/new-enumeration-checks-in-visual-studio-2022-version-17-2-preview-3/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Sign Up for the Pure Virtual C++ 2022 Conference</title>
		<link>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/</link>
					<comments>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Fri, 08 Apr 2022 18:52:39 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30382</guid>

					<description><![CDATA[<p>In the last couple of years we have run Pure Virtual C++, a free one-day virtual conference for the whole C++ community. This month we&#8217;re doing it again! Sign-up for free on the website to be the first to hear about our program schedule,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/">Sign Up for the Pure Virtual C++ 2022 Conference</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><img width="1376" height="362" class="wp-image-27841" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w" sizes="(max-width: 1376px) 100vw, 1376px" /></p>
<p>In the last couple of years we have run Pure Virtual C++, a free one-day virtual conference for the whole C++ community. This month we&#8217;re doing it again! <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">Sign-up for free on the website</a> to be the first to hear about our program schedule, access our extra on-demand C++ demos, and get more virtual surprises.</p>
<p>The live event will run <strong>April 26th 14:00-17:00 UTC</strong> on <a href="https://docs.microsoft.com/en-us/learn/tv/">Microsoft Learn TV</a>. It will also be streamed to YouTube and videos will be available to watch after the event.</p>
<p>The full program will be announced soon, but expect content on C++23, modules, static analysis, embedded C++, and some fun C++ corners you might not know about. In addition to the live sessions, we&#8217;ll be releasing on-demand content in the run-up to the conference.</p>
<p>The Pure Virtual C++ conference is organized by Microsoft and will be run under the <a href="https://docs.microsoft.com/en-gb/legal/learntv/codeofconduct">Learn TV Code of Conduct</a>.</p>
<p>Get involved in the conversation on Twitter using the #purevirtualcpp hashtag.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/">Sign Up for the Pure Virtual C++ 2022 Conference</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2022-conference/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Using GitHub Codespaces and Visual Studio Code for C++ Development</title>
		<link>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/#comments</comments>
		
		<dc:creator><![CDATA[Michael Price]]></dc:creator>
		<pubDate>Mon, 04 Apr 2022 22:22:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Containers]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30359</guid>

					<description><![CDATA[<p>GitHub Codespaces and Visual Studio Code lower the barrier to entry for developing C++-based applications and libraries.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/">Using GitHub Codespaces and Visual Studio Code for C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Whether you are just learning the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1000r4.pdf">quickly evolving C++ programming language</a>, an open-source developer patching a zero-day vulnerability in a low-level C++ library, or an experienced professional writing software in C or C++ for <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">embedded devices</a> or enterprise applications, <a href="https://github.com/features/codespaces">GitHub Codespaces</a> and <a href="https://code.visualstudio.com/">Visual Studio Code</a> combine to significantly lower the costs associated with configuring your environment, building, and testing your code. It doesn&#8217;t matter whether your computer&#8217;s operating system is Microsoft Windows, Apple macOS, or your favorite Linux distribution, Visual Studio Code works on them all. You can even work from the web browser of your mobile iOS or Android device.</p>
<h2 id="visual-studio-code-and-github-dev">Visual Studio Code and github.dev</h2>
<p>GitHub offers built-in support for Visual Studio Code developers via <a href="https://github.dev">github.dev</a>. For any repository hosted on GitHub, you can nearly instantly open an instance of Visual Studio Code directly in your web browser. In this environment, many of Visual Studio Code&#8217;s <a href="https://code.visualstudio.com/docs/editor/codebasics">navigation and editing features</a> are fully functional. You can search for strings in your repository or edit files and commit them to new branches. You can even install many of the great Visual Studio Code extensions from the <a href="https://marketplace.visualstudio.com/VSCode">Visual Studio Code Marketplace</a>.</p>
<h2 id="visual-studio-code-and-github-codespaces">Visual Studio Code and GitHub Codespaces</h2>
<p>Once you push changes to your repository using <a href="https://github.dev">github.dev</a>, any <a href="https://docs.github.com/en/actions">GitHub Actions</a> that are registered for your branch will execute, including any build or test actions such as the <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions">Microsoft C++ Code Analysis action</a>. But you might want to build and test your changes before pushing your changes up to GitHub. For this, you can
<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/creating-a-codespace">create</a> or <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/developing-in-a-codespace">connect</a> to an existing GitHub Codespace directly from Visual Studio Code (including the in-browser instance loaded by github.dev) or from the normal GitHub web page for the repository. <em>NOTE: GitHub Codespaces is currently only available to members of eligible organizations. See <a href="#known-limitations">Known Limitations</a> for more information.</em></p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/vscode-remotes-codespaces.png" alt="Screenshot of Visual Studio Code showing available Codespaces. A popout is displaying properties of the selected codespace." /></p>
<h3 id="visual-studio-code-is-a-first-class-editor-for-c-and-c">Visual Studio Code is a <a href="https://code.visualstudio.com/docs/languages/cpp">First-Class Editor for C and C++</a></h3>
<p>The extensibility model for Visual Studio Code is one of its most powerful features. It enables developers across the globe to produce terrific extensions. Microsoft has bundled many of the best extensions for C and C++ development into the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack</a>, which makes developing for one of the world&#8217;s most versatile programming languages as easy as it&#8217;s ever been. From extensions for build systems like <a href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code">Make</a> and build system generators like <a href="https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code">CMake</a>, to debugging and C++ static analysis tools and rich editor features like syntax highlighting and <a href="https://code.visualstudio.com/docs/editor/intellisense">IntelliSense</a> code completion, Visual Studio Code has what you need to get the job done, and it continues to improve with every release. Combining Visual Studio Code&#8217;s terrific support for C++ development with GitHub Codespaces&#8217; ease-of-use and portability, means that it&#8217;s easier than ever before to deliver your product or solution.</p>
<h3 id="true-portability-with-codespaces">True Portability with Codespaces</h3>
<p>Since Codespaces are development environments in the cloud, they are accessible from practically any system or device with a web browser and an Internet connection. And when you disconnect from your Codespace, its state is saved so that when you reconnect, potentially from a different device in potentially a very different location, you&#8217;ll be right back where you left off. When you are <a href="https://www.bing.com/images/search?q=beach+images">relaxing on the white sands of a beach resort</a>, you no longer need to run back to your office (or home office) in order to fix that critical zero-day bug that just read about on Reddit.</p>
<h3 id="managing-your-codespace-instances">Managing Your Codespace Instances</h3>
<p>Managing your Codespace instances can be done <a href="https://github.com/codespaces">directly from GitHub</a> or from within the Visual Studio Code Remote Explorer. From there, you can see the properties of your Codespaces or create, delete, or connect to your Codespaces. You can even change the machine type of an existing Codespace from the GitHub page or via the Command Palate in Visual Studio Code after connecting to a Codespace.</p>
<p>A machine type is a system configuration specifying the number of CPU cores, memory capacity, and storage capacity for a Codespace. GitHub Codespaces are provisioned in the cloud with the machine type you select. Depending on the organizations you are a member of, the repository a Codespace is being created for, and details about your GitHub account, different machine types might be available to you. To start, don&#8217;t worry about selecting the perfect machine type for your Codespace. You can always change your machine type later and retain all of your code changes without having to stash or commit them into the repository. Since less powerful machine types are <a href="https://docs.github.com/en/billing/managing-billing-for-github-codespaces/about-billing-for-codespaces#codespaces-pricing">billed at a lower rate</a>, you can leverage this to really optimize the tradeoff between time and cost as you see fit. For instance, you might choose a powerful machine type in order to complete an initial build of your project, then switch to a less powerful machine type while you are only making changes that cause smaller, incremental builds, only to switch back to a more powerful machine when you&#8217;d like to run a compute intensive task like running a static analysis tool.</p>
<p>The creation of your Codespaces are also customizable with <a href="https://code.visualstudio.com/docs/remote/create-dev-container">devcontainer</a> configuration files checked directly into your repository. You can provide a custom Dockerfile to use when spinning up your Codespace, pre-install Visual Studio Code extensions, forward ports from your Codespace instance to your local machine, or even run a tool every time a connection is made to the Codespace. You can even <a href="https://docs.github.com/en/codespaces/prebuilding-your-codespaces/about-codespaces-prebuilds">pre-build your Codespace containers using GitHub Actions</a> to make Codespace startup very fast!</p>
<h2 id="known-limitations">Known Limitations</h2>
<ul>
<li>Access to GitHub Codespaces feature is limited to users who are members of organizations on a GitHub Teams or GitHub Enterprise Cloud plan. Organization owners can <a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/enabling-codespaces-for-your-organization">enable the feature</a> in only a few steps. Access for individual users is currently in beta, to <a href="https://github.com/features/codespaces/signup">which you can easily request access</a>.</li>
<li>All GitHub Codespace instances run various <a href="https://github.com/github/feedback/discussions/9977">Linux distributions</a>.</li>
<li>The largest available machine type is: 32 cores, 64 GB RAM, 128 GB storage.</li>
<li>Changing machine type is only allowed between types that have the same amount of storage capacity.</li>
</ul>
<h2 id="call-to-action">Call to Action</h2>
<p>Try out the combination of Visual Studio Code and GitHub today, by going to your favorite C or C++ project on GitHub, and press the <strong>.</strong> (period) key to open up <a href="https://github.dev">github.dev</a>. Browse around. Experiment with the editor features of Visual Studio Code. When you&#8217;re ready to try compiling some code get started with GitHub Codespaces by accessing the Command Palate by pressing <strong>Ctrl+Shift+P</strong> (<strong>Cmd+Shift+P</strong> on macOS) and run the <strong>Codespaces: Create New Codespace</strong> command. Install the C/C++ Extension Pack and find out just how easy C++ development can be with Visual Studio Code and GitHub Codespaces. You can also follow the instructions in our <a href="https://github.com/microsoft/vscode-remote-try-cpp">example repository</a> that demonstrates Visual Studio Code&#8217;s remote container capabilities for a quick tour of the features.</p>
<h2 id="send-us-your-feedback">Send us your feedback</h2>
<p>We are always interested in your feedback. If you have a use case that we haven&#8217;t thought of, we&#8217;d love to hear from you. Want to complain that something isn&#8217;t working as you expected? We want to hear that too! Already using the product and want to tell us your successes? We definitely want to hear your story! You can comment below, and you can reach us via email at <a href="mailto://visualcpp@microsoft.com">visualcpp@microsoft.com</a> or on Twitter <a href="https://twitter.com/visualc">@VisualC</a>. For issues with the GitHub Codespaces service, you can also provide <a href="https://github.com/github/feedback/discussions/categories/codespaces-feedback">feedback directly to the GitHub Codespaces team</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/">Using GitHub Codespaces and Visual Studio Code for C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Enhancing Game Developer Productivity with Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/</link>
					<comments>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Thu, 31 Mar 2022 16:18:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[game dev]]></category>
		<category><![CDATA[productivity]]></category>
		<category><![CDATA[unreal engine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30338</guid>

					<description><![CDATA[<p>In this blog, we will discuss how much faster you can get to code with speedier C++ IntelliSense ready and opening a file. Learn how search improved with faster with C++ Find All References and indexed Find in Files.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/">Enhancing Game Developer Productivity with Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Since the launch of Visual Studio 2022, we have been continuously making performance improvements to enhance game developer productivity. In my <a href="https://www.youtube.com/watch?v=y8kt5842PT4">Microsoft Game Dev talk for GDC</a>, I shared why Visual Studio is the ultimate IDE for game developers. I also partnered with the folks at Double Fine Productions to <a href="https://developer.microsoft.com/en-us/games/events/gdc/psychonauts2">demonstrate their most loved features when developing the Award-winning Psychonauts 2.</a> Next, I shared features that Double Fine is most excited for in VS2022. Lastly, <a href="https://developer.microsoft.com/en-us/games/blog/microsoft-perforce-reimagining-game-production/">Microsoft Game Dev announced</a> that a set of GitHub Actions for Perforce Helix Core on Azure, authored directly by Perforce, is now available.</p>
<p>In this blog, I will show you some amazing speed improvements when searching and getting to code by discussing our measurements from large codebases such as Unreal Engine and Chromium. See how much faster you can get to code with speedier C++ IntelliSense ready and opening a file. Search faster with C++ Find All References and indexed Find in Files.</p>
<p>While game developers and developers with large codebases will benefit from these improvements the most, all C++ developers will gain increased productivity with these changes.</p>
<h1 id="testing-methodology">Testing Methodology</h1>
<p>We tested using an Unreal Engine 4 sample project on a desktop with an Intel Core i7-9700 @ 3Ghz, 64GB RAM, and an SSD. The tests took place on Visual Studio 2019 16.11 and Visual Studio 2022 17.1. The results were averaged over 3 runs. For Find in Files, we benchmarked using the Chromium repo, with more than 300,000 files.</p>
<h1 id="results">Results</h1>
<h2 id="getting-to-code">Getting to Code</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png"><img class="aligncenter size-full wp-image-30340" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png" alt="Image gettocodevs2022" width="1652" height="992" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png 1652w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-1536x922.png 1536w" sizes="(max-width: 1652px) 100vw, 1652px" /></a></p>
<p>When opening a file on Visual Studio 2019, it took 2.02 seconds for code to show up. In Visual Studio 2022, you can see the same action completing in only 0.82 seconds, resulting in a 2.44X speed up. In Visual Studio 2019, the time it took for semantic colorization to show up after opening a file was 12.9 seconds. You will experience that the same action is 2.22X faster in VS2022, taking 5.8 seconds.</p>
<p>For Unreal Engine projects, you will experience additional speed up for IntelliSense readiness. <a href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">Learn more in this blog post.</a></p>
<h2 id="code-search">Code Search</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png"><img class="aligncenter size-full wp-image-30341" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png" alt="Image searchvs2022" width="1652" height="992" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png 1652w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-1536x922.png 1536w" sizes="(max-width: 1652px) 100vw, 1652px" /></a></p>
<p>In Visual Studio 2022, you will see a speed up of 1.74X when using C++ Find All References (Shift + F12). The action was completed in 17.36 seconds; compared to Visual Studio 2019, the action took a little over half a minute.
For Find in Files in Visual Studio 2019, searching through 300,000 files in the Chromium repo took 30 seconds. In Visual Studio 2022, you will notice that the same action will take 1.5 seconds, a 20X improvement!</p>
<h1 id="analysis">Analysis</h1>
<p>You will notice several optimizations to the IntelliSense engine that created more efficiency in getting to code scenarios. Find All References was also enhanced by eliminating inefficiencies during search.</p>
<p>For Find in Files, you can now take advantage of indexed search. To enable indexed searching, go to <em>Tools &gt; Options &gt; Environment &gt; Preview Features</em> and ensure “Enable indexing for faster find experience” is checked. For more details, <a href="https://devblogs.microsoft.com/visualstudio/code-search-in-visual-studio-is-about-to-get-much-faster/">please see this blog post.</a></p>
<h1 id="feedback-wanted">Feedback Wanted!</h1>
<p>Your feedback through <a href="https://developercommunity.visualstudio.com/">Developer Community</a>, surveys, and social media channels has made these improvements possible. We thank you for your valuable comments.
These enhancements are a continuation of our focus on improving productivity for game developers. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like ones detailed in this blogpost. If you are a game developer, <a href="http://aka.ms/VSGameDevSurvey">let us know your thoughts in our 2022 Visual Studio Game Developer Survey</a>.</p>
<p>In addition, please continue to help shape the development of Visual Studio by talking to us in the comments below, on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h1 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h1>
<p><a href="https://visualstudio.microsoft.com/downloads/">Download the latest version of Visual Studio 2022</a> to take advantage of these productivity benefits today!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/">Enhancing Game Developer Productivity with Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>C++ Modules in CMake with Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/#comments</comments>
		
		<dc:creator><![CDATA[Will Buik]]></dc:creator>
		<pubDate>Thu, 17 Mar 2022 22:31:30 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30295</guid>

					<description><![CDATA[<p>We’ve seen a lot of excitement around C++ modules since we announced support in the Microsoft C++ compiler and Visual Studio. Ever since, the community has been asking us when CMake support was coming. I am happy to announce that Visual Studio 2022 17.2 Preview 2 has experimental support for C++ modules in CMake projects.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/">C++ Modules in CMake with Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We’ve seen a lot of excitement around C++ modules since we announced support in the Microsoft C++ compiler and Visual Studio. Ever since, the community has been asking us when CMake support was coming. I am happy to announce that Visual Studio 2022 17.2 Preview 2 has experimental support for C++ modules in CMake projects. One caveat for this early support, is that you must use the Visual Studio (MSBuild) generator. If you want to try it out, you can <a href="https://visualstudio.com/preview">download the latest preview of Visual Studio</a> today. We are looking forward to hearing your feedback about how modules work in your CMake projects.</p>
<p><a href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp">C++ modules</a> are a new feature in C++20. They can help you compartmentalize your code, speed up build times, and they work seamlessly, side-by-side with your existing code. To learn more, I would recommend checking <a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/">A Tour of C++ Modules in Visual Studio</a>. That post explores the details of how and when to use modules and some of the ways Visual Studio can help you do it.</p>
<p>For an even deeper dive into modules, you can also explore the following series:</p>
<ul>
<li><a href="https://devblogs.microsoft.com/cppblog/standard-c20-modules-support-with-msvc-in-visual-studio-2019-version-16-8/">Standard C++20 Modules support with MSVC</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">Moving a project to C++ named Modules</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</a></li>
</ul>
<h3 id="getting-started-with-modules-and-cmake">Getting Started with Modules and CMake</h3>
<p>While CMake support for modules in Visual Studio is still experimental, it is straightforward to start using it. You don’t need to do anything special in your CMake project files. Just make sure you have enabled the C++20 language standard. Starting in this preview, our CMake project template will do that for you, but if you are working with an existing project you will need to add this to your CMakeLists.txt:</p>
<p><code>set_property(TARGET $TargetName PROPERTY CXX_STANDARD 20)</code></p>
<p><strong><em>Note:</em></strong><em> Enabling C++20 requires CMake 3.12 or higher. Visual Studio ships with the latest version of CMake, but this may be a consideration if you use this project across operating systems or need to use an older version of CMake.</em></p>
<p>You will also need to make sure you are using the Visual Studio generator with CMake. Support for other generators, such as Ninja, is planned but it isn’t available yet. Ninja is the default generator when working with CMake projects in Visual Studio so you will need to modify your project’s <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-170">CMakePresets.json</a> or <a href="https://docs.microsoft.com/en-us/cpp/build/customize-cmake-settings?view=msvc-170">CMakeSettings.json</a> file to change this.</p>
<p><strong><em>CMake Presets:</em></strong></p>
<p>If your project is using CMake Presets, in CMakePresets.json, find the “windows-base” configure preset. It will have a “generator” property that is most likely set to “Ninja”. Update it to this:</p>
<pre>{
  "version": 3,
  "configurePresets": [ {
    "name": "windows-base",
    "hidden": true,
    "generator": "Visual Studio 17 2022",
    //…
  }]
}</pre>
<p><strong><em>CMake Settings:</em></strong></p>
<p>If your project is using CMake Settings, you can open the CMakeSettings.json editor and change the Generator setting (under Advanced) to “Visual Studio 17 2022:”</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png"><img class="alignnone size-full wp-image-30300" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png" alt="CMake Settings &gt; Advanced &gt; CMake generator" width="1425" height="826" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png 1425w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-300x174.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-1024x594.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-768x445.png 768w" sizes="(max-width: 1425px) 100vw, 1425px" /></a></p>
<p>You will need to do this for each of your project’s configurations.</p>
<p>And that’s it, once the Visual Studio generator is selected and the C++20 language standard is enabled for your target you can use modules in your project.</p>
<h3 id="creating-modules-in-a-cmake-project">Creating Modules in a CMake Project</h3>
<p>To add a module to your project, just right click on any folder and select “Add New Item:”</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png"><img class="alignnone size-full wp-image-30301" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png" alt="CMake Context Menu &gt; Add &gt; Add New Item..." width="1972" height="665" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png 1972w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-300x101.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-1024x345.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-768x259.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-1536x518.png 1536w" sizes="(max-width: 1972px) 100vw, 1972px" /></a></p>
<p>And select the “C++ Module Interface Unit (.ixx)” template in in the “Visual C++” category:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png"><img class="alignnone size-full wp-image-30302" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png" alt="New File &gt; Visual C++ &gt; C++ Module Interface Unit (.ixx)" width="1253" height="490" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png 1253w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-300x117.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-1024x400.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-768x300.png 768w" sizes="(max-width: 1253px) 100vw, 1253px" /></a></p>
<p>If you are using the <a href="https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/#cmake-targets-view">Targets View</a>, it is even easier. Just click “Add -&gt; New Module…” in the context menu on any target:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png"><img class="alignnone size-full wp-image-30303" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png" alt="CMake Targets View Context Menu &gt; Add &gt; New Module..." width="1232" height="667" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png 1232w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-300x162.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-1024x554.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-768x416.png 768w" sizes="(max-width: 1232px) 100vw, 1232px" /></a></p>
<h3 id="exporting-and-using-modules">Exporting and Using Modules</h3>
<p>Once you have created a Module interface (.ixx) file, you can export functions, classes, and structs. The example below defines a simple module called <code>Printers</code> and exports a single struct:</p>
<pre>// Printers.ixx
// 
// The .ixx extension lets the build system know this file contains
// a module interface.

// Begin global module fragment.
module;

// Headers included in the global module fragment (between "module;" and
// "export module Printers;") can be used by the module implementation but
// are not exported. These included headers are invisible to translation
// units that import the Printers module.
#include &lt;iostream&gt;

// Creates the Printers module. This can be imported into other translation
// units with "import Printers;" Any items marked with the export keyword
// will be available in translation units that import the Printers module.
export module Printers;

// This only applies to this module's translation unit. It does not leak
// into translation units that import the Printers module.
using namespace std;

// These constants are not exported, they are invisible from translation
// units that import the Printer module.
const string default_spacer = " ";
const string default_separator = ",\n";

// SimplePrinter is exported and accessible to any code that imports the
// Printers module.
export struct SimplePrinter
{
    string element_spacer;
    string separator;

    void print_element(int e)
    {
        std::cout &lt;&lt; e &lt;&lt; element_spacer;
    }

    void print_separator()
    {
        std::cout &lt;&lt; separator;
    }
};

// Exports the function get_default_printer.
// This is accessible from translation units that import the Printers module.
export SimplePrinter get_default_printer()
{
    return SimplePrinter {
        .element_spacer = default_spacer,
        .seperator = default_seperator
    };
}</pre>
<p>Once you define the module, other source files and module interfaces can consume it with the <code>import</code> keyword. It is possible to import any modules declared in the current target or any of its imports. For example, “PrintVector.cpp” below uses the <code>Printers</code> module we defined above:</p>
<pre>// PrintVector.cpp

// Conventional #includes and module imports can be freely mixed.
#include &lt;vector&gt;

// Import the Printers module defined in Printers.ixx.
import Printers;

using namespace std;

void print_vector(const vector &amp;list)
{
    // SimplePrinter and get_default_printer are imported from the
    // Printers module.
    SimplePrinter printer = get_default_printer();

    for (auto i : list) {
        printer.print_element(i);
    }
    printer.print_separator();
}</pre>
<p>You can do a lot with C++ modules. To learn more, I would recommend reading <a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/">A Tour of C++ Modules in Visual Studio</a> which goes into much more detail about how to use modules. For instance, it is possible to split module interfaces from their implementations. That post has been updated with some of the latest details about using modules with CMake.</p>
<h3 id="feedback">Feedback</h3>
<p>If you are interested in trying out C++ modules in your own CMake projects, please <a href="https://visualstudio.com/preview">download the latest Visual Studio Preview</a>. Try it out and let us know if you have any questions or feedback. If you find any issues or have a suggestion, the best way to reach out to us is to <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio">Report a Problem</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/">C++ Modules in CMake with Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/feed/</wfw:commentRss>
			<slash:comments>7</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio for remote macOS C++ development</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/#comments</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Wed, 16 Mar 2022 18:17:45 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30167</guid>

					<description><![CDATA[<p>The latest preview version of Visual Studio is now available to download. In this latest release, users wishing to develop cross platform C++ applications for macOS can now make use of Visual Studio’s Linux tools with CMake to target the Mac.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/">Visual Studio for remote macOS C++ development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW190762823 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentStart SCXW190762823 BCX8">The latest preview version of Visual Studio is now <a href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noopener">available to download</a>. In this latest release, users</span><span class="NormalTextRun SCXW190762823 BCX8"> wishing to develop cross platform C++ applications for </span><span class="NormalTextRun SCXW190762823 BCX8">macOS</span><span class="NormalTextRun SCXW190762823 BCX8"> can </span><span class="NormalTextRun SCXW190762823 BCX8">now </span><span class="NormalTextRun SCXW190762823 BCX8">make use of Visual Studio’s Linux tools with CMake to target </span><span class="NormalTextRun SCXW190762823 BCX8">the Mac. There is some setup required on the Mac side to enable the support, but then the Mac is treated just as any other remote (Linux) target by Visual Studio.</span></span><span class="EOP SCXW190762823 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1.png"><img class="alignnone size-full wp-image-30175" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1.png" alt="Example of an application targeting MacOS from Windows Visual Studio" width="1428" height="892" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1.png 1428w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1-1024x640.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1-768x480.png 768w" sizes="(max-width: 1428px) 100vw, 1428px" /></a></p>
<h4 id="installation">Installation</h4>
<p>To get started install the latest preview release of Visual Studio 2022 and select the Linux and embedded development with C++ workload. The components you need are selected by default.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1.png"><img class="alignnone size-full wp-image-30173" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1.png" alt="Select Linux and embedded development in C++ workload in latest preview release of Visual Studio 2022" width="910" height="460" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1.png 910w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1-300x152.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1-768x388.png 768w" sizes="(max-width: 910px) 100vw, 910px" /></a></p>
<h4 id="setup-on-the-mac">Setup on the Mac</h4>
<p>Visual Studio requires certain tools to be present on the Mac to enable the remote development experience.</p>
<h5 id="c-tools">C++ Tools</h5>
<p>If you have used your Mac for C++ development before you likely have everything installed that you need. If not, some of these tools should already be present (for example rsync) but some may need to be installed, typically the compiler command line tools, <em>cmake</em>, <em>ninja-build</em>, and <em>lldb-mi</em>. The following step should be performed in a terminal window on the Mac to set up the development environment.</p>
<ol>
<li>Make sure you have enabled your Mac for development:</li>
</ol>
<pre style="padding-left: 40px;"><em>DevToolsSecurity --enable</em></pre>
<ol start="2">
<li>Download the latest version of XCode from the App Store (<a href="https://apps.apple.com/us/app/xcode/id497799835?mt=12&amp;msclkid=506bfed6b46e11ecaf2b0760ad457b77">Xcode on the App Store (apple.com)</a>), or an older version through the <a href="https://developer.apple.com/xcode/downloads/">Apple Developer page</a>Use <em>xcode-select</em> to install the compiler tools:</li>
</ol>
<pre style="padding-left: 40px;"><em>xcode-select --install</em></pre>
<ol start="3">
<li>Install CMake from cmake.org. Follow the instructions here (<a href="https://cmake.org/install">Installing | CMake</a>) to copy and install the latest CMake. Make sure to update the PATH variable to include the CMake location. For example when using <em>zsh</em> add the line below to ~/.zshenv; when using <em>bash</em> add the line to ~/.bashrc.</li>
</ol>
<pre style="padding-left: 40px;">export PATH=/Applications/CMake.app/Contents/bin:$PATH</pre>
<ol start="4">
<li>Install ninja-build from <em>github</em> or using a package manager such as <em>brew</em>. If installing directly from GitHub use the following commands:</li>
</ol>
<pre style="padding-left: 40px;"><em>git clone https://</em><em>github.com/ninja-build/ninja.git</em>

<em>cd ninja</em>

<em>./configure.py --bootstrap</em>

<em>sudo cp ninja /usr/local/bin</em></pre>
<ol start="5">
<li>Install <em>lldb-mi</em>, a command line interface to the lldb debugger. Use a browser to download from <a href="https://go.microsoft.com/fwlink/?linkid=2154927">https://go.microsoft.com/fwlink/?linkid=2154927</a> . Then copy the binary to <em>/usr/local/bin</em> and set its execute permissions.</li>
</ol>
<pre style="padding-left: 40px;"><em>sudo cp ~/Downloads</em><em>/debugAdapters/lldb-mi/bin/lldb-mi /usr/local/bin</em> 
<em>sudo chmod +x /usr/local/bin
</em></pre>
<p style="padding-left: 40px;">Note: if you do not have a /usr/local/bin directory, this command will not work. You can create it using terminal command:</p>
<pre style="padding-left: 40px;">dir mkdir /usr/local/bin</pre>
<h5 id="remote-connection-enablement">Remote connection enablement</h5>
<p>Make sure you have enabled your Mac to allow remote connections. From System Preferences select Sharing, then ensure that Remote Login is selected, and your user has access. If you need to interact with an app that has UI remotely on the Mac you also need to enable Remote Management and under Computer Settings enable VNC viewers. You should then be able to access the Mac from Windows using a VNC client.</p>
<h4 id="connect-from-visual-studio">Connect from Visual Studio</h4>
<p>Once the necessary tools are installed on the Mac then Visual Studio can access the Mac using the Connection Manager.</p>
<p style="padding-left: 40px;">On a Windows machine open Visual Studio (with C++ and Linux workloads installed) and open the Connection Manager from Tools&gt;Options&gt;Cross Platform&gt;Connection Manager. Add a new connection using the Mac machine name or IP address, username, and password.</p>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3.png"><img class="alignnone size-full wp-image-30181" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3.png" alt="Image Picture3" width="623" height="364" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3.png 623w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-300x175.png 300w" sizes="(max-width: 623px) 100vw, 623px" /></a></p>
<p>Once a connection has been set up in Visual Studio it can be used as a CMake target in either a CMakeSettings.json or CMakePresets.json configuration. Below I’ll walk through setting up a new CMake project using CMakePresets.json.</p>
<h4 id="a-sample-cmake-project">A Sample CMake Project</h4>
<ol>
<li>Since we will use CMake presets for this example, first ensure that CMakePresets is enabled in your Visual Studio installation. Go to Tools&gt;Options&gt;CMake&gt;General and check “Always use CMakePresets.json”.</li>
<li>From File&gt;New&gt;Project select CMake Project to create a new project (in this example “CMakeProject90”). The project will open targeting the “Local Machine” by default. From the “Target System” dropdown select the connection to the Mac system that was made in the previous step.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4.png"><img class="alignnone size-full wp-image-30183" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4.png" alt="In the top bar of a CMake project, &quot;Target Machine&quot; will be automatically selected as well as x64 Debug and Default. Select connection to MacOS machine from &quot;Target System&quot; dropdown" width="624" height="90" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4-300x43.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></li>
</ol>
<p style="padding-left: 40px;">The target for the project will now reflect this choice and identify it as a Mac target.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png"><img class="alignnone size-full wp-image-30187" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png" alt="The top bar for the CMake project will now show the Mac machine you connected to after selection" width="624" height="82" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6-300x39.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p style="padding-left: 40px;">The CMake pane of the Output Window will contain a log of the copy and CMake configure operations.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7.png"><img class="alignnone wp-image-30188" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7.png" alt="Output window containing the log of the copy and Cmake configure operations" width="658" height="272" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7-300x124.png 300w" sizes="(max-width: 658px) 100vw, 658px" /></a></p>
<p style="padding-left: 40px;">At this point the project is ready to build and debug.</p>
<ol start="3">
<li>From the Solution Explorer open CMakeProject.cpp and place a breakpoint on the first line of <em>main</em>. From the “Select Startup Item” dropdown select “CMakeProject90”. Start debugging (F5). Visual Studio will build the project (see the Build pane of the Output Window) and start the debugger on the Mac. The debugger will halt the application pointing to the location of the breakpoint just set.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png"> </a><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8.png"><img class="alignnone size-full wp-image-30190" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8.png" alt="The application is being debugged with a breakpoint set. The debugger hit the breakpoint and now debugging capabilities, such as call stack pictured, are able to be viewed." width="780" height="347" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8.png 780w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8-300x133.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8-768x342.png 768w" sizes="(max-width: 780px) 100vw, 780px" /></a></li>
</ol>
<p style="padding-left: 40px;">The debugging capabilities of Visual Studio (for example, the locals, watch, and call stack windows) may now be used to examine the application.</p>
<h4 id="attach-debugging-on-the-mac">Attach Debugging on the Mac</h4>
<p>The Visual Studio debugger’s attach-to-process function also works for Mac targets.</p>
<ol>
<li>Change the main function of the above C++ application as follows:</li>
</ol>
<pre style="padding-left: 40px;">#include "CMakeProject90.h"
#include &lt;unistd.h&gt;
using namespace std;
int main()
{
       cout &lt;&lt; "Hello CMake." &lt;&lt; endl;
       while (true)
       {
             sleep(1);
       }
       return 0;
}</pre>
<p style="padding-left: 40px;">Save the file and select Debug&gt;Start Without Debugging.</p>
<ol start="2">
<li>Select Debug&gt;Attach to Process… On the “Attach to Process” dialog select Connection type “SSH”. Then Select the Mac connection from the “Connection target” dropdown. The dialog will populate the “Available process” display with the processes running on the Mac.</li>
</ol>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1.png"><img class="alignnone size-full wp-image-30198" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1.png" alt="Attach to Process Window with the Mac machine connection selected under Connection target and the available processes populated underneath, including the sample CMakeProject" width="780" height="644" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1.png 780w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1-300x248.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1-768x634.png 768w" sizes="(max-width: 780px) 100vw, 780px" /></a></p>
<p style="padding-left: 40px;">Select “Attach”. A “Select Code Type” dialog will pop-up. Select “Native (LLDB)” and click OK.</p>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2.png"><img class="alignnone size-full wp-image-30200" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2.png" alt="In Attach to Process window, after selecting &quot;Attach&quot; on the target available process the &quot;Select Code Type&quot; window will pop up. Native LLDB is selected for this example." width="624" height="442" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2-300x213.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p style="padding-left: 40px;">The debugger is now attached to the remote process on the Mac. Select Debug&gt;Break All to begin debugging.</p>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1.png"><img class="alignnone size-full wp-image-30201" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1.png" alt="Image Picture3" width="624" height="335" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1-300x161.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<h4 id="caveats">Caveats</h4>
<p>Currently only x64 Macs are fully supported for debugging. This means that when attempting to debug on an ARM64 Mac, Rosetta must be installed and only applications that are cross compiled for x64 can be debugged. The Mac must have an OS Version of at least 10.15 to install all of the debugger tools.</p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your macOS C++ development needs. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>A special thanks to Paul Maybee for authoring this post.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/">Visual Studio for remote macOS C++ development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Embedded Software Development in Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Thu, 10 Mar 2022 00:01:39 +0000</pubDate>
				<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30142</guid>

					<description><![CDATA[<p>In this post we will walk through the new Visual Studio Code Embedded Tools extension. We'll show how to acquire embedded tool dependencies with vcpkg then edit, build, deploy, and debug an Azure RTOS ThreadX project highlighting the new peripheral register and RTOS object views.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Embedded Software Development in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that we have released the Embedded Tools extension for Visual Studio Code. These capabilities are the same as what we recently announced for <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Visual Studio 2022</a>. Used in conjunction with the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifact capabilities</a> you can quickly bootstrap an embedded development machine and get started.</p>
<p>In this post we will walk you through how to acquire embedded tool dependencies with vcpkg, then demonstrate edit, build, deploy, and debugging directly in VS Code with new peripheral register and RTOS object views. We will demonstrate all of this with an Azure RTOS ThreadX project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png"><img class="alignnone size-full wp-image-30146" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png" alt="VS Code embedded development screenshot" width="1671" height="1044" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png 1671w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-1024x640.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-768x480.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-1536x960.png 1536w" sizes="(max-width: 1671px) 100vw, 1671px" /></a></p>
<p>Azure RTOS ThreadX is a widely used Real Time Operating System (RTOS) used on billions of microcontrollers (MCUs) in products around the world. We have dedicated pages for VS Code usage in the getting started guides for the <a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/vscode.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/blob/master/NXP/MIMXRT1060-EVK/vscode.md">NXP 1060</a>, and STMicro STM32L4_L4+ IOT01A boards (<a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L475E-IOT01A/vscode.md">L475E</a> or <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L4S5I-IOT01A/vscode.md">L4S5I</a>). The techniques used for interacting with these boards should be applicable to other targets by changing configuration information we’ll highlight throughout.</p>
<h4 id="installation">Installation</h4>
<p>To get started install VS Code, then in the extensions side bar search for Embedded Tools and install it.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png"><img class="alignnone size-full wp-image-30147" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png" alt="Embedded Tools extension page screenshot" width="624" height="167" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools-300x80.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<h4 id="using-vcpkg-to-acquire-embedded-tools">Using vcpkg to acquire embedded tools</h4>
<p>One of the challenges in embedded development is getting the tools necessary installed and configured. It is not uncommon to have different compilers used for different projects, custom debug tools, etc. This is where the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">artifact capabilities in vcpkg</a>  can help us. Today we’ll demonstrate using vcpkg from a PowerShell prompt to activate our embedded development environment, but you can use the shell you prefer on your platform. In a future release this will be integrated into a Visual Studio Code extension for a more seamless experience.</p>
<p>From a PowerShell prompt, clone the Azure RTOS getting started repo. This sample will serve as our example project for the remainder of this post.</p>
<pre>git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Navigate to the subfolder for the board you are using, here I’m using the Azure IoT DevKit.</p>
<pre>cd ./getting-started/MXChip/AZ3166</pre>
<p>If you haven’t already, install vcpkg.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre>iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>CMD Shell</p>
<pre>curl -LO https://aka.ms/vcpkg-init.cmd &amp;&amp; .\vcpkg-init.cmd</pre>
<p>In the project folder, there is a file vcpkg_configuration.json. This manifest file was created with vcpkg and has recorded the tools you need to build and debug this project. See the <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifacts post</a> for details on how to create your own manifest. Running the vcpkg activate command will use this file to determine if I have those tools, install them if I do not, then activate them in my environment for use.</p>
<pre>vcpkg activate</pre>
<p>So, in three commands we have cloned our embedded project, installed vcpkg, acquired and activated the necessary tools for building the project.</p>
<h4 id="using-vs-code-for-embedded-development">Using VS Code for embedded development</h4>
<p>In the previous section we used vcpkg to acquire the tools for our embedded project. Today vcpkg is not integrated in Visual Studio Code. So, at present we need to launch VS Code from the environment we activated at the command line so those tools are available for its use as well.</p>
<pre>code .</pre>
<p>Now that we have the project open in VS Code it is ready to go as any other CMake project. <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">VS Code can run the CMake build using the preconfigured CMakePresets file</a> with the compilers vcpkg acquired. Select the preset arm-gcc-cortex-m4 when prompted on opening the folder.</p>
<p>All the editing power of VS Code is now available for use with the embedded project. With this Azure RTOS project we’ll cover code navigation, IntelliSense, build, deploy, debugging. We’ll also cover new diagnostic capabilities around peripheral registers and RTOS object views.</p>
<h5 id="code-navigation-and-intellisense">Code Navigation and IntelliSense</h5>
<p>Use Ctrl + T to open symbol search and type button_a_callback, select the button_a_callback function to navigate to it. Note on hover that this function expands to TIM3-&gt;CCR1 which is a peripheral register on the board which we’ll inspect while we are debugging.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png"><img class="alignnone size-full wp-image-30148" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png" alt="IntelliSense function expansion screenshot" width="538" height="327" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png 538w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef-300x182.png 300w" sizes="(max-width: 538px) 100vw, 538px" /></a></p>
<h5 id="build-deploy-and-debug-on-hardware">Build, Deploy, and Debug on hardware</h5>
<p>Set a breakpoint on RGB_LED_SET_R().</p>
<p>To see how the launch is controlled in the sidebar open .vscode/launch.json and look at the launch configuration. You can see the miDebuggerPath set to use arm-none-eabi-gdb while the debugServerPath is set to invoke openocd with the configuration script in debugServerArgs. The information for describing peripheral registers is provided by the MCU manufacturer in an SVD file that we point to with svdPath. This project is configured to break on entry with the property stopAtConnect.</p>
<p>Now, with your board plugged into the PC with <a href="https://www.st.com/en/development-tools/stsw-link009.html">ST-LINK drivers installed</a>, select the debug icon in the activity bar and make sure Run and Debug is set to Launch. Now F5 will work using openocd acquired by vcpkg to flash and debug the attached board. Execution stops at the entry function, so here we see the assembly code for that. We can also view the disassembly by right clicking the function in the call stack window, Open Disassembly View.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png"><img class="alignnone size-full wp-image-30149" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png" alt="Assembly source and disassembly screenshot" width="1047" height="177" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png 1047w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-300x51.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-1024x173.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-768x130.png 768w" sizes="(max-width: 1047px) 100vw, 1047px" /></a></p>
<p>Press continue to let execution continue.</p>
<h5 id="peripheral-registers">Peripheral Registers</h5>
<p>Now press the A button on the board. This has triggered our breakpoint. We can now go to the command palette Ctrl + Shift + P  and enter “peripheral”, select Focus on Peripheral View View. This opens the peripheral register view using the information from our SVD file specified in the launch configuration. We can now scroll through this list to find the register we are interested in, here TIM3-&gt;CCR1 which will update when we step over the RGB_LED_SET_R function.</p>
<p>On break</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png"><img class="alignnone wp-image-30259 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png" alt="Register before stepping" width="847" height="405" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png 847w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new-300x143.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new-768x367.png 768w" sizes="(max-width: 847px) 100vw, 847px" /></a></p>
<p>After stepping</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png"><img class="alignnone wp-image-30260 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png" alt="Register after stepping" width="898" height="410" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png 898w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new-300x137.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new-768x351.png 768w" sizes="(max-width: 898px) 100vw, 898px" /></a></p>
<h5 id="rtos-object-views">RTOS Object Views</h5>
<p>VS Code threads view won’t show you the threads in our Azure RTOS application. Why not? A good explanation can be found in this <a href="https://azure.microsoft.com/resources/real-time-operating-system">white paper on Real Time Operating Systems</a>.</p>
<p>“A Real-Time Operating System is system software that provides services and manages processor resources for applications. These resources include processor cycles, memory, peripherals, and interrupts. The main purpose of a Real-Time Operating System is to allocate processing time among various duties the embedded software must perform. This typically involves a division of the software into pieces, commonly called “tasks” or “threads,” and creating a run-time environment that provides each thread with its own virtual microprocessor (“Multithreading”). Basically, a virtual microprocessor consists of a virtual set of microprocessor resources, e.g., register set, program counter, stack memory area, and a stack pointer. Only while executing does a thread use the physical microprocessor resources, but each thread retains its own copy of the contents of these resources as if they were its own private resources (the thread”s “context”).”</p>
<p>So for embedded development ideally you would have views that could show you information about these RTOS objects. To see the new available RTOS objects views, go to the command palate Ctrl + Shift + P  and enter “rtos” then select Focus on RTOS viewer view</p>
<p>This will open the threads view that shows at a glance much of the information you would commonly need during embedded development, thread ids and names, how many times they have run, where the stack starts, ends, and its size as well as the maximum stack usage.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png"><img class="alignnone size-full wp-image-30153" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png" alt="RTOS threads window" width="1277" height="167" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png 1277w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-300x39.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-1024x134.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-768x100.png 768w" sizes="(max-width: 1277px) 100vw, 1277px" /></a></p>
<p>There are other views for additional ThreadX objects like block and byte pools, events, mutexes, queues, and timers. You can find these by selecting the three dots in the RTOS Viewer panel.</p>
<p>We also have RTOS object views for FreeRTOS though the available objects there differ based on what it supports.</p>
<h5 id="hardware-breakpoint-limits">Hardware breakpoint limits</h5>
<p>One last debugging capability to call out is that embedded hardware targets commonly have a limited set of hardware breakpoints available. Setting too many can corrupt the debugger state. As such we have added hardwareBreakpoints to launch.json. For this board that is set to what it supports which is 6. If we set more than that we will see the breakpoint is not set but will show as a gray empty circle.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png"><img class="alignnone size-full wp-image-30154" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png" alt="Hardware breakpoint example screenshot" width="328" height="66" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png 328w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint-300x60.png 300w" sizes="(max-width: 328px) 100vw, 328px" /></a></p>
<p>If you mouse over the breakpoint in the breakpoints view you will see a warning that it won’t be hit. This prevents corrupting the connection to the board and allows us the opportunity to unset some other breakpoints and continue debugging uninterrupted.</p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose VS Code for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Embedded Software Development in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Execution and Static Analysis Support for MSVC on Compiler Explorer</title>
		<link>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/</link>
					<comments>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 01 Mar 2022 18:41:11 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30113</guid>

					<description><![CDATA[<p>Compiler Explorer is a popular resource for visualizing the assembly output of various compilers, trying out different compiler versions and flags, and testing many popular libraries.<br />
We&#8217;re pleased to announce that, as of today, code execution and static analysis are now available for MSVC on Compiler Explorer.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/">Execution and Static Analysis Support for MSVC on Compiler Explorer</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://godbolt.org/">Compiler Explorer</a> is a popular resource for visualizing the assembly output of various compilers, trying out different compiler versions and flags, and testing many popular libraries.</p>
<p>We&#8217;re pleased to announce that, as of today, code execution and static analysis are now available for MSVC on Compiler Explorer. Execution on CE has been one of our <a href="https://developercommunity.visualstudio.com/t/allow-code-execution-on-godboltorg-for-msvc-compil/663829">highest voted tickets on Developer Community</a>, so we hope many of you will find it useful. The static analysis tool provided is the same as offered in <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">GitHub Actions</a> and in the IDE as <a href="https://devblogs.microsoft.com/cppblog/in-editor-code-analysis-in-visual-studio-2019-preview-2/">background code analysis</a>.</p>
<p>To enable code execution, tick the &#8220;Execute the code&#8221; box in the &#8220;Output…&#8221; menu. Now, every time the code is compiled, it will be run and the output will be displayed in the Output window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png"><img class="aligncenter wp-image-30121 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png" alt="Execute the code and compile to binary options highlighted in the output menu" width="866" height="308" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png 866w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-300x107.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-768x273.png 768w" sizes="(max-width: 866px) 100vw, 866px" /></a></p>
<p>To enable static analysis, select &#8220;Static Analysis&#8221; from the &#8220;Add tool…&#8221; menu. Output from the tool will be written to a new Static Analysis window. You can find out more about our toolchain&#8217;s static analysis capabilities in our <a href="https://docs.microsoft.com/en-us/cpp/code-quality/code-analysis-for-c-cpp-overview?view=msvc-170">code analysis documentation</a>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png"><img class="aligncenter wp-image-30122 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png" alt="Static analysis highlighted in the add tool menu" width="849" height="311" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png 849w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1-300x110.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1-768x281.png 768w" sizes="(max-width: 849px) 100vw, 849px" /></a></p>
<p>You can see the static analysis in action below.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png"><img class="aligncenter wp-image-30128 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png" alt="Static analysis finding an issue with the code" width="3838" height="874" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png 3838w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-300x68.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-1024x233.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-768x175.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-1536x350.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-2048x466.png 2048w" sizes="(max-width: 3838px) 100vw, 3838px" /></a></p>
<p>A huge thanks to Matt Godbolt and Patrick Quist from the Compiler Explorer team for their support. On the Microsoft side, much of this work was done by Tim Myers and Dale Hirt.</p>
<p>You can let us know what you think of the new support on Twitter <a href="https://twitter.com/visualc">@visualc</a> or in the comments below.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/">Execution and Static Analysis Support for MSVC on Compiler Explorer</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>GSL 4.0.0 is Available Now</title>
		<link>https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/</link>
		
		<dc:creator><![CDATA[Dmitry Kobets]]></dc:creator>
		<pubDate>Tue, 01 Feb 2022 15:45:22 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[Writing Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30051</guid>

					<description><![CDATA[<p>GSL 4.0.0 has been released! Here is a summary of the changes.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/">GSL 4.0.0 is Available Now</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Version 4.0.0 of Microsoft’s implementation of the <a href="https://github.com/microsoft/GSL">C++ Core Guidelines Support Library</a> (GSL) is now available for you to download on the <a href="https://github.com/microsoft/gsl/releases">releases page</a>. This release maintains the safety guarantees that we have always offered and adds improvements to various parts of the library.</p>
<h2 id="what-changed-in-this-release">What changed in this release?</h2>
<ul>
<li><a href="#deprecation-of-gslstring_span">Deprecation of <code>gsl::string_span</code></a></li>
<li><a href="#removal-of-gsl-multi_span">Removal of <code>&lt;gsl/multi_span&gt;</code></a></li>
<li><a href="#header-files-dropped-the-gsl_-prefix">Header files dropped the <code>gsl_</code> prefix</a></li>
<li><a href="#changes-to-not_null">Changes to <code>not_null</code></a></li>
<li><a href="#gslspan-and-stdspan-now-use-the-correct-specialization-of-gslat"><code>gsl::span</code> and <code>std::span</code> now use the correct specialization of <code>gsl::at</code></a></li>
<li>The <code>zstring</code> family no longer requires empty brackets to be used: <a href="https://github.com/microsoft/GSL/issues/992">issue#992</a>
<ul>
<li>for example, <code>void foo(zstring&lt;&gt; str);</code> should now be <code>void foo(zstring str);</code></li>
</ul>
</li>
<li><code>gsl::narrowing_error</code> now has a helpful <code>what()</code> message</li>
<li><code>finally</code> and <code>final_action</code> are now <code>[[nodiscard]]</code></li>
<li><a href="#gsl-will-work-in-environments-where-exceptions-are-disabled-with-some-caveats">GSL will work in environments where exceptions are disabled, with some caveats</a></li>
<li>GSL will work in environments which do not support iostreams, via the addition of the <code>GSL_NO_IOSTREAMS</code> flag: <a href="https://github.com/microsoft/GSL/pull/935">#953</a></li>
<li><a href="#C-compilers">Updated compiler support</a></li>
<li><a href="#cmake-and-build-improvements">CMake and build improvements</a></li>
</ul>
<h2 id="deprecation-of-gslstring_span">Deprecation of <code>gsl::string_span</code></h2>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/pull/1680">isocpp/CppCoreGuidelines#1680</a> removed <code>string_span</code> from the C++ Core Guidelines. The recommendation is to use <code>std::string_view</code>, <code>std::span&lt;char&gt;</code> or <code>gsl::span&lt;char&gt;</code> instead. To more closely align Microsoft’s GSL with the C++ Core Guidelines, we deprecated our implementation of <code>string_span</code> and <code>zstring_span</code>, including <code>basic_string_span</code>, <code>basic_zstring_span</code>, and all related types. For the time being, we will continue to provide the <code>&lt;gsl/string_span&gt;</code> header, but it will not be actively worked on or maintained. A table of all supported and unsupported types/features can be found in the <a href="https://github.com/microsoft/GSL/blob/main/README.md">README.md</a>.</p>
<h2 id="removal-of-gsl-multi_span">Removal of <code>&lt;gsl/multi_span&gt;</code></h2>
<p><code>multi_span</code>, <code>strided_span</code>, and everything else in <code>&lt;gsl/multi_span&gt;</code> were deprecated over a year ago in <a href="https://github.com/microsoft/GSL/releases/tag/v3.0.0">GSL 3.0.0</a>, and it is time for them and their associated tests to be removed from the library.</p>
<h2 id="header-files-dropped-the-gsl_-prefix">Header files dropped the <code>gsl_</code> prefix</h2>
<p>All headers which previously contained a <code>gsl_</code> prefix in their name have had this prefix removed. For example, <code>&lt;gsl/gsl_algorithm&gt;</code> is now <code>&lt;gsl/algorithm&gt;</code>. The <code>gsl_</code> prefixed files still exist and pass through to the updated files, but will be removed in a future release.</p>
<h2 id="changes-to-not_null">Changes to <code>not_null</code></h2>
<p>To more closely align Microsoft’s GSL with the C++ Core Guidelines, <code>gsl::not_null</code> now accepts only types which are <em>comparable</em> to <code>nullptr</code>. Previously, it accepted only types which are <em>assignable</em> from <code>nullptr</code>, but this was stricter than what was intended by the <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#gslview-views">Core Guidelines</a>.</p>
<p>The functions <code>make_not_null</code> and <code>make_strict_not_null</code>, and the <code>not_null</code> comparison operators, are now all <code>noexcept</code>.</p>
<h2 id="gslspan-and-stdspan-now-use-the-correct-specialization-of-gslat"><code>gsl::span</code> and <code>std::span</code> now use the correct specialization of <code>gsl::at</code></h2>
<p><code>gsl::span</code> and <code>std::span</code> now have their own separate specializations of <code>gsl::at</code>, to ensure consistent behavior between the two versions of span. Both overloads are included when importing <code>&lt;gsl/span&gt;</code>. The <code>std::span</code> overload can be separately included from <code>&lt;gsl/util&gt;</code>.</p>
<h2 id="gsl-will-work-in-environments-where-exceptions-are-disabled-with-some-caveats">GSL will work in environments where exceptions are disabled, with some caveats</h2>
<p><code>gsl::narrow</code> is the only part of the library which may throw exceptions and has been moved into its own header <code>&lt;gsl/narrow&gt;</code>. This header is included in <code>&lt;gsl/gsl&gt;</code> only if exceptions are enabled. This allows users of the library who are working in environments without exceptions to use all of the other components of the library.</p>
<p>Note: <code>gsl::narrow_cast</code> is still in <code>&lt;gsl/util&gt;</code>, since it does not throw exceptions.</p>
<h2 id="updated-compiler-support">Updated compiler support</h2>
<p>The list of supported compilers/toolsets has been updated with newer versions. More info on compiler support can be found in the <a href="https://github.com/microsoft/GSL/blob/main/README.md#supported-compilers--toolsets">README.md</a>.</p>
<table>
<thead>
<tr>
<th>Compiler/Toolset</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>XCode</td>
<td>13.2.1 &amp; 12.5.1</td>
</tr>
<tr>
<td>GCC</td>
<td>11.1.0 &amp; 10.3.0</td>
</tr>
<tr>
<td>Clang</td>
<td>12.0.0 &amp; 11.0.0</td>
</tr>
<tr>
<td>Visual Studio with MSVC</td>
<td>VS2022 (17.0) &amp; VS2019 (16.11)</td>
</tr>
<tr>
<td>Visual Studio with LLVM</td>
<td>VS2022 (17.0) &amp; VS2019 (16.11)</td>
</tr>
</tbody>
</table>
<h2 id="cmake-and-build-improvements">CMake and build improvements</h2>
<ul>
<li>GSL Install logic is now guarded by a cmake option <code>GSL_INSTALL</code>: <a href="https://github.com/microsoft/GSL/pull/964">#964</a></li>
<li>Fix bug which prevented the library from being built on a 32-bit host and then being used on a 64-bit machine: <a href="https://github.com/microsoft/GSL/pull/893">#893</a></li>
<li>Build will now use <code>CMAKE_CXX_STANDARD</code> if it&#8217;s provided <a href="https://github.com/microsoft/GSL/pull/953">#953</a></li>
<li>Clean up <code>GSL_SUPPRESS</code> warning for intel compilers: <a href="https://github.com/microsoft/GSL/pull/906">#906</a></li>
<li>Fix build failure for C++20 compilers which don&#8217;t have <code>std::span</code>: <a href="https://github.com/microsoft/GSL/pull/993">#993</a></li>
<li>Cleaned up some static analysis warnings</li>
<li>The cmake cache variable <code>VS_ADD_NATIVE_VISUALIZERS</code> has been renamed to <code>GSL_VS_ADD_NATIVE_VISUALIZERS</code>: <a href="https://github.com/microsoft/GSL/pull/941">#941</a></li>
</ul>
<h2 id="summary">Summary</h2>
<p>This has been a list of the changes in the GSL 4.0.0 release. You can download the code at the <a href="https://github.com/microsoft/GSL">GSL GitHub page</a>. Please stay tuned for future releases!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/">GSL 4.0.0 is Available Now</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
