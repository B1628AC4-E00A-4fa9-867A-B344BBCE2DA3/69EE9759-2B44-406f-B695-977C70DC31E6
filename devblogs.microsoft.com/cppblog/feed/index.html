<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>The latest in C++, Visual Studio, VS Code, and vcpkg from the MSFT C++ team</description>
	<lastBuildDate>Tue, 19 Aug 2025 16:35:10 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Announcing Proxy 4: The Next Leap in C++ Polymorphism</title>
		<link>https://devblogs.microsoft.com/cppblog/announcing-proxy-4-the-next-leap-in-c-polymorphism/</link>
					<comments>https://devblogs.microsoft.com/cppblog/announcing-proxy-4-the-next-leap-in-c-polymorphism/#comments</comments>
		
		<dc:creator><![CDATA[Mingxin Wang]]></dc:creator>
		<pubDate>Tue, 19 Aug 2025 16:35:10 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35676</guid>

					<description><![CDATA[<p>Version 4 of Microsoft's Proxy library brings feature improvements, better diagnostics, better code generation, modern compiler/debugger support.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/announcing-proxy-4-the-next-leap-in-c-polymorphism/">Announcing Proxy 4: The Next Leap in C++ Polymorphism</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Proxy 4 is here! After years of innovation and sustained use in the Windows OS codebase (since 2022), Proxy has matured from a bold experiment into a production-grade, modern C++ library for runtime polymorphism. The theory behind Proxy is original, and its design is now proven at scale. We are excited to invite the broader C++ community to join us in shaping the future of polymorphism. Your ideas and contributions are more welcome than ever!</p>
<p>A special thank you to @SidneyCogdill for his outstanding contributions, especially for bringing support for C++20 modules to Proxy and driving major‑version compatibility efforts. His work has made the library even more accessible and future‑proof.</p>
<h2>What is Proxy?</h2>
<p>Proxy is a header-only, cross-platform C++20 library that lets you write polymorphic code without the pain of inheritance or the limitations of traditional virtual functions. Proxy enables you to:</p>
<ul>
<li>Write code that is portable, non-intrusive, and easy to maintain</li>
<li>Manage object lifetimes flexibly, with or without ownership</li>
<li>Achieve performance that rivals or exceeds hand-written code</li>
<li>Compose abstractions from any expression: member functions, free functions, operators, conversions, and more</li>
</ul>
<p>If you&#8217;re new to Proxy, check out our <a href="https://github.com/microsoft/proxy">GitHub repository</a> and our previous announcements: <a href="https://devblogs.microsoft.com/cppblog/announcing-the-proxy-3-library-for-dynamic-polymorphism/">Announcing the Proxy 3 Library for Dynamic Polymorphism</a> and <a href="https://devblogs.microsoft.com/cppblog/analyzing-the-performance-of-the-proxy-library/">Analyzing the Performance of the &#8220;Proxy&#8221; Library</a>.</p>
<h2>New Website: Your One-Stop Reference</h2>
<p>We&#8217;ve launched a new documentation website, built with MkDocs, to help you find everything you need about Proxy. The new site offers improved navigation, a unified FAQ, and a clear structure for all features and APIs. Explore the <a href="https://microsoft.github.io/proxy/">documentation</a> and discover how easy it is to get started!</p>
<p><img decoding="async" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/08/index.png" alt="Index" /></p>
<h2>Try Proxy Instantly in Compiler Explorer</h2>
<p>You can now experiment with Proxy directly in your browser using <a href="https://godbolt.org/z/E95nY7PYq">Compiler Explorer</a>! Write, run, and inspect Proxy code without any setup. Just click on &#8220;Libraries&#8221; and search for &#8220;proxy&#8221; in Compiler Explorer or use a shared link from our examples to get started. It&#8217;s a great way to see Proxy in action and share your findings with others.</p>
<p><img decoding="async" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/08/compiler-explorer.png" alt="Compiler Explorer" /></p>
<h2>What&#8217;s New in Proxy 4?</h2>
<h3>Skills: Composable Facade Capabilities</h3>
<p>Let&#8217;s see how easy it is to add formatting support to your types (<a href="https://godbolt.org/z/3G363xz71">run in Compiler Explorer</a>):</p>
<pre><code class="language-cpp">#include &lt;format&gt;
#include &lt;proxy/proxy.h&gt;

struct Formattable : pro::facade_builder
    ::add_skill&lt;pro::skills::format&gt;
    ::build {};

int main() {
  pro::proxy&lt;Formattable&gt; p = pro::make_proxy&lt;Formattable&gt;(123);
  std::cout &lt;&lt; std::format("{}\n", *p); // Prints "123"
}</code></pre>
<p>Skills are reusable building blocks that let you add powerful capabilities to your facades with a single line:</p>
<ul>
<li><a href="https://microsoft.github.io/proxy/spec/skills_format/"><code>skills::format</code> and <code>skills::wformat</code></a>: Enable standard C++ formatting for your proxies. This was never possible with virtual functions or earlier Proxy versions.</li>
<li><a href="https://microsoft.github.io/proxy/spec/skills_fmt_format/"><code>skills::fmt_format</code> and <code>skills::fmt_wformat</code></a>: Bring full <a href="https://github.com/fmtlib/fmt">{fmt} library</a> support to your proxies, letting you use advanced formatting features with zero boilerplate.</li>
<li><a href="https://microsoft.github.io/proxy/spec/skills_rtti/"><code>skills::rtti</code></a>: Add runtime type information and safe casting to your proxies.</li>
<li><a href="https://microsoft.github.io/proxy/spec/skills_as_view/"><code>skills::as_view</code></a> and <a href="https://microsoft.github.io/proxy/spec/skills_as_weak/"><code>skills::as_weak</code></a>: Allow seamless conversion to non-owning or weak proxies, making your code safer and more expressive.</li>
<li><a href="https://microsoft.github.io/proxy/spec/skills_slim/"><code>skills::slim</code></a>: Restrict your proxy to pointer-sized storage for maximum efficiency.</li>
</ul>
<p>Skills are easy to compose and extend. You can also author internal, domain‑specific skills to capture patterns (logging, metrics hooks, validation, instrumentation) so teams reuse a single, well-reviewed definition instead of duplicating conventions. This improves consistency and long‑term maintainability. See the <a href="https://microsoft.github.io/proxy/spec/basic_facade_builder/add_skill/">skills documentation</a> for more.</p>
<h3>Easy Borrowing and Weak References</h3>
<p>Proxy 4 introduces convenient aliases for non-owning and weak references: <code>proxy_view</code> and <code>weak_proxy</code>. These are built on top of the core <code>proxy</code> concept, making it easier to express borrowing and weak ownership patterns in your code. For example, you can use <code>proxy_view</code> to safely borrow an object without taking ownership, or <code>weak_proxy</code> to create a weak reference that can be locked when needed. See the <a href="https://microsoft.github.io/proxy/spec/proxy_view/"><code>proxy_view</code> documentation</a> and <a href="https://microsoft.github.io/proxy/spec/weak_proxy/"><code>weak_proxy</code> documentation</a> for details.</p>
<h3>Shared Ownership Made Simple</h3>
<p>With the new <code>make_proxy_shared</code> and <code>allocate_proxy_shared</code> APIs, you can create shared and weak proxies efficiently, without the overhead of <code>std::shared_ptr</code>. These APIs use compact internal pointer types, ensuring high performance and low memory usage. Learn more in the <a href="https://microsoft.github.io/proxy/spec/make_proxy_shared/"><code>make_proxy_shared</code> documentation</a> and <a href="https://microsoft.github.io/proxy/spec/allocate_proxy_shared/"><code>allocate_proxy_shared</code> documentation</a>.</p>
<h2>Smarter Dispatch and Conversion</h2>
<ul>
<li><a href="https://microsoft.github.io/proxy/spec/weak_dispatch/"><code>weak_dispatch</code></a> lets you define fallback behavior for missing conventions, so your code can handle incomplete types gracefully.</li>
<li>Conversion dispatches (<a href="https://microsoft.github.io/proxy/spec/explicit_conversion_dispatch/"><code>explicit_conversion_dispatch</code></a>, <a href="https://microsoft.github.io/proxy/spec/implicit_conversion_dispatch/"><code>implicit_conversion_dispatch</code></a>) are now easier to use and provide clearer error messages.</li>
<li>The new <a href="https://microsoft.github.io/proxy/spec/proxiable_target/"><code>proxiable_target</code></a> and <a href="https://microsoft.github.io/proxy/spec/inplace_proxiable_target/"><code>inplace_proxiable_target</code></a> concepts make it clear which target types can be used with a given facade, helping you avoid surprises and write safer code.</li>
</ul>
<h2>Recursive Facade Patterns Made Easy</h2>
<p>Proxy 4 introduces <code>facade_aware_overload_t</code>, which lets you define recursive conventions that refer to the facade itself without forcing early instantiation. This is especially useful for operator chaining patterns (like arithmetic or concatenation) that return new <code>proxy</code> objects of the same facade. Example:</p>
<pre><code class="language-cpp">#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;proxy/proxy.h&gt;

template &lt;class F&gt;
using BinaryOverload =
    pro::proxy&lt;F&gt;(const pro::proxy_indirect_accessor&lt;F&gt;&amp; rhs) const;

template &lt;class T, pro::facade F&gt;
pro::proxy&lt;F&gt; operator+(const T&amp; value,
                        const pro::proxy_indirect_accessor&lt;F&gt;&amp; rhs)
  requires(!std::is_same_v&lt;T, pro::proxy_indirect_accessor&lt;F&gt;&gt;)
{
  return pro::make_proxy&lt;F, T&gt;(value + proxy_cast&lt;const T&amp;&gt;(rhs));
}

struct Addable
    : pro::facade_builder              // Compose capabilities
      ::add_skill&lt;pro::skills::rtti&gt;   // RTTI support
      ::add_skill&lt;pro::skills::format&gt; // Formatting support
      ::add_convention&lt;pro::operator_dispatch&lt;"+"&gt;,
                       pro::facade_aware_overload_t&lt;BinaryOverload&gt;&gt; // Recursive operator
      ::build {};

int main() {
  pro::proxy&lt;Addable&gt; p1 = pro::make_proxy&lt;Addable&gt;(1);
  pro::proxy&lt;Addable&gt; p2 = pro::make_proxy&lt;Addable&gt;(2);
  pro::proxy&lt;Addable&gt; p3 = *p1 + *p2; // Uses facade-aware overload
  std::cout &lt;&lt; std::format("{}\n", *p3); // Prints "3"
}</code></pre>
<p>See the <a href="https://microsoft.github.io/proxy/spec/facade_aware_overload_t/"><code>facade_aware_overload_t</code> documentation</a> for details.</p>
<h2>Quality Improvements for Everyone</h2>
<ul>
<li><strong>Bitwise Trivially Relocatable</strong>: Proxy now supports types that can be moved with <code>memcpy</code>, enabling faster moves and assignments by default. This means better performance and less boilerplate for you. See the <a href="https://microsoft.github.io/proxy/spec/is_bitwise_trivially_relocatable/"><code>is_bitwise_trivially_relocatable</code> documentation</a> for more details.</li>
<li><strong>C++20 Modules Support</strong>: Thanks to @SidneyCogdill, Proxy now ships with <code>.ixx</code> files for blazing-fast builds and better IDE support.</li>
<li><strong>Diagnostics</strong>: Error messages are now much clearer and more actionable, helping you quickly understand and fix issues in your code.</li>
<li><strong>Debugging Experience</strong>: Proxy 4 generates better debugging symbols, making it easier to inspect proxies in your debugger and understand what&#8217;s happening under the hood.</li>
<li><strong>Accessibility Authoring</strong>: It&#8217;s now easier to expose reflection and dispatch capabilities in your facades, with less boilerplate and more flexibility.</li>
<li><strong>Code Generation</strong>: Proxy 4 refines the call path for indirect dispatch, reducing the number of instructions around indirect calls.</li>
<li><strong>Compiler Support</strong>: NVIDIA HPC is newly added to our supported toolchains. Proxy 4 passes tests on the latest GCC, Clang, MSVC, and NVIDIA HPC compilers. We&#8217;re committed to keeping Proxy working with these compilers going forward, including freestanding environments. See the <a href="https://github.com/microsoft/proxy#compiler-req">README</a> for minimum versions and flags.</li>
</ul>
<h2>Major Version Compatibility</h2>
<p>Upgrading a small component is usually straightforward, but migrating a monorepo or multi-module product can be challenging. Follow the guidelines below:</p>
<ol>
<li><strong>Minor or patch upgrades (e.g. 3.3.0 → 3.4.0)</strong>
All 3.x.y releases preserve API/ABI compatibility, so different parts of the program may safely depend on different 3.x.y versions. No special action is required.</li>
<li><strong>Major upgrades (e.g. 3.4.0 → 4.0.0)</strong>
<ul>
<li>If your current version is <em>earlier</em> than 3.4.0, migrate to 3.4.0 first.</li>
<li>Starting with 3.4.0, each major release is placed in a versioned inline namespace (<code>pro::v3</code>, <code>pro::v4</code>, …).  When a translation unit sees multiple majors, qualify the namespace explicitly:
<pre><code class="language-cpp">pro::v3::foo(); // Proxy 3 API
pro::v4::foo(); // Proxy 4 API</code></pre>
<p>The newest release re-exports its namespace as the inline (default) namespace, so unqualified calls (<code>pro::foo()</code>) resolve to the latest version once the migration is complete.</li>
<li>The macros also have major-qualified aliases, e.g. <a href="https://microsoft.github.io/proxy/spec/PRO_DEF_MEM_DISPATCH/"><code>PRO4_DEF_MEM_DISPATCH</code></a>. Use these forms whenever headers from multiple majors are included in the same translation unit.</li>
<li>Upgrade subsystems incrementally, module-by-module or DLL-by-DLL. When every target depends only on the new major, drop the old include path and remove the previous version from your build.</li>
</ul>
</li>
</ol>
<p>These rules let old and new code coexist during the transition while keeping ODR violations at bay.</p>
<h2>Other Notable Changes</h2>
<ul>
<li>The macro <code>PRO_DEF_WEAK_DISPATCH</code> has been removed in favor of the more flexible <a href="https://microsoft.github.io/proxy/spec/weak_dispatch/"><code>weak_dispatch</code></a> class.</li>
<li>The class <code>proxiable_ptr_constraints</code> has been merged into the <a href="https://microsoft.github.io/proxy/spec/ProFacade/"><em>ProFacade</em> requirements</a> for simplicity.</li>
<li>The function template <code>access_proxy</code> is now shadowed by <a href="https://microsoft.github.io/proxy/spec/proxy_invoke/"><code>proxy_invoke</code></a> and <a href="https://microsoft.github.io/proxy/spec/proxy_reflect/"><code>proxy_reflect</code></a>.</li>
<li>The <a href="https://microsoft.github.io/proxy/spec/ProFacade/"><em>ProFacade</em></a> and <a href="https://microsoft.github.io/proxy/spec/ProDispatch/"><em>ProDispatch</em> requirements</a> have been revised for clarity and consistency.</li>
</ul>
<h2>Summary</h2>
<p>Proxy 4 builds on a mature foundation introduced and proven in Proxy 3, and adds focused refinements rather than reinventing the model.</p>
<p>Core capabilities (established in Proxy 3 and still central in day‑to‑day use):</p>
<ul>
<li>Expression‑based polymorphism: define a facade once, make virtually any expression (member calls, free calls, operators, explicit/implicit conversions) polymorphic.</li>
<li>Flexible creation: <a href="https://microsoft.github.io/proxy/spec/make_proxy/"><code>make_proxy</code></a> (inline where possible), <a href="https://microsoft.github.io/proxy/spec/allocate_proxy/"><code>allocate_proxy</code></a> (custom allocators), raw pointer attachment, unique ownership, and composition of abstractions via <a href="https://microsoft.github.io/proxy/spec/basic_facade_builder/add_convention/"><code>add_convention</code></a> / <a href="https://microsoft.github.io/proxy/spec/basic_facade_builder/add_reflection/"><code>add_reflection</code></a> / <a href="https://microsoft.github.io/proxy/spec/basic_facade_builder/add_facade/"><code>add_facade</code></a>.</li>
<li>Lifetime versatility in a single <a href="https://microsoft.github.io/proxy/spec/proxy/"><code>proxy</code></a> type: same facade supports non‑owning, unique, inline, or externally managed objects transparently.</li>
<li>Overload resolution &amp; reflection support for concise, generic call sites.</li>
</ul>
<p>Targeted Proxy 4 refinements:</p>
<ul>
<li>Ergonomic aliases for borrowing / weak observation (<a href="https://microsoft.github.io/proxy/spec/proxy_view/"><code>proxy_view</code></a>, <a href="https://microsoft.github.io/proxy/spec/weak_proxy/"><code>weak_proxy</code></a>) built atop the existing core.</li>
<li>Skill-based composition (formatting, RTTI, view/weak conversion, slim layout, {fmt} integration) to replace repetitive convention boilerplate.</li>
<li>New shared/weak creation helpers (<a href="https://microsoft.github.io/proxy/spec/make_proxy_shared/"><code>make_proxy_shared</code></a>, <a href="https://microsoft.github.io/proxy/spec/allocate_proxy_shared/"><code>allocate_proxy_shared</code></a>) complement (not replace) the more frequently used <code>make_proxy</code> / <code>allocate_proxy</code> paths.</li>
<li>Concepts (<a href="https://microsoft.github.io/proxy/spec/proxiable_target/"><code>proxiable_target</code></a>, <a href="https://microsoft.github.io/proxy/spec/inplace_proxiable_target/"><code>inplace_proxiable_target</code></a>) clarify when a type can be used with <code>make_proxy</code> versus <code>make_proxy_inplace</code>, giving earlier, sharper diagnostics instead of template noise.</li>
<li><a href="https://microsoft.github.io/proxy/spec/facade_aware_overload_t/"><code>facade_aware_overload_t</code></a> enables recursive facade/operator definitions (e.g. arithmetic that returns the same facade) without forcing premature instantiation.</li>
<li><a href="https://microsoft.github.io/proxy/spec/weak_dispatch/"><code>weak_dispatch</code></a> for graceful fallback when some contained types omit a convention.</li>
<li>Improved diagnostics, relocation optimizations (<a href="https://microsoft.github.io/proxy/spec/is_bitwise_trivially_relocatable/"><code>is_bitwise_trivially_relocatable</code></a>), module support, and leaner code generation.</li>
</ul>
<p>Questions and feedback are welcome! If you find something unclear, a bug, or a documentation gap, feel free to open an issue or submit a PR.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/announcing-proxy-4-the-next-leap-in-c-polymorphism/">Announcing Proxy 4: The Next Leap in C++ Polymorphism</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/announcing-proxy-4-the-next-leap-in-c-polymorphism/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Dependabot support for vcpkg</title>
		<link>https://devblogs.microsoft.com/cppblog/dependabot-support-for-vcpkg/</link>
					<comments>https://devblogs.microsoft.com/cppblog/dependabot-support-for-vcpkg/#comments</comments>
		
		<dc:creator><![CDATA[Jamie Magee]]></dc:creator>
		<pubDate>Mon, 18 Aug 2025 18:30:16 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[dependabot]]></category>
		<category><![CDATA[GitHub]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35651</guid>

					<description><![CDATA[<p>We are excited to announce that GitHub’s Dependabot now brings automated dependency updates to C++ projects using vcpkg. This support is available for projects using vcpkg manifest files, empowering teams to keep their library dependencies current and secure with minimal effort. With Dependabot, your repo can receive automatic pull requests to upgrade your libraries to [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/dependabot-support-for-vcpkg/">Dependabot support for vcpkg</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are excited to announce that GitHub’s Dependabot now brings <a href="https://github.blog/changelog/2025-08-12-dependabot-version-updates-now-support-vcpkg/">automated dependency updates to C++ projects using vcpkg</a>. This support is available for projects using <a href="https://learn.microsoft.com/vcpkg/concepts/manifest-mode">vcpkg manifest files</a>, empowering teams to keep their library dependencies current and secure with minimal effort. With Dependabot, your repo can receive automatic pull requests to upgrade your libraries to the latest available versions.</p>
<h2>What does this mean for your projects?</h2>
<p>For C++ developers managing dependencies through vcpkg, this integration eliminates a critical gap in the DevSecOps pipeline. Dependabot will automatically scan your <code>vcpkg.json</code> manifests, monitor for updates, and create pull requests when new versions become available. This matches the automation capabilities enjoyed by other language ecosystems like JavaScript and Python.</p>
<p>Unlike most package managers, vcpkg uses a &#8220;baseline&#8221; system that&#8217;s particularly well-suited to C++&#8217;s complexity. Instead of updating individual packages piecemeal, Dependabot advances your entire baseline to a newer snapshot where all libraries have been tested together.</p>
<p>Think of it this way: rather than updating curl and leaving OpenSSL at an older version, which might cause compatibility issues, the baseline update moves you to a curated set where curl, OpenSSL, and all your other dependencies are known to work together. This approach prevents the ABI (Application Binary Interface) incompatibilities and version conflicts that plague C++ projects when libraries compiled with different settings try to interact.</p>
<p>A single change updates all unpinned dependencies to versions that vcpkg maintainers have verified work together. You can still pin specific libraries using <code>version&gt;=</code> constraints or overrides when needed. See <a href="https://learn.microsoft.com/vcpkg/users/versioning.concepts">vcpkg’s versioning documentation</a> for more details.</p>
<h2>Configuration and implementation</h2>
<p>Setting up Dependabot for vcpkg follows the same pattern as other supported ecosystems. Add the following configuration to your <code>.github/dependabot.yml</code> file:</p>
<pre><code class="language-yml">version: 2
updates:
- package-ecosystem: "vcpkg"
  directory: "/" # The location of your vcpkg.json
  schedule:
    interval: "weekly"
</code></pre>
<p>The configuration supports all standard <a href="https://docs.github.com/code-security/dependabot/working-with-dependabot/dependabot-options-reference">Dependabot options</a>, including custom schedules, cooldown periods, and custom commit messages.</p>
<h2>See it in action</h2>
<p>For a practical demonstration, check out this <a href="https://github.com/JamieMagee/dependabot-vcpkg">example repository</a> that showcases Dependabot updating vcpkg dependencies. The repository includes a <code>vcpkg.json</code> manifest with a <code>builtin-baseline</code> field that Dependabot automatically updates to the latest vcpkg port repository commit. You can examine <a href="https://github.com/JamieMagee/dependabot-vcpkg/pulls">the pull requests</a> to see what Dependabot does when updates are available.</p>
<picture><source srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/08/Screenshot-2025-08-18-152839-1024x664.png" media="(prefers-color-scheme: dark)" /><source srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/08/Screenshot-2025-08-18-090807-1024x671.png" media="(prefers-color-scheme: light)" /><img fetchpriority="high" decoding="async" class="aligncenter size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/08/Screenshot-2025-08-18-090807-1024x671.png" alt="A pull request created by Dependabot, updating vcpkg.json to the latest baseline from the vcpkg port repository" width="1024" height="671" /> </picture>
<h2>Maintenance benefits</h2>
<p>The integration brings modern dependency management practices to C++ development, ensuring libraries stay current with minimal manual effort. Regular dependency updates prevent the accumulation of technical debt that occurs when libraries fall behind multiple major versions. With Dependabot handling the routine work of checking for updates, developers can focus on feature development while maintaining a healthy dependency tree.</p>
<h2>Try out the experience</h2>
<p>Automated dependency management reduces maintenance overhead and helps prevent security issues from outdated packages. By implementing Dependabot for vcpkg, you can maintain current dependencies without dedicating significant manual effort to the task.</p>
<p>Take the first step today: add the Dependabot configuration file to your repository and let automated dependency management transform how your team handles C++ package updates.</p>
<h2>Learn more</h2>
<ul>
<li><a href="https://github.blog/changelog/2025-08-12-dependabot-version-updates-now-support-vcpkg/">Dependabot version updates now support vcpkg – GitHub Changelog</a></li>
<li><a href="https://github.com/dependabot/dependabot-core/issues">Report issues or get help with Dependabot for vcpkg</a></li>
<li><a href="https://github.com/JamieMagee/dependabot-vcpkg">Example repository with a vcpkg Dependabot PR</a></li>
<li><a href="https://docs.github.com/code-security/dependabot/working-with-dependabot/dependabot-options-reference">Dependabot options reference</a></li>
<li><a href="https://learn.microsoft.com/vcpkg/concepts/manifest-mode">vcpkg manifest mode</a></li>
<li><a href="https://learn.microsoft.com/vcpkg/users/versioning.concepts">vcpkg versioning concepts</a></li>
<li><a href="https://learn.microsoft.com/vcpkg/concepts/dependabot">Dependabot support for vcpkg</a></li>
</ul>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/dependabot-support-for-vcpkg/">Dependabot support for vcpkg</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/dependabot-support-for-vcpkg/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New in vcpkg (July 2025)</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Tue, 05 Aug 2025 20:34:38 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35637</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2025.07.25 registry release, 2025-06-20, 2025-07-16, and 2025-07-21 tool releases, as well as changes to vcpkg documentation throughout July. This release includes a new command for printing package SPDX licenses, binary caching optimizations, and support for visionOS, Solaris, and illumos systems. Some [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/">What’s New in vcpkg (July 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2025.07.25">2025.07.25</a> registry release, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-06-20">2025-06-20</a>, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-07-16">2025-07-16</a>, and <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-07-21">2025-07-21</a> tool releases, as well as changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout July. This release includes a new command for printing package SPDX licenses, binary caching optimizations, and support for visionOS, Solaris, and illumos systems.</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,653 total ports </strong>available in the vcpkg curated registry. A <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>34 new ports</strong> were added to the curated registry.</li>
<li><strong>282 ports were updated</strong>. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our 15 main <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>101 </strong>community contributors made commits.</li>
<li>The main vcpkg repo has over <strong>7,000 forks</strong> and <strong>25,300 stars</strong> on GitHub.</li>
</ul>
<h1>vcpkg changelog (2025.07.25 release)</h1>
<p>The following notable changes were made in this release:</p>
<ul>
<li>Added <a href="https://learn.microsoft.com/vcpkg/commands/license-report">new vcpkg command license-report</a>, which prints the SPDX licenses from the Software Bill of Materials (SBOMs) of all installed packages. In addition, SPDX licenses now also get printed for packages being installed via classic mode <code>vcpkg install &lt;port names&gt;</code> (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1514">Microsoft/vcpkg-tool#1514</a>).</li>
<li>Binary cache restore optimization: Now decompressing zip files ordered by size, resulting in time savings of up to 14% (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1715">Microsoft/vcpkg-tool#1715</a>, thanks @autoantwort!).</li>
<li>vcpkg now uses <em>azcopy</em> to upload large artifacts for binary caching, which enables binary cache entries &gt; 5GB in size (PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/1679">Microsoft/vcpkg-tool#1679</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1717">Microsoft/vcpkg-tool#1717</a>, thanks @dg0yt!).</li>
<li>Added support for visionOS as an available target platform for vcpkg builds (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1681">Microsoft/vcpkg-tool#1681</a>, thanks @colincornaby!).</li>
<li>Added support for building and using vcpkg on Solaris and illumos systems (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1684">Microsoft/vcpkg-tool#1684</a>, thanks @trisk!).</li>
<li>Other minor bug fixes and internal feature improvements.</li>
</ul>
<h1>Documentation changes</h1>
<ul>
<li>Minor documentation fixes (thanks @bgilbert and @ impugachev!).</li>
</ul>
<p>If you have any suggestions for our documentation, please <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a> or see the box at the bottom of a particular article.</p>
<h1>Total ports available for tested triplets</h1>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>2442</td>
</tr>
<tr>
<td>x64-windows</td>
<td>2564</td>
</tr>
<tr>
<td>x64-windows-release</td>
<td>2564</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2437</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2494</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1439</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>2157</td>
</tr>
<tr>
<td>arm64-windows-static-md</td>
<td>2138</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1406</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2433</td>
</tr>
<tr>
<td>arm64-osx</td>
<td>2359</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2551</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1980</td>
</tr>
<tr>
<td>x64-android</td>
<td>2041</td>
</tr>
<tr>
<td>arm64-android</td>
<td>2003</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<h1>Thank you to our contributors</h1>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a>, or <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs</a> repos in this release (listed by commit author or GitHub username):</p>
<table>
<tbody>
<tr>
<td>Aditya Rao</td>
<td>Craig Edwards</td>
<td>Kai Blaschke</td>
<td>Russell Greene</td>
</tr>
<tr>
<td>Albert Lee</td>
<td>Dewey Dunnington</td>
<td>Kai Pastor</td>
<td>S. M. Mohiuddin Khan Shiam</td>
</tr>
<tr>
<td>Aleksi Sapon</td>
<td>dg0yt</td>
<td>llm96</td>
<td>Saad</td>
</tr>
<tr>
<td>Alex Emirov</td>
<td>Dr. Patrick Urbanke</td>
<td>Loïc Bartoletti</td>
<td>Saikari</td>
</tr>
<tr>
<td>Alexis La Goutte</td>
<td>Egor Krugletsov</td>
<td>Luca Longinotti</td>
<td>Samuel Marks</td>
</tr>
<tr>
<td>Alexis Placet</td>
<td>Employee_NO427</td>
<td>Lukas Dürrenberger</td>
<td>Sander Cox</td>
</tr>
<tr>
<td>Ali Mohammad Pur</td>
<td>Ethrynto</td>
<td>Lukey</td>
<td>shixiong2333</td>
</tr>
<tr>
<td>Alonso Schaich</td>
<td>Fidel Yin</td>
<td>matlabbe</td>
<td>sidy3d</td>
</tr>
<tr>
<td>Amin Ya</td>
<td>Filippos Karapetis</td>
<td>Matthias Zronek</td>
<td>Stefano Sinigardi</td>
</tr>
<tr>
<td>An Tao</td>
<td>gav2xlin</td>
<td>Michał Petryka</td>
<td>Stephen Eckels</td>
</tr>
<tr>
<td>Anders Wind</td>
<td>GioGio</td>
<td>Michael MIGLIORE</td>
<td>SunBlack</td>
</tr>
<tr>
<td>Andrew Kaster</td>
<td>Igor Pugachev</td>
<td>miyanyan</td>
<td>Sylvain Doremus</td>
</tr>
<tr>
<td>Antony Peacock</td>
<td>ilya-fedin</td>
<td>Mzying2001</td>
<td>Taewon Park</td>
</tr>
<tr>
<td>autoantwort</td>
<td>Ivan</td>
<td>Nick D&#8217;Ademo</td>
<td>Takatoshi Kondo</td>
</tr>
<tr>
<td>avaliente-evs</td>
<td>Ivan Sorokin</td>
<td>Nick Logozzo</td>
<td>talregev</td>
</tr>
<tr>
<td>ayeteadoe</td>
<td>Jörg Bornemann</td>
<td>Oliver</td>
<td>Theodore Tsirpanis</td>
</tr>
<tr>
<td>Azure SDK Bot</td>
<td>JackeyLea</td>
<td>Osyotr</td>
<td>Thomas Arcila</td>
</tr>
<tr>
<td>Benjamin Gilbert</td>
<td>Jacopo Gasparetto</td>
<td>Pierre Wendling</td>
<td>Tim Flynn</td>
</tr>
<tr>
<td>Benjamin Pearce</td>
<td>James Grant</td>
<td>Pratik Chowdhury</td>
<td>toge</td>
</tr>
<tr>
<td>Branden Bonaby</td>
<td>Jeffrey Wardman</td>
<td>Rémy Tassoux</td>
<td>Vitalii Koshura</td>
</tr>
<tr>
<td>Bruce Mitchener</td>
<td>Jeremy Rifkin</td>
<td>Rafael Kitover</td>
<td>Weihang Ding</td>
</tr>
<tr>
<td>Carsten Rudolph</td>
<td>JoergAtGithub</td>
<td>RainChan</td>
<td>Yu SuiXian</td>
</tr>
<tr>
<td>Christian Panov</td>
<td>Johnny Willemsen</td>
<td>Raul Metsma</td>
<td>ZXShady</td>
</tr>
<tr>
<td>Chuck Walbourn</td>
<td>jreichel-nvidia</td>
<td>RippeR37</td>
<td>Russell Greene</td>
</tr>
<tr>
<td>Colin Cornaby</td>
<td>Juraj Zikmund</td>
<td>Rossmaxx</td>
<td></td>
</tr>
<tr>
<td>CQ_Undefine</td>
<td>Kadir</td>
<td>RuslanSemchenko</td>
<td></td>
</tr>
</tbody>
</table>
<h1>Learn more</h1>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases">main release notes</a> on GitHub. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to vcpkg documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/">What’s New in vcpkg (July 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Dynamically Update C++ syntax using Next Edit Suggestions</title>
		<link>https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Mon, 04 Aug 2025 16:36:10 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Copilot]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35626</guid>

					<description><![CDATA[<p>When working in a C++ repo, you often are maintaining and updating existing code just as often as you are writing new code. However, updating code in C++ can often require navigating to several different locations in a file to ensure consistency, which can disrupt your logical workflow. For example, changing a data member’s access [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/">Dynamically Update C++ syntax using Next Edit Suggestions</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>When working in a C++ repo, you often are maintaining and updating existing code just as often as you are writing new code. However, updating code in C++ can often require navigating to several different locations in a file to ensure consistency, which can disrupt your logical workflow. For example, changing a data member’s access level typically involves several steps: moving the member between the <code>public</code> and <code>private</code> sections of the class, adding getter/setter methods, and updating all references to respect this new access level.</p>
<p>GitHub Copilot now supports <strong>Next Edit Suggestions</strong> (or NES for short) to predict the next edits to come. NES in GitHub Copilot helps you stay in flow by not only helping predict where you’ll need to make updates, but also what you’ll need to change next.</p>
<h3>Example: Converting C code to C++</h3>
<p>At Microsoft Build, we showed how NES can dynamically update C++ code, including an example of updating code syntax that was using C functions to use the C++ Standard Template Library (STL).</p>
<p>For example, when updating code that reads from stdin from C-style code that uses raw character arrays to C++ code that uses the <code>std::string</code> type, NES predicts and suggests updates across all applicable areas near the cursor. NES replaces calls to <code>fgets</code> with calls to <code>std::getline</code> and replaces <code>atoi</code> with the C++ <code>std::stoi</code>, which has better error handling.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/nes-finalv2-ezgif.com-video-to-gif-converter-1.gif"><img decoding="async" class="alignnone size-full wp-image-35627" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/nes-finalv2-ezgif.com-video-to-gif-converter-1.gif" alt="NES dynamically updating fgets to getline across a C++ file" width="800" height="600" /></a></p>
<p>You can then review and make any relevant updates – for example, in this case, any other areas that call on strings.</p>
<p>Next Edit Suggestions is now available in both <a href="https://learn.microsoft.com/en-us/visualstudio/ide/copilot-next-edit-suggestions?view=vs-2022">Visual Studio</a> and <a href="https://code.visualstudio.com/docs/copilot/ai-powered-suggestions#_next-edit-suggestions">VS Code</a>.  As you try out NES, we&#8217;d love to hear your feedback. Share your feedback on <a href="https://developercommunity.visualstudio.com/VisualStudio/suggest">Developer Community</a> for Visual Studio or on <a href="https://github.com/microsoft/vscode-copilot-release">GitHub</a> for VS Code to help shape what’s next and how we can improve. If NES streamlines your workflow or saves you time, let us know &#8211; drop a comment or email us at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. We’re excited to see how you’re using NES for C++!</p>
<h3>Agent Mode and other new Copilot features</h3>
<p>GitHub Copilot is evolving beyond typical code completion, with features like Next Edit Suggestions, Agent Mode, and MCP transforming how developers interact with AI. The Visual Studio session at Build not only showcased NES in action, but also Agent Mode and MCP and how they each revolutionize the traditional Copilot interfaces. While NES predicts your next code edits in the editor, agent mode can work as an iterative AI assistant that understands your intent to provide dynamic edits and information.</p>
<p>To learn more about the C++ NES use cases detailed above and these other new features available for developers in Visual Studio, watch “Top GitHub Copilot features you missed in Visual Studio 2022”.</p>
<p><iframe src="//www.youtube.com/embed/Fq7myF58Odc?embeds_referring_euri=https" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></p>
<h3>What do you think?</h3>
<p>Try out the latest Copilot features for your C++ workflows today. To access these updates to Copilot, you’ll need an <a href="https://github.com/features/copilot?utm_source=vscom&amp;utm_medium=hero&amp;utm_campaign=cta-get#pricing">active GitHub Copilot subscription</a> and <a href="http://aka.ms/vs">the latest version of Visual Studio</a>.</p>
<p>Our team is working hard on improving C++ integrations with Copilot, so please let us know any other enhancements you’d like to see. Share your thoughts with us on <a href="https://developercommunity.visualstudio.com/VisualStudio/suggest">Developer Community</a> for Visual Studio or on <a href="https://github.com/microsoft/vscode">GitHub</a> for VS Code to help shape what’s next and how we can improve. You can also reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com,</a> via X at <a href="https://twitter.com/visualc">@VisualC</a>, or via Bluesky at <a href="https://bsky.app/profile/msftcpp.bsky.social">@msftcpp.bsky.social</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/">Dynamically Update C++ syntax using Next Edit Suggestions</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code CMake Tools Extension 1.21 Release: Multi-root improvements, CMake Presets v10, and more…</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Mon, 21 Jul 2025 12:10:34 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35611</guid>

					<description><![CDATA[<p>We’re excited to announce the latest 1.21 release of the CMake Tools extension for Visual Studio Code. This update brings a host of new updates, including addressing one of our top-voted issues for multi-root improvements and adding CMake presets version 10 support. To view the full list of updates with this release, please look at [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/">Visual Studio Code CMake Tools Extension 1.21 Release: Multi-root improvements, CMake Presets v10, and more…</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We’re excited to announce <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">the latest 1.21 release of the CMake Tools extension</a> for Visual Studio Code. This update brings a host of new updates, including addressing one of our top-voted issues for <strong>multi-root improvements</strong> and adding <strong>CMake presets version 10 support</strong>. To view the full list of updates with this release, please look at our <a href="https://github.com/microsoft/vscode-cmake-tools/blob/main/CHANGELOG.md">CHANGELOG</a>.</p>
<p>This release features the following ten contributions from our open-source community. Thank you for your continued support!</p>
<ul>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4273">Allow specifying a launch configuration which can be used when debugging tests via CTest</a> by <a href="https://github.com/Nerixyz">@nerixyz</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4422">Adding a new command cmake.cacheVariable</a> by <a href="https://github.com/malsyned">@malsyned</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/3953">Grouping default build targets based on CMake FOLDER property</a> by <a href="https://github.com/itzandroidtab">@itzandroidtab</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4340">Add name de-mangling for C++ symbols in the Test Explorer view</a> by <a href="https://github.com/rjaegers">@rjaegers</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4325">Fixes to case preservation for include paths on MacOS</a> by <a href="https://github.com/tringenbach">@tringenbach</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4458">Reduce heap usage with new optimized splits for large compile commands</a> by <a href="https://github.com/borjamunozf">@borjamunozf</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4321">Remove dependency for backtrace in presence of DEF_SOURCE_LINE</a> by <a href="https://github.com/rjaegers">@rjaegers</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/issues/2864">Fix gnuld error parsing false positive on make errors, false negatives due to trailing \r, and false parsing of new “multiple definitions” error</a> by <a href="https://github.com/0xemgy">@0xemgy</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/issues/4304">Fix bug where unrelated symlinks are read as variant files</a> by <a href="https://github.com/vitorramos">@vitorramos</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/issues/2855">Fix ENOENT error at vs code startup on some circumstances</a> by <a href="https://github.com/JDESTM">@STMicroelectronics</a></li>
</ul>
<h3>Multi-root improvements</h3>
<p>We addressed one of our <a href="https://github.com/microsoft/vscode-cmake-tools/issues/1069">top-voted customer feedback issues</a> to improve multi-root integration and allow users more customizability to enable/disable certain folders in mixed-language circumstances.</p>
<p>Now, we have added support for a new <code>cmake.exclude</code> setting that allows users to select specific folders to ignore in multi-root scenarios.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude.png"><img decoding="async" class="size-full wp-image-35612 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude.png" alt="The CMake exclude setting ignoring test and third party libraries for Pioneer" width="1072" height="269" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude.png 1072w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude-300x75.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude-1024x257.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude-768x193.png 768w" sizes="(max-width: 1072px) 100vw, 1072px" /></a></p>
<p>For example, when developing with 3<sup>rd</sup> party packages, you can specify for the extension to ignore these at build via this new setting, improving the overall user experience for your needs.</p>
<h3>CMake presets version 10 support</h3>
<p>We have also added support for the latest version 10 of CMake Presets, which adds two new features to enhance clarity and visualization in your build configurations: $<strong>comment</strong> and <strong>graphviz</strong> support.</p>
<p>CMake presets v10 introduces a new <code>$comment</code> field that allows developers to add inline documentation within their preset’s definitions, making it easier to understand and distinguish between different configurations. To learn more about using formatting using $comment, you can visit <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#format">Kitware’s documentation</a>.</p>
<p>Additionally, CMake presets now supports graphviz, which allows you to visualize the dependencies between targets and external libraries in your project. By specifying a <code>graphviz</code> field in your CMake presets, you can enable Graphviz DOT files that can be rendered via Graphviz.</p>
<h3>What do you think?</h3>
<p>Download <a href="https://code.visualstudio.com/Download">Visual Studio Code</a> and <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">the CMake Tools extension</a> and let us know what you think. We would love to see what you contribute to our<a href="https://github.com/microsoft/vscode-cmake-tools"> repo</a>. Please create an <a href="https://github.com/microsoft/vscode-cmake-tools/issues/">issue</a> if there’s anything you’d like to see and upvote/downvote any existing issues. Comment below or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com,</a> via X at <a href="https://twitter.com/visualc">@VisualC</a>., or via Bluesky at <a href="https://bsky.app/profile/msftcpp.bsky.social">@msftcpp.bsky.social</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/">Visual Studio Code CMake Tools Extension 1.21 Release: Multi-root improvements, CMake Presets v10, and more…</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Updates to Warning Suppressions in Microsoft C++ Code Analysis</title>
		<link>https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/</link>
					<comments>https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/#comments</comments>
		
		<dc:creator><![CDATA[Carson Radtke]]></dc:creator>
		<pubDate>Tue, 15 Jul 2025 18:00:13 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[code analysis]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35604</guid>

					<description><![CDATA[<p>Improvements to \#pragma warning and gsl::suppress in Microsoft C++ Code Analysis.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/">Updates to Warning Suppressions in Microsoft C++ Code Analysis</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Microsoft C++ Code Analysis is a powerful static analysis tool integrated into Visual
Studio that helps you identify and fix potential issues in your C++ code.
Large projects require effective management of analysis warnings to maintain code
quality and you sometimes need to suppress warnings, but must do so in a clear and
auditable way.</p>
<p>To that end, we are excited to announce significant updates to the warning suppression
mechanisms in Microsoft C++ Code Analysis. These enhancements provide better tracking,
justification, and overall management of warning suppressions, leading to a more
maintainable and robust codebase.</p>
<h2>What&#8217;s New in the SARIF Output?</h2>
<p>We enhanced the
<a href="https://sarif.info/">Static Analysis Results Interchange Format (SARIF)</a>
output to include detailed information about warning suppressions, most notably the
justification provided by you. This allows teams to easily review <em>why</em> a specific
warning was silenced.</p>
<p>To generate a SARIF file, use the <code>/analyze:log:format:sarif</code> compiler option. To ensure
that details about suppressed warnings (including their justifications) are included in
this SARIF log, you must also use the <code>/analyze:log:includesuppressed</code> option.</p>
<h2>What&#8217;s New in <code>gsl::suppress</code>?</h2>
<p>We have updated our support for <code>gsl::suppress</code> to align with the latest C++ Core
Guidelines syntax. Warnings can now be suppressed by using the <code>gsl::suppress</code> attribute
in the following way:</p>
<pre><code class="language-cpp">[[gsl::suppress( "&lt;warning_id&gt;", justification: "&lt;justification&gt;" )]]</code></pre>
<p>Where <code>&lt;warning_id&gt;</code> is the ID of the warning you want to suppress, and the optional
<code>&lt;justification&gt;</code> is a string that provides a justification for the suppression.</p>
<p><em>For now, <code>[[gsl::suppress]]</code> is only available for C++ codebases. For C codebases, you
must use the <code>#pragma warning(suppress)</code> syntax.</em></p>
<p>Example:</p>
<pre><code class="language-cpp">// CoreCheckExample.cpp
// Add CppCoreCheck package and enable code analysis in build for warnings.

int main()
{
    int arr[10];           // warning C26494
    int* p = arr;          // warning C26485

    [[gsl::suppress("bounds.1", justification : "This attribute suppresses Bounds rules #1")]]
    {
        int* q = p + 1;    // warning C26481 (suppressed)
        p = q++;           // warning C26481 (suppressed)
    }

    return 0;
}</code></pre>
<h2>What&#8217;s New in <code>#pragma warning</code>?</h2>
<p>We have extended <code>#pragma warning</code> to support the <code>justification</code> field. Here is how
you can use it starting in Visual Studio 2022 version 17.14:</p>
<pre><code class="language-cpp">#pragma warning(suppress : &lt;warning_id&gt;, justification : "&lt;justification&gt;")</code></pre>
<p>Where <code>&lt;warning_id&gt;</code> is the ID of the warning you want to suppress, and the optional
<code>&lt;justification&gt;</code> is a string that provides a justification for the suppression.</p>
<h2>Choosing Between <code>#pragma warning</code> and <code>gsl::suppress</code></h2>
<p>Both <code>#pragma warning(suppress)</code> and <code>[[gsl::suppress]]</code> offer fine-grained control over
warning suppression.</p>
<ul>
<li><code>#pragma warning(suppress)</code> is a general MSVC mechanism that can be used for any
compiler warning. It&#8217;s particularly useful when you need to suppress a warning in a
specific code block without altering the code&#8217;s structure significantly.</li>
<li><code>[[gsl::suppress]]</code> will only suppress warnings emitted by Microsoft C++ Code
Analysis. It is intended for use with the C++ Core Guidelines checks and can be applied
to a scope or a specific declaration.</li>
</ul>
<p>Whenever possible, we recommend using <code>[[gsl::suppress]]</code> for suppressing Microsoft C++
Code Analysis warnings.</p>
<h2>Why These Updates Matter</h2>
<p>These enhancements to warning suppression offer several key benefits:</p>
<ul>
<li><strong>Improved Auditability and Review:</strong> With justifications recorded directly in the
code and optionally in SARIF logs, code reviews become more effective. Team members can
quickly understand the rationale behind a suppression without needing to consult
external documentation or the original author.</li>
<li><strong>Enhanced Code Maintainability:</strong> Clear justifications prevent accidental
re-introduction of issues when code is refactored or suppressions are reviewed. They
provide a history of why certain warnings were deemed acceptable at a particular point.</li>
<li><strong>Better Management of Technical Debt:</strong> Suppressed warnings can be a form of
technical debt. Justifications help in tracking and prioritizing which suppressions
should be revisited and potentially fixed.</li>
<li><strong>Consistency Across Suppression Mechanisms:</strong> By adding justification support to both
<code>#pragma warning</code> and <code>gsl::suppress</code>, we provide a consistent experience for you. This
allows old code to use <code>#pragma warning</code> while new code can use <code>[[gsl::suppress]]</code>, all
while maintaining the ability to provide justifications.</li>
</ul>
<h3>Impact on Existing Workflows</h3>
<p>These new features are additive. Existing suppression mechanisms (without
justifications) will continue to work as before. However, we encourage you to
start using the <code>justification</code> attribute for new suppressions and to gradually update
existing ones where clarity is beneficial. There is no automatic migration, but the
process of adding justifications is straightforward.</p>
<h3>Availability</h3>
<p>These enhancements are available in the MSVC compiler toolset shipping with Visual
Studio 2022 version 17.14 and newer, and will be part of future Visual Studio releases.
Ensure your Visual Studio is updated to leverage these improvements.</p>
<h2>Try It Out</h2>
<pre><code class="language-c++">// example.cpp
// Compile with: cl /analyze:only /analyze:plugin EspxEngine.dll /analyze:log:format:sarif /analyze:log:includesuppressed example.cpp

int main()
{
    int arr[10];           // warning C26494
    int* p = arr;          // warning C26485

    [[gsl::suppress("bounds.1", justification : "This attribute suppresses Bounds rules #1")]]
    {
        int* q = p + 1;    // warning C26481 (suppressed)
        p = q++;           // warning C26481 (suppressed)
    }

    return 0;
}</code></pre>
<p>You can run the above code with the following options:
<code>/analyze /analyze:log:format:sarif /analyze:log:includesuppressed</code> to generate a SARIF
file that includes the suppression details.
(Note: <code>EspxEngine.dll</code> is the plugin that enables C++ Core Guidelines checks, which are
the target of <code>gsl::suppress</code>.)</p>
<pre><code class="language-powershell">&gt; cl /analyze:only /analyze:plugin EspxEngine.dll /analyze:log:format:sarif /analyze:log:includesuppressed .\example.cpp
Microsoft (R) C/C++ Optimizing Compiler Version 19.50.35305.95 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

example.cpp
D:\tmp\example.cpp(7) : warning C26485: Expression 'arr': No array to pointer decay (bounds.3).
D:\tmp\example.cpp(6) : warning C26494: Variable 'arr' is uninitialized. Always initialize an object (type.5).</code></pre>
<p>You will also find a file named <code>example.nativecodeanalysis.sarif</code>, you can open it with
VSCode (don&#8217;t forget to install the latest version of the
<a href="https://marketplace.visualstudio.com/items?itemName=MS-SarifVSCode.sarif-viewer">SARIF Viewer extension</a>).
After filtering to include suppressed warnings, you will see the warning details which
include the suppression information. Here is an example of what you will see:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2.png"><img decoding="async" class="alignnone size-full wp-image-35609" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2.png" alt="extension screenshot png image" width="2500" height="1359" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2.png 2500w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-300x163.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-1024x557.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-768x417.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-1536x835.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-2048x1113.png 2048w" sizes="(max-width: 2500px) 100vw, 2500px" /></a></p>
<h2>Feedback</h2>
<p>We would love to hear your thoughts on the new changes to warning suppressions! Please
share your feedback and suggestions in the comments below. If you run into any issues,
please let us know by filing a feedback ticket on
<a href="https://developercommunity.visualstudio.com/cpp">Visual Studio Developer Community</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/">Updates to Warning Suppressions in Microsoft C++ Code Analysis</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Smarter, workspace-aware code completions for C++ in VS Code</title>
		<link>https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 08 Jul 2025 14:50:11 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Copilot]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35581</guid>

					<description><![CDATA[<p>C++ code understanding Developing C++ code can be complex. C++ project structure, style, and convention can vary widely from repository to repository, and critical context for a given task often spans multiple files. This can require C++ developers to open and navigate across several files to fully understand a given project and author new code. [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/">Smarter, workspace-aware code completions for C++ in VS Code</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h3>C++ code understanding</h3>
<p>Developing C++ code can be complex. C++ project structure, style, and convention can vary widely from repository to repository, and critical context for a given task often spans multiple files. This can require C++ developers to open and navigate across several files to fully understand a given project and author new code.</p>
<p>The GitHub Copilot team has focused on two areas to improve the C++ developer experience for code completions:</p>
<ul>
<li><strong>Upgrades to the underlying completions model</strong> to better understand C++ syntax and patterns across diverse codebases.</li>
<li><strong>Enhancing workspace awareness for C++</strong> so that Copilot can provide more relevant completions</li>
</ul>
<p>These improvements are designed to help the <a href="https://code.visualstudio.com/docs/copilot/ai-powered-suggestions">autocomplete-style inline GitHub Copilot code completions</a> be even more productive with C++ coding, minimizing manual intervention.</p>
<h3>Model updates for code completions</h3>
<p>The GitHub Copilot team has upgraded the base completions model to the new <a href="https://github.blog/changelog/2025-03-27-gpt-4o-copilot-your-new-code-completion-model-is-now-generally-available/">GPT-4o Copilot model</a>. This model has additional training on over 275,000 high-quality public repositories in over 30 popular programming languages (including C++) and improved latency. This base model is available across Visual Studio and VS Code by default.</p>
<h3>Updates to workspace awareness for C++ code completions</h3>
<p>Additionally, with the latest improvements to GitHub Copilot code completions, Copilot can detect even more relevant context in C++ projects in order to provide more accurate code suggestions in VS Code for your specific codebase. This is now available in <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/v1.26.3">the latest 1.26.3 release of the C/C++ extension</a>.</p>
<p>To access these improvements, ensure you are on 1.322.0 or later of the <a href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot">Copilot extension</a> and 1.26.3 or later of the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++ extension</a> with <a href="https://code.visualstudio.com/docs/cpp/configure-intellisense">IntelliSense configured</a>.</p>
<h3>What&#8217;s Next?</h3>
<p>We are committed to delivering similar improvements to Visual Studio 2022 17.14, so stay tuned for updates.</p>
<p>Our team is working hard on improving C++ integrations with Copilot, so please let us know any other enhancements you’d like to see. Share your thoughts with us on <a href="https://developercommunity.visualstudio.com/VisualStudio/suggest">Developer Community</a> for Visual Studio or on <a href="https://github.com/microsoft/vscode">GitHub</a> for VS Code to help shape what’s next and how we can improve. You can also reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via X at <a href="https://x.com/visualc">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/">Smarter, workspace-aware code completions for C++ in VS Code</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New in vcpkg (June 2025)</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Fri, 04 Jul 2025 19:02:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35583</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2025.06.13 registry release, 2025-04-16, 2025-05-19, and 2025-06-02 tool releases, as well as changes to vcpkg documentation throughout May and June. This release includes bug fixes, several documentation changes, and the removal of the x-gha binary caching provider for GitHub (alternatives are [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/">What’s New in vcpkg (June 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2025.06.13">2025.06.13</a> registry release, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-04-16">2025-04-16</a>, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-05-19">2025-05-19</a>, and <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-06-02">2025-06-02</a> tool releases, as well as changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout May and June. This release includes bug fixes, several documentation changes, and the removal of the <code>x-gha</code> binary caching provider for GitHub (alternatives are described below).</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,621 total ports </strong>available in the vcpkg curated registry. A <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>35 new ports</strong> were added to the curated registry.</li>
<li><strong>517 ports were updated</strong>. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our 15 main <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>132 </strong>community contributors made commits.</li>
<li>The main vcpkg repo has over <strong>6,900 forks</strong> and <strong>25,100 stars</strong> on GitHub.</li>
</ul>
<h2>vcpkg changelog (2025.06.13 release)</h2>
<p>The following notable changes were made in this release:</p>
<ul>
<li>Due to <a href="https://github.com/actions/cache/discussions/1510">recent changes in GitHub Actions Cache’s API</a>, the <code>x-gha</code> binary caching provider has been rendered obsolete. As a result, we had to remove it from vcpkg (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1662">Microsoft/vcpkg-tool#1662</a>). Instead, you can use one of the following methods to cache binaries in GitHub; we welcome any feedback from our users about how this experience could be improved in the future:
<ul>
<li>Use <a href="https://learn.microsoft.com/vcpkg/consume/binary-caching-github-packages">GitHub Packages with NuGet</a>, which uses vcpkg’s caching mechanism and preserves caching granularity per port. This is the method the vcpkg team recommends.</li>
<li>Use <a href="https://github.com/actions/cache">actions/cache</a> in your workflow to cache the installed directory. The downside of this method is that the whole installed tree gets cached as a single artifact, so single port updates invalidate all packages.</li>
</ul>
</li>
<li>Fixed a bug causing permissions while using <code>upkg</code> to not be preserved (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1625">Microsoft/vcpkg-tool#1625</a>).</li>
<li>Improved diagnostics and bug fixes for vcpkg x-test-features command (PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/1649">Microsoft/vcpkg-tool#1649</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1650">Microsoft/vcpkg-tool#1650</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1663">Microsoft/vcpkg-tool#1663</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1676">Microsoft/vcpkg-tool#1676</a>, thanks @autoantwort!).</li>
<li>Fixed an issue causing slow binary cache insertions in some Docker containers (PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/1659">Microsoft/vcpkg-tool#1659</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1669">Microsoft/vcpkg-tool#1669</a>, thanks @Thomas1664, @dg0yt!).</li>
<li>Other minor bug fixes and internal feature improvements (thanks @autoantwort, @dg0yt, @huangqinjin, @DewJunkie!).</li>
</ul>
<h2>Documentation changes</h2>
<ul>
<li>The vcpkg docs have moved to the MicrosoftDocs organization, under the URL <a href="https://github.com/MicrosoftDocs/vcpkg-docs">https://github.com/MicrosoftDocs/vcpkg-docs</a>. The existing repo has fully migrated with no loss in functionality. Links to the old repo should redirect to the new one automatically. The experience on the Learn website remains the same.</li>
<li>Added documentation for the new commands <a href="https://learn.microsoft.com/vcpkg/commands/format-feature-baseline">format-feature-baseline</a> and <a href="https://learn.microsoft.com/vcpkg/commands/test-features">x-test-features</a> (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/455">MicrosoftDocs/vcpkg-docs#455</a>).</li>
<li>Added documentation for vcpkg license-report command (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/491">MicrosoftDocs/vcpkg-docs#491</a>).</li>
<li>Updated <a href="https://learn.microsoft.com/vcpkg/consume/binary-caching-github-packages?pivots=windows-runner">Tutorial: Set up a vcpkg binary cache using GitHub Packages in a GitHub Actions workflow</a> to clarify that mono is no longer pre-installed by default for GitHub Actions Ubuntu runners (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/495">MicrosoftDocs/vcpkg-docs#495</a>).</li>
<li>Updated <a href="https://learn.microsoft.com/vcpkg/users/buildsystems/msbuild-integration">vcpkg in MSBuild projects</a> article to add instructions about how to pass MSBuild properties to vcpkg builds (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/481">MicrosoftDocs/vcpkg-docs#481</a>).</li>
<li>Removed documentation references to GitHub Actions Cache and <code>x-gha</code> provider, de-indexed the associated tutorial, and added a removal notice on the reference page.</li>
<li>Other minor documentation improvements (thanks @Alan Pope, @Ivan Sorokin, @shijunz, @Tiago Freitas, @Yan Romao!).</li>
</ul>
<p>If you have any suggestions for our documentation, please <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a> or see the box at the bottom of a particular article.</p>
<h2>Total ports available for tested triplets</h2>
<table>
<tbody>
<tr>
<td><strong>Triplet</strong></td>
<td><strong>Ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>2406</td>
</tr>
<tr>
<td>x64-windows</td>
<td>2524</td>
</tr>
<tr>
<td>x64-windows-release</td>
<td>2524</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2398</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2450</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1410</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>2122</td>
</tr>
<tr>
<td>arm64-windows-static-md</td>
<td>2102</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1377</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2394</td>
</tr>
<tr>
<td>arm64-osx</td>
<td>2321</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2510</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1939</td>
</tr>
<tr>
<td>x64-android</td>
<td>1996</td>
</tr>
<tr>
<td>arm64-android</td>
<td>1961</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<h2>Thank you to our contributors</h2>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a>, or <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs</a> repos in this release (listed by commit author or GitHub username):</p>
<table>
<tbody>
<tr>
<td>Adrien Bourdeaux</td>
<td>Eugene Gershnik</td>
<td>Long Nguyen</td>
<td>Ryan Zoeller</td>
</tr>
<tr>
<td>Alan Pope</td>
<td>Faaux</td>
<td>Lukas Berbuer</td>
<td>Saad</td>
</tr>
<tr>
<td>Alexandre Bique</td>
<td>Fabien Pean</td>
<td>m7913d</td>
<td>Sander Cox</td>
</tr>
<tr>
<td>Alexis La Goutte</td>
<td>flightless-coder</td>
<td>Martin Valgur</td>
<td>Scott Hart</td>
</tr>
<tr>
<td>Alexis Placet</td>
<td>galabovaa</td>
<td>Matt H</td>
<td>Sebastian Goth</td>
</tr>
<tr>
<td>Alfred E. Heggestad</td>
<td>gastineau</td>
<td>Matthew Oliver</td>
<td>shijunz</td>
</tr>
<tr>
<td>Amin Ya</td>
<td>Harald</td>
<td>Maxime Gervais</td>
<td>SunBlack</td>
</tr>
<tr>
<td>Andrew Kaster</td>
<td>Henrique Teles</td>
<td>Mengna-Li</td>
<td>Szabolcs Horvát</td>
</tr>
<tr>
<td>Andrey</td>
<td>huangqinjin</td>
<td>Michał Petryka</td>
<td>Takahiro Ueda</td>
</tr>
<tr>
<td>Anthony Umfer</td>
<td>hy zhang</td>
<td>Michael R. P. Ragazzon</td>
<td>talregev</td>
</tr>
<tr>
<td>autoantwort</td>
<td>Hyunjin Song</td>
<td>miyanyan</td>
<td>Tamás PEREGI</td>
</tr>
<tr>
<td>Benno Waldhauer</td>
<td>i-curve</td>
<td>Moritz Beutel</td>
<td>Theodore Tsirpanis</td>
</tr>
<tr>
<td>blavallee</td>
<td>Ildar Khayrutdinov</td>
<td>mschollerer</td>
<td>Thomas1664</td>
</tr>
<tr>
<td>Buck Yeh</td>
<td>ilya-fedin</td>
<td>myd7349</td>
<td>Tiago Freitas</td>
</tr>
<tr>
<td>Carsten Rudolph</td>
<td>Ivan Sorokin</td>
<td>Mys Vac</td>
<td>Tim Flynn</td>
</tr>
<tr>
<td>Charlie</td>
<td>Jack Boos Yu</td>
<td>Nenad Banfic</td>
<td>Timofei Zhakov</td>
</tr>
<tr>
<td>Chase Knowlden</td>
<td>Jacob Wujciak-Jens</td>
<td>Nick D&#8217;Ademo</td>
<td>Timur Chernykh</td>
</tr>
<tr>
<td>chausner</td>
<td>JacobBarthelmeh</td>
<td>Nick Logozzo</td>
<td>toge</td>
</tr>
<tr>
<td>Chuck Walbourn</td>
<td>Jaka</td>
<td>nunupeke</td>
<td>Tom G. Huang</td>
</tr>
<tr>
<td>Clement Peron</td>
<td>Jean-Sebastien Paquet</td>
<td>Oleg Derevenetz</td>
<td>Tom Tan</td>
</tr>
<tr>
<td>CQ_Undefine</td>
<td>Jeremy Rifkin</td>
<td>Osyotr</td>
<td>Tomasz Kalisiak</td>
</tr>
<tr>
<td>Damian Dyńdo</td>
<td>JoergAtGithub</td>
<td>Pasukhin Dmitry</td>
<td>tomy2105</td>
</tr>
<tr>
<td>Daniel Bertalan</td>
<td>Johannes Meßmer</td>
<td>Pavel Kisliak</td>
<td>Vitalii Koshura</td>
</tr>
<tr>
<td>David Machaj</td>
<td>Jonathan Sweemer</td>
<td>Peter Adam Korodi</td>
<td>Vladimir Petrigo</td>
</tr>
<tr>
<td>Denis Barkar</td>
<td>jreichel-nvidia</td>
<td>Peter Steneteg</td>
<td>Vladimir Shaleev</td>
</tr>
<tr>
<td>DevFdv</td>
<td>Kadir</td>
<td>Rémy Tassoux</td>
<td>Wentsing Nee</td>
</tr>
<tr>
<td>DewJunkie</td>
<td>Kai Blaschke</td>
<td>Rafael Kitover</td>
<td>whyzix</td>
</tr>
<tr>
<td>Dr. Patrick Urbanke</td>
<td>Kai Pastor</td>
<td>Reupen Shah</td>
<td>wolfgitpr</td>
</tr>
<tr>
<td>eao197</td>
<td>karnigen</td>
<td>Reza Alizadeh Majd</td>
<td>xavier2k6</td>
</tr>
<tr>
<td>Egor Tyuvaev</td>
<td>Kevin Ring</td>
<td>Riccardo Ressi</td>
<td>xvitaly</td>
</tr>
<tr>
<td>Employee_NO427</td>
<td>l.feng</td>
<td>Ridwan Abdul Hafidh</td>
<td>Yan Romao</td>
</tr>
<tr>
<td>Eric Kilmer</td>
<td>Lars Fröhlich</td>
<td>Rimas Misevičius</td>
<td>Yury Bura</td>
</tr>
<tr>
<td>Ethan J. Musser</td>
<td>llm96</td>
<td>rinechran</td>
<td>Zhichao Wang</td>
</tr>
</tbody>
</table>
<h2>Learn more</h2>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases">main release notes</a> on GitHub. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to vcpkg documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/">What’s New in vcpkg (June 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>How Electronic Arts standardized C++ builds across Windows and Linux with Visual Studio Build Tools</title>
		<link>https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/</link>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Thu, 26 Jun 2025 12:00:43 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35568</guid>

					<description><![CDATA[<p>At Electronic Arts (EA), the Frostbite Enginering Workflows team has thousands of developers who work on powerful game engines behind popular games.  EA has relied on Visual Studio for years due to several features such as IntelliSense, Build Insights, and the overall debugging experience and eagerly use newer integrations such as GitHub Copilot.  They also [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/">How Electronic Arts standardized C++ builds across Windows and Linux with Visual Studio Build Tools</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>At Electronic Arts (EA), the Frostbite Enginering Workflows team has thousands of developers who work on powerful game engines behind popular games.  EA has relied on Visual Studio for years due to several features such as IntelliSense, Build Insights, and the overall debugging experience and eagerly use newer integrations such as GitHub Copilot.  They also use Visual Studio capabilities for their cross-platform development needs.</p>
<p>We&#8217;re proud to partner with EA to shape cross-platform development capabilities in Visual Studio. Read more in the full story about how we worked with EA to enable them to customize their build experience and ensure consistent builds for thousands of developers at: <strong><a href="http://aka.ms/ea-vs-game-dev">aka.ms/ea-vs-game-dev</a></strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB.jpg"><img decoding="async" class="alignnone size-full wp-image-35569" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB.jpg" alt="A picture of a college football game in a video game " width="1454" height="818" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB.jpg 1454w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB-300x169.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB-1024x576.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB-768x432.jpg 768w" sizes="(max-width: 1454px) 100vw, 1454px" /></a></p>
<p style="text-align: center;"><span style="font-size: 8pt;"><em>A snapshot from EA Sports College Football 25, a video game produced by Electronic Arts</em></span></p>
<h2>Send us feedback!</h2>
<p><a href="https://visualstudio.microsoft.com/vs/">Download Visual Studio</a> and give <a href="https://learn.microsoft.com/en-us/cpp/linux/download-install-and-setup-the-linux-development-workload?view=msvc-170">our cross-platform tooling</a> a try! If you have any feedback for us on how to improve our cross-platform tooling for you, please<a href="https://developercommunity.visualstudio.com/cpp?space=8&amp;entry=suggestion"> file a suggestion ticket on Developer Community</a>. The comments below are open and we are also available via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/">How Electronic Arts standardized C++ builds across Windows and Linux with Visual Studio Build Tools</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Address Sanitizer Updates for Visual Studio 2022 Version 17.14</title>
		<link>https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/</link>
					<comments>https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/#comments</comments>
		
		<dc:creator><![CDATA[David Justo]]></dc:creator>
		<pubDate>Tue, 27 May 2025 20:04:30 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35494</guid>

					<description><![CDATA[<p>Introduction It has been an exciting few months for the Address Sanitizer (ASan) since our last update. In addition to our continuous focus on quality and correctness, our internal “dogfooding” (i.e. internal adoption) effort has reached several important milestones. In this update, I want to go over some of the quality improvements since Visual Studio [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/">Address Sanitizer Updates for Visual Studio 2022 Version 17.14</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>It has been an exciting few months for the <a href="https://learn.microsoft.com/cpp/sanitizers/asan?view=msvc-170">Address Sanitizer</a> (ASan) since our last update. In addition to our continuous focus on quality and correctness, our internal “dogfooding” (i.e. internal adoption) effort has reached several important milestones.</p>
<p>In this update, I want to go over some of the quality improvements since <a href="https://devblogs.microsoft.com/cppblog/msvc-address-sanitizer-updates-in-visual-studio-2022-version-17-13/">Visual Studio 2022 version 17.13</a><a href="https://devblogs.microsoft.com/cppblog/msvc-address-sanitizer-updates-in-visual-studio-2022-version-17-13/">,</a> and to give a peek into how ASan is now protecting our C++ toolset against memory safety errors during development.</p>
<h2>Some improvements in Visual Studio 2022 version 17.14</h2>
<ul>
<li>We increased the number of ASan flags that can be set through <code>__asan_default_options</code>, the alternative to the environment variable <code>ASAN_OPTIONS</code>. This was an adoption blocker for apps that, for security reasons, can’t access the environment during execution.</li>
<li>For <a href="https://developer.microsoft.com/games/articles/2021/07/address-sanitizer-now-available-for-xbox-developers/">Xbox developers</a>, we now have automated testing ensuring that ASan’s dependencies are compatible with the Xbox OS. This is important since we now integrate changes from upstream LLVM on a weekly basis, meaning that we need to actively guard against Xbox-incompatible changes.</li>
<li>We fixed a <a href="https://developercommunity.visualstudio.com/t/Access-violation-call-stack-not-fully-di/10827640">regression</a> that corrupted the callstack displayed during error reporting in x64.</li>
<li>Improved stability by removing the lazy loading of <code>DbgHelp</code> symbolization helpers, minimizing loader lock contention.</li>
<li><a href="https://github.com/microsoft/STL/pull/5241">In the STL</a>, we now allow ASan container annotations to be disabled on a per-allocator basis. This allows users to control container poisoning, which is useful when custom allocators (e.g. arenas) are in use.</li>
</ul>
<p>This release also contains several other improvements, many of which were contributed by the ASan open-source community in the <a href="https://github.com/llvm/llvm-project">LLVM repo</a>. By contributing to LLVM upstream, you are also contributing to MSVC’s ASan. We thank the entire LLVM ASan community for their efforts, and plan to continue contributing our improvements upstream as well.</p>
<h2>Protecting the C++ toolchain</h2>
<p>To protect the toolchain against memory safety errors, all PRs made against the MSVC toolset and libraries now need to pass ASan instrumentation tests. These are tests where the compiler itself is instrumented with ASan to catch memory safety violations while executing our compiler test suite.</p>
<p>To be clear, this is different from compiling test programs with ASan, i.e. having the compiler run <code>/fsanitize=address</code> on some <code>.cpp</code> file. Instead, the compiler itself is built with <code>/fsanitize=address</code> before executing its test matrix so that ASan may monitor allocations during compilation.</p>
<p>Through this process, we have learned a lot about how to adopt ASan in a large and historied codebase like MSVC and it’s helped us drive several improvements in both the toolset as well as in ASan itself, so we’re excited about the quality improvement cycle that dogfooding ASan within MSVC unlocks for us.</p>
<h2>Let’s harden our C++ code together!</h2>
<p>The ASan team is proud to help you secure your C++ applications, and we would love to hear from you. If you’re not using it already, download Visual Studio and give the Address Sanitizer a try. We can be reached out through the comments below and through our official support channels: <a href="https://developercommunity.visualstudio.com/cpp">Developer Community</a> or through Visual Studio by clicking <a href="https://learn.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022">Help &gt; Send Feedback &gt; Report A Problem / Provide a suggestion in the product.</a></p>
<p>Until next time!</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/">Address Sanitizer Updates for Visual Studio 2022 Version 17.14</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
	</channel>
</rss>
