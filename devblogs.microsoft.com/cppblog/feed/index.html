<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>The latest in C++, Visual Studio, VS Code, and vcpkg from the MSFT C++ team</description>
	<lastBuildDate>Thu, 08 Feb 2024 00:17:29 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>OpenMP improvements in Visual Studio C/C++ compiler: loop collapse</title>
		<link>https://devblogs.microsoft.com/cppblog/open-mp-improvements-in-visual-studio-cpp/</link>
					<comments>https://devblogs.microsoft.com/cppblog/open-mp-improvements-in-visual-studio-cpp/#respond</comments>
		
		<dc:creator><![CDATA[Natalia Glagoleva]]></dc:creator>
		<pubDate>Wed, 07 Feb 2024 17:00:40 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Experimental]]></category>
		<category><![CDATA[OpenMP]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33572</guid>

					<description><![CDATA[<p>The MSVC compiler adds support for OpenMP "collapse" feature on for loops.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/open-mp-improvements-in-visual-studio-cpp/">OpenMP improvements in Visual Studio C/C++ compiler: loop collapse</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Our <a href="https://devblogs.microsoft.com/cppblog/msvc-openmp-update/">previous blog post</a> about OpenMP support in Visual Studio was published a while ago. Meanwhile, in Visual Studio 2022 version 17.8, we&#8217;ve added support for the <code>collapse</code> feature, fixed several bugs, and made some code quality improvements. All this work is accessible if you are using the <code>-opemp:llvm</code> switch (see the <a href="https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/">Improved OpenMP Support for C++ in Visual Studio</a> blogpost for details about this switch). In this blog we&#8217;ll talk about loop collapsing, which we&#8217;ve implemented on <code>for</code> loops according to the OpenMP Standard 5.2.</p>
<h2 id="collapse-clause-in-openmp-standard-3-1"><code>collapse</code> clause in OpenMP Standard 3.1</h2>
<p>The <code>collapse</code> clause applies to a nest of loops. The whole nest is then considered to be one giant loop over the combined loop space and can be split to run on several threads, similar to a single <code>for</code> loop.
For example:</p>
<pre><code class="language-C++">void bar(float *a, int i, int j);
int jl, ju, il, iu;
void foo(float *a)
{
  int i, j;
  #pragma omp for collapse(2) private(i, j)
  for (i=il; i&lt;=iu; ++i){
    for (j=jl; j&lt;=ju; ++j)
      bar(a,i,j);
    }
}</code></pre>
<p>Here the overall loop space is all iterations from <code>i=il</code>, <code>j=jl</code> up to <code>iu</code>, <code>ju</code> (inclusive). All iterations will be split between threads more or less evenly.</p>
<p>In the OpenMP Standard 3.1 the loop space has to be rectangular. This means that the bounds and the increment of the inner loops can&#8217;t depend on the variables which are non-invariant in the outer loops. The example above complies with this definition: <code>jl</code> and <code>ju</code> do not depend on <code>i</code> and do not change between iterations of the outer loop.</p>
<p>With this restriction, the collapsed loop nest can have any of the schedules applicable to an ordinary <code>for</code> loop.</p>
<h2 id="implementation-of-collapse-clause-for-rectangular-loop-nests-code-generation">Implementation of <code>collapse</code> clause for rectangular loop nests: code generation</h2>
<p>For a rectangular loop nest like in example above the compiler generates code similar to this:</p>
<pre><code class="language-C++">void bar(float *a, int i, int j);
int jl, ju, il, iu;
void foo(float *a)
{
  int i, j;
  kmp_uint64 ij, iju;

  bounds_info_t boundsNest[2] = { { loop_type_t::loop_type_int32, 
                                    loop_type_t::loop_type_int32, 
                                    comparison_t::comp_less_or_eq, 0, 
                                    static_cast&lt;kmp_uint64&gt;(il), 0,
                                    static_cast&lt;kmp_uint64&gt;(iu), 0, 
                                    static_cast&lt;kmp_int64&gt;(1), 0 },
                                  { loop_type_t::loop_type_int32, 
                                    loop_type_t::loop_type_int32, 
                                    comparison_t::comp_less_or_eq, 0, 
                                    static_cast&lt;kmp_uint64&gt;(jl), 0,
                                    static_cast&lt;kmp_uint64&gt;(ju), 0, 
                                    static_cast&lt;kmp_int64&gt;(1), 0 } };
  kmp_uint64 originalIVs[2];

  iju = __kmpc_process_loop_nest_rectang(
        nullptr, omp_get_thread_num(), /*in/out*/ boundsNest, 2);

  #pragma omp for private(i, j, ij)
  for (ij=0; ij&lt;=iju; ++ij){
      __kmpc_calc_original_ivs_rectang(nullptr, ij,
                    boundsNest, /*out*/ originalIVs, 2);
      i = originalIVs[0];
      j = originalIVs[1];
      bar(a,i,j);
    }
}</code></pre>
<p>We generate an additional call to the runtime to calculate the overall number of iterations (<code>__kmpc_process_loop_nest_rectang</code>), and in the loop we call another runtime function (<code>__kmpc_calc_original_ivs_rectang</code>) to get the values of the original induction variables (IVs).</p>
<h2 id="implementation-of-collapse-clause-for-rectangular-loop-nests-runtime">Implementation of <code>collapse</code> clause for rectangular loop nests: runtime</h2>
<p>The code generation above is supported by two additional functions in the runtime:</p>
<p><code>__kmpc_process_loop_nest_rectang</code> &#8211; to calculate bounds for new collapsed loop;</p>
<p><code>__kmpc_calc_original_ivs_rectang</code> &#8211; to get the original loop induction variables&#8217; values from the value of the new induction variable.</p>
<p>Information is passed from the generated code to the runtime and back using arrays of structs, which define the type of bounds and increment, type of the loop IV, what operation the loop is using and the loop bounds. This information is filled in for all loops in the nest.</p>
<p>Both functions and all the needed definitions are included in the Visual Studio version of LLVM OpenMP runtime (libomp140[d] dll, active with the <strong>-openmp:llvm</strong> flag), and also upstreamed into LLVM libomp. It&#8217;s included in LLVM 17.x; live has an additional performance improvement (same as in Visual Studio version).</p>
<h2 id="collapse-clause-in-openmp-standard-5-2"><code>collapse</code> clause in OpenMP Standard 5.2</h2>
<p>In the most recent OpenMP Standard 5.2 inner loops&#8217; lower and upper bounds can depend on outer loops&#8217; induction variables, e.g.:</p>
<pre><code class="language-C++">void bar(float *a, int i, int j);

void foo(float *a)
{
  #pragma omp parallel for collapse(2)
  for (int i = 0; i &lt; M; i++)
    for (int j = i; j &lt; M; j++){
      bar(a, i, j);
    }
}</code></pre>
<p>For a complete definition of what is allowed please refer to <a href="https://www.openmp.org/wp-content/uploads/OpenMP-API-Specification-5-2.pdf">the standard</a>.</p>
<h2 id="implementation-of-collapse-clause-for-non-rectangular-loop-nests-code-generation">Implementation of <code>collapse</code> clause for non-rectangular loop nests: code generation</h2>
<p>Non-rectangular loop nests are generated differently from rectangular ones. The runtime gets a description of the loop nest and returns a chunk to execute, with chunk bounds expressed in the terms of the original loop IVs.</p>
<p>For the non-rectangular nest example above the compiler keeps all loops and generates additional checks for bounds:</p>
<pre><code class="language-C++">void bar(float *a, int i, int j);
int jl, ju, il, iu;
void foo(float *a)
{
  int i, j;
  kmp_uint64 ij, iju;

  bounds_info_t boundsNest[2] = { { loop_type_t::loop_type_int32, 
                                    loop_type_t::loop_type_int32, 
                                    comparison_t::comp_less_or_eq, 0, 0, 0,
                                    static_cast&lt;kmp_uint64&gt;(M), 0, 
                                    static_cast&lt;kmp_int64&gt;(1), 0 },
                                  { loop_type_t::loop_type_int32, 
                                    loop_type_t::loop_type_int32, 
                                    comparison_t::comp_less_or_eq, 0, 0, 
                                    static_cast&lt;kmp_uint64&gt;(1),
                                    static_cast&lt;kmp_uint64&gt;(M), 0, 
                                    static_cast&lt;kmp_int64&gt;(1), 0 } };
  bounds_info_t chunkBoundsNest[2];
  kmp_int32 lastiter = false;

  #pragma omp for private(i, j, ij)
  auto haveWork = __kmpc_for_collapsed_init(nullptr, omp_get_thread_num(),
                  /*in/out*/ boundsNest, /*out*/ chunkBoundsNest, 2, /*out*/ &amp;lastiter);

  if (haveWork) {
            int ilnew = chunkBoundsNest[0].lb0_u64;

            int jA0new = chunkBoundsNest[1].lb0_u64;
            int jA1new = 0;

            int iunew = chunkBoundsNest[0].ub0_u64;
            int junew = chunkBoundsNest[1].ub0_u64;

    for (i = ilnew; i &lt;= iunew; ++i) {
        for (j = i * jA1new + jA0new; j &lt;= i * jB1 + jB0; ++j) {
            if ((i &gt;= iunew) &amp;&amp; (j &gt; junew)) goto done2;
            bar(a, i, j);
        }
        jA0new = jA0;
        jA1new = jA1;
    }
done2:
    ;

  }
}</code></pre>
<p>This way the runtime can have different strategies for how to split the overall space, and we don&#8217;t need to change the code generation.</p>
<h2 id="implementation-of-collapse-clause-for-non-rectangular-loop-nests-runtime">Implementation of <code>collapse</code> clause for non-rectangular loop nests: runtime</h2>
<p>For the non-rectangular case we need only one additional exposed function in the runtime, <code>__kmpc_for_collapsed_init</code>, to calculate the lower and upper bounds of the chunks to execute.</p>
<p>The overall loop nest space is enlarged to a parallelogram (parallelepiped), taking care to not produce an overflow, then this enlarged space is split into more or less equal chunks, then we figure out how it translates back to the original space (chunks will become less evenly split during this translation).</p>
<p>Current implementation is generic, and should be functional with all combinations of loop bounds and increments allowed by the standard, for any number of nested loops. Performance is on par with LLVM (which is also doing a similar enlarging of the loop space).</p>
<p>We think that in practice <code>collapse</code> should be most useful for 2- or 3- level nested loops of specific shapes, e.g. triangular with the upper or lower bound being loop nest invariant. It would be great to recognize such loops and use specialized algorithms in these cases, to split overall space more evenly (not necessarily perfectly). These specializations won&#8217;t need different code generation. A recognition of the special case and branching to a different algorithm can be done in the runtime. Adding specialized cases could greatly improve performance. We believe that implementing such algorithms should be much easier in the runtime (using C and some features of C++) than doing experiments with new code generation.</p>
<p>Same as for the rectangular case, all runtime support is included in the Visual Studio version of the LLVM OpenMP runtime and also upstreamed into the LLVM libomp runtime.</p>
<h2 id="feedback">Feedback</h2>
<p>We encourage you to try out the <code>collapse</code> feature in Visual Studio 2022 version 17.8 or newer. As always, we welcome your feedback. Please share your thoughts and comments with us through <a href="https://developercommunity.visualstudio.com/home">Developer Community</a>. You can also reach us on X (@VisualC), or via email at visualcpp@microsoft.com.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/open-mp-improvements-in-visual-studio-cpp/">OpenMP improvements in Visual Studio C/C++ compiler: loop collapse</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/open-mp-improvements-in-visual-studio-cpp/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Quick Tips for using Copilot Chat with C++ in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/quick-tips-for-using-copilot-chat-with-c-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/quick-tips-for-using-copilot-chat-with-c-in-visual-studio/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 06 Feb 2024 19:42:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Copilot]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33531</guid>

					<description><![CDATA[<p>GitHub Copilot Chat is now available in both Visual Studio and Visual Studio Code when you have an active subscription to the service. Copilot Chat is your AI pair-programmer that allows you to speak in plain text through the chat interface to accomplish programming tasks such as understanding sections of code,</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/quick-tips-for-using-copilot-chat-with-c-in-visual-studio/">Quick Tips for using Copilot Chat with C++ in Visual Studio</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>GitHub Copilot Chat is now available in both <a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.VSGitHubCopilot">Visual Studio</a> and <a href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-chat">Visual Studio Cod</a><a href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-chat">e</a> when you have an active subscription to the service. Copilot Chat is your AI pair-programmer that allows you to speak in plain text through the chat interface to accomplish programming tasks such as understanding sections of code, generating test cases, and generating code.</p>
<p>This blog post will focus on tips for using Copilot Chat functionality with C++ in Visual Studio, but the same functionality is available in Visual Studio Code and will be covered in future blog posts. Additionally, in future posts, we will dive into various C++ scenarios as reported by our customers.</p>
<p>You can learn more about the Copilot Chat extension through the <a href="https://learn.microsoft.com/en-us/visualstudio/ide/visual-studio-github-copilot-chat?view=vs-2022">Visual Studio documentation</a>.</p>
<hr />
<h4 style="text-align: center;" style="text-align: center;" id="download-github-copilot-chat"><strong>Download GitHub Copilot Chat</strong></h4>
<p>To learn more about accessing GitHub Copilot Chat in Visual Studio, please view <a href="https://learn.microsoft.com/en-us/visualstudio/ide/visual-studio-github-copilot-chat?view=vs-2022">these instructions</a>. You will need a <a href="https://docs.github.com/en/billing/managing-billing-for-github-copilot/about-billing-for-github-copilot">subscription</a> to GitHub Copilot for Individuals or GitHub Copilot for Business.</p>
<hr />
<h3 id="introduction-to-copilot-chat-in-visual-studio">Introduction to Copilot Chat in Visual Studio</h3>
<p>You can use the new Copilot Chat functionality to work with your existing C++ code.  To open the chat window, navigate to <em>View &gt; GitHub Copilot Chat </em>or right-click anywhere in your code and select <strong>Ask Copilot</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-VS.png"><img decoding="async" class="size-large wp-image-33540 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-VS-1024x846.png" alt="An image of the Copilot Chat pane in Visual Studio" width="640" height="529" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-VS-1024x846.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-VS-300x248.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-VS-768x635.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-VS.png 1188w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h5 id="performing-actions-via-commands">Performing actions via / commands</h5>
<p>In the chat window, you can use the <strong>/</strong> symbol to list out commands to perform on the codebase. The full list of available commands can be found <a href="https://learn.microsoft.com/en-us/visualstudio/ide/copilot-chat-context?view=vs-2022">here</a>, or the list of commands will automatically populate the available commands when you type <strong>/</strong> in the chat window.<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/slash-commands.png"><img decoding="async" class=" wp-image-33541 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/slash-commands-1024x429.png" alt="A list of all the slash commands available in Visual Studio once pressed, such as the /askvs command highlighted and a brief explanation to the right." width="704" height="295" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/slash-commands-1024x429.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/slash-commands-300x126.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/slash-commands-768x322.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/slash-commands.png 1192w" sizes="(max-width: 704px) 100vw, 704px" /></a></p>
<p>For example, you can use <strong>/explain</strong> to get code explanations on a desired function or file. You can also use <strong>/generate </strong>to ask Copilot Chat to generate a specific snippet of code.</p>
<h5 id="adding-file-context-via-sign">Adding file context via # sign</h5>
<p>Large language models (LLMs) are trained on public repository data at a point in time and do not know anything about your current codebase. You can use the <strong>#</strong> commands to specify the context you want Copilot Chat to include and help Copilot Chat provide contextually relevant answers. For example, you can specify <strong>#file:FIleName.cpp</strong> in-line in your prompt to Copilot Chat so that it looks at the specified file. Once you type the <strong># </strong>sign, all file names or selections will populate to select.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/file-context-copilot.png"><img decoding="async" class="size-large wp-image-33542 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/file-context-copilot-1024x429.png" alt="Pressing the # sign in Copilot Chat populates all the documents available to specify to Copilot Chat." width="640" height="268" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/file-context-copilot-1024x429.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/file-context-copilot-300x126.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/file-context-copilot-768x322.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/file-context-copilot.png 1197w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>By selecting a specific context, you can provide more information to Copilot Chat without having to copy/paste code and ensure you receive the most relevant answers when applicable. Copilot Chat will always indicate which files were included as context under <strong>References</strong> under your prompt. For example, by default, there are no references sent from my code upon no file specification.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/no-references-copilot.png"><img decoding="async" class="size-full wp-image-33543 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/no-references-copilot.png" alt="Copilot Chat References displaying no references were sent to the model when no file context is provided." width="694" height="265" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/no-references-copilot.png 694w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/no-references-copilot-300x115.png 300w" sizes="(max-width: 694px) 100vw, 694px" /></a></p>
<p>Then, once some file is specified, you can see the code references in the <strong>References</strong> flyout.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/references-nousername.png"><img decoding="async" class="size-large wp-image-33582 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/references-nousername-1024x286.png" alt="Image references nousername" width="640" height="179" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/references-nousername-1024x286.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/references-nousername-300x84.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/references-nousername-768x214.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/references-nousername.png 1461w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>As you&#8217;ll see, Copilot Chat can empower you as a C++ developer to focus more on the task at hand by being a true AI pair programmer through help with asks such as:</p>
<ul>
<li>Making code more readable</li>
<li>Generating functions</li>
<li>Generating test cases</li>
<li>Understanding what a snippet of code does.</li>
</ul>
<p><div class="alert alert-primary">Please keep in mind that while GitHub Copilot Chat is a great tool for software developers to get started across a multitude of different tasks, it is powered by AI and surprises and mistakes are possible. Make sure to verify any generated code or suggestions provided in your scenarios.</div></p>
<h3 id="making-code-more-readable">Making code more readable</h3>
<p>Copilot Chat can improve your existing C++ code, as you can ask it prompts like to make your code more readable or simplify your existing code.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/calculator-cpp.png"><img decoding="async" class="size-large wp-image-33549 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/calculator-cpp-1024x732.png" alt="Some C++ code showcasing a Calculator class with functions such as add, subtract, multiply, and divide" width="640" height="458" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/calculator-cpp-1024x732.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/calculator-cpp-300x215.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/calculator-cpp-768x549.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/calculator-cpp.png 1116w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>Here, there is some C++ code (starting repo linked <a href="https://github.com/sinemakinci1/basic-cpp-copilot-example/">here</a>) that creates a Calculator class and has operations to add, subtract, multiply, and divide. This code is not as simple as it could be and creates some excessive variables. You can highlight the section and right-click to Ask Copilot to simplify this code for you. Copilot Chat will take the context in the highlighted section to propose better C++ code for your project. Since Copilot Chat operates as a pair programmer, Visual Studio will provide a diff view to allow you to accept, modify, or cancel the proposed changes from Copilot Chat.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/New-simplify.gif"><img decoding="async" class="aligncenter wp-image-33550 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/New-simplify.gif" alt="Copilot Chat simplifying some code as shown in a GIF." width="1920" height="938" /></a></p>
<p>Copilot Chat can also help you fix functions. For example, there are a few issues with this C++ code. Firstly, dividing by zero returns zero, which is not quite accurate. Instead, you may want it to return an error such as Not-A-Number (NaN). Therefore, you can ask Copilot Chat to rewrite the code such that it returns NaN and insert it into the file.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/Nan-copilot-1.png"><img decoding="async" class=" wp-image-33569 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/Nan-copilot-1.png" alt="Asking Copilot to rewrite the divide function such that it returns NaN instead of 0." width="727" height="697" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/Nan-copilot-1.png 705w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/Nan-copilot-1-300x288.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/Nan-copilot-1-24x24.png 24w" sizes="(max-width: 727px) 100vw, 727px" /></a></p>
<p>Additionally, these functions in the calculator do not change the Calculator state, so you can have Copilot Chat fix this issue at large by appending static modifiers to member functions that do not change the Calculator state. Copilot Chat will even provide helpful commentary on static functions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-static.png"><img decoding="async" class=" wp-image-33554 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-static.png" alt="Asking Copilot Chat to make member functions static" width="656" height="1012" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-static.png 586w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/copilot-chat-static-194x300.png 194w" sizes="(max-width: 656px) 100vw, 656px" /></a></p>
<h3 id="generate-new-c-code">Generate new C++ code</h3>
<p>Copilot Chat can also help generate new code for you.</p>
<p>You can generate code by asking Copilot Chat in the chat window using the <strong>/generate</strong> command and specifying the specific file to generate code for. In this case, you can ask it to create a new function that calculates if two numbers are equal, and it will even use your existing coding conventions to generate a new function in your class.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/generate-code.png"><img decoding="async" class="size-full wp-image-33555 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/generate-code.png" alt="Asking copilot to generate a new function that checks if two numbers are equal and copilot chat generated code" width="907" height="787" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/generate-code.png 907w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/generate-code-300x260.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/generate-code-768x666.png 768w" sizes="(max-width: 907px) 100vw, 907px" /></a></p>
<h3 id="create-tests-for-your-code">Create tests for your code</h3>
<p>Now that there are a few functions written for the calculator, you can ask Copilot Chat to create tests for this. Specifically, you can ask by using the <strong>/tests</strong> command in the Copilot Chat window to write out tests for my code. In this case, the output was GTests that follow the mathematical conventions expected and included the appropriate header functions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot.png"><img decoding="async" class=" wp-image-33557 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot-1024x996.png" alt="Asking copilot chat to create tests for your code creates GTest unit tests" width="848" height="825" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot-1024x996.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot-300x292.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot-768x747.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot-24x24.png 24w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot-48x48.png 48w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/gtest-copilot.png 1117w" sizes="(max-width: 848px) 100vw, 848px" /></a></p>
<p>Giving Copilot Chat additional context on your desired needs can yield better responses tailored to you. For example, if you did not want it to generate tests using the GTest framework, but instead wanted to use Catch2, you should explain that in your prompt. You can always add other relevant additional project contexts to Copilot Chat based on your desired results, such as desired package manager, language standard, and testing framework.</p>
<h3 id="explain-a-section-of-code"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot.png"><img decoding="async" class=" wp-image-33558 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot-1024x997.png" alt="A prompt asking for Catch2 framework to create unit tests in main.cpp with Copilot giving the right response." width="966" height="941" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot-1024x997.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot-300x292.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot-768x748.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot-24x24.png 24w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot-48x48.png 48w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/catch2-copilot.png 1113w" sizes="(max-width: 966px) 100vw, 966px" /></a>Explain a section of code</h3>
<p>Copilot Chat can also help explain C++ code in plain text while referencing the applicable symbols. For example, you can ask Copilot what a highlighted section of the new test code does, and it will explain it all to you in plain language to make it easier for you to digest.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain.png"><img decoding="async" class="alignnone wp-image-33559 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain.png" alt="Copilot Chat explaining what a section of my test code does." width="732" height="511" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain.png 675w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain-300x209.png 300w" sizes="(max-width: 732px) 100vw, 732px" /></a></p>
<p>Copilot Chat will even suggest follow-up questions to the snippet of code at the bottom with easy, thought-provoking access.</p>
<h3 id="what-do-you-think"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain-2-highlight.png"><img decoding="async" class=" wp-image-33561 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain-2-highlight.png" alt="Copilot Chat will automatically suggest follow-up questions to ask. In this case, it asked follow up questions about running my Google Tests" width="724" height="490" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain-2-highlight.png 643w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/02/add-test-explain-2-highlight-300x203.png 300w" sizes="(max-width: 724px) 100vw, 724px" /></a>What do you think?</h3>
<p>Copilot Chat can help you achieve new levels of productivity in your C++ workflows. We are working hard on integrating it even further with Visual Studio, so please let us know any suggestions you’d like to see to improve your workflows. Additionally, let us know what other types of content you’d like to see regarding use cases or additional information about Copilot Chat. We welcome all types of feedback on your experience with the product. The comments below are open, or you can find us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via Twitter at <a href="https://twitter.com/visualc">@VisualC</a>. To open a bug, please see <a href="https://developercommunity.visualstudio.com/report?space=8&amp;entry=problem">Visual Studio feedback</a>. You can also always upvote or downvote the provided suggestion in Copilot Chat to provide feedback to the model itself.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/quick-tips-for-using-copilot-chat-with-c-in-visual-studio/">Quick Tips for using Copilot Chat with C++ in Visual Studio</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/quick-tips-for-using-copilot-chat-with-c-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC Toolset Minor Version Number 14.40 in VS 2022 v17.10</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-toolset-minor-version-number-14-40-in-vs-2022-v17-10/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-toolset-minor-version-number-14-40-in-vs-2022-v17-10/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Griffing]]></dc:creator>
		<pubDate>Thu, 01 Feb 2024 18:51:22 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33499</guid>

					<description><![CDATA[<p>As we approach delivery of Visual Studio 2022 v17.9, the MSVC toolset version is 14.39. In Visual Studio 2022 version 17.10, the MSVC Toolset minor version will continue with 14.40 and continue incrementing in the ‘14.4x’ series.<br />
The file version and directories in Visual Studio v17.10 and subsequent installations will appear as follows:<br />
[VSInstallDir]\VC\Tools\MSVC\14.4x.BBBBB<br />
Where: </p>
<p>‘4x’ is a digit 40-49,</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/msvc-toolset-minor-version-number-14-40-in-vs-2022-v17-10/">MSVC Toolset Minor Version Number 14.40 in VS 2022 v17.10</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>As we approach delivery of Visual Studio 2022 v17.9, the MSVC toolset version is 14.39. In Visual Studio 2022 version 17.10, the MSVC Toolset minor version will continue with 14.40 and continue incrementing in the ‘14.4x’ series.</p>
<p>The file version and directories in Visual Studio v17.10 and subsequent installations will appear as follows:</p>
<p>[VSInstallDir]\VC\Tools\MSVC\14.<strong><em>4x</em></strong>.<strong><em>BBBBB</em></strong></p>
<p><em>Where: </em></p>
<ul>
<li><em>‘</em><strong><em>4x</em></strong><em>’ is a digit 40-49, where the ‘x’ value will continue to increase in future Visual Studio releases, starting with ‘40’</em> in VS 2022 v17.10<em>.</em></li>
<li><em>‘</em><strong><em>BBBBB</em></strong><em>’ is a build-specific version 5-digit number, which increases with each release/update/servicing update.</em></li>
</ul>
<p>We will make separate announcements about MSVC compiler toolset versions beyond 14.4x (i.e., versions &gt;= 14.50) at an appropriate time in the future.</p>
<h3 id="build-system-and-library-impact">Build System and Library Impact</h3>
<p>In Visual Studio 2022 version 17.10 and later, in-box project system support is being updated to support MSVC toolsets in the 14.4x version range. Specifically:</p>
<ul>
<li>The C++ Project System (MS Build) is being updated to support ‘14.4x’ MSVC toolsets under the v143 Platform Toolset.</li>
</ul>
<p><img decoding="async" width="1384" height="381" class="wp-image-33506" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-description-automatica-1.png" alt="A screenshot of a computer Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-description-automatica-1.png 1384w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-description-automatica-1-300x83.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-description-automatica-1-1024x282.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-description-automatica-1-768x211.png 768w" sizes="(max-width: 1384px) 100vw, 1384px" /></p>
<p><img decoding="async" width="1290" height="248" class="wp-image-33507" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-program-description-au-1.png" alt="A screenshot of a computer program Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-program-description-au-1.png 1290w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-program-description-au-1-300x58.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-program-description-au-1-1024x197.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-computer-program-description-au-1-768x148.png 768w" sizes="(max-width: 1290px) 100vw, 1290px" /></p>
<ul>
<li>We have validated that CMake support in Visual Studio 2022 supports the minor version change.</li>
</ul>
<p>Custom build systems, projects, libraries, and VS Extensions checking for valid MSVC build version will need to be adjusted to allow for ‘14.4x’. For example, code which checks the _MSC_VER predefined macro and assumes that all Visual Studio 2022 versions of MSVC having a value below 1940 will need to be updated.</p>
<p>Table 1. Mapping of VS 2022 update releases to current MSVC versions</p>
<table>
<tbody>
<tr>
<td width="161"><strong><span style="font-size: 10pt;">Visual Studio Releases</span></strong></td>
<td width="211"><strong><span style="font-size: 10pt;">Updates with new MSVC Tools</span></strong></td>
<td width="137"><strong><span style="font-size: 10pt;">MSVC version  </span></strong></td>
<td width="102"><strong><span style="font-size: 10pt;">_MSC_VER</span></strong></td>
<td width="120"><strong><span style="font-size: 10pt;">End of Support</span></strong></td>
</tr>
<tr>
<td width="161"><span style="font-size: 10pt;"><strong>Visual Studio 2022</strong></span></td>
<td width="211"><span style="font-size: 10pt;"> GA (Version 17.0) LTSC</span></td>
<td width="137"><span style="font-size: 10pt;">19.30.30705</span></td>
<td width="102"><span style="font-size: 10pt;">1930</span></td>
<td width="120"><span style="font-size: 10pt;">Jul 11, 2023</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.1</span></td>
<td width="137"><span style="font-size: 10pt;">19.31.31103</span></td>
<td width="102"><span style="font-size: 10pt;">1931</span></td>
<td width="120"><span style="font-size: 10pt;">May 10, 2022</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.2 LTSC</span></td>
<td width="137"><span style="font-size: 10pt;">19.32.31326</span></td>
<td width="102"><span style="font-size: 10pt;">1932</span></td>
<td width="120"><span style="font-size: 10pt;">Jan 9, 2024</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.3</span></td>
<td width="137"><span style="font-size: 10pt;">19.33.31629</span></td>
<td width="102"><span style="font-size: 10pt;">1933</span></td>
<td width="120"><span style="font-size: 10pt;">Nov 8, 2022</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.4.14 LTSC</span></td>
<td width="137"><span style="font-size: 10pt;">19.34.31948</span></td>
<td width="102"><span style="font-size: 10pt;">1934</span></td>
<td width="120"><span style="font-size: 10pt;">Jul 11, 2024</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.5.3</span></td>
<td width="137"><span style="font-size: 10pt;">19.35.32216</span></td>
<td width="102"><span style="font-size: 10pt;">1935</span></td>
<td width="120"><span style="font-size: 10pt;">May 16, 2023</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.6.11 LTSC</span></td>
<td width="137"><span style="font-size: 10pt;">19.36.32544</span></td>
<td width="102"><span style="font-size: 10pt;">1936</span></td>
<td width="120"><span style="font-size: 10pt;">Jan 9, 2025</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.7.7</span></td>
<td width="137"><span style="font-size: 10pt;">19.37.32826</span></td>
<td width="102"><span style="font-size: 10pt;">1937</span></td>
<td width="120"><span style="font-size: 10pt;">Nov 14, 2023</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.8.6 LTSC</span></td>
<td width="137"><span style="font-size: 10pt;">19.38.33135</span></td>
<td width="102"><span style="font-size: 10pt;">1938</span></td>
<td width="120"><span style="font-size: 10pt;">Jul 8, 2025</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.9</span></td>
<td width="137"><span style="font-size: 10pt;">19.39.xxxxx</span></td>
<td width="102"><span style="font-size: 10pt;">1939</span></td>
<td width="120"><span style="font-size: 10pt;">TBD</span></td>
</tr>
<tr>
<td width="161"></td>
<td width="211"><span style="font-size: 10pt;">Version 17.10</span></td>
<td width="137"><span style="font-size: 10pt;">19.40.xxxxx</span></td>
<td width="102"><span style="font-size: 10pt;">1940</span></td>
<td width="120"><span style="font-size: 10pt;">TBD</span></td>
</tr>
<tr>
<td width="161"><span style="font-size: 10pt;"><strong> </strong></span></td>
<td width="211"><span style="font-size: 10pt;">…</span></td>
<td width="137"><span style="font-size: 10pt;">…</span></td>
<td width="102"><span style="font-size: 10pt;">…</span></td>
<td width="120"><span style="font-size: 10pt;">…</span></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h3 id="side-by-side-msvc-toolsets">Side-By-Side MSVC Toolsets</h3>
<p>We recognize that it may not be possible to immediately address existing built-in checks in build environments. To mitigate issues encountered, until built-in checks are updated, we recommend using an older MSVC Toolset in VS 2022 via the <a href="https://devblogs.microsoft.com/cppblog/side-by-side-minor-version-msvc-toolsets-in-visual-studio-2019/">Side-By-Side Minor Version MSVC Toolsets</a> feature.</p>
<p>In addition to the mechanism provided in the linked blog post, it is also possible to select a SxS toolset in the C++ Project system on a per-project basis via Project Properties &gt; Advanced &gt; MSVC Toolset Version. The drop-down will contain the installed MSVC Toolsets under the v143 Platform Toolset.</p>
<p><img decoding="async" width="1210" height="613" class="wp-image-33508" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/word-image-33499-3-1.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/word-image-33499-3-1.png 1210w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/word-image-33499-3-1-300x152.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/word-image-33499-3-1-1024x519.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/word-image-33499-3-1-768x389.png 768w" sizes="(max-width: 1210px) 100vw, 1210px" /></p>
<h3 id="send-us-your-feedback">Send us your feedback</h3>
<p>Your feedback is invaluable to us as we strive to enhance your experience. Please feel free to leave your comments below. Alternatively, you can share your thoughts through the <a href="https://developercommunity.visualstudio.com/cpp" target="_blank" rel="noopener">Visual Studio Developer Community</a>, where we have created <a href="https://aka.ms/msvc-ver14.40-devcom">this feedback item</a> related to this announcement. We are also available on Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>) and can be reached via email at visualcpp@microsoft.com. We look forward to hearing from you!</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/msvc-toolset-minor-version-number-14-40-in-vs-2022-v17-10/">MSVC Toolset Minor Version Number 14.40 in VS 2022 v17.10</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-toolset-minor-version-number-14-40-in-vs-2022-v17-10/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Testing the MSVC Compiler Backend</title>
		<link>https://devblogs.microsoft.com/cppblog/testing-the-msvc-compiler-backend/</link>
					<comments>https://devblogs.microsoft.com/cppblog/testing-the-msvc-compiler-backend/#comments</comments>
		
		<dc:creator><![CDATA[Troy Johnson]]></dc:creator>
		<pubDate>Wed, 31 Jan 2024 17:00:52 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33497</guid>

					<description><![CDATA[<p>This post provides a behind-the-scenes look at how we test MSVC&#8216;s backend, which is responsible for optimization and code generation.<br />
Many people worldwide use our compiler and expect it to provide a high-quality experience in terms of correctness (compiled code behaves as written),</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/testing-the-msvc-compiler-backend/">Testing the MSVC Compiler Backend</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This post provides a behind-the-scenes look at how we test <a href="https://learn.microsoft.com/en-us/cpp/build/reference/compiling-a-c-cpp-program?view=msvc-170">MSVC</a>&#8216;s backend, which is responsible for optimization and code generation.</p>
<p>Many people worldwide use our compiler and expect it to provide a high-quality experience in terms of <strong>correctness</strong> (compiled code behaves as written), <strong>performance</strong> (speed of the compiled code), and <strong>throughput</strong> (speed of the compiler itself). By sharing with you how we test, you will better understand the level of quality control that goes into producing the compiler that you use.</p>
<p>This topic may bring to mind a compiler bug that you have encountered in the past or are presently experiencing. You may wonder how it slipped through our testing. We are not writing this post to claim that our testing catches every problem or that we have fixed every detected problem. The compiler is a complex system supporting an evolving C++ language on old and new processors for applications ranging from office productivity to the latest Xbox games. We continually prioritize which features to implement and bugs to fix based on customer impact. Those actions generate more tests, but our set of tests remains finite whereas our customers’ creativity is infinite.</p>
<h1 id="correctness-testing">Correctness Testing</h1>
<p>Our top priority is ensuring that your compiled code behaves as written, even when optimized. Therefore, our compiler engineers’ everyday role of authoring and reviewing pull requests (PRs) that modify the compiler’s code also includes writing and running tests. Tests are run using Microsoft <a href="https://azure.microsoft.com/en-us/products/devops/">Azure DevOps</a> pipelines. A lot of testing occurs before PRs are merged to our source code repository so that we catch problems before they are introduced, and then additional testing occurs after merging. We aim for a balanced approach that catches most problems early but still allows our compiler engineers to move quickly.</p>
<h2 id="internal-tests">Internal Tests</h2>
<p>Our first line of defense is a compiler built with assertions enabled. Assertions are conditional aborts mixed into the compiler’s code to check for unexpected internal states. Our compiler engineers use this kind of compiler for their daily development work and our test pipelines use it too. The additional checks make throughput slower, so we release a faster version that has most checks disabled. We introduce new assertions as we work on the compiler, while keeping one eye on throughput since we don’t want to make the checked compiler too slow for development and testing.</p>
<h2 id="regression-tests">Regression Tests</h2>
<p>We run regression tests on every PR and gate merges on all tests passing. MSVC has endured for decades, so we have accumulated many tests based on previous bug reports and compiler engineers proactively writing tests. These tests must compile, execute, and produce their expected output. The tests are run for all supported targets with a variety of compiler options, which takes a few hours. We can’t have a test pipeline for every combination of compiler options, so we test the more common ones and allow individual tests to require specific additional options. Furthermore, not every option is appropriate for every test, so we limit some tests to certain configurations. Passing all of these tests is already a high bar, but we go further.</p>
<h2 id="optimization-tests">Optimization Tests</h2>
<p>The main problem with using only traditional regression tests for an optimizing compiler is that optimizations tend to be invisible from a testing perspective. After all, the goal when adding an optimization is that the program runs faster, but its output should not change. Conversely, if an engineer introduces a bug that stops an optimization from occurring, then all regression tests would continue passing and the bug would remain undetected. What to do? To combat this problem, we added two new testing systems to supplement existing regression tests.</p>
<h3 id="unit-testing">Unit Testing</h3>
<p>The goal of a unit test is to check a particular subsystem within the compiler itself, ranging from only one function to one optimization phase, in isolation with respect to the rest of the compiler. We added a unit test framework, run under a merge-gating pipeline, that allows us to write small chunks of compiler code to verify key behaviors. For example, there is an internal compiler facility for matching fragments of the compiler’s intermediate representation (IR), so we can write tests to validate that it matches what it should match and does not match what it should not match. When a unit test catches a bug, it is easy to fix because we know exactly what is wrong.</p>
<p>Unit testing scales upward to test optimizations, but eventually becomes unwieldy. Internal compiler state must be created programmatically within the test and any related subsystems need to be mocked up. As we have written more of these tests, we have gotten better at making parts of the compiler more amenable to unit testing. Beyond a certain point though, we still need a different testing method.</p>
<h3 id="filecheck-like-testing">FileCheck-Like Testing</h3>
<p>Outside of Microsoft, tests written for the LLVM project, which is the basis for Clang and other compilers, use a program called <a href="https://llvm.org/docs/CommandGuide/FileCheck.html">FileCheck</a> to scan textual compiler output, like messages or assembly code, for certain patterns that span multiple lines. For example, it can check that the compiler emits a <em>mov</em> instruction followed by an <em>add</em> instruction and require that both the <em>mov</em> and the <em>add</em> use the same register, no matter what that register happens to be. Thus, the tests can check that a specific message or code pattern was emitted while being immune to irrelevant code generation changes like arbitrary register selection. Think regular expressions but driven by a special purpose language tailored for checking multi-line compiler output.</p>
<p>For MSVC, we wanted to adopt a similar testing approach but faced a few challenges related to tests expecting output in a fixed order. First, MSVC is multithreaded, so debug messages emitted by the compiler can appear unordered. This problem is handled by including something in the message to make it unique, such as the function name, or by running the compiler in single-threaded mode for the test. Second, and independent of the multithreading issue, MSVC may emit functions to .asm files in a different order than they appeared in the C++ code. Furthermore, optimization settings may change that order, which makes it difficult to write tests for multiple functions at once. This behavior has years of inertia behind it and would be disruptive to change, so we needed a tool which would allow our engineers to write tests that tolerated functions being emitted in an arbitrary order. This behavior is a radical algorithmic departure from how LLVM’s FileCheck behaves and it is necessary only to cope with an output-sequencing quirk that is specific to MSVC, so we wrote our own tool.</p>
<p>The final challenge is arguably a strength. MSVC cannot ingest a serialized form of the compiler’s IR, nor can it apply exactly one optimization while skipping others. Therefore, our test input is always C++ code which passes through multiple compiler phases before reaching the phase that is the desired test subject. Although this limitation initially appears to be a weakness, it has the advantage that our tests are realistic because the IR that ultimately gets tested is less sanitized. For example, if we could write a test that accepted IR as input and ran exactly one optimization, then the test would present that optimization with exactly the input that it expected, and it would continue passing unless the optimization itself was modified later. When an optimization is run in production, however, the IR reaching the optimization may have greater variation and cause the optimization to fail. For example, a change to an earlier phase may invalidate an assumption made by the optimization, causing it to no longer apply. Thus, although they are more fragile, tests accepting C++ code as input more closely model real behavior than IR tests.</p>
<h2 id="assembly-diffs">Assembly Diffs</h2>
<p>We can generate assembly language diffs of our regression tests to see the effect of a given PR. The diffs are generated automatically and include a summary about whether code size increased or decreased overall, but reviewing the substance of the diffs is a manual process. First, the automation gives compiler engineers the ability to check whether their PR changed generated code. For example, it would be a surprise if a refactoring PR changed generated code and would indicate that the engineer made a mistake. Likewise, when implementing an optimization, it would be surprising if no code changed and may indicate that the engineer made a mistake. Second, it shows how the PR changed the generated code so that the engineer can verify their change made sense. For example, if the engineer attempted to cause more loop unrolling, then they would expect code size to increase, whereas if they optimized away redundant instructions, then they would expect code size to decrease.</p>
<h2 id="windows-testing">Windows Testing</h2>
<p>Every PR that might change the instructions emitted by the compiler is tested by using the modified compiler to build Windows for multiple architectures. Then, those builds of Windows perform their usual boot verification tests to ensure that they work correctly. Although we have this system automated, it takes a day or two, which means that compiler engineers must switch to a different task while waiting for their PR to pass Windows testing. Why do we bother to endure this delay and context switching?</p>
<p>First, as you might expect, building Windows has been a requirement for MSVC since day one. Although compiler PRs do not immediately affect Windows because it is built with a released version of the compiler, it is too late for us to discover a problem when the Windows team upgrades their compiler. Breaking the Windows build or especially boot verification via a compiler bug leads to extremely tedious debugging, so we are very proactive about not breaking it in the first place.</p>
<p>Second, Windows is a serious stress test for the compiler due to its size, complexity, and mix of legacy and newer code. It sometimes reveals problems that our other testing does not find and then we capture the failing behavior into a smaller regression test so that we can detect the same problem earlier in the future.</p>
<h2 id="dogfooding">Dogfooding</h2>
<p>Another Microsoft software product that is built as part of testing the compiler is the compiler itself! PRs to our compiler’s development branch are always built with the most recent preview release of the compiler. Another test pipeline uses the just-built compiler to build itself. This process ensures that we use our product while developing our product, also known as dogfooding. Any problems detected by these steps are fixed quickly to allow development to proceed unhindered.</p>
<h2 id="other-microsoft-software-as-tests">Other Microsoft Software as Tests</h2>
<p>Besides Windows and MSVC, MSVC is used to build other C++-based software that Microsoft ships, including Office, Teams, and SQL, so we have many customers in house. We don’t build this software as part of testing the compiler, but our internal customers give us feedback whenever they update to newer compilers. We work with them to ensure that MSVC meets their needs.</p>
<h2 id="real-world-code-tests">Real World Code Tests</h2>
<p>We have additional Azure DevOps test pipelines that build what we call “real world code,” which is a selection of open-source software that can be built for Windows. The software universe is vast, so we can’t build everything, but we build a subset because it can reveal compiler bugs. We do not gate PRs on these tests, although developers can optionally run them. Instead, we run them regularly out of our production branch and receive weekly test reports.</p>
<h1 id="performance-testing">Performance Testing</h1>
<p>We have other Azure DevOps pipelines that run benchmark suites multiple times before and after a PR, flagging statistically significant improvements or regressions in performance and code size. SPEC CPU 2017 is one such suite. We use performance benchmarks to examine the impact of new optimizations.
Not every performance improvement is easily measured; long-term forward progress can mean the accumulation of many small optimizations that each would register as noise. Periodically we review the performance progress that MSVC has made over the past several months to ensure that we’re moving in the right direction. We compare performance with other compilers available for Windows. We also use this opportunity to discuss opportunities for improvement and which applications or benchmarks we want to focus on next.</p>
<h1 id="throughput-testing">Throughput Testing</h1>
<p>We have a collection of <a href="https://learn.microsoft.com/en-us/cpp/build/reference/linkrepro?view=msvc-170">link repros</a> that allows us to distill building large applications into a simple link command that invokes link-time code generation (LTCG). We can build these link repros, time them, and avoid merging any PR that significantly degrades throughput, but the best time for us to spot throughput issues is during code reviews. We try to spot the introduction of algorithms with O(N2) or worse complexity into our repository because those may become throughput bottlenecks later.
We monitor our throughput variation over time because it is natural as more optimizations are added to a compiler for its throughput to gradually decrease. Occasionally, we will do a short sprint to improve throughput to rectify long-term throughput creep.</p>
<h1 id="walkthrough-of-a-bug-fix">Walkthrough of a Bug Fix</h1>
<p>Let’s look at what happens when a compiler engineer fixes a bug that you reported:</p>
<ol>
<li>A fix is identified and a PR is posted for other engineers to review. The PR contains both the fix and at least one new regression test based on the bug report. The PR may introduce additional asserts to help us catch similar problems in the future. It also may introduce new unit or FileCheck-style tests. The goal is to catch the same or similar problem as early as possible, so the appropriate style of test varies for each bug.</li>
<li>Required test pipelines are run in Azure DevOps. The engineer iterates on the PR until all tests pass. The engineer may elect to run some optional pipelines, depending on the nature of the bug.</li>
<li>The engineer may look at assembly diffs, run performance pipelines, or run throughput tests. This depends on the nature of the PR. The engineer continues to iterate on the PR if there is anything unexpected.</li>
<li>The engineer submits their PR for Windows build and boot testing, then waits for it to pass while they move on to their next task. If a Windows test fails, then they investigate and may need to back up a few steps.</li>
<li>The PR is merged with the review and approval of at least one other compiler engineer.</li>
<li>Additional continuous integration testing is done on recent compilers and may flag the PR as needing additional work. If a fix cannot be submitted the same day, then the PR is reverted.</li>
</ol>
<h1 id="walkthrough-of-a-new-feature-or-optimization">Walkthrough of a New Feature or Optimization</h1>
<p>New features are inspired by the language standard and conversations with our customers; new optimizations are inspired by profiling and suggestion tickets. Both result in one or more engineers developing a prototype and discussing their approach in a design review with leadership and principal engineers. At this point, there is at least one motivating test case for the work, but as the work progresses, there is greater emphasis on producing a larger number of tests than in the bug-fix workflow above. For a bug fix, the engineer incrementally extends our testing to catch one additional (and often unusual) case, but for a new optimization or compiler feature, there are no existing tests that are specifically intended to cover it. Therefore, a variety of new tests must be produced. We try to generate most of these tests early so that we can evaluate our progress toward completion. There also is greater emphasis on measuring performance and throughput impact. Otherwise, the mechanics of submitting a PR and testing it are the same as above.</p>
<h1 id="release-testing">Release Testing</h1>
<p>Development of major components like the compiler’s frontend and backend proceed independently in separate production branches off our main branch. At a regular cadence, we merge each production branch to our main branch after more extensive testing, which includes building Windows, running the boot verification tests, and also running every other test that the Windows team would run when integrating one of their own feature branches.</p>
<p>As the time approaches to release a new version of the compiler, we create a release branch from our main branch. We build preview releases of the compiler from the release branch. Preview releases allow others to try out the compiler and report problems early. For later previews, we focus on fixing bugs reported against the earlier previews, but otherwise are much more restrictive in terms of the changes that we allow into the release branch.</p>
<p>Each preview and final release undergoes additional testing where we use it to build a large collection of open source software, including the entire <a href="https://learn.microsoft.com/en-us/vcpkg/get_started/overview">vcpkg</a> catalog. Furthermore, because the compiler ships as part of Visual Studio, it must pass all of the testing processes in place for Visual Studio as well. Certain test workflows involve both the compiler and the IDE. Before merging the PR that inserts the released compiler into Visual Studio’s release branch, we build a Visual Studio release candidate from that PR. We install that version of Visual Studio on multiple virtual machines for different architectures, doing both clean installs and upgrade installs. We launch Visual Studio, create several flavors of C++ projects, build them, and run them to check various integrated features, like the debugger, static analysis, and the address sanitizer.</p>
<h1 id="conclusion">Conclusion</h1>
<p>MSVC is an industrial quality C++ compiler with many customers depending on it. We take testing very seriously and we hope that this post has helped you to understand our process better. Please share your thoughts and comments with us through Developer Community. You can also reach us on X (@VisualC), or via email at visualcpp@microsoft.com.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/testing-the-msvc-compiler-backend/">Testing the MSVC Compiler Backend</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/testing-the-msvc-compiler-backend/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New in vcpkg (January 2024)</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-january-2024/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-january-2024/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Tue, 30 Jan 2024 01:42:53 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33512</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2024.01.12 release and changes to vcpkg documentation throughout January. This month’s vcpkg release was mainly minor bug fixes, while several new documentation articles were added.<br />
Some stats for this period:</p>
<p>There are now 2,377 total libraries available in the vcpkg public registry.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-january-2024/">What’s New in vcpkg (January 2024)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.01.12">2024.01.12 release</a> and changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout January. This month’s vcpkg release was mainly minor bug fixes, while several new documentation articles were added.</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,377 total libraries</strong> available in the vcpkg public registry.</li>
<li><strong>15 new ports</strong> were added to the open-source registry. A <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>227 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>25 contributors</strong> submitted PRs, issues, or participated in discussions in the main repo.</li>
<li>The main vcpkg repo has over <strong>5,900 forks</strong> and <strong>20,700 stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="vcpkg-changelog-2024-01-12-release">vcpkg changelog (2024.01.12 release)</h3>
<ul>
<li>Arm artifact registry updated to new default URL (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1317">Microsoft/vcpkg-tool#1317</a>, thanks @mcgordonite!).</li>
<li>Various minor bugfixes.</li>
</ul>
<p>&nbsp;</p>
<h3 id="documentation-changes">Documentation changes</h3>
<ul>
<li>New articles:
<ul>
<li><a href="https://learn.microsoft.com/vcpkg/concepts/system-package-managers"><strong>Comparing vcpkg with system package managers</strong></a><strong>:</strong> vcpkg is designed to work side-by-side with system package managers. Learn about situations when a system package manager is more or less beneficial compared to vcpkg.</li>
<li><a href="https://learn.microsoft.com/vcpkg/concepts/supported-hosts"><strong>Supported hosts</strong></a><strong>:</strong> Review which host platforms and architectures vcpkg can run on and what vcpkg’s level of support for each is.</li>
<li><a href="https://learn.microsoft.com/vcpkg/users/versioning-troubleshooting"><strong>Versioning troubleshooting guide</strong></a><strong>:</strong> Discover solutions to common problems encountered while trying to manage port versions and features.</li>
<li><a href="https://learn.microsoft.com/vcpkg/troubleshoot/build-failures"><strong>Troubleshoot build failures in vcpkg ports</strong></a><strong>:</strong> Discover ways to resolve build failures with vcpkg ports.</li>
<li><a href="https://learn.microsoft.com/vcpkg/reference/software-bill-of-materials"><strong>Software Bill of Materials generation</strong></a><strong>:</strong> Learn about vcpkg support for Software Bill of Materials (SBOM). SBOM is a popular specification that tracks important information used to build a package, such as source origin, and aims to provide package consumers with software transparency and integrity.</li>
</ul>
</li>
<li>Added documentation for X_VCPKG_NUGET_PREFIX environment variable.</li>
<li>Various minor improvements throughout the docs.</li>
</ul>
<p>If you have any suggestions for our documentation, feel free to <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a>. You can also leave feedback for existing articles by using the Feedback button at the bottom of an article and choosing &#8220;This page&#8221;.</p>
<p><img decoding="async" width="304" height="172" class="wp-image-33513" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-website-description-automatical.png" alt="A screenshot of a website Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-website-description-automatical.png 304w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/a-screenshot-of-a-website-description-automatical-300x170.png 300w" sizes="(max-width: 304px) 100vw, 304px" /></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total ports available for tested triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x64-windows</td>
<td>2,229</td>
</tr>
<tr>
<td>x86-windows</td>
<td>2,148</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2,120</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2,146</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,811</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1,230</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1,196</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2,188</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2,079</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1,523</td>
</tr>
<tr>
<td>x64-android</td>
<td>1,582</td>
</tr>
<tr>
<td>arm64-android</td>
<td>1,543</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg, vcpkg-tool, or vcpkg-docs repos in this release:</p>
<ul>
<li>dg0yt (26 commits)</li>
<li>autoantwort (6 commits)</li>
<li>RT2Code (5 commits)</li>
<li>Thomas1664 (5 commits)</li>
<li>omarhogni (4 commits)</li>
<li>m-kuhn (3 commits)</li>
<li>AenBleidd (3 commits)</li>
<li>Neumann-A (3 commits)</li>
<li>eao197 (2 commits)</li>
<li>xiaozhuai (2 commits)</li>
<li>jiayuehua (2 commits)</li>
<li>kobykahane (1 commit)</li>
<li>DragonJoker (1 commit)</li>
<li>RealTimeChris (1 commit)</li>
<li>Tradias (1 commit)</li>
<li>daschuer (1 commit)</li>
<li>SchaichAlonso (1 commit)</li>
<li>luncliff (1 commit)</li>
<li>chausner (1 commit)</li>
<li>mcgordonite (1 commit)</li>
<li>charlespina (1 commit)</li>
<li>cmello (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="is-your-company-looking-for-a-better-c-c-dependency-management-experience">Is your company looking for a better C/C++ dependency management experience?</h3>
<p>We are partnering with companies to help them get started with vcpkg and overcome any initial hurdles. We have also been making product and documentation changes based on feedback we receive from these partnerships. If you are interested in trying out vcpkg or just have some thoughts to share with us, feel free to reach out at <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a>.</p>
<p>&nbsp;</p>
<h3 id="learn-more">Learn more</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.01.12">full 2024.01.12 release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-january-2024/">What’s New in vcpkg (January 2024)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-january-2024/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>C++ in VS Code: Getting Started &#038; Configuring IntelliSense</title>
		<link>https://devblogs.microsoft.com/cppblog/c-in-vs-code-getting-started-configuring-intellisense/</link>
					<comments>https://devblogs.microsoft.com/cppblog/c-in-vs-code-getting-started-configuring-intellisense/#respond</comments>
		
		<dc:creator><![CDATA[Alexandra Kemper]]></dc:creator>
		<pubDate>Mon, 22 Jan 2024 20:31:03 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=32742</guid>

					<description><![CDATA[<p>Ever wondered how you can configure IntelliSense in the C++ Extension  in Visual Studio Code? Or the easiest way to run your C++ code? With the new features added to the C++ extension, configuring IntelliSense and setting up a project is easier than ever.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/c-in-vs-code-getting-started-configuring-intellisense/">C++ in VS Code: Getting Started &#038; Configuring IntelliSense</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW143481977 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW143481977 BCX8">Ever</span> <span class="NormalTextRun SCXW143481977 BCX8">wondered how you can </span><span class="NormalTextRun SCXW143481977 BCX8">configure IntelliSense in the C++ Extension  in Visual Studio Code</span><span class="NormalTextRun SCXW143481977 BCX8">? Or </span><span class="NormalTextRun SCXW143481977 BCX8">the easiest way</span> <span class="NormalTextRun SCXW143481977 BCX8">to run your C++ code?</span><span class="NormalTextRun SCXW143481977 BCX8"> W</span><span class="NormalTextRun SCXW143481977 BCX8">ith the </span><span class="NormalTextRun SCXW143481977 BCX8">new </span><span class="NormalTextRun SCXW143481977 BCX8">features </span><span class="NormalTextRun SCXW143481977 BCX8">added</span> <span class="NormalTextRun SCXW143481977 BCX8">to the </span><span class="NormalTextRun SCXW143481977 BCX8">C++ </span><span class="NormalTextRun SCXW143481977 BCX8">extension</span><span class="NormalTextRun SCXW143481977 BCX8">, </span><span class="NormalTextRun SCXW143481977 BCX8">configuring</span> <span class="NormalTextRun SCXW143481977 BCX8">IntelliSense</span><span class="NormalTextRun SCXW143481977 BCX8"> and </span><span class="NormalTextRun SCXW143481977 BCX8">setting up a project is easier than ever. This includes a “Getting Started with C++” walkthrough,</span> c<span class="NormalTextRun SCXW143481977 BCX8">onfigure IntelliSense indicator</span><span class="NormalTextRun SCXW143481977 BCX8">, and the language status bar</span><span class="NormalTextRun SCXW143481977 BCX8">.</span></span></p>
<p>&nbsp;</p>
<h3 aria-level="2" aria-level="2" id="getting-started-with-c-walkthrough"><span data-contrast="none">&#8220;Getting Started with C++&#8221; Walkthrough </span><span data-ccp-props="{&quot;134245418&quot;:true,&quot;134245529&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:160,&quot;335559739&quot;:80,&quot;335559740&quot;:279}"> </span></h3>
<p><span class="TextRun SCXW216764055 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentStart SCXW216764055 BCX8">With the C++ Extension for VS Code installed, t</span><span class="NormalTextRun SCXW216764055 BCX8">he</span> <span class="NormalTextRun SCXW216764055 BCX8">new</span><span class="NormalTextRun SCXW216764055 BCX8"> Getting Started </span><span class="NormalTextRun SCXW216764055 BCX8">w</span><span class="NormalTextRun SCXW216764055 BCX8">alkthrough</span> helps<span class="NormalTextRun SCXW216764055 BCX8"> you set up your environment and will </span><span class="NormalTextRun SCXW216764055 BCX8">have you running </span><span class="NormalTextRun SCXW216764055 BCX8">your </span><span class="NormalTextRun SCXW216764055 BCX8">C++ code in </span><span class="NormalTextRun SCXW216764055 BCX8">no time</span><span class="NormalTextRun SCXW216764055 BCX8">. </span><span class="NormalTextRun SCXW216764055 BCX8">Invoke it by running the</span> </span><strong><span class="TextRun SCXW216764055 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW216764055 BCX8">Open Walkthrough </span></span></strong><span class="TextRun SCXW216764055 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW216764055 BCX8">command </span></span><span class="TextRun SCXW216764055 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW216764055 BCX8">in the command palette and selecting the C++ walkthrough</span><span class="NormalTextRun SCXW216764055 BCX8">.</span> <span class="NormalTextRun SCXW216764055 BCX8">You can also </span><span class="NormalTextRun SCXW216764055 BCX8">follow along with this step-by-step tutorial:</span></span><span class="EOP SCXW216764055 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<p><iframe title="Getting Started with C++ in 5 minutes" width="640" height="360" src="https://www.youtube.com/embed/qeEcV6u1kV4?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe></p>
<p><span class="TextRun SCXW141529743 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW141529743 BCX8">While this video is specifically using macOS, the walkthrough can be used with any platform. It</span><span class="NormalTextRun SCXW141529743 BCX8"> includes steps on </span><span class="NormalTextRun SCXW141529743 BCX8">how to </span><span class="NormalTextRun CommentStart SCXW141529743 BCX8">set</span> <span class="NormalTextRun SCXW141529743 BCX8">up a C++ environment</span><span class="NormalTextRun SCXW141529743 BCX8">, creat</span><span class="NormalTextRun SCXW141529743 BCX8">e</span><span class="NormalTextRun SCXW141529743 BCX8"> a</span><span class="NormalTextRun SCXW141529743 BCX8"> file, </span><span class="NormalTextRun SCXW141529743 BCX8">run</span> <span class="NormalTextRun SCXW141529743 BCX8">your code,</span><span class="NormalTextRun SCXW141529743 BCX8"> debu</span><span class="NormalTextRun SCXW141529743 BCX8">g</span> <span class="NormalTextRun SCXW141529743 BCX8">your code</span><span class="NormalTextRun SCXW141529743 BCX8">, and</span><span class="NormalTextRun SCXW141529743 BCX8"> use </span><span class="NormalTextRun SCXW141529743 BCX8">advanced debugging features</span><span class="NormalTextRun SCXW141529743 BCX8">.</span> </span><span class="EOP SCXW141529743 BCX8" data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"><span tabindex="0">It</span> <span tabindex="0">also</span> helps you install<span tabindex="0"> a</span> <span tabindex="0">C++ compiler </span><span tabindex="0">based on </span><span tabindex="0">your </span><span tabindex="0">operating system and</span> <span tabindex="0">configure </span><span tabindex="0">IntelliSense to use th</span><span tabindex="0">e newly installed compiler.</span></span></p>
<h3 aria-level="2" aria-level="2" id="why-intellisense"><span data-contrast="none">Why IntelliSense? </span><span data-ccp-props="{&quot;134245418&quot;:true,&quot;134245529&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:160,&quot;335559739&quot;:80,&quot;335559740&quot;:279}"> </span></h3>
<p><span class="TextRun SCXW150542675 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW150542675 BCX8">This leads to the question – </span><span class="NormalTextRun SCXW150542675 BCX8">wh</span><span class="NormalTextRun SCXW150542675 BCX8">at is </span><span class="NormalTextRun SCXW150542675 BCX8">Intelli</span><span class="NormalTextRun SCXW150542675 BCX8">S</span><span class="NormalTextRun SCXW150542675 BCX8">ense</span><span class="NormalTextRun SCXW150542675 BCX8">? Why does it need to be configured? </span></span><a class="Hyperlink SCXW150542675 BCX8" href="https://code.visualstudio.com/docs/editor/intellisense" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW150542675 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW150542675 BCX8" data-ccp-charstyle="Hyperlink">Intelli</span><span class="NormalTextRun SCXW150542675 BCX8" data-ccp-charstyle="Hyperlink">S</span><span class="NormalTextRun SCXW150542675 BCX8" data-ccp-charstyle="Hyperlink">ense </span></span></a><span class="TextRun SCXW150542675 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW150542675 BCX8">is</span><span class="NormalTextRun SCXW150542675 BCX8"> a tool </span><span class="NormalTextRun SCXW150542675 BCX8">built into VS Code</span><span class="NormalTextRun SCXW150542675 BCX8"> that </span><span class="NormalTextRun SCXW150542675 BCX8">provides</span><span class="NormalTextRun SCXW150542675 BCX8"> various code editing features that will help you code faster </span><span class="NormalTextRun SCXW150542675 BCX8">and</span> <span class="NormalTextRun SCXW150542675 BCX8">more efficiently. For example, </span><span class="NormalTextRun SCXW150542675 BCX8">code completion, parameter info, code actions (light bulbs), and member lists are all generated by </span><span class="NormalTextRun SCXW150542675 BCX8">IntelliSense</span><span class="NormalTextRun SCXW150542675 BCX8">.</span></span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/IntelliSenseExample.gif"><img decoding="async" class="aligncenter wp-image-33455" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/IntelliSenseExample.gif" alt="A gif that shows that as you type in VS Code, IntelliSense provides different features, like a dropdown of suggestions." width="598" height="255" /></a></p>
<p><span data-contrast="auto">IntelliSense is powered by a language service, which provides language specific completions for your code. For these to be C++ specific, IntelliSense needs to first be configured. This configuration can be done via a compiler, compile_commands.json file, or another VS Code extension (e.g. the Makefile or CMake extension).</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<p><span data-contrast="auto">The C++ Extension will, on most occasions, configure IntelliSense automatically for you. For details on this process, reference the</span><a href="https://code.visualstudio.com/docs/cpp/configure-intellisense"><span data-contrast="none"> IntelliSense documentation</span></a><span data-contrast="auto">. But how can you check if IntelliSense is already configured? </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<h4 aria-level="3" aria-level="3" id="configure-intellisense-indicator"><span data-contrast="none">Configure IntelliSense indicator</span><span data-ccp-props="{&quot;134245418&quot;:true,&quot;134245529&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:160,&quot;335559739&quot;:80,&quot;335559740&quot;:279}"> </span></h4>
<p><span class="TextRun SCXW24636514 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW24636514 BCX8">If you do not have </span><span class="NormalTextRun SCXW24636514 BCX8">IntelliSense</span><span class="NormalTextRun SCXW24636514 BCX8"> configured</span><span class="NormalTextRun SCXW24636514 BCX8"> for your workspace</span><span class="NormalTextRun SCXW24636514 BCX8">, you will see now see a new</span><span class="NormalTextRun SCXW24636514 BCX8"> indicator in the status bar with a warning sign</span><span class="NormalTextRun SCXW24636514 BCX8">, as shown below:</span></span><span class="EOP SCXW24636514 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/configure-intellisense-indicator.png"><img decoding="async" class="aligncenter wp-image-33457" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/configure-intellisense-indicator.png" alt="screenshot of the status bar in VS Code, which shows a yellow indicator to the right of the C++ symbol. The yellow indicator says configure intellisense." width="671" height="41" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/configure-intellisense-indicator.png 1586w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/configure-intellisense-indicator-300x18.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/configure-intellisense-indicator-1024x62.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/configure-intellisense-indicator-768x46.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/configure-intellisense-indicator-1536x93.png 1536w" sizes="(max-width: 671px) 100vw, 671px" /></a></p>
<p><span class="TextRun SCXW134998660 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW134998660 BCX8">Click on the </span><span class="NormalTextRun SCXW134998660 BCX8">“Configure IntelliSense” </span><span class="NormalTextRun SCXW134998660 BCX8">button to open the Configuration Q</span><span class="NormalTextRun CommentStart SCXW134998660 BCX8">uick</span> P<span class="NormalTextRun SCXW134998660 BCX8">ick</span><span class="NormalTextRun SCXW134998660 BCX8">, as explained below, which will help you get configured</span><span class="NormalTextRun SCXW134998660 BCX8">. </span></span><span class="EOP SCXW134998660 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<h4 aria-level="3" aria-level="3" id="configuration-quick-pick"><span data-contrast="none">Configuration Quick Pick</span><span data-ccp-props="{&quot;134245418&quot;:true,&quot;134245529&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:160,&quot;335559739&quot;:80,&quot;335559740&quot;:279}"> </span></h4>
<p><span class="TextRun SCXW64247617 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentStart CommentHighlightPipeClicked CommentHighlightClicked SCXW64247617 BCX8">Select a new configuration for IntelliSense by using the Configuration Quick Pick. Open the </span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">Q</span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">uick </span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">P</span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">ick </span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">either by clicking the Configure IntelliSense button or by </span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">entering </span></span><strong><span class="TextRun SCXW64247617 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">Select IntelliSense Configuration</span></span></strong><span class="TextRun SCXW64247617 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8"> in the Command Palette. </span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">Select a configuration </span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8">from</span><span class="NormalTextRun CommentHighlightClicked SCXW64247617 BCX8"> those available in the dropdown.</span></span><span class="EOP CommentHighlightPipeClicked SCXW64247617 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/compiler_quicpick.png"><img decoding="async" class="aligncenter wp-image-33458" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/compiler_quicpick.png" alt="Image of the dropdown for the compiler quickpick which shows a list of compilers, such as cl.exe and g++.exe. At the bottom of the list there are the options to select another compiler on your machine, help me install a compile, and do not configure with a compiler," width="557" height="272" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/compiler_quicpick.png 1462w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/compiler_quicpick-300x147.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/compiler_quicpick-1024x501.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/compiler_quicpick-768x376.png 768w" sizes="(max-width: 557px) 100vw, 557px" /></a></p>
<p><span data-contrast="none">If no options are listed, there are multiple ways to install a compiler on your machine. On Windows, select “Help me install a compiler” from the dropdown which will take you to the step-by-step installation instructions in the walkthrough. On a MacOS or Linux machine, choose “Install a compiler” to have the C++ Extension install a C++ compiler for you. For either scenario, the installed compiler will automatically be configured for IntelliSense by the C++ Extension. To learn more, reference the </span><a href="https://code.visualstudio.com/docs/cpp/configure-intellisense"><span data-contrast="none">Configuring IntelliSense documentation</span></a><span data-contrast="none">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<h3 aria-level="3" aria-level="3" id="language-status-bar"><span data-contrast="none">Language Status Bar </span><span data-ccp-props="{&quot;134245418&quot;:true,&quot;134245529&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:160,&quot;335559739&quot;:80,&quot;335559740&quot;:279}"> </span></h3>
<p><span data-contrast="auto">To check whether IntelliSense is configured and actively doing work in the background, use the new language status bar. Hover over the {} in the status bar which will show you the IntelliSense status. It also indicates the status of whether your workspace has been parsed and indexed, as well as the option to run code analysis. For IntelliSense, you are looking for the “IntelliSense: Ready” status, indicating it is configured and ready for code evaluation. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335551550&quot;:2,&quot;335551620&quot;:2,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> <a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/language-status-bar.png"><img decoding="async" class="aligncenter wp-image-33459" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/language-status-bar.png" alt="Image of the language status bar, which is located whne hovering over the {} symbol." width="420" height="184" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/language-status-bar.png 1760w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/language-status-bar-300x132.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/language-status-bar-1024x449.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/language-status-bar-768x337.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/language-status-bar-1536x674.png 1536w" sizes="(max-width: 420px) 100vw, 420px" /></a></span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"><span class="TextRun SCXW200403425 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW200403425 BCX8">If “IntelliSense: Not configured” is </span><span class="NormalTextRun SCXW200403425 BCX8">displayed, you need to configure IntelliSense in your workspace. Follow the steps described previously to select an IntelliSense configuration through the configuration Q</span><span class="NormalTextRun CommentStart SCXW200403425 BCX8">uick</span> P<span class="NormalTextRun SCXW200403425 BCX8">ick</span><span class="NormalTextRun SCXW200403425 BCX8">.</span></span><span class="EOP SCXW200403425 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:279}"> </span> </span></p>
<h3 aria-level="3" aria-level="3" id="have-issues-with-getting-intellisense-configured"><b><span data-contrast="none">Have issues with getting IntelliSense configured?  </span></b><span data-ccp-props="{&quot;134245418&quot;:true,&quot;134245529&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:120,&quot;335559740&quot;:279}"> </span></h3>
<p><span data-contrast="none">If you run into any issues with configuring IntelliSense, please feel free to<a href="https://github.com/microsoft/vscode-cpptools/discussions/new/choose"> start a discussion</a> or </span><a href="https://github.com/microsoft/vscode-cpptools/issues/new?assignees=&amp;labels=&amp;projects=&amp;template=1_language-service.yml"><span data-contrast="none">raise an issue</span></a><span data-contrast="none"> in </span><span data-contrast="none">our GitHub repository. </span><span data-contrast="none">We can also be reached via the comments below, per email at  </span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com,</span></a><span data-contrast="none"> or through our team on X (formerly known as Twitter) at  </span><a href="https://twitter.com/visualc"><span data-contrast="none">@</span></a><a href="https://twitter.com/visualc"><span data-contrast="none">VisualC.</span></a><span data-contrast="none">  </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:240,&quot;335559740&quot;:279}"> </span></p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/c-in-vs-code-getting-started-configuring-intellisense/">C++ in VS Code: Getting Started &#038; Configuring IntelliSense</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/c-in-vs-code-getting-started-configuring-intellisense/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC ARM64 optimizations in Visual Studio 2022 17.8 </title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-arm64-optimizations-in-visual-studio-2022-17-8/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-arm64-optimizations-in-visual-studio-2022-17-8/#comments</comments>
		
		<dc:creator><![CDATA[Jiong Wang (ARM Ltd)]]></dc:creator>
		<pubDate>Tue, 09 Jan 2024 17:00:51 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33353</guid>

					<description><![CDATA[<p>Visual Studio 2022 17.8 has been released recently (download it here). While there is already a blog “Visual Studio 17.8 now available!” covering new features and improvements, we would like to share more information with you about what is new for the MSVC ARM64 backend in this blog.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/msvc-arm64-optimizations-in-visual-studio-2022-17-8/">MSVC ARM64 optimizations in Visual Studio 2022 17.8 </a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Visual Studio 2022 17.8 has been released recently (download it <a href="https://visualstudio.microsoft.com/downloads/">here</a>). While there is already a blog “<a href="https://devblogs.microsoft.com/visualstudio/visual-studio-17-8-now-available/">Visual Studio 17.8 now available!</a>” covering new features and improvements, we would like to share more information with you about what is new for the MSVC ARM64 backend in this blog. In the last couple of months, we have been improving code-generation for the auto-vectorizer so that it can generate Neon instructions for more cases. Also, we have optimized instruction selection for a few scalar code-generation scenarios, for example short circuit evaluation, comparison against immediate, and smarter immediate split for logic instruction.</p>
<h2 id="auto-vectorizer-supports-conversions-between-floating-point-and-integer"><span style="font-size: 14pt;">Auto-Vec</span><span style="font-size: 14pt;">torizer</span><span style="font-size: 14pt;"> supports conversions between floating-point and integer</span></h2>
<p>The following conversions between floating-point and integer types are common in real-world code. Now, they are all enabled in the ARM64 backend and hooked up with the auto-vectorizer.</p>
<table>
<tbody>
<tr>
<td>From</td>
<td>To</td>
<td>Instruction</td>
</tr>
<tr>
<td><em>double</em></td>
<td><em>float</em></td>
<td><em>fcvtn</em></td>
</tr>
<tr>
<td><em>double</em></td>
<td><em>int64</em>_t</td>
<td><em>fcvtzs</em></td>
</tr>
<tr>
<td><em>double</em></td>
<td><em>uint64_t</em></td>
<td><em>fcvtzu</em></td>
</tr>
<tr>
<td><em>float</em></td>
<td><em>double</em></td>
<td><em>fcvtl</em></td>
</tr>
<tr>
<td><em>float</em></td>
<td><em>int32_t</em></td>
<td><em>fcvtzs</em></td>
</tr>
<tr>
<td><em>float</em></td>
<td><em>uint32_t</em></td>
<td><em>fcvtzu</em></td>
</tr>
<tr>
<td><em>int64_t</em></td>
<td><em>double</em></td>
<td><em>scvtf</em></td>
</tr>
<tr>
<td><em>uint64_t</em></td>
<td><em>double</em></td>
<td><em>ucvtf</em></td>
</tr>
<tr>
<td><em>int32_t</em></td>
<td><em>float</em></td>
<td><em>scvtf</em></td>
</tr>
<tr>
<td><em>uint32_t</em></td>
<td><em>float</em></td>
<td><em>ucvtf</em></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<pre class="prettyprint language-c"><code class="language-c">void test (double * __restrict a, unsigned long long * __restrict b) 
{ 
    for (int i = 0; i &lt; 2; i++)
    { 
        a[i] = (double)b[i]; 
    } 
} </code></pre>
<p>In Visual Studio 2022 17.7, the code-generation was the following in which both the computing throughput and load/store bandwidth utilization were suboptimal due to scalar instructions being used.</p>
<pre class="prettyprint language-default"><code class="language-default">ldp    x9, x8, [x1]
ucvtf  d17, x9
ucvtf  d16, x8
stp    d17, d16, [x0]</code></pre>
<p>In Visual Studio 2022 17.8.2, the code-generation has been optimized into:</p>
<pre class="prettyprint language-default"><code class="language-default">ldr    q16,[x1]
ucvtf  v16.2d,v16.2d
str    q16,[x0]</code></pre>
<p>A single pair of Q register load &amp; store plus SIMD instructions are used now.</p>
<p>The above example is a conversion between double and 64-bit integer, so both types are the same size. There was another issue in the ARM64 backend preventing auto-vectorization on conversion between different sized types and it has been fixed as well. MSVC also auto-vectorizes the following example now:</p>
<pre class="prettyprint language-c"><code class="language-c">void test_df_to_sf (float * __restrict a, double * __restrict b, int * __restrict c)
{
    for (int i = 0; i &lt; 4; i++)
    {
        a[i] = (float) b[i];
        c[i] = ((int)a[i]) &lt;&lt; 5;
    }
}</code></pre>
<p>The code-generation in Visual Studio 2022 17.7 was:</p>
<pre class="prettyprint language-default"><code class="language-default">ldp     d17, d16, [x1]
ldp     d17, d16, [x1]
fcvt    s17, d17
fcvt    s16, d16
fcvtzs  w8, s17
stp     s17, s16, [x0]
lsl     w9, w8, #5
fcvtzs  w8, s16
lsl     w8, w8, #5
stp     w9, w8, [x2]</code></pre>
<p>Scalar instructions plus loop unrolling were employed. In Visual Studio 2022 17.8.2, the loop is vectorized:</p>
<pre class="prettyprint language-default"><code class="language-default">ldr     q16, [x1]
fcvtn   v16.2s, v16.2d
str     d16, [x0]
fcvtzs  v16.2s, v16.2s
shl     v16.2s, v16.2s, #5
str     d16, [x2]</code></pre>
<h2 id="auto-vectorizer-now-supports-extended-left-shifts"><span style="font-size: 14pt;">Auto-vectorizer now supports extended left shifts</span></h2>
<p>Extended left shifts are also common in real world code, therefore the ARM64 ISA has native instructions to support it. Neon has <code>SSHLL </code>and <code>USHLL </code>to support signed and unsigned extended left shift. They extend the shift source first, then perform shift on the extended value. Let&#8217;s have a look at the following example:</p>
<pre class="prettyprint language-c"><code class="language-c">void test_signed (signed short * __restrict a, signed char * __restrict b)
{
    for (int i = 0; i &lt; 8; i++)
        a[i] = b[i] &lt;&lt; 7;
}

void test_unsigned (unsigned short * __restrict a, unsigned char * __restrict b)
{
    for (int i = 0; i &lt; 8; i++)
        a[i] = b[i] &lt;&lt; 7;
}</code></pre>
<p>The code-generation in Visual Studio 2022 17.7 was:</p>
<pre class="prettyprint language-default"><code class="language-default">|test_signed| PROC
    ldr    d16, [x1]
    sxtl   v16.8h, v16.8b
    shl    v16.8h, v16.8h, #7
    str    q16, [x0]
|test_unsigned| PROC
    ldr    d16, [x1]
    ushll  v16.8h, v16.8b, #0
    shl    v16.8h, v16.8h, #7
    str    q16, [x0]</code></pre>
<p>There is vectorization, an independent type promotion is done first and followed by a normal shift. They can be optimized into a single extended shift. We have taught the ARM64 backend about this, and Visual Studio 2022 17.8.2 now generates:</p>
<pre class="prettyprint language-default"><code class="language-default">|test_signed| PROC
    ldr    d16, [x1]
    sshll  v16.8h, v16.8b, #7
    str    q16, [x0]
|test_unsigned| PROC
    ldr    d16, [x1]
    ushll  v16.8h, v16.8b, #7
    str    q16, [x0]</code></pre>
<p>A single <code>SSHLL</code> or <code>USHLL</code> is used. But <code>SSHLL</code> and <code>USHLL</code> only encode shift amounts within <code>[0, bit_size_of_shift_source - 1]</code>. For example, the shift amount can only be <code>[0, 15]</code> for the above testcases. Therefore, we cannot use both instructions if we want to move the element to the upper half of the wider destination, because the shift amount then will be 16, which is out of the encoding range. For this case, signedness does not matter and ARM64 Neon has <code>SHLL</code><em> (Shift Left Long &#8211; by element size) </em>to support it.</p>
<p>Let us increase the shift amount to the element size of the shift source, which is 8:</p>
<pre class="prettyprint language-c"><code class="language-c">void test_signed(signed short * __restrict a, signed char * __restrict b)
{
    for (int i = 0; i &lt; 8; i++)
        a[i] = b[i] &lt;&lt; 8;
}

void test_unsigned(unsigned short * __restrict a, unsigned char * __restrict b)
{
    for (int i = 0; i &lt; 8; i++)
        a[i] = b[i] &lt;&lt; 8;
}</code></pre>
<p>The code-generation in Visual Studio 2022 17.7 was:</p>
<pre class="prettyprint language-default"><code class="language-default">|test_signed| PROC
    ldr    d16, [x1]
    sxtl   v16.8h, v16.8b
    shl    v16.8h, v16.8h, #7
    str    q16, [x0]
|test_unsigned| PROC
    ldr    d16, [x1]
    ushll  v16.8h, v16.8b, #0
    shl    v16.8h, v16.8h, #7
    str    q16, [x0]</code></pre>
<p>And in Visual Studio 2022 17.8.2, it becomes:</p>
<pre class="prettyprint language-default"><code class="language-default">|test_signed| PROC
    ldr   d16, [x1]
    shll  v16.8h, v16.8b, #8
    str   q16, [x0]
|test_unsigned| PROC
    ldr   d16, [x1]
    shll  v16.8h, v16.8b, #8
    str   q16, [x0]</code></pre>
<h2 id="scalar-code-generation-improved-on-immediate-materialization-for-cmp-cmn"><span style="font-size: 14pt;">Scalar code-generation improved on immediate materialization for CMP/CMN</span></h2>
<p>On the blog introducing <a href="https://devblogs.microsoft.com/cppblog/msvc-arm64-optimizations-in-visual-studio-2022-17-6/">ARM64 optimizations for Visual Studio 2022 17.6</a>, there was one piece of feedback on unnecessary immediate materialization for integer comparison. In the 17.8 development cycle, we have improved a couple of relevant places inside the ARM64 backend.</p>
<p>For integer comparison, the ARM64 backend is now smarter and knows an <em>immediate</em> could be adjusted to <em>immediate</em> <em>+ 1</em> or <em>immediate &#8211; 1</em> then fits into adjusted comparison. Here are some examples:</p>
<pre class="prettyprint language-c"><code class="language-c">int test_ge2gt (int a)
{
    if (a &gt;= 0x10001)
        return 1;
    else
        return 0;
}

int test_lt2le (int a)
{
    if (a &lt; -0x1fff)
        return 1;
    else
        return 0;
}</code></pre>
<p><code>0x10001</code> inside <code>test_ge2gt</code> does not fit into the immediate encoding for the ARM64 <a id="post-33353-_Int_I4YP8m5X"></a><code>CMP</code> instruction, either verbatim or shifted. However, if we subtract it by 1 and turn greater equal (ge) into greater (gt) accordingly, then <code>0x10000</code> will fit into the shifted encoding.</p>
<p>For <em>test_lt2le</em>, the negative immediate, <em>-0x1fff</em>, does not fit into immediate encoding for ARM64 <em>CMN</em> instruction, but if we subtract it by 1 and turn less (lt) into less equal (le) accordingly, then <em>-0x2000</em> will fit into shifted encoding.</p>
<p>So, the code-generation is the following by Visual Studio 2022 17.7:</p>
<pre class="prettyprint language-default"><code class="language-default">|test_ge2gt| PROC
    mov     w8, #0x10001
    cmp     w0, w8
    csetge  w0
|test_lt2le| PROC
    mov     w8, #-0x1FFF
    cmp     w0, w8
    csetlt  w0</code></pre>
<p>There is an extra <code>MOV</code> instruction to materialize the immediate into the register because it does not fit into encoding verbatim. After the above-mentioned improvements, Visual Studio 2022 17.8.2 generates:</p>
<pre class="prettyprint language-default"><code class="language-default">|test_ge2gt| PROC
    cmp     w0, #0x10, lsl #0xC
    csetgt  w0
|test_lt2le| PROC
    cmn     w0, #2, lsl #0xC
    csetle  w0</code></pre>
<p>The sequence is more efficient.</p>
<h2 id="scalar-code-generation-improved-on-logic-immediate-loading"><span style="font-size: 14pt;">Scalar code-generation improved on logic immediate loading</span></h2>
<p>We have also taken steps further to improve immediate handling of other instructions. One improvement is: ARM64 has a rotated encoding for logic immediate (please refer to description of <code>DecodeBitMasks</code> in the <em>Arm Architecture Reference Manual</em> for details<em>)</em>, this immediate encoding is used by <code>AND</code>/<code>ORR</code>. If one immediate does not fit into rotated encoding verbatim, it could after a split.</p>
<p>For example, programmers frequently write code patterns like the following:</p>
<pre class="prettyprint language-c"><code class="language-c">#define FLAG1_MASK 0x80000000
#define FLAG2_MASK 0x00004000

int cal (int a)
{
    return a &amp; (FLAG1_MASK | FLAG2_MASK);
}</code></pre>
<p>The compiler middle-end usually logically combines all the <code>AND</code>ed immediates with the return expression then returns <code>a &amp; 0x80004000</code> which does not fit into the rotated encoding, hence a <code>MOV</code>/<code>MOVK</code> sequence will be generated to load the immediate, the cost will be three instructions. The code generation in Visual Studio 2022 17.7 was:</p>
<pre class="prettyprint language-default"><code class="language-default">mov   w8, #0x4000
movk  w8, #0x8000, lsl #0x10
and   w0, w0, w8</code></pre>
<p>If we split <code>0x80004000</code> into <code>0xffffc000</code> and <code>0x80007fff</code>, <code>AND</code>ing them sequentially will have the same effect as <code>AND</code>ing <code>0x80004000</code>, but both <code>0xffffc000</code> and <code>0x80007fff</code> fit into the rotated encoding, so we save one instruction. The code generation in Visual Studio 2022 17.8.2 is:</p>
<pre class="prettyprint language-default"><code class="language-default">and  w8, w0, #0xFFFFC000
and  w0, w8, #0x80007FFF</code></pre>
<p>The immediate gets split in a way that the split parts fit into two <code>AND</code> instructions. We only want to split the immediate when it has sole use site, otherwise we will end up with duplicated sequences. Therefore, the split is guided with use count.</p>
<h2 id="scalar-code-generation-now-catches-more-ccmp-opportunities"><span style="font-size: 14pt;">Scalar code-generation now catches more CCMP opportunities</span></h2>
<p>The <code>CCMP</code> (conditional compare) instruction is useful for accelerating short circuit evaluation, for example:</p>
<pre class="prettyprint language-c"><code class="language-c">int test (int a)
{
    return a == 17 || a == 31;
}</code></pre>
<p>For this testcase, Visual Studio 2022 17.7 was smart enough to employ <code>CCMP</code> and generated:</p>
<pre class="prettyprint language-default"><code class="language-default">cmp     w0, #0x11
ccmpne  w0, #0x1F, #4
cseteq  w0</code></pre>
<p>However, <code>CCMP</code> only takes a 5-bit immediate, so if we change the testcase to:</p>
<pre class="prettyprint language-c"><code class="language-c">int test (int a)
{
    return a == 17 || a == 32;
}</code></pre>
<p>The immediate <code>#32 </code>does not fit into <code>CCMP</code>’s encoding, so the compiler will stop generating it, hence the code generation in Visual Studio 2022 17.7 was:</p>
<pre class="prettyprint language-default"><code class="language-default">    cmp  w0, #0x11
    beq  |$LN3@test|
    cmp  w0, #0x20
    mov  w0, #0
    bne  |$LN4@test|
|$LN3@test|
    mov  w0, #1
|$LN4@test|
    ret</code></pre>
<p>It employs an if-then-else structure and is verbose. Here, the compiler should have a better cost model and knows it will still be beneficial if it moves <code>#32</code> into a register and employ <code>CCMP</code>’s register form. We have fixed this in Visual Studio 2022 17.8.2, and the code generation becomes:</p>
<pre class="prettyprint language-default"><code class="language-default">cmp     w0, #0x11
mov     w8, #0x20
ccmpne  w0, w8, #4
cseteq  w0
ret</code></pre>
<h2 id="using-movi-mvni-for-immediate-move-in-smaller-loops"><span style="font-size: 14pt;">Using MOVI/MVNI for immediate move in smaller loops</span></h2>
<p>We missed an opportunity to use shifted <code>MOVI</code>/<code>MVNI</code> for combining immediate move</p>
<p>In small loops. For example,</p>
<pre class="prettyprint language-c"><code class="language-c">void vect_movi_msl (int *__restrict a, int *__restrict b, int *__restrict c) {
    for (int i = 0; i &lt; 8; i++)
        a[i] = 0x1200;

    for (int i = 0; i &lt; 8; i++)
        c[i] = 0x12ffffff;
}</code></pre>
<p>In 17.7 release, MSVC generated:</p>
<pre class="prettyprint language-default"><code class="language-default">|movi_msl| PROC
    mov x9, #0x1200
    movk x9, #0x1200, lsl #0x20
    ldr x8, |$LN29@movi_msl|
    stp x9, x9, [x0]
    stp x8, x8, [x2]
    stp x9, x9, [x0, #0x10]
    stp x8, x8, [x2, #0x10]</code></pre>
<p>Scalar <code>MOV</code>/<code>MOVK</code> instructions are employed, and 8 iterations are needed to initialize each array. Both immediates can be loaded into vector registers using <code>MOVI</code>/<code>MVNI</code>, therefore increasing the storage bandwidth and reducing the iteration number.</p>
<p>Shifted <code>MOVI</code> shifts the immediate to the left and fills with 0s, so <code>0x1200</code> can be loaded as the following:</p>
<pre class="prettyprint language-c"><code class="language-c">0x12 &lt;&lt; 8 = 0x1200</code></pre>
<p>Shifted <code>MVNI</code> shifts the immediate first, then inverts the result:</p>
<pre class="prettyprint language-c"><code class="language-c">~((0xED) &lt;&lt; 0x18) = 0x12ffffff</code></pre>
<p>In 17.8, MSVC generates:</p>
<pre class="prettyprint language-default"><code class="language-default">|movi_msl| PROC
    movi v17.4s, #0x12, lsl #8
    mvni v16.4s, #0xED, lsl #0x18
    stp q17, q17, [x0]
    stp q16, q16, [x2]</code></pre>
<p>Benefiting from vector register’s width and the employment of paired store, only one iteration is needed.</p>
<p><strong><span style="font-size: 14pt;"><em>In closing</em></span></strong></p>
<p>That is all for this blog, your feedback is valuable for us. Please share your thoughts and comments with us through <a href="https://developercommunity.visualstudio.com/cpp">Visual C++ Developer Community</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/msvc-arm64-optimizations-in-visual-studio-2022-17-8/">MSVC ARM64 optimizations in Visual Studio 2022 17.8 </a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-arm64-optimizations-in-visual-studio-2022-17-8/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>#include Diagnostics in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/include-diagnostics-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/include-diagnostics-in-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Mryam Girmay]]></dc:creator>
		<pubDate>Mon, 08 Jan 2024 16:21:52 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33437</guid>

					<description><![CDATA[<p>We’re excited to announce that the #include Diagnostics feature is now available in Visual Studio 2022 17.9 Preview 2. This new feature allows you to better understand the behavior of #include directives by providing detailed information on each directive’s references and build time. </p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/include-diagnostics-in-visual-studio/">#include Diagnostics in Visual Studio</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">We’re excited to announce that the #include Diagnostics feature is now available in Visual Studio 2022 17.9 Preview 2. This new feature allows you to better understand the behavior of #include directives by providing detailed information on each directive’s references and build time.</span><span data-ccp-props="{}"> </span></p>
<p><div style="text-align:center"><a class="cta_button_link" href="https://visualstudio.microsoft.com/vs/preview/" style="text-transform: titlecase; display: inline-block; background-color: #5C2D91; color: white; padding: 10px; margin:10px 0; text-decoration: none;" target="_blank">Download Visual Studio Preview</a></div></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1.png"><img decoding="async" class="aligncenter size-full wp-image-33440" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1.png" alt="Image include diagnostics context menu" width="2186" height="515" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1.png 2186w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1-300x71.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1-1024x241.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1-768x181.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1-1536x362.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_context_menu-1-2048x482.png 2048w" sizes="(max-width: 2186px) 100vw, 2186px" /></a></p>
<p><span data-contrast="auto">To begin utilizing this feature, activate </span><b><span data-contrast="auto">#include diagnostics</span></b><span data-contrast="auto"> by performing a right-click in your editor to display the context menu. Then, navigate to the ‘Include Directives’ option and choose ‘Enable #include Diagnostics’.</span><span data-ccp-props="{}"> </span></p>
<h3 aria-level="1" aria-level="1" id="include-references"><span data-contrast="none">#include References</span><span data-ccp-props="{&quot;134245418&quot;:true,&quot;134245529&quot;:true,&quot;335559738&quot;:240,&quot;335559739&quot;:0}"> </span></h3>
<p>T<span data-contrast="auto">he feature in Visual Studio allows you to analyze the usage of #include directives in your code. It shows where and how often each directive is referenced, which can be particularly useful when dealing with a long list of directives. If you find an #include directive that is infrequently used but significantly impacts your compile time, this tool will help you identify it quickly so you can take the necessary steps to optimize your code.</span><span data-ccp-props="{}"> </span></p>
<p><span data-contrast="auto">Once you enable #include diagnostics, you should see a line of text above each #include directive. This is the CodeLens feature in action. The text above the #include directive indicates the count of its references in your current file. Clicking this count opens a window listing these references. Selecting any reference from this list will direct you to its corresponding line of code in your project.</span><span data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_references.gif"><img decoding="async" class="aligncenter wp-image-33443 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_references.gif" alt="An image illustrating references in #include diagnostics." width="828" height="535" /></a></p>
<h3 id="include-build-time"><span data-contrast="none">#include Build Time</span></h3>
<p>T<span data-contrast="auto">his feature presents the build time for each #include directive. To activate this, you’ll need to run </span><a href="https://devblogs.microsoft.com/cppblog/build-insights-now-available-in-visual-studio-2022/"><span data-contrast="none">Build Insights</span></a><span data-contrast="auto"> by navigating to </span><b><span data-contrast="auto">Build </span></b><span data-contrast="auto">-&gt; </span><b><span data-contrast="auto">Run Build Insights. </span></b><span data-contrast="auto">This action will generate the necessary build time data. </span><span data-contrast="auto">This allows you to easily visualize and evaluate the build time for each #include directive by comparing its usage and compilation time. The information provided by #include Diagnostics can be utilized to optimize your #include directives and improve compilation time. In addition to the information provided by the new #include diagnostics you may also want to consider checking out our documentation on </span><a href="https://learn.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-170"><span data-contrast="none">C++ modules</span></a><span data-contrast="auto"> as an alternative to #include to further improve compilation time.</span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_buildTime-1.gif"><img decoding="async" class="aligncenter wp-image-33445 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/01/include_diagnostics_buildTime-1.gif" alt="A GIF displaying the #include build time using #include diagnostics." width="828" height="333" /></a></p>
<h3 id="send-us-your-feedback"><span data-ccp-props="{}">Send us your feedback </span></h3>
<p><span style="font-size: 1rem; text-align: var(--bs-body-text-align);" data-contrast="auto">Your feedback is invaluable to us as we strive to enhance your experience. Please feel free to leave your comments below. Alternatively, you can share your thoughts through the </span><a style="background-color: #f7f7f9; font-size: 1rem; text-align: var(--bs-body-text-align);" href="https://developercommunity.visualstudio.com/cpp"><span data-contrast="none">Visual Studio Developer Community</span></a><span style="font-size: 1rem; text-align: var(--bs-body-text-align);" data-contrast="auto">. We’re also available on Twitter (</span><a style="background-color: #f7f7f9; font-size: 1rem; text-align: var(--bs-body-text-align);" href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span style="font-size: 1rem; text-align: var(--bs-body-text-align);" data-contrast="auto">) and can be reached via email at visualcpp@microsoft.com. We look forward to hearing from you!</span><span style="font-size: 1rem; text-align: var(--bs-body-text-align);" data-ccp-props="{}"> </span></p>
<p><span data-ccp-props="{}"> </span></p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/include-diagnostics-in-visual-studio/">#include Diagnostics in Visual Studio</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/include-diagnostics-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New in the vcpkg 2023.12.12 Release</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-the-vcpkg-2023-12-12-release/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-the-vcpkg-2023-12-12-release/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Sat, 16 Dec 2023 00:11:00 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33385</guid>

					<description><![CDATA[<p>The 2023.12.12 release of the vcpkg package manager is available. This blog post summarizes changes from November 21st, 2023 to December 12th, 2023 for the Microsoft/vcpkg, Microsoft/vcpkg-tool, and Microsoft/vcpkg-docs GitHub repos.<br />
Some stats for this period:</p>
<p>10 new ports were added to the open-source registry.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-the-vcpkg-2023-12-12-release/">What’s New in the vcpkg 2023.12.12 Release</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2023.12.12">2023.12.12 release of the vcpkg package manager is available</a>. This blog post summarizes changes from November 21<sup>st</sup>, 2023 to December 12<sup>th</sup>, 2023 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a>, and <a href="https://github.com/microsoft/vcpkg-docs">Microsoft/vcpkg-docs</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>10 new ports</strong> were added to the open-source registry. A <a href="https://learn.microsoft.com/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>208 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main <a href="https://learn.microsoft.com/vcpkg/concepts/triplets">triplets</a>.</li>
<li>There are now <strong>2,362 total libraries</strong> available in the vcpkg public registry.</li>
<li><strong>19 contributors</strong> submitted PRs, issues, or participated in discussions in the main repo.</li>
<li>The main vcpkg repo has over <strong>5,800 forks</strong> and <strong>20,400 stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="feature-changes">Feature changes</h3>
<ul>
<li>CMake usage information is now provided for pkgconfig files (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1268">Microsoft/vcpkg-tool#1268</a>, thanks @autoantwort!).</li>
<li>vcpkg will print port versions more frequently as part of its output to the user’s terminal while it is installing or modifying dependencies for improved transparency (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1292">Microsoft/vcpkg-tool#1292</a>).</li>
<li>Added an identifier to specify QNX as a platform in vcpkg.json (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1282">Microsoft/vcpkg-tool#1282</a>, thanks @Arech!).</li>
</ul>
<p>&nbsp;</p>
<h3 id="bug-fixes">Bug fixes</h3>
<ul>
<li>Fixed processor architecture environment variable not being set properly for some x64 systems (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1297">Microsoft/vcpkg-tool#1297</a>).</li>
<li>Other minor bugfixes.</li>
</ul>
<p>&nbsp;</p>
<h3 id="documentation-changes">Documentation changes</h3>
<ul>
<li>Added <a href="https://learn.microsoft.com/vcpkg/get_started/get-started-vscode">Tutorial: Install and use packages with CMake in Visual Studio Code</a>.</li>
<li>Documented <a href="https://learn.microsoft.com/vcpkg/maintainers/functions/vcpkg_download_sourceforge">vcpkg_download_sourceforge</a> and <a href="https://learn.microsoft.com/vcpkg/maintainers/functions/vcpkg_extract_archive">vcpkg_extract_archive</a> helper functions.</li>
<li>Some minor typo fixes and edits (thanks @FantasqueX, @JacobOgle, and @adentinger!).</li>
</ul>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total ports available for tested triplets</h3>
<table style="width: 25.0336%; height: 364px;">
<tbody>
<tr style="height: 28px;">
<td style="height: 28px;"><strong>triplet</strong></td>
<td style="height: 28px;"><strong>ports available</strong></td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x64-windows</td>
<td style="height: 28px;">2,208</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x86-windows</td>
<td style="height: 28px;">2,129</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x64-windows-static</td>
<td style="height: 28px;">2,095</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x64-windows-static-md</td>
<td style="height: 28px;">2,123</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">arm64-windows</td>
<td style="height: 28px;">1,788</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x64-uwp</td>
<td style="height: 28px;">1,222</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">arm64-uwp</td>
<td style="height: 28px;">1,188</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x64-linux</td>
<td style="height: 28px;">2,167</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x64-osx</td>
<td style="height: 28px;">2,062</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">arm-neon-android</td>
<td style="height: 28px;">1,516</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">x64-android</td>
<td style="height: 28px;">1,576</td>
</tr>
<tr style="height: 28px;">
<td style="height: 28px;">arm64-android</td>
<td style="height: 28px;">1,536</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg, vcpkg-tool, or vcpkg-docs repos in this release:</p>
<ul>
<li>dg0yt (25 commits)</li>
<li>Thomas1664 (9 commits)</li>
<li>autoantwort (6 commits)</li>
<li>RT2Code (2 commits)</li>
<li>moritz-h (2 commits)</li>
<li>alagoutte (2 commits)</li>
<li>Neumann-A (2 commits)</li>
<li>ilya-lavrenov (1 commit)</li>
<li>talregev (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>RealTimeChris (1 commit)</li>
<li>Tradias (1 commit)</li>
<li>jiayuehua (1 commit)</li>
<li>JacobOgle (1 commit)</li>
<li>FantasqueX (1 commit)</li>
<li>adentinger (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="is-your-company-looking-for-a-better-c-c-dependency-management-experience">Is your company looking for a better C/C++ dependency management experience?</h3>
<p>We are partnering with companies to help them get started with vcpkg and overcome any initial hurdles. We have also been making product and documentation changes based on feedback we receive from these partnerships. If you are interested in trying out vcpkg or just have some thoughts to share with us, feel free to reach out at <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a>.</p>
<p>&nbsp;</p>
<h3 id="learn-more">Learn more</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2023.12.12">full 2023.12.12 release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-the-vcpkg-2023-12-12-release/">What’s New in the vcpkg 2023.12.12 Release</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-the-vcpkg-2023-12-12-release/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New for Makefile Tools in Visual Studio Code Release 0.8: Post-Configure Scripts and more…</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-makefile-tools-in-visual-studio-code-release-0-8-post-configure-scripts-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-makefile-tools-in-visual-studio-code-release-0-8-post-configure-scripts-and-more/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Thu, 14 Dec 2023 18:23:58 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=33368</guid>

					<description><![CDATA[<p>The latest version 0.8 of Makefile Tools in Visual Studio Code has shipped and is now available. This release includes two new features: a setting to support adding post-configure scripts and settings to add argument support to parse into your pre- and post-configure scripts. </p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-for-makefile-tools-in-visual-studio-code-release-0-8-post-configure-scripts-and-more/">What’s New for Makefile Tools in Visual Studio Code Release 0.8: Post-Configure Scripts and more…</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The latest version 0.8 of Makefile Tools in Visual Studio Code has shipped and is now available. This release includes two new features: a setting to support <strong>adding</strong> <strong>post-configure scripts</strong> and settings to add <strong>argument support to parse into your pre- and post-configure scripts. </strong>This release also features <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/CHANGELOG.md">several bug fixes and improvements, including one from our open-source community</a>. Thank you all for your contributions to this extension!</p>
<p><div style="text-align:center"><a class="cta_button_link" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools" style="text-transform: titlecase; display: inline-block; background-color: #0078D4; color: white; padding: 10px; margin:10px 0; text-decoration: none;" target="_blank">Download the Makefile Tools Extension</a></div></p>
<h3 id="post-configure-scripts">Post-Configure Scripts</h3>
<p>In your Visual Studio Code settings, you can now specify a post-configure script to run after your Makefile configure step.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-configure.png"><img decoding="async" class="size-full wp-image-33369 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-configure.png" alt="A screenshot of the setting to specify a post configure script in VS Code" width="873" height="562" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-configure.png 873w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-configure-300x193.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-configure-768x494.png 768w" sizes="(max-width: 873px) 100vw, 873px" /></a></p>
<p>Once a post configure script is specified, you can select <strong>Makefile: Always Post Configure</strong> to automatically run this script after a Makefile configure.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/always-post-configure.png"><img decoding="async" class="size-large wp-image-33372 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/always-post-configure-1024x692.png" alt="A screenshot of the setting to automatically run post configure script" width="640" height="433" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/always-post-configure-1024x692.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/always-post-configure-300x203.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/always-post-configure-768x519.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/always-post-configure.png 1258w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>To fire the specified post-configure script at any time, you can select <strong>Makefile: Post Configure</strong> from the VS Code command palette.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-confiugre-command.png"><img decoding="async" class="size-large wp-image-33373 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-confiugre-command-1024x174.png" alt="Makefile Tools command to run post configure script" width="640" height="109" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-confiugre-command-1024x174.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-confiugre-command-300x51.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-confiugre-command-768x130.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-confiugre-command-1536x261.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/post-confiugre-command.png 1804w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h2 id="argument-support-for-pre-and-post-configure-scripts">Argument Support for Pre- and Post-Configure Scripts</h2>
<p>Both Makefile pre- and post-configure scripts now support arguments that you can pass in from your VS Code settings on both a global level (<code>makefile.preConfigureArgs</code>and <code>makefile.postConfigureArgs</code>) and a per-configuration level (<code>makefile.configurations[].preConfigureArgs </code>and <code>makefile.configurations[].postConfigureArgs</code>).</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/command-args.png"><img decoding="async" class="size-large wp-image-33374 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/command-args-1024x390.png" alt="VS Code settings for adding pre and post configure arguments" width="640" height="244" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/command-args-1024x390.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/command-args-300x114.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/command-args-768x292.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/command-args-1536x585.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/command-args.png 1800w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>An example of global pre-configure arguments and debug configuration-level post-configure arguments can be seen below for reference:</p>
<pre>“makefile.preConfigureArgs” : [“install”]

“makefile.configurations”: [

    {

        “name”: “Debug”,

        “postConfigureArgs”: [ “debug” ]

    }

]</pre>
<h2 id="pre-release-versions-now-available">Pre-release versions now available</h2>
<p>Additionally, we have implemented a new pre-release cycle for the extension, so users can opt-in to try out the latest features as they ship before an official release. To opt in at any point, please select <strong>Switch to Pre-Release Version</strong> under Makefile Tools in the extension marketplace in Visual Studio Code.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/prerelease-makefile.png"><img decoding="async" class="size-large wp-image-33375 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/prerelease-makefile-1024x282.png" alt="Option to Switch to pre-release version in Makefile Tools" width="640" height="176" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/prerelease-makefile-1024x282.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/prerelease-makefile-300x83.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/prerelease-makefile-768x212.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2023/12/prerelease-makefile.png 1407w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h2 id="other-extension-updates">Other extension updates</h2>
<p>The C++ extension also recently <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/v1.18.5">shipped their 1.18 release</a> which has many new relevant features for C++ Makefile users. For example, if you are having a difficult time installing a compiler to get started with compiling with Makefile on a Mac or Linux machine, you can use the new automated compiler acquisition process. Ensure you have the C/C++ extension downloaded in VS Code to access the latest features and check out <a href="https://devblogs.microsoft.com/cppblog/c-extension-in-vs-code-1-18-release-quick-fixes-for-missing-header-files-extract-to-function-more/">the latest blog post</a> to learn more.</p>
<h2 id="what-do-you-think">What do you think?</h2>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Download the Makefile Tools extension for Visual Studio Code</a> today, give the latest version a try, and let us know what you think. Check out <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/README.md">our README documentation</a> to learn more about activating the extension and getting started.</p>
<p>If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-makefile-tools/issues">Issues section of our GitHub repository</a>.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:VisualC@microsoft.com">VisualC@microsoft.com</a>. You can also find our team’s latest announcements on Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-for-makefile-tools-in-visual-studio-code-release-0-8-post-configure-scripts-and-more/">What’s New for Makefile Tools in Visual Studio Code Release 0.8: Post-Configure Scripts and more…</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-makefile-tools-in-visual-studio-code-release-0-8-post-configure-scripts-and-more/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
