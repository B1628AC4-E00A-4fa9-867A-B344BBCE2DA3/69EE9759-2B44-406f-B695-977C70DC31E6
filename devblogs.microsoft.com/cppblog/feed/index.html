<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Wed, 11 Aug 2021 16:40:19 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Attach to a Remote Process with LLDB in Visual Studio 2022 Preview 3</title>
		<link>https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/</link>
					<comments>https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/#respond</comments>
		
		<dc:creator><![CDATA[Erika Sweet]]></dc:creator>
		<pubDate>Wed, 11 Aug 2021 16:21:30 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Clang]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28613</guid>

					<description><![CDATA[<p>You can now use Attach to Process to remote debug processes with GDB or LLDB in Visual Studio. The ability to attach to a process running on a remote system with GDB was added in Visual Studio 2019. The ability to attach to a process with LLDB is new in Visual Studio 2022 Preview 3.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/">Attach to a Remote Process with LLDB in Visual Studio 2022 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>You can now use <strong>Attach to Process</strong> to remote debug processes with GDB or LLDB in Visual Studio. The ability to attach to a process running on a remote system with GDB was added in Visual Studio 2019. The ability to attach to a process with LLDB is new in Visual Studio 2022 Preview 3.</p>
<p>Remote debugging in Visual Studio is especially valuable for teams who write cross-platform C++ code that runs on Windows and Linux or macOS. For example, if you use Windows + Visual Studio as your primary development environment, then you may need to occasionally debug code running on Linux or macOS. Rather than switching platforms and using GDB or LLDB from the command line, you can use Visual Studio to remote debug processes running on Linux and macOS. Visual Studio’s remote C++ support assumes that your source code is located in the Windows file system.</p>
<p>While a native, command driven workflow may be the best choice for your team, we know that some teams:</p>
<ul>
<li>Are unfamiliar with platform specific tools, especially if they use Windows + the Visual Studio debugger as their primary development environment.</li>
<li>Prefer Visual Studio&#8217;s graphical interface and feature set over a command line interface.</li>
<li>Find it unproductive to switch between platforms for native debugging.</li>
<li>Rely on a subset of developers who are comfortable with command line tools to debug all non-Windows errors and are looking to democratize that process.</li>
</ul>
<p>Follow the steps below to get started debugging a remote process with LLDB and Visual Studio 2022.</p>
<h4 id="getting-started-instructions">Getting started instructions</h4>
<p>1. On Windows, <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/">Install Visual Studio 2022 Preview 3 or later.</a></p>
<p>2. On your remote system, acquire LLDB and LLDB-mi. On macOS you can install LLDB with XCode or the XCode Command Line Tools. You can install a build of LLDB-mi maintained by the C/C++ Extension for VS Code.</p>
<p><div style="text-align:center"><a class="cta_button_link" href="https://go.microsoft.com/fwlink/?linkid=2154927" style="text-transform: titlecase; display: inline-block; background-color: #5C2D91; color: white; padding: 10px; margin:10px 0; text-decoration: none;" target="_blank">Install LLDB-mi for macOS</a></div></p>
<p>We don’t currently maintain a LLDB-mi binary for Linux. You can install LLDB and LLDB-mi with the instructions in <a href="https://github.com/microsoft/vscode-cpptools/issues/5415#issuecomment-662603085">this comment</a> from iamWing in the C/C++ Extension for VS Code repository.</p>
<p>3. On your remote system, start SSH (<a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-160#set-up-the-ssh-server-on-the-remote-system">instructions</a>) and the process that you want to debug.</p>
<p>4. On Windows, open Visual Studio 2022 and select <strong>Debug &gt; Attach to Process…</strong></p>
<ul>
<li>Set the <strong>Connection type</strong> to SSH.</li>
<li>Set the <strong>Connection target. </strong>You can select any system that you have added to the Visual Studio <a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-160">Connection Manager</a>, or you can provide a new address with the format <strong>user@host </strong>(e.g., demo@121.121.2.11). You can also add new connections to the Visual Studio Connection Manager with our <a href="https://docs.microsoft.com/en-us/cpp/linux/connectionmanager-reference?view=msvc-160">command line tool</a>.</li>
<li>Set the <strong>code type </strong>to Native (LLDB). If you are remote debugging with GDB, then set the code type to Native (GDB).</li>
</ul>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type.png"><img class="aligncenter size-full wp-image-28614" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type.png" alt="The Visual Studio dialog is labeled &quot;Select Code Type.&quot; The option &quot;Debug these code types&quot; is selected and followed by two options: Native (GDB) and Native (LLDB). Native (LLDB) is selected." width="488" height="383" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type.png 488w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/select-code-type-300x235.png 300w" sizes="(max-width: 488px) 100vw, 488px" /></a></p>
<ul>
<li>The <strong>list of available processes</strong> will list all processes running on your remote system by process name and ID. Select the process that you want to remote debug and press “Attach” to launch the debugger.</li>
</ul>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1.png"><img class="aligncenter size-full wp-image-28625" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1.png" alt="The Visual Studio dialog is labeled &quot;Attach to Process.&quot; The connection type is SSH, the connection target is &quot;erika@localhost&quot;, and the code type is &quot;Native (LLDB) code&quot;. A list of 3 processes is displayed under &quot;Available processes&quot;, and process &quot;CMakeProject&quot; is selected." width="853" height="604" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1.png 853w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1-300x212.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/attach-to-process-1-768x544.png 768w" sizes="(max-width: 853px) 100vw, 853px" /></a></p>
<p>5. Visual Studio will attach LLDB to the selected process and start a debugging session. You can pause the debugger to see the current execution point. All the debug windows support by Visual Studio will be populated with data from the remote process.</p>
<h4 id="talk-to-us">Talk to us!</h4>
<p>Attach to Process is the first remote debugging scenario supported by LLDB in Visual Studio. Try it out and give us your feedback, or let us know if there are other remote debugging features that you want to see. The best way to file a bug or suggest a feature is with the <strong>Send Feedback</strong> button in the upper right-hand corner of the IDE. See <a href="https://docs.microsoft.com/en-us/visualstudio/ide/feedback-options?view=vs-2019#:~:text=In%20Visual%20Studio%2C%20choose%20the%20feedback%20icon%20in,information%2C%20see%20Suggest%20a%20feature%20for%20Visual%20Studio.">Visual Studio feedback options</a> for more information.</p>
<p>We’d love to learn how your team is adopting our support for LLDB. If you have feedback or a success story to share, you can contact us at <a href="mailto:vcpp-linux@microsoft.com">vcpp-linux@microsoft.com</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/">Attach to a Remote Process with LLDB in Visual Studio 2022 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/attach-to-a-remote-process-with-lldb-in-visual-studio-2022-preview-3/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>ARM64EC Support in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Moyo Okeremi]]></dc:creator>
		<pubDate>Tue, 10 Aug 2021 19:45:49 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28369</guid>

					<description><![CDATA[<p>ARM64EC (“Emulation Compatible”) is a new application binary interface (ABI) for building apps for Windows 11 on ARM. With ARM64EC, you can build new native apps that can run on ARM or incrementally transition existing x64 apps to native performance on ARM.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/">ARM64EC Support in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>ARM64EC (“Emulation Compatible”) is a new application binary interface (ABI) for building apps for Windows 11 on ARM. With ARM64EC, you can build new native apps that can run on ARM or incrementally transition existing x64 apps to native performance on ARM. For more information about ARM64EC, check out the <a href="https://aka.ms/arm64ecannounceblog">Windows Developer blog</a>.</p>
<h2 id="why-should-developers-target-arm64ec">Why Should Developers Target ARM64EC?</h2>
<p>Applications that are built to run on ARM, give customers the benefit of a great native experience that unlocks the full power of the ARM device. However, from a developer perspective, porting an app to run on ARM can be all-or-nothing, since <strong>all</strong> the binaries within a process need to be rebuilt as ARM before a customer can enjoy the benefits.</p>
<p>With ARM64EC, you can choose to start small and build incrementally. Once you identify the part of your codebase that would benefit most from native performance, you can simply rebuild it as ARM64EC. The rest of the app will remain fully functional as emulated x64, but the recompiled ARM64EC parts will now have native speed.</p>
<p>In addition, the ability to mix and match x64 and ARM64EC makes it possible to build an app on ARM even if it depends on x64 code outside of your control. For example, projects with third-party dependencies that don’t support ARM can leave them as x64. Also, apps with an in-proc plugin ecosystem can build as ARM64EC to get native speed on ARM, while continuing to load and use x64 plugins.</p>
<h2 id="how-to-target-arm64ec-in-visual-studio">How to Target ARM64EC in Visual Studio</h2>
<p>To start using Visual Studio to build your projects as ARM64EC, you&#8217;ll need to install these prerequisites:</p>
<ul>
<li>The latest <a href="https://aka.ms/windowsinsidersdk">Windows Insider SDK build</a> which is available through the Windows Insider program.</li>
<li>The latest <a href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noopener">Visual Studio 2019 Preview</a> or <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/" target="_blank" rel="noopener">Visual Studio 2022 Preview</a></li>
<li>The ARM64EC tools from the Visual Studio Installer:</li>
</ul>
<p style="padding-left: 40px;"><img width="713" height="275" class="wp-image-28370" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-email.png" alt="Graphical user interface, text, application, email Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-email.png 713w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-email-300x116.png 300w" sizes="(max-width: 713px) 100vw, 713px" /></p>
<p>Once you have installed all the prerequisites, you can now target ARM64EC in your MSBuild and CMake Projects as explained in the following sections.</p>
<h3 id="msbuild-projects">MSBuild Projects</h3>
<p>Open your C++ project or solution in Visual Studio. If you don’t have one yet, create a new one by navigating to: <strong>Create a new project &gt; C++ Console App</strong>:</p>
<p><img class="wp-image-28371" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica.png" alt="A screenshot of a computer Description automatically generated with medium confidence" width="858" height="371" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica.png 2552w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-300x130.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1024x443.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-768x332.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1536x664.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-2048x885.png 2048w" sizes="(max-width: 858px) 100vw, 858px" /></p>
<p>Open up the configuration manager by navigating to the tool bar and clicking <strong>build &gt; configuration manager</strong>:</p>
<p><img class="wp-image-28372" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1.png" alt="A screenshot of a computer Description automatically generated" width="409" height="362" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1.png 1118w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1-300x266.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1-1024x908.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/a-screenshot-of-a-computer-description-automatica-1-768x681.png 768w" sizes="(max-width: 409px) 100vw, 409px" /></p>
<p>In the Active solution platform box, select <strong>&lt;New…&gt;</strong> to create a new platform:</p>
<p><img class="wp-image-28373" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word.png" alt="Graphical user interface, text, application, Word, email Description automatically generated" width="683" height="261" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word.png 1709w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-300x115.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-1024x391.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-768x293.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-word-1536x587.png 1536w" sizes="(max-width: 683px) 100vw, 683px" /></p>
<p>Select <strong>ARM64EC</strong>, Copy settings from <strong>x64</strong>, check the <strong>Create new project platforms</strong> checkbox and click <strong>OK</strong>:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1.png"><img class="alignnone wp-image-28383" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1-300x220.png" alt="Image Picture1" width="378" height="277" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1-300x220.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/Picture1.png 624w" sizes="(max-width: 378px) 100vw, 378px" /></a></p>
<p>Finally, ensuring that ARM64EC is the active solution configuration, select <strong>Build </strong>from the menu to successfully build your ARM64EC project.</p>
<p><strong>Note</strong>: By design, not all projects in the ARM64EC solution need to be targeting ARM64EC as they can target x64 instead. Ensure that you configure those x64 projects in the configuration manager to target x64 under the ARM64EC solution build:</p>
<p><img class="wp-image-28375" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description.png" alt="Graphical user interface, application Description automatically generated" width="884" height="345" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description.png 1664w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-300x117.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-1024x399.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-768x300.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-application-description-1536x599.png 1536w" sizes="(max-width: 884px) 100vw, 884px" /></p>
<p>For more information on working with MSBuild C++ Projects, see our documentation on <a href="https://docs.microsoft.com/en-us/cpp/build/creating-and-managing-visual-cpp-projects?view=msvc-160">Visual Studio Projects &#8211; C++ | Microsoft Docs</a> and <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging-cpp?view=vs-2019">Remote Debug a C++ Project &#8211; Visual Studio (Windows) | Microsoft Docs</a></p>
<h3 id="cmake-projects">CMake Projects</h3>
<p>If you haven’t already, install the CMake Build tools from the Visual Studio Installer:</p>
<p><img class="wp-image-28376" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr.png" alt="Graphical user interface, text, application Description automatically generated" width="425" height="238" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr.png 800w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-300x168.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-768x430.png 768w" sizes="(max-width: 425px) 100vw, 425px" /></p>
<p>Open your C++ CMake project in Visual Studio. If you don’t have one yet, create a new one by navigating to: <strong>Create a new project &gt; CMake Project</strong>:</p>
<p><img class="wp-image-28377" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall.png" alt="Graphical user interface Description automatically generated" width="704" height="342" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall.png 2468w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-300x146.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-1024x497.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-768x373.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-1536x746.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-description-automaticall-2048x994.png 2048w" sizes="(max-width: 704px) 100vw, 704px" /></p>
<p>With <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">CMakePresets.json</a> integration in Visual Studio, the default active configuration of the new project will be the Windows default which targets configuring and building on the local Windows Machine. This is the scenario we are interested in.</p>
<p><img class="wp-image-28378" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1.png" alt="Graphical user interface, text, application Description automatically generated" width="673" height="158" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1.png 1975w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-300x70.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-1024x241.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-768x180.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-application-descr-1-1536x361.png 1536w" sizes="(max-width: 673px) 100vw, 673px" /></p>
<p>Open up the CMakePresets.json file by going to the active configuration dropdown and selecting <strong>Manage Configurations</strong>:</p>
<p><img class="wp-image-28379" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa.png" alt="Graphical user interface, text Description automatically generated" width="717" height="230" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa.png 1175w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa-300x96.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa-1024x329.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/graphical-user-interface-text-description-automa-768x246.png 768w" sizes="(max-width: 717px) 100vw, 717px" /></p>
<p>Modify the architecture property under the windows configuration you want for ARM64EC:</p>
<pre class="prettyprint"> "architecture": { 
    "value": "arm64ec", 
    "strategy": "external"
 }</pre>
<p><strong>Note: </strong>The default generator is Ninja. If using the visual studio generator (2019 or 2022), change the strategy field to<strong> set.</strong></p>
<p>If using Ninja generator, you’ll also need to set some environment variables by adding the <strong>environment </strong> object to your CMakePresets configuration:</p>
<pre class="prettyprint"> "environment": { 
    "CXXFLAGS": "/arm64EC",
    "CFLAGS": "/arm64EC" 
 }</pre>
<p>Save the CMakePresets file and make sure the active configuration is set to the arm64ec configuration. From the menu bar, select <strong>project menu, </strong>then select<strong> Configure &lt;Project Name&gt; </strong>in order to generate your CMake cache.</p>
<p>Build your CMake Project targeting ARM64EC like any other CMake project: navigate to the <strong>Build Menu </strong>and select <strong>build all</strong>.</p>
<p>For more information on working with CMake projects and CMakePresets, see our documentation on  <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-160">CMake projects in Visual Studio | Microsoft Docs</a> , <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">Configure and build with CMake Presets | Microsoft Docs</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-remote-debugging?view=msvc-160">Tutorial: Debug a CMake project on a remote Windows machine | Microsoft Docs</a>.</p>
<h2 id="give-us-your-feedback">Give us your feedback</h2>
<p>Download the latest <a href="https://visualstudio.microsoft.com/vs/preview/&quot; \t &quot;_blank">Visual Studio 2019 Preview</a> or <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/" target="_blank" rel="noopener">Visual Studio 2022 Preview</a>  today and give it a try. We’d love to hear from you to help us prioritize and build the right features for you. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/spaces/8/index.html" target="_blank" rel="noopener">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>). The best way to file a bug or suggest a feature is via Developer Community.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/">ARM64EC Support in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Moving a project to C++ named Modules</title>
		<link>https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/</link>
					<comments>https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Tue, 10 Aug 2021 17:23:41 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[C++ language]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[modules]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28553</guid>

					<description><![CDATA[<p>There is a lot of hype (and perhaps restraint) to using modules in projects. The general blocker tends to be build support, but even with good build support there is a distinct lack of useful resources for practices around moving projects to using named modules (not just header units).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">Moving a project to C++ named Modules</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>There is a lot of hype (and perhaps restraint) to using modules in projects. The general blocker tends to be build support, but even with good build support there is a distinct lack of useful resources for practices around moving projects to using named modules (not just header units). In this blog we will take a small project I created, analyze its components, draft up a plan for modularizing it, and execute that plan.</p>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#tools-used">Tools used.</a></li>
<li><a href="#project-description">Project description.</a></li>
<li><a href="#cpp-today">Ball Pit! in C++ without modules.</a></li>
<li><a href="#ungluing">Ungluing from <code>#include</code></a>
<ul>
<li><a href="#starting-small">Starting small&#8230;</a></li>
<li><a href="#visibility">Choosing visibility</a></li>
<li><a href="#3rd-party-pain">3rd party pain.</a></li>
<li><a href="#polish">Polishing with modules.</a></li>
</ul>
</li>
<li><a href="#all-together">All together now.</a></li>
</ul>
<h4><span id="tools-used">Tools used</span></h4>
<p>For the purposes of this project, we will be using the following tools:</p>
<ul>
<li>CMake &#8211; Version: <code>3.20.21032501-MSVC_2</code>. <em>Note:</em> this is the installed version of CMake which comes with Visual Studio 2019.</li>
<li>Visual Studio 2019 &#8211; Version: <code>16.11</code>.</li>
</ul>
<h4><span id="project-description">Project description</span></h4>
<p>I remember when I was younger, I used to love doing kid things like eating terrible fast food, but going to these restaurants had an additional perk: the play places! One of my favorite things to do was go to the ball pit, dive in, and make a giant splash of color.</p>
<p><a style="display: block; margin-left: auto; margin-right: auto; width: 50%;" title="Rachmaninoff, CC BY-SA 4.0 &lt;https://creativecommons.org/licenses/by-sa/4.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Ball_pit_with_playground_slide.jpg"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Ball_pit_with_playground_slide.jpg/512px-Ball_pit_with_playground_slide.jpg" alt="Ball pit with playground slide" width="512" /></a></p>
<p>I shudder to think of going into one nowadays, but I have not forgotten how much fun they were. I have also recently become very inspired by OneLoneCoder on YouTube and his <a href="https://www.youtube.com/watch?v=LPzyNOHY3A4">series on programming simple physics engines</a>. I decided I would try to take this simple physics engine and make something a little bit fun and a lot more colorful, introducing &#8220;Ball Pit!&#8221;:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/ball-pit.gif"><img class="aligncenter size-full wp-image-28558" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/ball-pit.gif" alt="Image ball pit" width="320" height="240" /></a></p>
<p>&#8220;Ball Pit!&#8221; is a quite simple program built using the following discrete components:</p>
<ul>
<li>OneLoneCoder <a href="https://github.com/OneLoneCoder/olcPixelGameEngine">PixelGameEngine</a> (PGE) &#8211; Drives graphics.</li>
<li>A simple physics engine for managing all the objects on screen.</li>
<li>A data structure related to handling collisions between objects, a <a href="https://en.wikipedia.org/wiki/Quadtree">quad-tree</a>.</li>
<li>A world object to contain our beautiful orbs.</li>
<li>Utilities such as common types and functions on those types.</li>
<li>The main game object which is responsible for the primary game loop and polling user input.</li>
</ul>
<h4><span id="cpp-today">Ball Pit! in C++ without modules</span></h4>
<p>Since we established a basic design layout in the previous section, let us see what we can produce using C++20 without any modules whatsoever. Without further ado, here is the code in all its <code>#include</code> glory: <a href="https://github.com/cdacamar/ball_pit/tree/ce90e45245bf7981fd797d992389693bdd586c0b">Ball Pit! Without modules</a>. The easiest way to build this project is to  use <a href="https://docs.microsoft.com/en-us/cpp/build/open-folder-projects-cpp?view=msvc-160">Visual Studio&#8217;s open folder</a> support.</p>
<p>Alternatively you can do the following (in a VS2019 developer command prompt):</p>
<pre>$ mkdir build &amp; cd build &amp; cmake -G"Visual Studio 16 2019" -Ax64 ..\</pre>
<p>Once CMake has generated the solution for you can open it using Visual Studio 2019, use the familiar F5 loop and off you go!</p>
<h5 id="traditional-c-structure">Traditional C++ Structure</h5>
<p>Let us talk briefly about the traditional project structure of this code. We have the following, familiar, breakdown:</p>
<pre>ball_pit/
├─ include/
├─ src/</pre>
<p>As you might expect the <code>include/</code> directory is almost a mirror of some files under <code>src/</code>. You also end up with a sizeable set of includes in our primary <code>ball-pit.cpp</code> to pull all the pieces together:</p>
<pre>#include "bridges/pge-bridge.h"

#include "physics/physics-ball.h"
#include "physics/physics-engine.h"
#include "physics/quad-tree.h"
#include "util/basic-types.h"
#include "util/enum-utils.h"
#include "util/random-generator.h"
#include "world/world.h"</pre>
<p>You might notice that these includes directly reflect the design we set out to have:</p>
<ul>
<li>PGE for graphics: <code>"bridges/pge-bridge.h"</code></li>
<li>Physics engine: <code>"physics/physics-engine.h"</code></li>
<li>Quad-tree: <code>"physics/quad-tree.h"</code></li>
<li>World object: <code>"world/world.h"</code></li>
<li>Utilities: <code>"util/*</code></li>
<li>Main game: (the current source file: <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/src/ball-pit.cpp"><code>ball-pit.cpp</code></a>)</li>
</ul>
<p>Since we made the decision to use header files you will notice that we get some declarations like this:</p>
<pre>inline RandomNumberGenerator&amp; random_generator()</pre>
<p>Where there is a strong desire not to implement this simple function in its own <code>.cpp</code> file for simplicity&#8217;s sake, but if you forget the critical <code>inline</code> keyword or, even worse, mark it as <code>static</code> you will not get the behavior you expect from this function.</p>
<p>Another thing which I like to do on my projects is separate 3rd party headers from the rest of the project using these &#8220;bridge&#8221; header files. The reason is so that I can easily control warning suppression/isolated requirements for that header. The PGE header is isolated into its own bridge called <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/bridges/pge-bridge.h"><code>pge-bridge.h</code></a>.</p>
<p>Finally, for projects which utilize <code>#include</code> as a code sharing mechanism, I like to employ the idea that each header file should stand completely on its own, meaning that if a header uses something like <code>std::vector</code> it cannot rely on that container being introduced through some other header, it must include it itself. This is good practice; it makes maintaining headers minimal as you move them around and use them in more places.</p>
<h4><span id="ungluing">Ungluing from <code>#include</code></span></h4>
<p>At the beginning it was mentioned that we are using CMake as our configuration system but, as of publishing, CMake&#8217;s support for modules is still experimental. What we <em>can</em> do is generate build system output for a build system which <em>does</em> support modules: MSBuild&#8217;s! All we need to do is tell MSBuild that there are module interfaces in this project and &#8220;Presto!&#8221; we have a modules-compatible project! By default, MSBuild will key off any source files with a <code>.ixx</code> extension to automatically support named modules—exactly what we want! Now, how do we get there?</p>
<p>If we examine the <code>include/</code> tree we get a surprisingly promising idea of what module interfaces we need:</p>
<pre>ball_pit/
├─ include/
│  ├─ bridges/
│  │  ├─ pge-bridge.h
│  ├─ physics/
│  │  ├─ physics-ball.h
│  │  ├─ physics-engine.h
│  │  ├─ physics-utils.h
│  │  ├─ quad-tree.h
│  ├─ util/
│  │  ├─ basic-types.h
│  │  ├─ enum-utils.h
│  │  ├─ random-generator.h
│  │  ├─ stopwatch.h
│  ├─ world/
│  │  ├─ world.h</pre>
<p>It is common for mature projects to have a similar structure and breakdown of components and it makes sense for maintainability reasons. As a goal for modularizing this project let us aim to remove the entire directory tree of <code>include/</code> and take advantage of modules as much as possible. Let us do exactly that by introducing some new files into the directory tree which reflects our header file layout (making them empty for now):</p>
<pre>ball_pit/
├─ modules/
│  ├─ bridges/
│  │  ├─ pge-bridge.ixx
│  ├─ physics/
│  │  ├─ physics-ball.ixx
│  │  ├─ physics-engine.ixx
│  │  ├─ physics-utils.ixx
│  │  ├─ quad-tree.ixx
│  ├─ util/
│  │  ├─ basic-types.ixx
│  │  ├─ enum-utils.ixx
│  │  ├─ random-generator.ixx
│  │  ├─ stopwatch.ixx
│  ├─ world/
│  │  ├─ world.ixx</pre>
<p>Now the process of moving everything over to using modules begins!</p>
<h5><span id="starting-small">Starting small&#8230;</span></h5>
<p>When tackling a project of any size you want to start as small as you possibly can. In the case of &#8220;Ball Pit!&#8221; I started with <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/util/enum-utils.h"><code>include/util/enum-utils.ixx</code></a> because it did not depend on anything besides a STL header. The first thing you need to do is add the content to your module interface:</p>
<pre>module;
#include &lt;type_traits&gt;
export module Util.EnumUtils;

template &lt;typename T&gt;
concept Enum = std::is_enum_v&lt;T&gt;;

template &lt;Enum E&gt;
using PrimitiveType = std::underlying_type_t&lt;E&gt;;

template &lt;Enum E&gt;
constexpr auto rep(E e) { return PrimitiveType&lt;E&gt;(e); }</pre>
<p>This is <em>almost</em> a 1-to-1 copy-paste of the header but with the following exceptions:</p>
<ul>
<li>Our STL headers are injected into the <a href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp?view=msvc-160#modules-and-header-files">global module fragment</a> (the region between <code>module;</code> and <code>export module ...)</code>.</li>
<li>We have given a proper name to our module: <code>Util.EnumUtils</code>. <em>Note:</em> the <code>.</code> separated names do not indicate any filesystem structure.</li>
<li>We no longer need header include guards.</li>
</ul>
<p>There is one last thing missing: we did not actually export anything! Since all these names are used around the project, we need to export everything, and the easiest way to export lots of declarations at once is to use the <code>export { ... }</code> syntax. Take a look:</p>
<pre>module;
#include &lt;type_traits&gt;
export module Util.EnumUtils;

export
{

template &lt;typename T&gt;
concept Enum = std::is_enum_v&lt;T&gt;;

template &lt;Enum E&gt;
using PrimitiveType = std::underlying_type_t&lt;E&gt;;

template &lt;Enum E&gt;
constexpr auto rep(E e) { return PrimitiveType&lt;E&gt;(e); }

} // export</pre>
<p>The next logical step for us is to replace any instance of <code>#include "util/enum-utils.h"</code> with <code>import Util.EnumUtils;</code>. This part is largely mechanical and to play off <a href="https://docs.microsoft.com/en-us/cpp/cpp/import-export-module?view=msvc-160#import">guidance around mixing <code>import</code> and <code>#include</code></a> I ensured to place any <code>import</code> after any <code>#include</code>&#8216;s. Finally, we add this new interface to the <code>CMakeLists.txt</code> <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/CMakeLists.txt#L27">here</a>, configure, build and run again. Things should run the same as before except that we are one step closer to modularizing the project!</p>
<h5><span id="visibility">Choosing visibility</span></h5>
<p>Named modules are all about defining the surface area of your API. Now that we have a tool which allows us to hide implementation details that would otherwise be unnecessary for consumers, we can start to think about what the accessible parts of the API should be. Let us look at modularizing <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/util/random-generator.h"><code>include/util/random-generator.h</code></a>. In this file we have the following declarations:</p>
<pre>enum class RandomSeed : decltype(std::random_device{}()) { };

template &lt;std::integral I&gt;
using IntDistribution = std::uniform_int_distribution&lt;I&gt;;

template &lt;std::floating_point I&gt;
using RealDistribution = std::uniform_real_distribution&lt;I&gt;;

class RandomNumberGenerator
{
   ...
};

inline RandomNumberGenerator&amp; random_generator()
{
   ...
}</pre>
<p>Of these declarations the ones we use outside of the header are <code>IntDistribution</code>, <code>RealDistribution</code>, and <code>random_generator()</code> (not even the class name directly). As such we can define the module like so:</p>
<pre>export module Util.RandomGenerator;

import Util.EnumUtils;

enum class RandomSeed : decltype(std::random_device{}()) { };

export
template &lt;std::integral I&gt;
using IntDistribution = std::uniform_int_distribution&lt;I&gt;;

export
template &lt;std::floating_point I&gt;
using RealDistribution = std::uniform_real_distribution&lt;I&gt;;

class RandomNumberGenerator
{
    ...
};

export
RandomNumberGenerator&amp; random_generator()
{
    ...
}</pre>
<p>Notice that we do not even need to export the declaration of the class <code>RandomNumberGenerator</code>. We do not need its name; we only need its functionality, and we can prevent users from creating extra instances of it by allowing its use through <code>random_generator()</code> only.</p>
<p>Furthermore, we no longer need <code>random_generator()</code> to be marked as <code>inline</code> because there is now only one definition in any given translation unit. Do not be afraid to put compiled code in an interface, it is its own translation unit and obeys the rules of compiled code.</p>
<h5><span id="3rd-party-pain">3rd party pain</span></h5>
<p>In C++ we deal with sharing code all the time and a lot of the time that code has a distinctive style, compiler requirements, default warning settings, etc. When we move code into a modules world, and in particular 3rd party code, we need to take some things into consideration: what part of the library do we want to expose? What runtime requirements are in the library if it is header only? Do we want to &#8220;seal&#8221; off bad parts of the library? With modules we start to have answers to these questions based on the requirements of our project. Integrating 3rd party library functionality into modularized projects is one of the most interesting parts of using modules because modules give us tools we never had before to deal with ODR (One Definition Rule) and name resolution. In this section we will focus on modularizing the <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/include/bridges/pge-bridge.h"><code>include/bridges/pge-bridge.h</code></a>.</p>
<p>The OneLoneCoder PixelGameEngine is a nice library if you are just starting out exploring games programming. It is easy to integrate into projects (because it is a single header file) and the interfaces are simple&#8211;which plays to our advantage in deciding what parts of the library we want to expose. In &#8220;Ball Pit!&#8221; we use the following functionality from PGE:</p>
<ul>
<li><code>olc::PixelGameEngine</code> &#8212; For the main program.</li>
<li><code>olc::Key</code> &#8212; For user input.</li>
<li><code>olc::Pixel</code> &#8212; For coloring pixels.</li>
<li><code>olc::vf2d</code>/<code>olc::vi2d</code> &#8212; Standard vector classes (<code>float</code> and <code>int</code> respectively).</li>
<li><code>olc::BLACK</code>, <code>olc::WHITE</code>, <code>olc::BLUE</code>, and <code>olc::RED</code> &#8212; Color constants.</li>
</ul>
<p>We can, by default, export each of the above with a using-declaration:</p>
<pre>module;
#pragma warning(push)
#pragma warning(disable: 4201) // nonstandard extension used: nameless struct/union
#pragma warning(disable: 4245) // 'argument': conversion from 'int' to 'uint8_t', possible loss of data
#include "olcPixelGameEngine.h"
#pragma warning(pop)
export module Bridges.PGE;

export
namespace olc
{
    // For game.
    using olc::PixelGameEngine;
    using olc::Key;

    // For basic types.
    using olc::Pixel;
    using olc::vf2d;
    using olc::vi2d;

    // Allow using the multiply operator from olc::v2d_generic.
    using olc::operator*;
}</pre>
<p>The reason we use a using-declaration is because we do not want the module to own all these objects/functions. By injecting the names through a using-declaration their linkage remains tied to the global module so we can separately compile them in <a href="https://github.com/cdacamar/ball_pit/blob/ce90e45245bf7981fd797d992389693bdd586c0b/src/3rd_party/olcPixelGameEngine.cpp"><code>src/3rd_party/olcPixelGameEngine.cpp</code></a> as before.</p>
<p>You will immediately notice that the color constants are mysteriously missing. This is because these constants are defined with <code>static</code> linkage in the header file so we cannot export them directly and the reason is <a href="http://eel.is/c%2B%2Bdraft/basic.link#18">buried in standardese</a>. It is simpler to remember that you cannot export an internal linkage entity (i.e. one declared <code>static</code>). The way to get around this is wrap them in a function which has module linkage:</p>
<pre>export
namespace olc
{
    ...
    // Note: Because these color constants are defined to be static in the header they cannot be
    // directly exported.  Instead we export their values through a module-owned variable.
    namespace ModuleColors
    {
        auto Black()
        {
            return olc::BLACK;
        }

        auto White()
        {
            return olc::WHITE;
        }

        auto Blue()
        {
            return olc::BLUE;
        }

        auto Red()
        {
            return olc::RED;
        }
    }
    ...
}</pre>
<p>Once we have these functions, we need to replace any instance of <code>olc::COLOR</code> with its respective call to our exported color function.</p>
<p>And that is it! We have successfully exported exactly what we need from PGE for our &#8220;Ball Pit!&#8221; app! Just as before, you add this to the <code>CMakeLists.txt</code>, replace <code>#include "bridges/pge-bridge.h"</code> with <code>import Bridges.PGE;</code>.</p>
<h5><span id="polish">Polishing with modules</span></h5>
<p>Once you have gone through the exercise of modularizing more and more of the project you might find that your main program begins to reflect the header file version:</p>
<pre>import Bridges.PGE;

import Physics.Ball;
import Physics.Engine;
import Physics.QuadTree;
import Util.BasicTypes;
import Util.EnumUtils;
import Util.RandomGenerator;
import World;</pre>
<p>Dandy! Modules also give us similar tools as header files do in that we can group common sets of modules together into a &#8220;package&#8221;. To understand what I am talking about let us look at a header file equivalent of grouping common functionality. Here is what a grouping of all the headers under <code>include/physics/*</code> might look like:</p>
<p><code>include/physics/physics.h</code></p>
<pre>#ifndef PHYSICS_H
#define PHYSICS_H

#include "physics/physics-ball.h"
#include "physics/physics-engine.h"
#include "physics/physics-utils.h"
#include "physics/quad-tree.h"

#endif PHYSICS_H</pre>
<p>The problem, of course, is while this is convenient and you do not need to think about which specific file to include for your current project, you end up paying the cost of every header file in the package regardless of if you use it or not. It flies in the face of C++&#8217;s core concept: pay for what you use. With the introduction of C++20 modules we no longer have this problem because modules do next to zero work when you import them, so we can safely create the following interface without negatively impacting the compile time of consumers:</p>
<p><code>modules/physics/physics.ixx</code></p>
<pre>export module Physics;

export import Physics.Ball;
export import Physics.Engine;
export import Physics.QuadTree;
export import Physics.Utils;</pre>
<p>We can also do the same for anything under <code>Util.*</code>. This leads us to a rather, I think, respectable looking <code>ball-pit.cpp</code>:</p>
<pre>import Bridges.PGE;

import Physics;
import Util;
import World;</pre>
<h4><span id="all-together">All together now</span></h4>
<p>It was a little bit of a journey getting here, and there are learnings along the way. I will not dillydally any further, here is the complete, modularized, version of &#8220;Ball Pit!&#8221;: <a href="https://github.com/cdacamar/ball_pit/tree/565e3bff28b78b84ac3765d6c786e96980177867"><code>ball_pit</code></a>. You can check out the code, configure, and build it the same as we <a href="#cpp-today">covered earlier</a> using Visual Studio 2019 version 16.11.</p>
<p>There is one thing I want to mention, because I can all but guarantee it is on everybody&#8217;s mind: what is the build throughput? With modules there is an up-front cost in building our interfaces. With the old inclusion model, we did not have to build our include files explicitly (only implicitly). We end up building more up front, but the result is that we can <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> our main program and its components much, much faster. Here is a snapshot of the difference:</p>
<p>Compiling <code>ball-pit.cpp</code>:</p>
<table>
<tbody>
<tr>
<td>Without modules</td>
<td>With modules</td>
</tr>
<tr>
<td>3.55275s</td>
<td>0.15413s</td>
</tr>
</tbody>
</table>
<p><em>Note:</em> these times were an average of 10 runs. You can see the results yourself by observing the <code>c1xx.dll</code> in the build log (left in for comparisons).</p>
<p>Yep, that is a real ~23x speedup difference. That kind of compile time if you&#8217;re developing a game can make a dramatic difference if you are wanting to quickly test changes to your game or make mistakes, like I often do :).</p>
<h4 id="closing">Closing</h4>
<p>The process of using named modules in complex projects can be time consuming, but this type of refactor pays off in both reducing development costs associated with recompiling and code hygiene. Named modules give us so much more than simply better compile times and in the above we have only scratched the surface of what is possible. Stay tuned for more modules educational content from us in the future!</p>
<p>We urge you to go out and try using Visual Studio 2019/2022 with Modules. Both Visual Studio 2019 and Visual Studio 2022 Preview are available through the <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio downloads</a> page!</p>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow me on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">Moving a project to C++ named Modules</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/feed/</wfw:commentRss>
			<slash:comments>16</slash:comments>
		
		
			</item>
		<item>
		<title>Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/#respond</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Thu, 29 Jul 2021 15:59:04 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[debug]]></category>
		<category><![CDATA[debugging]]></category>
		<category><![CDATA[edit and continue]]></category>
		<category><![CDATA[hot reload]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28456</guid>

					<description><![CDATA[<p>Hot Reload support for C++ Applications<br />
In Visual Studio 2022 Preview 2, we are happy to announce that Hot Reload is now supported for C++.<br />
Hot Reload for C++, powered by Edit and Continue, is a new way of editing your code while actively debugging.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/">Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="hot-reload-support-for-c-applications">Hot Reload support for C++ Applications</h1>
<p>In Visual Studio 2022 Preview 2, we are happy to announce that Hot Reload is now supported for C++.</p>
<p>Hot Reload for C++, powered by Edit and Continue, is a new way of editing your code while actively debugging. Hot Reload allows you to apply code changes without stopping at a breakpoint or restarting your app.</p>
<p><span style="font-size: 14pt;"><em>Currently, Hot Reload is only supported for MSBuild C++ projects, but we are working on enabling support for CMake projects in an upcoming preview.</em> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/HRShort.gif"><img class="aligncenter size-full wp-image-28481" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/HRShort.gif" alt="Image Hot reload changing cube spin speed" width="1200" height="675" /></a></p>
<p>To learn more about Hot Reload, please refer to the Visual Studio Blog post: <a href="https://devblogs.microsoft.com/visualstudio/speed-up-your-dotnet-and-cplusplus-development-with-hot-reload-in-visual-studio-2022">Speed up your .NET and C++ development with Hot Reload in Visual Studio 2022</a></p>
<h1 id="we-want-your-feedback-survey">We Want Your Feedback: Survey</h1>
<p>As we are looking at these experiences, please let us know how Hot Reload and/or Edit and Continue support for C++ can be further enhanced to improve your day-to-day productivity. We’re looking forward to your feedback.</p>
<p><strong>Please participate in this 3-minute <a href="https://www.surveymonkey.com/r/B7GRLF6">Hot Reload for C++ Survey</a>.</strong></p>
<p>You can also reach us on Twitter (@VisualC).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/">Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Wed, 28 Jul 2021 16:00:32 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28441</guid>

					<description><![CDATA[<p>The July 2021 update of the C++ extension for Visual Studio Code is here, bringing you brand new features— such as a Disassembly View while debugging, inline macro expansions, and debug support for Windows ARM64 architecture—along with a bunch of enhancements and bug fixes.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/">Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The July 2021 update of <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">the C++ extension for Visual Studio Code</a> is here, bringing you brand new features— such as a Disassembly View while debugging, inline macro expansions, and debug support for Windows ARM64 architecture—along with a bunch of enhancements and bug fixes. To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.5.0">release notes on GitHub.</a></p>
<h2 id="disassembly-view">Disassembly View</h2>
<p>We’re excited to announce that Disassembly View— our #1 upvoted GitHub issue (<a href="https://github.com/microsoft/vscode-cpptools/issues/206">#206</a>)— is publicly available in VS Code Insiders! Disassembly View allows you to debug assembly code corresponding to the instructions created by your compiler. It’ll be available in the 1.59 release of Visual Studio Code in August, but in the meantime you can <a href="https://code.visualstudio.com/insiders/">download VS Code Insiders</a> and try it out!</p>
<p>To open Disassembly View while debugging, right click your source code and select <strong>Open Disassembly View. </strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png"><img class="alignnone size-full wp-image-28452" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png" alt="Image showing the right-click menu option to Open Disassembly View" width="3101" height="1999" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png 3101w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-300x193.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-1024x660.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-768x495.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-1536x990.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-2048x1320.png 2048w" sizes="(max-width: 3101px) 100vw, 3101px" /></a></p>
<p>In the Disassembly View, the yellow hollow marker represents the current instruction. For each instruction, you’ll see the memory address (left column) and the machine language instructions displayed as hex (middle column) and as assembly language (right column). You can navigate between instructions, step over (<strong>F10</strong>) and step in to (<strong>F11</strong>) instructions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png"><img class="alignnone size-full wp-image-28451" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png" alt="Image showing the Disassembly View opened side by side with source code" width="3105" height="1929" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png 3105w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-300x186.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-1024x636.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-768x477.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-1536x954.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-2048x1272.png 2048w" sizes="(max-width: 3105px) 100vw, 3105px" /></a></p>
<p>To set a breakpoint in the Disassembly View, hover over the instruction and click the red filled circle that appears to the left of the memory address.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png"><img class="alignnone wp-image-28450" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png" alt="Image showing the red filled circle that appears on hover to set a breakpoint at an instruction in Disassembly View" width="889" height="203" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png 1265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-300x69.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-1024x234.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-768x175.png 768w" sizes="(max-width: 889px) 100vw, 889px" /></a></p>
<p>Unset the breakpoint by clicking the red dot again, or by unchecking the box in the Breakpoints section of the Debug pane.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png"><img class="alignnone size-full wp-image-28449" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png" alt="Image showing the Breakpoints section of the Debug pane, where users can enable and disable breakpoints" width="530" height="184" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png 530w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1-300x104.png 300w" sizes="(max-width: 530px) 100vw, 530px" /></a></p>
<p>Check out this GIF to see Disassembly View in action:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-view-sidey-by-side.gif"><img class="alignnone size-full wp-image-28447" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-view-sidey-by-side.gif" alt="GIF showing how to open Disassembly View while debugging, navigate between instructions and set breakpoints" width="3116" height="1954" /></a></p>
<h2 id="macro-expansion">Macro Expansion</h2>
<p>With this latest release of the C++ extension, you can expand macros inline (GitHub issue <a href="https://github.com/microsoft/vscode-cpptools/issues/4183">#4183</a>), making it easier to read and understand your code. To expand a macro inline, click on it, select the lightbulb, and then click <strong>Inline macro.</strong></p>
<p><strong><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/macro-expansion.gif"><img class="alignnone size-full wp-image-28448" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/macro-expansion.gif" alt="GIF showing how to expand a macro inline" width="586" height="280" /></a></strong></p>
<h2 id="windows-arm64-debugging">Windows ARM64 Debugging</h2>
<p>Last year, we announced support for running the C++ extension on Windows ARM64 architecture, giving Surface Pro X users access to C++ IntelliSense, code navigation, and build support. With the July 2021 update of the C++ extension, you can debug projects on Windows ARM64, completing the end-to-end Surface Pro X C++ development experience in VS Code.</p>
<h2 id="what-do-you%e2%80%afthink">What do you think?</h2>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>. You can also join our Insiders program and get access to early builds of our release by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/">Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/feed/</wfw:commentRss>
			<slash:comments>10</slash:comments>
		
		
			</item>
		<item>
		<title>Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</title>
		<link>https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/</link>
					<comments>https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Wed, 21 Jul 2021 18:31:46 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[compiler command line]]></category>
		<category><![CDATA[modules]]></category>
		<category><![CDATA[MSVC]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28323</guid>

					<description><![CDATA[<p>In this three-part series we will explore how to build modules and header units from the command line as well as how to use/reference them.<br />
The goal of this post is to serve as a brief tour of compiling and using primary module interfaces from the command line and the options we use.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In this three-part series we will explore how to build modules and header units from the command line as well as how to use/reference them.</p>
<p>The goal of this post is to serve as a brief tour of compiling and using primary module interfaces from the command line and the options we use.</p>
<p><em>Note:</em> This tutorial will focus primarily on dealing with IFC and object file output. Other types of compiler output such as PDB info are not mentioned.</p>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#summary">Summary of C++ modules options.</a></li>
<li><a href="#interface-basics">Basics of building a module interface.</a></li>
<li><a href="#module-dependencies">Modules with interface dependencies.</a></li>
</ul>
<h4><span id="summary">Summary of C++ modules options</span></h4>
<table>
<tbody>
<tr>
<th>Option</th>
<th>Brief Description</th>
</tr>
<tr>
<td id="interface"><code>/interface</code></td>
<td>Tells the compiler that the input file is a module interface unit.</td>
</tr>
<tr>
<td><code>/internalPartition</code></td>
<td>Tells the compiler that the input file is an <a href="https://devblogs.microsoft.com/cppblog/c-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5/#module-partitions">internal partition unit</a>.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-reference?view=msvc-160">/reference</a></code></td>
<td>Provides the compiler with an IFC file to reference for the nominated module interface name.</td>
</tr>
<tr>
<td id="ifc-search-dir"><code>/ifcSearchDir</code></td>
<td>When the compiler falls back to implicit module interface search, directories specified by this option will be used.</td>
</tr>
<tr>
<td><code>/ifcOutput</code></td>
<td>Tells the compiler where the IFC resulting from compilation should go. If that destination is a directory the compiler will generate a name based on the interface name or the header unit name.</td>
</tr>
<tr>
<td><code>/ifcOnly</code></td>
<td>Instructs the compiler to only produce an IFC as the result of compilation. No other outputs will be produced as the result of compilation even if other options are specified.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-exportheader?view=msvc-160">/exportHeader</a></code></td>
<td>Instructs the compiler to create a header unit from the input.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/headername?view=msvc-160">/headerName</a></code></td>
<td>Tells the compiler that the input designates the name of a header.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/translateinclude?view=msvc-160">/translateInclude</a></code></td>
<td>Instructs the compiler to perform <code>#include</code> -&gt; <code>import</code> translation if the header-name nominates an importable header.</td>
</tr>
<tr>
<td><code>/showResolvedHeader</code></td>
<td>When building a header unit, show the fully resolved path to that header unit after compilation.</td>
</tr>
<tr>
<td><code>/validateIfcChecksum[-]</code></td>
<td>Off by default. Specifying this switch will enforce an extra security check using the stored content hash in the IFC.</td>
</tr>
</tbody>
</table>
<h4><span id="interface-basics">Basics of building a module interface</span></h4>
<p>For the content in this section, we will assume that you have an appropriate compiler environment command prompt set up and that you have navigated to the directory with your test files.</p>
<p>Let&#8217;s look at the most basic scenario we can for starters:</p>
<p><code>m.ixx</code>:</p>
<pre class="">export module MyModule;

export
void f() { }</pre>
<p><code>main.cpp</code>:</p>
<pre class="">import MyModule;

int main() {
  f();
}</pre>
<p>The simplest way to build this sample is the following:</p>
<pre>$ cl /c /std:c++latest m.ixx
$ cl /std:c++latest /reference MyModule=MyModule.ifc main.cpp m.obj
$ .\main.exe</pre>
<p>One quick note about the name of file <code>m.ixx</code> above, the <code>.ixx</code> extension is the default module interface extension for MSVC. If you wish to use a different extension then you must use <a href="#interface"><code>/interface</code></a> along with <a href="https://docs.microsoft.com/en-us/cpp/build/reference/tc-tp-tc-tp-specify-source-file-type?view=msvc-160"><code>/TP</code></a> in order to compile the input as both C++ and as a module interface. Here&#8217;s a quick example of compiling the module interface if the name were <code>my-module.cppm</code>:</p>
<pre>$ cl /c /std:c++latest /interface /TP my-module.cppm</pre>
<p>In the first line we compile the module interface, and two things happen implicitly:</p>
<ol>
<li>The compiler will derive a name for the resulting object file based on the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/specifying-the-pathname?view=msvc-160">base name of the input file</a>. The resulting object file in this case is derived from <code>m.ixx</code> transformed into <code>m.obj</code>.</li>
<li>The compiler will derive a name for the resulting IFC file based on the <em>module interface name</em>. The resulting IFC in this case is derived from the module name <code>MyModule</code> transformed into <code>MyModule.ifc</code>. Note that the name of the input file has no bearing on the exported module interface name, they are completely orthogonal to each other so if this file were named <code>foobar.ixx</code> the generated IFC name would still be <code>MyModule.ifc</code>.</li>
</ol>
<p>If we take away the two implicit points above, we will end up with a command line which looks like this:</p>
<pre>$ cl /c /std:c++latest m.ixx /ifcOutput MyModule.ifc /Fom.obj</pre>
<p>On the import side we could take advantage of the compiler&#8217;s implicit lookup behavior to find the module interface:</p>
<pre>$ cl /std:c++latest main.cpp m.obj
$ .\main.exe</pre>
<p>Whoa! Hold on there! What happened? Well, in MSVC the compiler implements a well-coordinated lookup to find the module interface implicitly. Because the compiler generates a module interface IFC based on the module name it can safely be assumed that if there is no direct <code>/reference</code> option on the command line then there could be an IFC somewhere on disk which is named after the module interface name. In the scenario above we are trying to import a module interface named <code>MyModule</code> so there might be a <code>MyModule.ifc</code> on disk, and indeed there is! It is worth pointing out that this implicit lookup behavior will search the current directory along with any directory added using <a href="#ifc-search-dir"><code>/ifcSearchDir</code></a>.</p>
<p>Let&#8217;s consider a scenario where the destination for the resulting IFC is not in the immediate directory. Consider the following directory structure:</p>
<pre>./
├─ src/
│  ├─ m.ixx
│  ├─ main.cpp
├─ bin/</pre>
<p>And let&#8217;s assume that our compiler command prompt is rooted at <code>./</code> and that we want all output to go into the <code>bin\</code> folder. Here&#8217;s what the fully explicit command lines look like:</p>
<pre>$ cl /c /std:c++latest src\m.ixx /Fobin\m.obj /ifcOutput bin\MyModule.ifc
$ cl /std:c++latest /reference MyModule=bin\MyModule.ifc src\main.cpp /Fobin\m.obj /Febin\main.exe bin\m.obj</pre>
<p>There are a lot of things going on so let&#8217;s narrow the scope of noise to just the command line options required to compile <code>main.cpp</code> and not link it.</p>
<pre>$ cl /c /std:c++latest /reference MyModule=bin\MyModule.ifc src\main.cpp /Fobin\m.obj</pre>
<p><em>Note:</em> The <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fo-object-file-name?view=msvc-160"><code>/Fo</code></a> tells the compiler where to put the resulting object file. Further, in order to ensure that the compiler can properly detect that the destination is a directory, please append the trailing &#8216;<code>\</code>&#8216; at the end of the argument.</p>
<p>If we wanted to take advantage of the compiler&#8217;s implicit naming mechanisms the command lines would be the following:</p>
<pre>$ cl /c /std:c++latest src\m.ixx /Fobin\ /ifcOutput bin\
$ cl /std:c++latest /ifcSearchDir bin\ src\main.cpp /Fobin\ /Febin\ bin\m.obj</pre>
<p>Notice that the difference here is we simply provide a directory as the argument to each of our command line options.</p>
<h4><span id="module-dependencies">Modules with interface dependencies</span></h4>
<p>Often, we don&#8217;t want to build a single module interface and call it a day, it is frequently the case that sufficiently large projects will be composed of many module interfaces which describe various parts of the system. In this section we&#8217;ll explore how to build translation units which depend on one or more interfaces.</p>
<p>Let&#8217;s consider a slightly more sophisticated directory layout:</p>
<pre>./
├─ src/
│  ├─ types/
│  │  ├─ types.ixx
│  ├─ util/
│  │  ├─ util.ixx
│  ├─ shop/
│  │  ├─ shop.ixx
│  │  ├─ shop-unit.cpp
│  ├─ main.cpp
├─ bin/</pre>
<p>The code for these files can be found <a href="https://gist.github.com/cdacamar/8226c1893dd8c8a81974c939be52809f">here</a>.</p>
<p>As you explore the code you will find that many of these modules/source files contain references to module interfaces and those interfaces may reference yet another interface. At its core, the most basic dependency graph looks like the following:</p>
<pre>   types.ixx
   /       \
util.ixx  shop.ixx
  \        /
shop-unit.cpp
      |
   main.cpp</pre>
<p>Without further ado, here are the explicit command lines in all their glory:</p>
<pre>$ cl /c /EHsc /std:c++latest src\types\types.ixx /Fobin\types.obj /ifcOutput bin\types.ifc
$ cl /c /EHsc /std:c++latest /reference types=bin\types.ifc src\util\util.ixx /Fobin\util.obj /ifcOutput bin\util.ifc
$ cl /c /EHsc /std:c++latest /reference types=bin\types.ifc src\shop\shop.ixx /Fobin\shop.obj /ifcOutput bin\shop.ifc
$ cl /c /EHsc /std:c++latest /reference types=bin\types.ifc /reference util=bin\util.ifc /reference shop=bin\shop.ifc src\shop\shop-unit.cpp /Fobin\shop-unit.obj
$ cl /EHsc /std:c++latest /reference shop=bin\shop.ifc /reference types=bin\types.ifc src\main.cpp /Fobin\main.obj /Febin\main.exe bin\types.obj bin\util.obj bin\shop.obj bin\shop-unit.obj</pre>
<p>That is quite a mouthful. One thing you might notice is that when we built <code>src\shop\shop-unit.cpp</code> we needed a reference to both <code>types</code> and <code>shop</code> even though there&#8217;s no explicit import of either interface. The reason for this is because <code>util</code> has an implicit dependency on <code>types</code> to resolve <code>Product</code> properly and because it is a module unit the line <code>module shop;</code> implicitly imports the module interface <code>shop</code>, this behavior is defined by the C++ standard.</p>
<p>Applying some techniques learned above we can drastically reduce the noise by using implicit naming/lookup:</p>
<pre>$ cl /c /EHsc /std:c++latest src\types\types.ixx /Fobin\ /ifcOutput bin\
$ cl /c /EHsc /std:c++latest /ifcSearchDir bin\ src\util\util.ixx /Fobin\ /ifcOutput bin\
$ cl /c /EHsc /std:c++latest /ifcSearchDir bin\ src\shop\shop.ixx /Fobin\ /ifcOutput bin\
$ cl /c /EHsc /std:c++latest /ifcSearchDir bin\ src\shop\shop-unit.cpp /Fobin\
$ cl /EHsc /std:c++latest /ifcSearchDir bin\ src\main.cpp /Fobin\ /Febin\ bin\types.obj bin\util.obj bin\shop.obj bin\shop-unit.obj</pre>
<p>This is looking much better. We can take it a step further by taking advantage of the fact that <code>cl.exe</code> will process each source file in a linear sequence:</p>
<pre>$ cl /EHsc /std:c++latest /ifcSearchDir bin\ src\types\types.ixx src\util\util.ixx src\shop\shop.ixx src\shop\shop-unit.cpp src\main.cpp /Fobin\ /Febin\main.exe /ifcOutput bin\</pre>
<p>The command above uses implicit naming/lookup along with <code>cl.exe</code>&#8216;s linear source processing behavior.</p>
<p><em>Note:</em> the above command line will <strong>not</strong> work if the option <a href="https://docs.microsoft.com/en-us/cpp/build/reference/mp-build-with-multiple-processes?view=msvc-160"><code>/MP</code></a> is used (compiling multiple inputs in parallel).</p>
<p>Just to be complete, we could also use explicit naming for our module interfaces in the single command line above:</p>
<pre>$ cl /EHsc /std:c++latest /reference shop=bin\shop.ifc /reference types=bin\types.ifc /reference util=bin\util.ifc src\types\types.ixx src\util\util.ixx src\shop\shop.ixx src\shop\shop-unit.cpp src\main.cpp /Fobin\ /Febin\main.exe /ifcOutput bin\</pre>
<p>The reason either of these command lines work is that the compiler will not try to do anything special with a <code>/reference</code> option unless the name designating the IFC is used and there is no extra cost to add <code>/reference</code> options for a command line if you know the module will be generated at some point in the input sequence.</p>
<h4 id="closing">Closing</h4>
<p>In part 2 we will cover how to handle module interface partitions. Finally, in part 3 we will cover how to handle header units.</p>
<p>We urge you to go out and try using Visual Studio 2019/2022 with Modules. Both Visual Studio 2019 and Visual Studio 2022 Preview are available through the <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio downloads</a> page!</p>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow me on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Build and Debug C++ with WSL 2 Distributions and Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/#respond</comments>
		
		<dc:creator><![CDATA[Erika Sweet]]></dc:creator>
		<pubDate>Wed, 14 Jul 2021 18:58:54 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28300</guid>

					<description><![CDATA[<p>Visual Studio 2022 introduces a native WSL 2 toolset for C++ development. This toolset is available now in Visual Studio 2022 version 17.0 Preview 2. WSL 2 is the new, recommended version of the Windows Subsystem for Linux (WSL) architecture that provides better Linux file system performance,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/">Build and Debug C++ with WSL 2 Distributions and Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><div style="text-align:center"><a class="cta_button_link" href="https://aka.ms/vs2022preview" style="text-transform: titlecase; display: inline-block; background-color: #5C2D91; color: white; padding: 10px; margin:10px 0; text-decoration: none;" target="_blank">Download Visual Studio 2022 Preview</a></div>
Visual Studio 2022 introduces a native WSL 2 toolset for C++ development. This toolset is available now in <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/">Visual Studio 2022 version 17.0 Preview 2</a>. WSL 2 is the new, recommended version of the <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux (WSL)</a> architecture that provides better Linux file system performance, GUI support, and full system call compatibility. Visual Studio’s WSL 2 toolset allows you to build and debug C++ code on WSL 2 distros from Visual Studio without ever adding an SSH connection. You can already build and debug C++ code on WSL 1 distros using the <a href="https://devblogs.microsoft.com/cppblog/c-with-visual-studio-2019-and-windows-subsystem-for-linux-wsl/">native WSL 1 toolset</a> introduced in Visual Studio 2019 version 16.1.</p>
<div style="text-align: center;"><iframe src="//www.youtube.com/embed/IKI2w75aAow" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></div>
<p>&nbsp;</p>
<p>Visual Studio’s WSL 2 toolset supports both CMake and MSBuild-based Linux projects. However, CMake is our recommendation for all C++ cross-platform development with Visual Studio because it allows you to build and debug the same project on Windows, WSL, and remote systems.</p>
<h4 id="how-does-the-wsl-2-toolset-work">How does the WSL 2 toolset work?</h4>
<p>Our C++ cross-platform support in Visual Studio assumes that all source files originate in the Windows file system. When targeting a WSL 2 distro, Visual Studio will execute a local rsync copy to copy files from the Windows file system to the WSL file system. This local rsync copy will occur automatically when Visual Studio detects that you are using a WSL 2 distro and will require no user intervention. See <a href="https://docs.microsoft.com/en-us/windows/wsl/compare-versions">Comparing WSL 1 and WSL 2</a> to learn more about the differences between WSL 1 and WSL 2.</p>
<p>Continue reading for a step-by-step guide on getting started with CMake and WSL 2 and an overview of our MSBuild-based WSL 2 support.</p>
<h4 id="cross-platform-cmake-development-with-a-wsl-2-distro">Cross-platform CMake development with a WSL 2 distro</h4>
<p>The WSL 2 toolset is supported by our CMake Presets integration in Visual Studio. You can learn more about CMake Presets in our <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">announcement blog post</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">documentation</a>. Follow the instructions below to build and debug a CMake project on a WSL 2 distro.</p>
<p>1. Install WSL and a WSL 2 distro with the <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Windows Subsystem for Linux Installation Guide for Windows 10</a>.</p>
<p>2. Install the required build tools on your WSL 2 distro. You will need a C++ compiler, gdb, CMake, an underlying build system generator, rsync, and zip. You can install these dependencies on distros that use apt with the following commands:</p>
<div style="text-align: center;">
<pre class="prettyprint">sudo apt update
sudo apt install g++ gdb make ninja-build rsync zip</pre>
</div>
<p>In this tutorial I’ll use GCC and Ninja on Ubuntu. I will install a recent version of CMake using Visual Studio’s CMake binary deployment in step 9.</p>
<p>3. Open a CMake project in Visual Studio 2022 version 17.0 Preview 2 or later. Visual Studio defines a CMake project as a folder with a CMakeLists.txt file at the project root. You can either clone a CMake repository (like <a href="https://github.com/esweet431/bullet3">bullet3</a>), open a local CMake project, or create a new CMake project with the CMake Project template. In this tutorial I’m going to create a new CMake project with the CMake Project template.
<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started.png"><img class="aligncenter size-full wp-image-28301" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started.png" alt="The &quot;Get started&quot; menu in the Visual Studio Installer. Options are &quot;Clone a repository&quot;, &quot;Open a project or solution&quot;, &quot;Open a local folder&quot;, or &quot;Create a new project&quot;." width="384" height="417" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started.png 384w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started-276x300.png 276w" sizes="(max-width: 384px) 100vw, 384px" /></a>
4. Enable Visual Studio’s CMake Presets integration. You can add a CMakePresets.json file to the root of the project or enable the integration globally in <strong>Tools &gt; Options &gt; CMake &gt; General</strong>. You must close and reopen the folder in Visual Studio to activate the integration. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#enable-cmakepresetsjson-integration-in-visual-studio-2019">Enable CMake Presets integration</a> for more information.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets.png"><img class="aligncenter size-full wp-image-28302" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets.png" alt="An image of the checkbox to enable CMake Presets integration in Tools &gt; Options &gt; CMake &gt; General in Visual Studio. The option to &quot;Prefer using CMake Presets for CMake configure, build, and test&quot; is checked and highlighted red." width="732" height="248" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets.png 732w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets-300x102.png 300w" sizes="(max-width: 732px) 100vw, 732px" /></a></p>
<p>5. You should now see three dropdowns across the menu bar. Use the dropdown on the left to select your active Target System. This is the system where CMake will be invoked to configure and build the project. Visual Studio queries for WSL installations with <strong>wsl -l -v</strong>. In the example below, my Target System is <strong>WSL2: Ubuntu-20.04.</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system.png"><img class="aligncenter size-full wp-image-28303" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system.png" alt="An image of the Target System dropdown in Visual Studio. The options are &quot;Local Machine&quot;, &quot;172.26.1.64&quot;, &quot;WSL2: Ubuntu-20.04&quot; and &quot;WSL1: Debian&quot;. &quot;WSL2: Ubuntu-20.04&quot; is selected." width="737" height="165" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system.png 737w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system-300x67.png 300w" sizes="(max-width: 737px) 100vw, 737px" /></a></p>
<p>Note: If Visual Studio starts to configure your project automatically, read step 9 to manage CMake binary deployment and then return to step 6. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#modify-automatic-configuration-and-cache-notifications">Modify automatic configuration and cache notifications</a> to customize this behavior.</p>
<p>6. Use the dropdown in the middle to select your active Configure Preset. Configure Presets tell Visual Studio how to invoke CMake and generate the underlying build system. In the example in Step 5 (above), my active Configure Preset is the <strong>linux-default</strong> Preset created by Visual Studio. If you want to create a custom Configure Preset, select <strong>Manage Configurations…</strong>. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#select-a-configure-preset">Select a Configure Preset</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#edit-presets">Edit Presets</a> for more information.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manage-configs.png"><img class="aligncenter size-full wp-image-28304" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manage-configs.png" alt="An image of the Configure Preset dropdown. The only option is &quot;linux-default&quot;, which is selected." width="210" height="92" /></a></p>
<p>7. Use the dropdown on the right to select your active Build Preset. Build Presets tell Visual Studio how to invoke build. In the example in Step 5 (above), my active Build Preset is the <strong>Default </strong>Preset created by Visual Studio. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#select-a-build-preset">Select a Build Preset</a> for more information.</p>
<p>8. Configure the project on WSL 2. If project generation does not start automatically, then you can manually invoke configure with <strong>Project &gt; Configure &lt;project-name&gt;</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation.png"><img class="aligncenter size-full wp-image-28305" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation.png" alt="An image of the Project menu in Visual Studio. &quot;Configure CMakeProject&quot; is selected." width="307" height="223" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation.png 307w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation-300x218.png 300w" sizes="(max-width: 307px) 100vw, 307px" /></a></p>
<p>9. If you do not have a supported version of CMake installed on your WSL 2 distro, then Visual Studio will prompt you to deploy a recent version of CMake. Select “Yes” to deploy CMake binaries to your WSL 2 distro.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment.png"><img class="aligncenter size-full wp-image-28306" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment.png" alt="Image binary deployment" width="757" height="95" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment.png 757w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment-300x38.png 300w" sizes="(max-width: 757px) 100vw, 757px" /></a></p>
<p>10. Confirm that the configure step has completed and that you can see the <strong>CMake generation finished</strong> message in the CMake pane of the Output Window. Note that build files are written to a directory in the WSL 2 distro’s file system.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output.png"><img class="aligncenter size-full wp-image-28307" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output.png" alt="The CMake pane of the Output Window is open in Visual Studio. The last line of output reads &quot;CMake generation finished.&quot;" width="1118" height="309" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output.png 1118w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output-300x83.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output-1024x283.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output-768x212.png 768w" sizes="(max-width: 1118px) 100vw, 1118px" /></a></p>
<p>11. Select the active debug target. The debug dropdown menu lists all the CMake targets available to the project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debug-drop.png"><img class="aligncenter size-full wp-image-28308" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debug-drop.png" alt="An image of the debug dropdown menu in Visual Studio. The CMake target &quot;CMakeProject&quot; is selected." width="300" height="144" /></a></p>
<p>12. Set a breakpoint. Expand the project subfolder in the Solution Explorer and in the .cpp file set a breakpoint in main(). You can also navigate to CMake Targets View by selecting the View Picker button in the Solution Explorer.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view.png"><img class="aligncenter size-full wp-image-28309" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view.png" alt="Image targets view" width="356" height="137" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view.png 356w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view-300x115.png 300w" sizes="(max-width: 356px) 100vw, 356px" /></a></p>
<p>13. Now click “Start” (Debug &gt; Start) or press F5. Your project will build, the executable will launch on your WSL 2 distro, and you will hit your breakpoint. You can see the output of your program (in this case, “Hello CMake.”) in the Linux Console Window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging.png"><img class="aligncenter size-full wp-image-28310" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging.png" alt="CMakeProject.cpp is open and running under the debugger. A breakpoint is set and hit at line 11. The Linux Console Window is open and reads &quot;Hello CMake.&quot;" width="1170" height="832" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging.png 1170w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging-300x213.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging-1024x728.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging-768x546.png 768w" sizes="(max-width: 1170px) 100vw, 1170px" /></a></p>
<h4 id="msbuild-based-linux-development-with-a-wsl-2-distro">MSBuild-based Linux development with a WSL 2 distro</h4>
<p>CMake is our recommendation for all C++ cross-platform development with Visual Studio because it allows you to build and debug the same project on Windows, WSL, and remote systems. If you are already using a MSBuild-based Linux project, then you can upgrade to the WSL 2 toolset in <strong>Property Pages &gt; General &gt; Platform Toolset</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild.png"><img class="aligncenter size-full wp-image-28311" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild.png" alt="Property Pages are open in a MSBuild-based Linux project. The &quot;Platform Toolset&quot; option is selected, and &quot;WSL2 Toolset&quot; is the selected value." width="558" height="162" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild.png 558w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild-300x87.png 300w" sizes="(max-width: 558px) 100vw, 558px" /></a></p>
<h4 id="talk-to-us">Talk to us!</h4>
<p>Our native WSL 2 toolset and CMake Presets integration are still in preview. We’ll continue to address your feedback in future releases of Visual Studio. The best way to file a bug or suggest a feature is with the <strong>Send Feedback</strong> button in the upper right-hand corner of the IDE. See <a href="https://docs.microsoft.com/en-us/visualstudio/ide/feedback-options?view=vs-2019#:~:text=In%20Visual%20Studio%2C%20choose%20the%20feedback%20icon%20in,information%2C%20see%20Suggest%20a%20feature%20for%20Visual%20Studio.">Visual Studio feedback options</a> for more information.</p>
<p>We’d love to learn how your team is adopting our support for WSL 2. If you have feedback or a success story to share, you can contact us at vcpp-linux@microsoft.com. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/">Build and Debug C++ with WSL 2 Distributions and Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Code Scanning C++ with GitHub Actions</title>
		<link>https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/#comments</comments>
		
		<dc:creator><![CDATA[Nick Uhlenhuth]]></dc:creator>
		<pubDate>Wed, 07 Jul 2021 15:25:27 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28264</guid>

					<description><![CDATA[<p>Last year, GitHub released code scanning, which enables developers to incorporate security checks into their CI/CD environment and developer workflow. This post demonstrates the basics of using CodeQL, the analysis engine behind code scanning, with GitHub Actions.<br />
What is CodeQL?<br />
CodeQL is an analysis engine that automates security checks by running queries against a database generated from your codebase.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/">Code Scanning C++ with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Last year, GitHub <a href="https://github.blog/2020-09-30-code-scanning-is-now-available/">released code scanning</a>, which enables developers to incorporate security checks into their CI/CD environment and developer workflow. This post demonstrates the basics of using CodeQL, the analysis engine behind code scanning, with GitHub Actions.</p>
<h1 id="what-is-codeql">What is CodeQL?</h1>
<p><a href="https://codeql.github.com/docs/codeql-overview/">CodeQL</a> is an analysis engine that automates security checks by running queries against a database generated from your codebase. This CodeQL database is created during the build process and represents the source code in relational form. By default, code scanning runs standard CodeQL queries written by GitHub researchers and the community, but you can also author your own custom queries.</p>
<p>The default set includes queries such as “Pointer overflow check”, “Potentially overflowing call to snprintf”, “Uncontrolled format string”, and more.</p>
<p>&nbsp;</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.jpg"><img class="alignnone size-full wp-image-28274" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.jpg" alt="Image Capture" width="2366" height="1274" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.jpg 2366w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-300x162.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-1024x551.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-768x414.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-1536x827.jpg 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-2048x1103.jpg 2048w" sizes="(max-width: 2366px) 100vw, 2366px" /></a></p>
<h1 id="setting-up-codeql-with-github-actions">Setting up CodeQL with GitHub Actions</h1>
<p>Code scanning with CodeQL is free for public repositories, and is part of GitHub Advanced Security for GitHub Enterprise. Here are instructions for the quick, <a href="https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/setting-up-code-scanning-for-a-repository">4-click setup process</a>. Alternatively, I’ve included a gif of the steps below:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/codeqlsetup.gif"><img class="alignnone size-full wp-image-28267" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/codeqlsetup.gif" alt="Image codeqlsetup" width="2080" height="1342" /></a></p>
<p>And just like that, you’re off to the races! The default CodeQL analysis workflow is configured to analyze your code each time you push a chance or raise a pull request against the default branch. This means code scanning automatically happened after I committed the new file directly to the main branch.</p>
<p>You can <a href="https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/setting-up-code-scanning-for-a-repository#viewing-the-logging-output-from-code-scanning">view the logging output</a> of the scan under the Actions tab, and you can <a href="https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/managing-code-scanning-alerts-for-your-repository">view/manage any code scanning alerts</a> under the Security tab.</p>
<h1 id="baselining">Baselining</h1>
<p>Sometimes, especially for large legacy codebases, the number of alerts can be overwhelming. For that reason, CodeQL only shows new/fixed alerts in pull requests. If you want to manage existing alerts, you can do so in the “Code scanning alerts” section under the “Security” tab.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-scaled.jpg"><img class="alignnone size-full wp-image-28275" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-scaled.jpg" alt="Image Capture2" width="2500" height="1138" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-scaled.jpg 2500w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-300x137.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-1024x466.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-768x350.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-1536x699.jpg 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-2048x932.jpg 2048w" sizes="(max-width: 2500px) 100vw, 2500px" /></a></p>
<p>It’s important to understand the distinction between <em>Dismiss </em>and <em>Delete</em>. One key distinction is that by <em>Dismissing </em>an alert, the same code won’t regenerate the alert. By <em>Deleting</em> an alert, the same code will generate the same alert the next time it is scanned. In the case that you want to bulk-dismiss alerts, you can do this from the summary of alerts (after filtering the list to whatever set of alerts you’d like to dismiss).</p>
<h1 id="feedback">Feedback</h1>
<p>This post just scratches the surface of code scanning in your CI/CD environment. Once you get the understand the basics, you may choose to author your own custom CodeQL queries or adjust the frequency of scanning. We hope you give code scanning with GitHub Actions a try, and we look forward to your feedback.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/">Code Scanning C++ with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Customized Warning Levels and Code Analysis for External Headers</title>
		<link>https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/</link>
					<comments>https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/#comments</comments>
		
		<dc:creator><![CDATA[Will Buik]]></dc:creator>
		<pubDate>Wed, 30 Jun 2021 16:17:45 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28162</guid>

					<description><![CDATA[<p>If you have tried to keep your code clean by selecting strict compiler warning levels or code analysis rulesets, you likely know how frustrating it can be to see these warnings for headers that are not part of your project. To alleviate this,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">Customized Warning Levels and Code Analysis for External Headers</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>If you have tried to keep your code clean by selecting strict compiler warning levels or code analysis rulesets, you likely know how frustrating it can be to see these warnings for headers that are not part of your project. To alleviate this, we’ve made it easy to mark headers as external to your project in the latest <a href="https://visualstudio.microsoft.com/vs/preview/">preview Visual Studio 2019</a>. This is something we have been working on for a while with help and feedback from the community. Some of you may remember our previous post, <a href="https://devblogs.microsoft.com/cppblog/broken-warnings-theory/">Broken Warnings Theory</a>, when we added experimental external header support to the Microsoft C++ Compiler. I’m happy to announce that, thanks to this feedback, external headers are now officially supported by the compiler, code analysis, and integrated into the IDE.</p>
<p>These external headers can have their own compiler warning level, code analysis, and template diagnostics settings. This leaves you free to choose stricter settings for your project’s code to enforce code quality without getting bogged down with warnings from headers that are beyond your control.</p>
<h2 id="adding-external-headers-to-your-projects">Adding External Headers to Your Projects</h2>
<p>You can find a new “External Include Directories” property for your projects under “VC++ Directories” which can be used to designate any include directory as containing external headers. This external include directory will be added to the include search path as normal, but every header that in that directory or a subdirectory of it will be treated as external. From a compilation standpoint, you won’t notice any differences, but you can choose a different set of warning levels and other analysis settings for headers in these directories.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated.png"><img class="size-full wp-image-28164 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated.png" alt="Specify “External Include Directories” in the project properties “VC++ Directories” tab." width="786" height="544" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated.png 786w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated-768x532.png 768w" sizes="(max-width: 786px) 100vw, 786px" /></a></p>
<p>By default, all headers from the toolset and the Windows SDK are included as external headers. However, you can add any other include directories (such as 3<sup>rd</sup> party libraries) to this new property, separated by a semicolon as well.</p>
<p>Keep in mind that this new property will be ignored by earlier versions of the toolset. If you want to ensure that the project builds properly with earlier versions, you will need to make sure that any “External Include Directories” are also listed in the “Include Directories” property or they will not be found by the compiler. In Visual Studio 2019, we will continue to also include the toolset and Windows SDK headers in the existing “Include Directories” property for backwards compatibility, but in the next major release of Visual Studio this will be removed.</p>
<h2 id="customizing-warning-levels-external-headers">Customizing Warning Levels External Headers</h2>
<p>You can customize the way external headers are treated in the project properties “C/C++ &gt; External Includes” tab.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes.png"><img class="size-full wp-image-28165 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes.png" alt="Set the warning level, code analysis, and other settings for external header in the project properties “C/C++ &gt; External Includes” tab." width="786" height="544" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes.png 786w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes-768x532.png 768w" sizes="(max-width: 786px) 100vw, 786px" /></a></p>
<h2 id="customizing-code-analysis-settings-for-external-headers">Customizing Code Analysis Settings for External Headers</h2>
<p>Being able to mark certain headers as external to the project will make Code Analysis much easier to use. The examples below show some of the ways you can leverage this new feature to get the most out of Code Analysis.</p>
<h3 id="migration-from-undocumented-caexcludepath-to-external-and-analyzeexternal-options">Migration from undocumented CAExcludePath to /external:* and /analyze:external* options</h3>
<p>To support one of the most common requirements of suppressing code analysis warnings for defects in library headers over which developers have no control, we created a temporary solution to use a special environment variable (“CAExcludePath”), that can be used to specify directories for which code analysis will not report any warnings.</p>
<p>We now have a better solution to control code analysis behavior for external files. While we decided to leave “CAExcludePath” option as is, we strongly recommend to switch to the /external:* and /analyze:external* options. With these options, code analysis of external headers can be turned off, or use a separate ruleset from the rest of the codebase. These come with even better usability and maintainability as they are all available through the VS IDE.</p>
<h3 id="using-analyzeexternal-with-external">Using /analyze:external- with /external:*</h3>
<p>Consider the following header and source files, with no meaningful functionality but intentionally injected bugs:</p>
<p><strong>Header File (externallib.h)</strong></p>
<pre class="prettyprint">#pragma once
 
#include &lt;Windows.h&gt;
 
#pragma warning (disable:26440 26497)
namespace ExternalLib
{
#pragma warning(disable:4700)
    int GetValue()
    {
        int arr[2];
        return arr[2];
    }
 
    template &lt;typename T&gt;
    T GetValue(T, _In_range_(0, sizeof(T) - 1) int)
    {
        T arr[4];
        return arr[sizeof(T)];
    };
}</pre>
<p><strong>Source File (MyApp1.cpp)</strong></p>
<pre class="prettyprint">#include &lt;externallib.h&gt;
 
using namespace ExternalLib;
 
void foo()
{
    auto sum = GetValue(3ll, 4);
    sum += GetValue(3, 3);
    sum += GetValue(L'a', 2);
    sum += GetValue('a', 1);
}</pre>
<p>When analyzed with default options we get code analysis warnings for functions from both the header file and source file:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External.png"><img class="size-full wp-image-28167 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External.png" alt="Errors without /External" width="1081" height="369" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External.png 1081w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External-300x102.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External-1024x350.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External-768x262.png 768w" sizes="(max-width: 1081px) 100vw, 1081px" /></a></p>
<p>Now, if we add the directory for the externallib.h to the “External Include Directories” as follows:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External.png"><img class="size-full wp-image-28168 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External.png" alt="Add Include to External" width="750" height="519" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External.png 750w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External-300x208.png 300w" sizes="(max-width: 750px) 100vw, 750px" /></a></p>
<p>And then set the “Disable Code Analysis for External Headers” to “Yes (/analyze:external-)” as follows:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External.png"><img class="size-full wp-image-28169 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External.png" alt="Disable Code Analysis for External" width="750" height="522" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External.png 750w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External-300x209.png 300w" sizes="(max-width: 750px) 100vw, 750px" /></a></p>
<p>Executing “Run Code Analysis” will no longer report any Code Analysis warnings from the external header file:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only.png"><img class="size-full wp-image-28170 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only.png" alt="Errors from Source File Only" width="1100" height="144" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only.png 1100w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only-300x39.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only-1024x134.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only-768x101.png 768w" sizes="(max-width: 1100px) 100vw, 1100px" /></a></p>
<p>Some templates may have bugs depending on the template arguments. If you want to analyze templates even if they are in the external files, you can set the “Template Diagnostics in External Headers” option to “Yes (/external:templates-)”. Now, executing “Run Code Analysis” will report Code Analysis warnings for the template functions even if they are in the external header file:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors.png"><img class="size-full wp-image-28171 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors.png" alt="Errors from External Templates" width="1103" height="234" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors.png 1103w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors-300x64.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors-1024x217.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors-768x163.png 768w" sizes="(max-width: 1103px) 100vw, 1103px" /></a></p>
<h3 id="using-analyzeexternalruleset-with-external">Using /analyze:external:ruleset with /external:*</h3>
<p>Instead of turning off code analysis for external files, it is now possible to analyze external files with a different ruleset from the rest of the codebase by specifying a different ruleset file with the “Analysis Ruleset for External Headers” option.</p>
<p>For this example, I have created a custom ruleset “ExternalHeaderRules” that enables only two rules, C6021 and C6385, as warnings. Then I selected it for the “Analysis Ruleset for External Headers” option:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset.png"><img class="size-full wp-image-28172 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset.png" alt="Custom Ruleset for External Headers" width="750" height="522" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset.png 750w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset-300x209.png 300w" sizes="(max-width: 750px) 100vw, 750px" /></a></p>
<p>Please note that the “Disable Code Analysis for External Headers” option is set to “No”, enabling code analysis on the external headers. With this change, code analysis will now analyze functions from external files using the custom “ExternalHeaderRules” ruleset, and report following warnings:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors.png"><img class="size-full wp-image-28173 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors.png" alt="Errors from Custom Ruleset" width="1097" height="226" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors.png 1097w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors-300x62.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors-1024x211.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors-768x158.png 768w" sizes="(max-width: 1097px) 100vw, 1097px" /></a></p>
<p>Currently, the &#8220;Template Diagnostics in External Headers” option is ignored if “Analysis Ruleset for External Headers” is used. We plan to change the behavior to honor the option and treat templates as non-external and apply the general ruleset instead of the ruleset for external headers.</p>
<h3 id="bonus-even-better-code-analysis-performance">Bonus: Even Better Code Analysis Performance</h3>
<p>While we were working on this feature, we realized some of the built-in checkers were not really skipping functions from the files that are excluded through “CAExcludePath” environment variable. Instead, they were analyzed just like others and the resultant warnings from those functions were simply filtered out. As we add support for the /external:* option, we updated them to honor “CAExcludePath” as well as /external:* and /analyze:external- options, and to skip analysis of functions from excluded or external files. This resulted in observed performance improvements in our production codebase, ranging from 25% to 30%. Actual performance improvements will vary depending on how much of the codebase is from excluded or external header files, and how much of the project uses PCH, etc.</p>
<h2 id="external-headers-and-the-microsoft-c-compiler">External Headers and the Microsoft C++ Compiler</h2>
<p>Several new flags have been added to the Microsoft C++ Compiler to specify external include directories and their warning and code analysis settings. You can learn more about the behavior of these flags on our <a href="https://docs.microsoft.com/en-us/cpp/build/reference/external-external-headers-diagnostics?view=msvc-160">compiler documentation pages</a>.</p>
<h2 id="send-us-feedback">Send Us Feedback</h2>
<p>Please grab a copy of the <a href="https://visualstudio.microsoft.com/downloads/">latest Visual Studio 2019 preview</a> and try it out. We would love to hear your feedback about Visual Studio. If you have feedback, suggestions, or any other comments please submit them to <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">Customized Warning Levels and Code Analysis for External Headers</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/feed/</wfw:commentRss>
			<slash:comments>7</slash:comments>
		
		
			</item>
		<item>
		<title>STL Visualizers on GitHub</title>
		<link>https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/</link>
					<comments>https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/#comments</comments>
		
		<dc:creator><![CDATA[Anju Del Moral Gonzalez]]></dc:creator>
		<pubDate>Wed, 23 Jun 2021 15:06:37 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28219</guid>

					<description><![CDATA[<p>We are happy to announce that now it’s possible to contribute to the STL Visualizers for Visual Studio&#8217;s debugger on GitHub.<br />
A visualizer is a file with .natvis extension that allows you to manipulate the way native types appear in the debugger&#8217;s watch window. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/">STL Visualizers on GitHub</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">We are happy to announce that now it’s possible to contribute to the STL Visualizers for Visual Studio&#8217;s debugger on <a href="https://github.com/microsoft/STL/blob/main/stl/debugger/STL.natvis">GitHub</a>.</span></p>
<p><span data-contrast="auto">A visualizer is a file with .natvis extension that allows you to manipulate the way native types appear in the debugger&#8217;s watch window.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><img class="aligncenter wp-image-28229" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/watch-simpleview.png" alt="A visualisation for vectors of ints" width="271" height="282" /></p>
<p><span data-contrast="auto">We&#8217;ve been working on fixing existing issues with the visualizers and augmenting them, but with C++20 coming with new types, they have been falling behind. We decided to open source them so that the community can benefit and collaborate.</span></p>
<p>&nbsp;</p>
<h1 id="whats-available"><span data-contrast="auto">What’s Available? </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">The file is now in the GitHub repo under </span><a href="https://github.com/microsoft/STL/blob/main/stl/debugger/STL.natvis"><span data-contrast="none">stl\debugger\STL.natvis</span></a><span data-contrast="auto">. We also have available documentation for the .natvis file format </span><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019"><span data-contrast="none">here</span></a><span data-contrast="auto">. All changes made on GitHub will be ported to Visual Studio.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">This has been up already for a couple of weeks and we are happy to see that there are already contributors helping in this new area. We would like to thank AdamBucior, statementreply, SuperWig and joemmett. Some of the PRs add visualizers to coroutines, chrono, ranges, the spaceship operator, source location, span, and more. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">  </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> <a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/112188892-57bd2d80-8bfb-11eb-9044-66bca3e1b2b0.png"><img class="aligncenter wp-image-28228" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/112188892-57bd2d80-8bfb-11eb-9044-66bca3e1b2b0.png" alt="Visualisation of various chrono types" width="743" height="368" /></a></span></p>
<p>&nbsp;</p>
<h1 id="contribute-now"><span data-contrast="auto">Contribute now!</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We are happy with the results of this change, and we would like to see more. After you make changes to the visualizer you can test them by adding the natvis file to any Visual Studio C++ project by right clicking your project, selecting Add &gt; Existing Item, and choosing the STL.natvis file. After doing this you should be able to see your changes in a Visual Studio debugging session. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.png"><img class="aligncenter wp-image-28227" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.png" alt="Selecting the STL.natvis file" width="257" height="189" /></a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/">STL Visualizers on GitHub</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
	</channel>
</rss>
