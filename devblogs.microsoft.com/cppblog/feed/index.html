<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Wed, 12 May 2021 18:12:24 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>OpenMP Updates and Fixes for C++ in Visual Studio 2019 version 16.10</title>
		<link>https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/</link>
					<comments>https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/#respond</comments>
		
		<dc:creator><![CDATA[Chris Pulido]]></dc:creator>
		<pubDate>Wed, 12 May 2021 18:12:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27978</guid>

					<description><![CDATA[<p>In our previous blog post about improved OpenMP support in Visual Studio, we announced the addition of the -openmp:llvm switch in Visual Studio 2019 version 16.9 to enable compiled programs to target LLVM’s OpenMP runtime library for the x64 architecture. This switch supports all the OpenMP 2.0 directives that -openmp supports,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/">OpenMP Updates and Fixes for C++ in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In our <a href="https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/">previous blog post</a> about improved OpenMP support in Visual Studio, we announced the addition of the <strong>-openmp:llvm</strong> switch in Visual Studio 2019 version 16.9 to enable compiled programs to target LLVM’s OpenMP runtime library for the x64 architecture. This switch supports all the OpenMP 2.0 directives that <strong>-openmp</strong> supports, as well as unsigned integer indices in parallel for loops, and a subset of the SIMD directives that are supported under <strong>-openmp:experimental</strong>. It also enabled a few correctness fixes. Starting in <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 version 16.10 Preview 2</a>, the <strong>-openmp:llvm </strong>switch now works for x86 and arm64. We have also fixed a couple of bugs in 16.10 Preview 3.</p>
<h1 id="openmpllvm-now-available-for-x86-and-arm64">-openmp:llvm Now Available for x86 and arm64</h1>
<p>Starting in Visual Studio 2019 version 16.10 Preview 2, in addition to X64 support, we have added support for targeting LLVM’s OpenMP runtime library with <strong>-openmp:llvm </strong>for the x86 and ARM64 architectures. Compiling with <strong>-openmp:llvm </strong>will automatically add a dynamic link to libomp140.i386.dll (or libomp140d.i386.dll under <strong>/DEBUG</strong>) when targeting x86, or libomp140.aarch64.dll (or libomp140d.aarch64.dll under <strong>/DEBUG</strong>) when targeting ARM64. You can find these libraries under the Visual Studio installation directory at <code>VC\Redist\MSVC\&lt;version&gt;\debug_nonredist\&lt;arch&gt;\Microsoft.VC142.OpenMP.LLVM</code>.</p>
<p>As a reminder, the <strong>-openmp:llvm</strong> switch is experimental, and features from OpenMP 3.0 that were added with the <strong>-openmp:llvm</strong> switch in Visual Studio version 16.9 are still only supported with the additional
<strong>-openmp:experimental</strong> flag in Visual Studio version 16.10, and thus are provided with certain limitations in 16.10. In particular, <strong>#pragma omp task </strong>is not yet available on x86 or arm64, and there is only limited functionality on x64 in 16.10. Lastly, future versions of the LLVM OpenMP runtime DLLs may not be backwards compatible and the current version of these DLLs is not redistributable.</p>
<h1 id="bug-fixes-in-16-10-preview-3">Bug Fixes in 16.10 Preview 3</h1>
<ul>
<li><strong>return</strong> statements inside parallel regions now issue a helpful error message since they are non-conforming. The snippet below would previously crash the compiler with an <a href="https://developercommunity2.visualstudio.com/t/Return-in-OpenMP-loop-causes-internal-co/908052">internal compiler error</a>.</li>
</ul>
<pre class="prettyprint">#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "Hello World!\n";

#pragma omp parallel for schedule(dynamic)
    for (auto i = 0; i &lt; 100; ++i)
    {
        // should issue error C3010: 'return': jump out of OpenMP structured block not allowed
        return -1;  
    }

    return 0;
}</pre>
<ul>
<li>The <strong>if</strong> clause now chooses the correct scope for a variable. In the snippet below, the inner <strong>if </strong>clause was referencing the outer shared variable <strong>i</strong> which has a value of 1, rather than the inner private variable <strong>i</strong> which has the value of 0, causing the program to print “nested” four times instead of one. A similar fix was also applied to the <strong>num_threads</strong> clause.</li>
</ul>
<pre class="prettyprint">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
int main(void)
{
  int i = 1;
  int retVal = 0;
  #pragma omp parallel if(retVal) default(none) private(i)
  {
    printf("hello\n");
    i = 0;
    #pragma omp parallel if(i) default(none) num_threads(4)
    {
      printf("nested\n");
    }
  }
  return 0;
}</pre>
<h1 id="our-openmp-plans">Our OpenMP Plans</h1>
<p>As of 16.10, the currently supported standard is still OpenMP 2.0, though we have made some improvements and fixed some long-standing bugs. We have started the long process to support newer versions of the OpenMP standard. Our goal is to support the most recent OpenMP standard, and this will be done step-by-step, with new features leveraging LLVM’s OpenMP runtime. Our next step for OpenMP will be to support the additional features added in the OpenMP 3.1 standard. Then we will add support for the pragmas and clauses added in the OpenMP 4.5 standard that do not involve offloading. Which features are added first after that will depend on your feedback. We would love to hear from you which specific OpenMP features you would like to see first.</p>
<h1 id="feedback">Feedback</h1>
<p>We encourage you to try out this update in the latest <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 version 16.10 Preview</a>. If you encounter a correctness issue in code generated with the <strong>-openmp:llvm</strong> switch or bugs in the libomp140 DLLs shipped with Visual Studio, please let us know. We can be reached via the comments below, via twitter (<a href="https://twitter.com/visualc">@visualc</a>), or via <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/">OpenMP Updates and Fixes for C++ in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>New Static Analysis Rule for Bounds Checking</title>
		<link>https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/</link>
					<comments>https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/#respond</comments>
		
		<dc:creator><![CDATA[Jordan Maples]]></dc:creator>
		<pubDate>Tue, 11 May 2021 17:32:50 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[Writing Code]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[static analysis]]></category>
		<category><![CDATA[warning]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28054</guid>

					<description><![CDATA[<p>We have added a new experimental static analysis rule in Visual Studio 16.10 version Preview 3 &#8211; C26458, WARNING_PATH_SENSITIVE_USE_GSL_AT. The new warning is a more precise and less noisy version of warning C26446, WARNING_USE_GSL_AT. Both warnings analyse standard containers for unchecked element access and they both share the warning message: “Prefer to use gsl::at() instead of unchecked subscript operator (bounds.4).” This new warning,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/">New Static Analysis Rule for Bounds Checking</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We have added a new experimental static analysis rule in Visual Studio 16.10 version Preview 3 &#8211; C26458, <code>WARNING_PATH_SENSITIVE_USE_GSL_AT</code>. The new warning is a more precise and less noisy version of warning C26446, <code>WARNING_USE_GSL_AT</code>. Both warnings analyse standard containers for unchecked element access and they both share the warning message: “Prefer to use <code>gsl::at()</code> instead of unchecked subscript operator (bounds.4).” This new warning, however, uses path sensitive analysis to track buffer size validation calls to provide a less noisy, more targeted warning compared to C26446.</p>
<p>Path sensitive analysis is not an inexpensive operation: the complexity and time required to analyze each function depends on the length, number of branching operations, and individual properties that are tracked in each function. The path simulation walks the function and emulates each branch and loop that it encounters, updating an internal state based on various assumptions made in the code. Consider the following code segment:</p>
<pre class="prettyprint">    int i{};
    // ...
    if (i &lt; v.size()) {
        // ...
    }
    // ...
</pre>
<p>As the simulation reaches the branch, the analysis forks its state. In one fork it tracks that <code>i</code> is less than <code>v.size()</code>, and in the other <code>i</code> is greater than or equal to <code>v.size()</code>. The analysis does not necessarily know the value of <code>i</code> or the number of elements in <code>v</code>. It will only know the relation between these two due to the comparison. The same branching happens when the analysis encounters a loop.</p>
<h3 id="example-and-comparison-to-c26446">Example and comparison to C26446:</h3>
<pre class="prettyprint">void function(std::vector&lt;int&gt;&amp; v)
{
    if(!v.empty())
        v[0]; // C26446
    v[0]; // C26446 and C26458
}
</pre>
<p>In the path sensitive check, one branch simulated knows that <code>v</code> is not empty proving that it is safe to access the first element, but in the other, <code>v</code> is empty, which is why the second access issues the warning. C26446, on the other hand, will warn on any <code>operator[]</code> call not made by a <code>gsl::span</code>.</p>
<h3 id="why-is-this-check-in-experimental-and-what-can-it-not-do">Why is this check in experimental and what can it not do?</h3>
<p>Currently, C26458 does not track expansion of the container. Meaning that calls to <code>push_back</code>, <code>emplace</code>, <code>insert</code>, etc. are not yet supported. Nor does it track removal of elements. However, unlike the expansion of the container, reduction requires full revalidation of the containers bounds. Support for expansion/reduction of containers will be added in a future update.</p>
<pre class="prettyprint">void function(std::vector&lt;int&gt;&amp; v)
{
    if (v.size() &gt; 2)
    {
        v[2]; // C26446

        v.push_back(0);
        v[2]; // C26446
        v[3]; // C26446 &amp; C26458

        v.erase(v.begin()); // element removal currently removes all assumptions for the container
        v[2]; // 26446 &amp; C26458
    }
}
</pre>
<h2 id="how-to-enable-c26458">How to enable C26458</h2>
<h3 id="enabling-the-rule-in-visual-studio">Enabling the rule in Visual Studio:</h3>
<p>In the Project Properties page: Navigate to Configuration Properties -&gt; Code Analysis -&gt; Microsoft and select C++ Core Guidelines Experimental Rules.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1.png"><img class="alignnone wp-image-28055 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1.png" alt="Image Picture1" width="624" height="389" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1-300x187.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>Alternatively, you can configure your current ruleset to include C26458.</p>
<p>We recommend that users disable C26446 when using C26458 to avoid duplicate warnings.</p>
<h2 id="feedback-and-follow-up">Feedback and follow up:</h2>
<p>Let us know your experience with the new checker, we are eager to hear back from all of you. Also, let us know if you would like to see more path sensitive rules like this in the future. Please download the latest <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2019</a> and give it a try! Any feedback is welcome. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a>, <a href="mailto:visualcpp@microsoft.com">email</a>, and <a href="https://twitter.com/visualc">Twitter</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/">New Static Analysis Rule for Bounds Checking</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Finding Bugs with AddressSanitizer: Patterns from Open Source Projects</title>
		<link>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/</link>
					<comments>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/#comments</comments>
		
		<dc:creator><![CDATA[Kevin Cadieux]]></dc:creator>
		<pubDate>Mon, 10 May 2021 19:05:14 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28026</guid>

					<description><![CDATA[<p>AddressSanitizer (ASan) was officially released in Visual Studio 2019 version 16.9. We recently used this feature to find and fix a bug in the MSVC compiler itself. To further validate the usefulness of our ASan implementation, we also used it on a collection of widely used open source projects where it found bugs in Boost,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/">Finding Bugs with AddressSanitizer: Patterns from Open Source Projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>AddressSanitizer (ASan) was <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/">officially released in Visual Studio 2019 version 16.9</a>. We recently used this feature to <a href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/">find and fix a bug in the MSVC compiler itself</a>. To further validate the usefulness of our ASan implementation, we also used it on a collection of widely used open source projects where it found bugs in Boost, Azure IoT C SDK, and OpenSSL. In this article, we present our findings by describing the type of bugs that we found and how they presented themselves in these projects. We provide links to the GitHub commits where these bugs were fixed so you can get a helpful look at what code changes were involved. If you are unfamiliar with what ASan is and how to use it, you may want to take a look at the <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-160">AddressSanitizer documentation</a> prior to delving into this article.</p>
<p>&nbsp;</p>
<h3 id="boost-and-the-eager-iterator"><span style="font-size: 18pt;">Boost and the Eager Iterator</span></h3>
<p>An <em>eager iterator</em> is one that points to an element outside the bounds of a container and is then dereferenced. The following code sample shows an example of this buggy memory access pattern:</p>
<pre class="prettyprint">template &lt;typename Iter&gt;
int ComputeSum(Iter b, Iter e)
{
    int sum = 0;

    for (; b &lt;= e; ++b) {
        // ERROR: will dereference the 'end' iterator
        // due to the use of the '&lt;=' operator above.
        sum += *b;
    }

    return sum;
}</pre>
<p>Sometimes, eager iterators can appear by mistake in loops that are more complex, such as in the <code>do_length</code> function from Boost&#8217;s UTF-8 conversion facet implementation, shown below:</p>
<pre class="prettyprint">int utf8_codecvt_facet::do_length(
    std::mbstate_t &amp;,
    const char * from,
    const char * from_end, 
    std::size_t max_limit
) const
#if BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(600))
        throw()
#endif
{ 
    int last_octet_count=0;
    std::size_t char_count = 0;
    const char* from_next = from;

    while (from_next+last_octet_count &lt;= from_end &amp;&amp; char_count &lt;= max_limit) {
        from_next += last_octet_count;
        last_octet_count = (get_octet_count(*from_next));
        ++char_count;
    }
    return static_cast&lt;int&gt;(from_next-from);
}</pre>
<p>Here, the less-or-equal operator is used to correctly set <code>from_next</code> to <code>from_end</code> when the latter points at a UTF-8 character boundary. However, this also causes a bug where the end iterator is dereferenced. Building this code with ASan and debugging it in Visual Studio results in an ASan break at the expected location:</p>
<p><img class="alignnone wp-image-28029" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-2.png" alt="Screenshot of a debugging session in Visual Studio showing an AddressSanitizer global buffer overflow error in the 'do_length' function at line 'last_octet_count = (get_octet_count(*from_next));'" width="700" height="456" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-2.png 700w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-2-300x195.png 300w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>We let the Boost team know about this issue and they promptly <a href="https://github.com/boostorg/detail/commit/131208d8ccd82ef69afb9cf0bad1a314bd931d88">committed a fix on GitHub</a>.</p>
<p>&nbsp;</p>
<h3 id="azure-iot-c-sdk-an-array-and-its-length-constant-disagree"><span style="font-size: 18pt;">Azure IoT C SDK: An Array and Its Length Constant Disagree</span></h3>
<p>A disagreement between an array and its length constant happens when a constant is used to keep track of the length of an array but has the incorrect length. This can result in memory access bugs when the length constant is used in memory copy operations. The simple example below illustrates the problem:</p>
<pre class="prettyprint">#include &lt;cstring&gt;

unsigned char GLOBAL_BUFFER[] = { 1,2,3,4,5 };
constexpr size_t BUF_SIZE = 6;

void CopyGlobalBuffer(unsigned char* dst)
{
    // ERROR: AddressSanitizer: global-buffer-overflow
    std::memcpy(dst, GLOBAL_BUFFER, BUF_SIZE);
}</pre>
<p>We found an instance of this bug in the Azure IoT C SDK, where the length constant for a string did not match the actual length:</p>
<pre class="prettyprint">static const unsigned char* TWIN_REPORTED_PROPERTIES = 
    (const unsigned char*)
    "{ \"reportedStateProperty0\": \"reportedStateProperty0\", "
    "\"reportedStateProperty1\": \"reportedStateProperty1\" }";

static int TWIN_REPORTED_PROPERTIES_LENGTH = 117;</pre>
<p>The value of the <code>TWIN_REPORTED_PROPERTIES_LENGTH</code> constant is 117 while the actual size of the <code>TWIN_REPORTED_PROPERTIES</code> string is 107, resulting in a global buffer overflow when copying the string with <code>memcpy</code>. Building this code with ASan and debugging with Visual Studio shows an error during a call to <code>memcpy</code>, in a deep internal function named <code>CONSTBUFFER_Create_Internal</code>:</p>
<p><img class="alignnone wp-image-28032" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-5.png" alt="Screenshot of a debugging session in Visual Studio showing an AddressSanitizer error in the 'CONSTBUFFER_Create_Internal' function on line '(void)memcpy(temp, source, size);'" width="700" height="456" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-5.png 700w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-5-300x195.png 300w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>This didn’t immediately tell us what the origin of the bug was, but thanks to the ASan integration within Visual Studio, it was possible to use the Call Stack window to walk up the stack and find the function that passed the incorrect size value:</p>
<p><img class="alignnone wp-image-28033" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-6.png" alt="Screenshot of the Call Stack window from a debugging session in Visual Studio. The call stack contains the following functions: CONSTBUFFER_Create_Internal, real_CONSTBUFFER_Create, send_one_report_patch, twin_msgr_do_work_started_with_EXPIRED_in_progress_patches_success, RunTests, and main." width="698" height="205" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-6.png 698w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-6-300x88.png 300w" sizes="(max-width: 698px) 100vw, 698px" /></p>
<p>The culprit in this case was the <code>send_one_report_patch</code> function, which passed <code>TWIN_REPORTED_PROPERTIES</code> and <code>TWIN_REPORTED_PROPERTIES_LENGTH</code> to a function that indirectly calls <code>CONSTBUFFER_Create_Internal</code>:</p>
<pre class="prettyprint">static void send_one_report_patch(TWIN_MESSENGER_HANDLE handle, time_t current_time)
{
    const unsigned char* buffer = (unsigned char*)TWIN_REPORTED_PROPERTIES;
    size_t size = TWIN_REPORTED_PROPERTIES_LENGTH;
    CONSTBUFFER_HANDLE report = real_CONSTBUFFER_Create(buffer, size);

    umock_c_reset_all_calls();
    set_twin_messenger_report_state_async_expected_calls(report, current_time);
    (void)twin_messenger_report_state_async(handle, report, 
        TEST_on_report_state_complete_callback, NULL);

    real_CONSTBUFFER_DecRef(report);
}</pre>
<p>We fixed this issue by using the <code>sizeof</code> operator to set the length constant to a value that always reflects the actual size of the string. You can find our <a href="https://github.com/Azure/azure-iot-sdk-c/commit/79f6983b2ed86541bbdd943dbee59390efdd0ca9#diff-3c98bfc52b3211e281a71ec49c4ad26d5d0bb632f26795d33982d5e04abe2c31">bug fix commit on GitHub</a>.</p>
<p>&nbsp;</p>
<h3 id="openssl-and-the-shapeshifting-type"><span style="font-size: 18pt;">OpenSSL and the Shapeshifting Type</span></h3>
<p>A shapeshifting type is born when a type’s size varies depending on a preprocessor definition. If the type is then assumed to have a specific size, memory access bugs can occur. A simple example is shown below:</p>
<pre class="prettyprint">#include &lt;cstdint&gt;
#include &lt;cstring&gt;
#include &lt;array&gt;

#ifdef BIGGER_INT
typedef int64_t MyInt;
#else
typedef int32_t MyInt;
#endif

MyInt GLOBAL_BUFFER[] = { 1,2,3,4,5 };

void SizeTypeExample()
{
    int localBuffer[std::size(GLOBAL_BUFFER)];

    // ERROR: AddressSanitizer: stack-buffer-overflow
    std::memcpy(localBuffer, GLOBAL_BUFFER, sizeof(GLOBAL_BUFFER));
}</pre>
<p>If <code>BIGGER_INT</code> is defined, the <code>memcpy</code> operation might trigger a stack buffer overflow due to the <code>localBuffer</code> variable assuming <code>MyInt</code> has a size identical to <code>int</code>. An instance of this bug was found in the <code>test_param_time_t</code> OpenSSL test:</p>
<pre class="prettyprint">static int test_param_time_t(int n)
{
    time_t in, out;
    unsigned char buf[MAX_LEN], cmp[sizeof(size_t)];
    const size_t len = raw_values[n].len &gt;= sizeof(size_t)
                       ? sizeof(time_t) : raw_values[n].len;
    OSSL_PARAM param = OSSL_PARAM_time_t("a", NULL);

    memset(buf, 0, sizeof(buf));
    le_copy(buf, raw_values[n].value, sizeof(in));
    memcpy(&amp;in, buf, sizeof(in));
    param.data = &amp;out;
    if (!TEST_true(OSSL_PARAM_set_time_t(&amp;param, in)))
        return 0;
    le_copy(cmp, &amp;out, sizeof(out));
    if (!TEST_mem_eq(cmp, len, raw_values[n].value, len))
        return 0;
    in = 0;
    if (!TEST_true(OSSL_PARAM_get_time_t(&amp;param, &amp;in)))
        return 0;
    le_copy(cmp, &amp;in, sizeof(in));
    if (!TEST_mem_eq(cmp, sizeof(in), raw_values[n].value, sizeof(in)))
        return 0;
    param.data = &amp;out;
    return test_param_type_extra(&amp;param, raw_values[n].value, sizeof(size_t));
}</pre>
<p>Here, <code>size_t</code> is assumed to be the same type as <code>time_t</code>, but this is not always the case depending on the architecture being compiled for. When copying <code>out</code> to <code>cmp</code> using the <code>le_copy</code> function, the size of the copying operation is <code>sizeof(time_t)</code> but the <code>cmp</code> buffer was initialized with size <code>size_t</code>. When building the OpenSSL tests with ASan and debugging with Visual Studio, the debugger breaks with an ASan error inside <code>le_copy</code>:</p>
<p><img class="alignnone wp-image-28037" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-10.png" alt="Screenshot of a debugging session in Visual Studio, showing an AddressSanitizer error in the 'le_copy' function on line 'memcpy(out, in, len)'." width="700" height="445" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-10.png 700w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-10-300x191.png 300w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>Again, thanks to the ASan integration in VS, we were able to use the call stack window to walk up to the actual source of the bug: the <code>test_param_time_t</code> function:</p>
<p><img class="alignnone wp-image-28038" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-11.png" alt="Screenshot of the Call Stack window from a Visual Studio debugging session. The call stack contains the following functions: le_copy, test_param_time_t, run_tests, and main." width="696" height="182" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-11.png 696w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-11-300x78.png 300w" sizes="(max-width: 696px) 100vw, 696px" /></p>
<p>We let the OpenSSL team know about this bug and a fix was <a href="https://github.com/openssl/openssl/commit/628d2d3a7f2318b6a6a1c36f9d8d12032c69a9dd">committed on GitHub</a>.</p>
<p>&nbsp;</p>
<h3 id="try-addresssanitizer-today"><span style="font-size: 18pt;">Try AddressSanitizer Today!</span></h3>
<p>In this article, we shared how we were able to use AddressSanitizer to find bugs in various open source projects. We hope this will motivate you to try out this feature on your own code base. Have you found eager iterators, shapeshifting types, or array / length constant disagreements in your projects? Let us know in the comments below, on Twitter <a href="https://twitter.com/visualc">(@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p><em>This article contains code snippets from the following sources:</em></p>
<p><em><a href="https://github.com/boostorg/detail/blob/b29edf18cb94b01076c2cca1d72b32dc684ee575/include/boost/detail/utf8_codecvt_facet.ipp">utf8_codecvt_facet.ipp</a> file, <a href="https://github.com/boostorg/boost">Boost C++ Libraries</a>, Copyright (c) 2001 Ronald Garcia and Andrew Lumsdaine, distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</em></p>
<p><em><a href="https://github.com/Azure/azure-iot-sdk-c">Azure IoT C SDKs and Libraries</a>, Copyright (c) Microsoft Corporation, distributed under the <a href="https://github.com/Azure/azure-iot-sdk-c/blob/116d971f17a64d79ca745b46d707c8210dbe3437/LICENSE">MIT License</a>.</em></p>
<p><em><a href="https://github.com/Azure/azure-c-shared-utility">Azure C Shared Utility</a>, Copyright (c) Microsoft Corporation, distributed under the <a href="https://github.com/Azure/azure-c-shared-utility/blob/c4e4d472679958b595a06c58849e3e2faf0074b7/LICENSE">MIT License</a>.</em></p>
<p><em><a href="https://github.com/openssl/openssl/blob/8020d79b4033400d0ef659a361c05b6902944042/test/params_api_test.c">params_api_test.c</a> file, <a href="https://github.com/openssl/openssl">OpenSSL</a>, Copyright 2019-2021 The OpenSSL Project Authors, Copyright (c) 2019 Oracle and/or its affiliates, distributed under the <a href="https://www.apache.org/licenses/LICENSE-2.0.txt">Apache License 2.0</a>.</em></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/">Finding Bugs with AddressSanitizer: Patterns from Open Source Projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>2x-3x Performance Improvements for Debug Builds</title>
		<link>https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/</link>
					<comments>https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/#comments</comments>
		
		<dc:creator><![CDATA[Pranav Kant]]></dc:creator>
		<pubDate>Fri, 07 May 2021 12:38:13 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[faster]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[debug builds]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27969</guid>

					<description><![CDATA[<p>We have made substantial runtime performance improvements in the x86/x64 C++ compiler for Visual Studio&#8217;s default debug configuration. For Visual Studio 2019 version 16.10 Preview 2, we measure 2x &#8211; 3x speedup for programs compiled in debug mode. These improvements come from reducing the overhead introduced by runtime checks (/RTCs) which are enabled by default. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/">2x-3x Performance Improvements for Debug Builds</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">We have made substantial runtime performance improvements in the x86/x64 C++ compiler for Visual Studio&#8217;s default debug configuration. For </span><a href="https://visualstudio.microsoft.com/vs/preview/%22%20/"><span data-contrast="none">Visual Studio 2019</span><span data-contrast="auto"> version 16.10 Preview 2</span></a><span data-contrast="auto">, we measure 2x &#8211; 3x speedup for programs compiled in debug mode. These improvements come from reducing the overhead introduced by runtime checks (/RTCs) which are enabled by default.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h3 id="default-debug-configuration"><b><span data-contrast="auto">Default debug configuration</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h3>
<p><span data-contrast="auto">When you compile your code in debug configuration in Visual Studio, there are some flags that are passed to the C++ compiler by default. Most relevant to this blog post are </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks?view=msvc-160"><span data-contrast="none">/RTC1</span></a><span data-contrast="auto">, </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/jmc?view=msvc-160"><span data-contrast="none">/JMC</span></a><span data-contrast="auto"> and </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/z7-zi-zi-debug-information-format?view=msvc-160"><span data-contrast="none">/ZI</span></a><span data-contrast="auto">. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">While all of these flags add useful debugging functionality, their interactions, particularly when /RTC1 is involved, add significant overhead. In this release, we removed the unnecessary overhead while making sure they keep helping you find bugs and make your debugging experience smoother.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Consider the following simple function:</span></p>
<div>
<div>
<pre>1    int foo() {
2        return 32;
3    }</pre>
</div>
</div>
<p>and <span data-contrast="auto">the x64 assembly generated by the 16.9 compiler when compiled with /RTC1 /JMC /ZI (<a href="https://godbolt.org/z/MnWehTso7">Godbolt link</a>):</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<div>
<pre>1    int foo(void) PROC                  
2    $LN3:
3            push rbp
4            push rdi
5            sub rsp, 232                ; extra space allocated due to /ZI, /JMC
6            lea rbp, QWORD PTR [rsp+32]
7            mov rdi, rsp
8            mov ecx, 58                 ; (= x)
9            mov eax, -858993460         ; 0xCCCCCCCC
10           rep stosd                   ; write 0xCC on stack for x DWORDs
11           lea rcx, OFFSET FLAT:__977E49D0_example@cpp
12           ; call due to /JMC
13           call __CheckForDebuggerJustMyCode
14           mov eax, 32
15           lea rsp, QWORD PTR [rbp+200]
16           pop rdi
17           pop rbp
18           ret 0
19    int foo(void) ENDP</pre>
</div>
<p><span data-contrast="auto">In the assembly shown above, the /JMC and /ZI flags add a total of 232 additional bytes on the stack (line 5). This stack space is not always necessary. When combined with the /RTC1 flag, which initializes the allocated stack space (line 10), it consumes a lot of CPU cycles. In this specific example, even though the stack space we allocated is necessary for proper functioning of /JMC and /ZI, its initialization is not. We can prove at compile time that these checks are unnecessary. There are plenty of such functions in any real-world C++ codebase, and that’s where the performance benefit comes from.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Keep reading to get a deeper dive into each of these flags, their interactions with /RTC1, and how we avoid its unnecessary overhead.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="rtc1"><b><span data-contrast="auto">/RTC1</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><span data-contrast="auto">Using </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks?view=msvc-160"><span data-contrast="none">/RTC1</span></a><span data-contrast="auto"> flag is equivalent to using both /RTCs and /RTCu flags. /RTCs initializes the stack frame of functions by 0xCC to do various runtime checks namely, detecting uninitialized local variables, detecting array overrun and underruns, and stack pointer verification (for x86). You can see the code bloat with /RTCs </span><a href="https://godbolt.org/z/fEo9sYGTG"><span data-contrast="none">here</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">As seen in the above assembly code (line 10), the </span><code><i><span data-contrast="auto">rep stosd</span></i></code><span data-contrast="auto"> instruction, introduced by /RTCs, is the main reason for the slowdown. The situation is exacerbated when /RTCs (or /RTC1) is used in conjunction with /JMC, /ZI, or both.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="interactions-with-jmc"><b><span data-contrast="auto">Interactions with /JMC</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><a href="https://docs.microsoft.com/en-us/cpp/build/reference/jmc?view=msvc-160"><span data-contrast="none">/JMC</span></a><span data-contrast="auto"> stands for </span><i><span data-contrast="auto">Just My Code Debugging</span></i><span data-contrast="auto"> functionality</span><span data-contrast="auto">,</span><span data-contrast="auto"> and during debugging, it automatically skips over functions that are not written by you (such as framework, library, and other non-user code). It works by inserting a function call in the prologue that calls into the runtime library. This helps the debugger to distinguish between user and non-user code. The problem here is that inserting a function call into the prologue of every function in your project means that there are no leaf functions anymore in your whole project. If the function doesn&#8217;t need any stack frame originally, now it will, because as per </span><a href="https://docs.microsoft.com/en-us/cpp/build/stack-usage?view=msvc-160#stack-allocation"><span data-contrast="none">AMD64 ABI</span></a> for Windows platforms<span data-contrast="auto">, we need to have at least four stack slots available for function parameters (called <em>P</em></span><i><span data-contrast="auto">aram Home area</span></i><span data-contrast="auto">). This means all the functions that were not being initialized earlier by /RTCs, because they were leaf functions and had no stack frame, will now be initialized. It&#8217;s normal to have lots and lots of leaf functions in your program</span><span data-contrast="auto">,</span><span data-contrast="auto"> especially if you are using a heavily templated code library like C++ STL. /JMC will happily eat some of your CPU cycles in this case. This doesn&#8217;t apply for x86 (32 bit) because we don&#8217;t have any param home area there. You can see the effects of /JMC </span><a href="https://godbolt.org/z/v9qE3e7f5"><span data-contrast="none">here</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="interaction-with-zi"><b><span data-contrast="auto">Interaction with /ZI</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><span data-contrast="auto">The next interaction we are going to talk about is with /ZI. It enables your code for </span><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/edit-and-continue-visual-cpp?view=vs-2019"><span data-contrast="none">Edit and Continue</span></a><span data-contrast="auto"> support, which means you don&#8217;t need to recompile the whole program during debugging for small changes.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">In order to add such support, we add some padding bytes to the stack (the actual number of padding bytes depends on how big a function is). This way</span><span data-contrast="auto">,</span><span data-contrast="auto"> all the new variables you add during your debugging session can be allocated on the padding area without changing the total stack frame size, and you can continue your debugging without having to recompile your code.  See </span><a href="https://godbolt.org/z/oef3Pjn4G"><span data-contrast="none">here</span></a><span data-contrast="auto"> how enabling this flag adds an extra 64 bytes to the generated code.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">As you may have guessed, more stack area means more things to initialize by /RTCs, leading to more overhead.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h3 id="solution"><b><span data-contrast="auto">Solution</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h3>
<p><span data-contrast="auto">The root of all these problems is unnecessary initialization. Do we really need to initialize the stack area every time? No. One can safely prove within the compiler when stack initialization is really needed. For example, you need it when there is at least one address-taken variable, an array declared in your function or uninitialized variables. For every other case, we can safely skip over the initialization, as we are not going to find anything useful through runtime checks anyway.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">The situation gets a bit more complicated when you compile with edit-and-continue because now you may add uninitialized variables in the debugging session that can only be detected if we initialize the stack area. And we may not have done that. To solve this problem, we included the necessary bits in debugging info and exposed it via <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/debug-interface-access-sdk?view=vs-2019">Debug Interface Access SDK</a>. This information tells the debugger where the padding area introduced by /ZI </span><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiasymbol-get-framepadoffset?view=vs-2019"><span data-contrast="none">starts</span></a><span data-contrast="auto"> and </span><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiasymbol-get-framepadsize?view=vs-2019"><span data-contrast="none">ends</span></a><span data-contrast="auto">. It also tells the debugger if the function </span><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiasymbol-get-isrtcs?view=vs-2019"><span data-contrast="none">needed any stack initialization</span></a><span data-contrast="auto">. If so, the debugger then unconditionally initializes the stack area in this memory range for the functions that you have edited during your debugging session. The new variables are always allocated on top of this initialized area and our runtime checks can now detect if your newly added code is safe or not.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h3 id="results"><b><span data-contrast="auto">Results</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h3>
<p><span data-contrast="auto">We compiled following projects in default debug configuration and then used the generated executables to run tests. We noticed 2x – 3x improvements in all the projects we tried. More STL-heavy projects may see larger improvements. Let us know in the comments any improvements you noticed in your projects. Project 1 and </span><a href="https://zeux.io/2019/01/17/is-c-fast/"><span data-contrast="none">Project 2</span></a><span data-contrast="auto"> are customer provided samples.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5.png"><img class="size-full wp-image-28007 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5.png" alt="Image results" width="1024" height="570" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5-300x167.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5-768x428.png 768w" sizes="(max-width: 1024px) 100vw, 1024px" /></a></p>
<p>&nbsp;</p>
<h4 id="tell-us-what-you-think"><b><span data-contrast="auto">Tell us what you think!</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><span data-contrast="auto">We hope this speedup makes your debugging workflow efficient and enjoyable. We are continuously listening to your feedback and working towards improving your inner loop experience. We’d love to hear about your experience in the comments below. You can also get in touch with us at </span><a href="https://developercommunity.visualstudio.com/spaces/8/index.html"><span data-contrast="none">Developer Community</span></a><span data-contrast="none">, email (</span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="none">), and Twitter (</span><a href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span data-contrast="none">).</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/">2x-3x Performance Improvements for Debug Builds</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>Ignoring Automatic Initialization for Code Analysis</title>
		<link>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/</link>
					<comments>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Thu, 06 May 2021 15:00:15 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27927</guid>

					<description><![CDATA[<p>Reading uninitialized memory is one of the major sources of security vulnerabilities in C and C++ programs. Microsoft developed many tools to find such errors including compiler warnings, static analysis checks, and more recently: code instrumentation.  For a more detailed overview of uninitialized memory related vulnerabilities and mitigations please refer to Microsoft Security Response Center’s great blog post.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/">Ignoring Automatic Initialization for Code Analysis</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">Reading uninitialized memory is one of the major sources of security vulnerabilities in C and C++ programs. Microsoft developed many tools to find such errors including compiler warnings, static analysis checks, and more recently: code instrumentation.  For a more detailed overview of uninitialized memory related vulnerabilities and mitigations please refer to <a href="https://msrc-blog.microsoft.com/2020/05/13/solving-uninitialized-stack-memory-on-windows/">Microsoft Security Response Center’s great blog post</a></span><span data-contrast="auto">. This blog post summarizes the potential interactions between code analysis and code instrumentation and improvements we&#8217;ve made in Visual Studio 2019 version 16.9.1.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">When we turn on the automatic initialization features of MSVC it will initialize certain constructs on the stack with a pattern. This solution can help mitigate the risks of reading uninitialized memory. However, to keep the performance costs of this mitigation minimal, the compiler will not initialize everything. It is a best effort method that tries to hit a good balance in mitigating security risks and avoiding noticeable performance regressions. Moreover, this is a non-standard feature that might not be available (or might behave differently) in other compilers, or in other versions of the same compiler. As a result, users should never rely on such an instrumentation. The proper fix is to explicitly initialize memory in the source code and only use instrumentation as a mitigation for any error that slipped through the code reviews, static analysis or any other tools of the QA process.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">As a result, we want the compiler to warn on the following code regardless of the options used to compile the code:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint">void g(int); 
void f() { 
    int l; 
    g(l); // Warning C6001 expected regardless of the build configuration. 
}</pre>
<p><span data-contrast="auto">Starting from Visual Studio 2019 version 16.9.1, and 16.10 Preview 2 we ensured that the code analysis always sees the code as written as opposed to the instrumented version.  This behavior is in line with other toolchains and encourages developers to not rely on the automatic initialization feature.</span></p>
<p>Download the latest <a href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noopener">Visual Studio 2019 Preview</a> today and give it a try. We’d love to hear from you to help us prioritize and build the right features for you. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/spaces/8/index.html" target="_blank" rel="noopener">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>). The best way to file a bug or suggest a feature is via Developer Community.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/">Ignoring Automatic Initialization for Code Analysis</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/feed/</wfw:commentRss>
			<slash:comments>7</slash:comments>
		
		
			</item>
		<item>
		<title>Pure Virtual C++ 2021 is Today</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/</link>
					<comments>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 03 May 2021 09:41:17 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27954</guid>

					<description><![CDATA[<p>Pure Virtual C++, a free one-day virtual conference for the whole C++ community, is starting today (May 3rd) at 14:30 UTC. You can watch it and interact with the speakers at Learn TV. There&#8217;ll be sessions on C++20 modules, CMake, vcpkg,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/">Pure Virtual C++ 2021 is Today</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png"><img class="aligncenter size-full wp-image-27841" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png" alt="Image word image" width="1376" height="362" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w" sizes="(max-width: 1376px) 100vw, 1376px" /></a></p>
<p><a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event-2021/">Pure Virtual C++</a>, a free one-day virtual conference for the whole C++ community, is starting today (May 3rd) at 14:30 UTC. You can watch it and interact with the speakers at <a href="https://docs.microsoft.com/en-gb/learn/tv/">Learn TV</a>. There&#8217;ll be sessions on C++20 modules, CMake, vcpkg, and code analysis.</p>
<p>All of our pre-conference demos, including what&#8217;s new in C++20 support in MSVC, are now live on <a href="https://www.youtube.com/playlist?list=PLReL099Y5nRcWPNnKO4cwxN5RJZl9A48P">YouTube</a>.</p>
<p>Hope to see you there!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/">Pure Virtual C++ 2021 is Today</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Pure Virtual C++ 2021 Schedule Available</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 20 Apr 2021 18:03:44 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27919</guid>

					<description><![CDATA[<p>The schedule for Pure Virtual C++ 2021 is now live on the event website. Remember to sign up to be the first to access our extra on-demand C++ demos and get more virtual surprises.<br />
Schedule<br />
All times are on Monday 3rd May 2021 UTC.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/">Pure Virtual C++ 2021 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The schedule for Pure Virtual C++ 2021 is <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">now live on the event website</a>. Remember to sign up to be the first to access our extra on-demand C++ demos and get more virtual surprises.</p>
<h1 id="schedule">Schedule</h1>
<p>All times are on Monday 3<sup>rd</sup> May 2021 UTC. Abstracts and speaker bios are available on the <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">website</a>.</p>
<ul>
<li>14:30-15:00 UTC: Visibility, Reachability, Linkage &#8211; The Three Secret Spices of C++ Modules by Daniela Engert</li>
<li>15:00-15:30 UTC: An Introduction to CMakePresets.json by Erika Sweet, Kyle Edwards, and Bill Hoffman</li>
<li>15:40-16:10 UTC: Manage code dependencies at work with new vcpkg features by Augustin Popa</li>
<li>16:15-16:45 UTC: Code Analysis: Empowering developers to write performant, reliable, and safe C++ by Sunny Chatterjee</li>
<li>16:50-17:20 UTC: C++ Modules: Year 2021 by Gabriel Dos Reis</li>
</ul>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/">Pure Virtual C++ 2021 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
		<item>
		<title>CMake Presets integration in Visual Studio and Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/#comments</comments>
		
		<dc:creator><![CDATA[Erika]]></dc:creator>
		<pubDate>Tue, 20 Apr 2021 16:30:20 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27911</guid>

					<description><![CDATA[<p>CMakePresets.json was released in CMake 3.19 and 3.20 and allows users to specify common configure, build, and test options and share them with others. We have added support for CMakePresets.json in Visual Studio and the CMake Tools extension for Visual Studio Code.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">CMake Presets integration in Visual Studio and Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">CMakePresets.json</a> was released in CMake 3.19 and 3.20 and allows users to specify common configure, build, and test options and share them with others. We have added support for CMakePresets.json in Visual Studio and the CMake Tools extension for Visual Studio Code. You can now invoke CMake with the same CMakePresets.json file in Visual Studio, in Visual Studio Code, in a Continuous Integration pipeline, and from the CLI on Windows, Linux, and macOS.</p>
<p>Our CMake Presets integration is now available in preview in <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 version 16.10 Preview 2</a> and <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools version 1.7</a>.</p>
<h4 id="why-should-i-use-cmake-presets">Why should I use CMake Presets?</h4>
<p>CMake released support for <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#configure-preset">Configure Presets</a> in CMake 3.19. Our team at Microsoft contributed support for <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#build-preset">Build Presets</a> and <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#test-preset">Test Presets</a> in CMake 3.20. We’re excited to adopt CMake Presets to address some common problems related to CMake configuration and build.</p>
<ul>
<li><strong>Move seamlessly between Visual Studio and Visual Studio Code. </strong>With the adoption of CMakePresets.json, the same file can be used to drive CMake in both Visual Studio and Visual Studio Code. This makes it easier for developers on your team to hop between Visual Studio and Visual Studio Code and work in the development environment that best suits their needs.</li>
<li><strong>Project-specific information can always be checked in. </strong>CMake supports two files: CMakePresets.json and CMakeUserPresets.json. CMakePresets.json is intended to save project-wide presets, while CMakeUserPresets.json is intended for developers to save their own local presets. This ensures project-specific information can always be checked into source control and makes it easier for new team members to get up-and-running. It also makes it easier for teams to synchronize changes to their CMake builds across the entire team. Both CMakePresets.json and CMakeUserPresets.json are supported in Visual Studio and Visual Studio Code.</li>
<li><strong>Reproduce builds in Visual Studio and Visual Studio Code from the CLI. </strong>Since CMakePresets.json is supported by CMake itself, the same CMakePresets.json file can be used to invoke CMake in Visual Studio, in Visual Studio Code, in a Continuous Integration pipeline, and from the CLI on Windows, Linux, and macOS. CMake 3.20 or higher is required to build with CMakePresets.json from the CLI.</li>
<li><strong>Streamline build instructions for open source CMake projects. </strong>You can pull down any project that has a CMakePresets.json file at the root of the repository and build and test it locally using the instructions encoded in a preset. All command arguments that can be passed to CMake or CTest from the command line can be specified in a Configure, Build, or Test Preset.</li>
</ul>
<p>For more information on CMake Presets, you can check out my recent <a href="https://www.youtube.com/watch?v=-NhaPNq16Qk">session at ACCU</a> where I demonstrate how to use CMakePresets.json in Visual Studio, from the CLI, and in a GitHub Actions pipeline. You can also view a <a href="https://github.com/esweet431/box2d-lite/blob/main/CMakePresets.json">sample CMakePresets.json file</a>, register for <a href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2021-conference/">Pure Virtual C++</a>, or read the <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">official CMake documentation</a>. More information on CMake Presets integration in Visual Studio and VS Code is below.</p>
<h4 id="cmake-presets-in-visual-studio">CMake Presets in Visual Studio</h4>
<p>The best resource to learn about our CMake Presets integration in Visual Studio is our <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">documentation</a>. CMake Presets integration in Visual Studio is still in preview.</p>
<p>CMakePresets.json will be a recommended alternative to CMakeSettings.json. Visual Studio will never read from both CMakePresets.json and CMakeSettings.json at the same time. You can enable CMake Presets integration for all projects in <strong>Tools &gt; Options &gt; CMake &gt; General</strong>. You must close and reopen the folder in Visual Studio to activate the integration.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable.png"><img class="aligncenter size-full wp-image-27912" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable.png" alt="The Tools &gt; Options &gt; CMake dialog in Visual Studio. The option to &quot;Use CMakePresets.json to drive CMake configure, build, and test&quot; is checked and underscored in red." width="740" height="429" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable.png 740w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable-300x174.png 300w" sizes="(max-width: 740px) 100vw, 740px" /></a>You can enable CMake Presets integration for a single project by adding a CMakePresets.json file to the root of the open folder. Again, you must close and reopen the folder to activate the integration. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#enable-cmakepresetsjson-integration-in-visual-studio-2019">Enable CMake Presets integration in Visual Studio 2019</a> for more information.</p>
<p>Once CMake Presets integration is enabled, you will see three dropdowns across the menu bar.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets.png"><img class="aligncenter size-full wp-image-27914" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets.png" alt="The menu bar has 3 dropdowns. The dropdown on the left reads &quot;WSL: ubuntu2004&quot;, the dropdown in the middle reads &quot;ninja-debug&quot;, and the dropdown on the right reads &quot;verbose-build&quot;. " width="664" height="158" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets.png 664w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets-300x71.png 300w" sizes="(max-width: 664px) 100vw, 664px" /></a></p>
<p>The dropdown on the left indicates the active <strong>Target System</strong>. This is the system where CMake will be invoked to configure and build the project. This dropdown lists your local machine, all SSH connections in the <a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-160#set-up-the-remote-connection">Connection Manager</a> by host name, and all Windows Subsystem for Linux (WSL) installations that Visual Studio can find.</p>
<p>The dropdown in the middle indicates the active <strong>Configure Preset</strong>. This is the Configure Preset that will be used when CMake is invoked to generate the project build system. This dropdown lists the union of non-hidden Configure Presets defined in CMakePresets.json and CMakeUserPresets.json that apply to the active <strong>Target System</strong>. The active Configure Preset in the image above is ninja-debug.</p>
<p>The dropdown on the right indicates the active <strong>Build Preset</strong>. This is the Build Preset that will be used when CMake is invoked to build the project. This dropdown lists the union of non-hidden Build Presets defined in CMakePresets.json and CMakeUserPresets.json that apply to the active <strong>Configure Preset</strong>. The active Build Preset in the image above is verbose-build. Check out our documentation on <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#configure-and-build">CMake configuration and build</a> to learn more.</p>
<p>With Visual Studio you can edit, build, and debug your CMake targets on Windows, WSL, and remote systems from the comfort of a single IDE. Visual Studio will automatically copy your source code to the specified target system, but your build tools (CMake, generator, compilers), rsync, zip, and gdb must be already installed. See <a href="https://docs.microsoft.com/en-us/cpp/linux/download-install-and-setup-the-linux-development-workload?view=msvc-160#options-for-creating-a-linux-environment">Creating a Linux environment</a> for more information.</p>
<p>For more information on adding presets, editing presets, running tests, and more, see our documentation on <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">CMake Presets integration in Visual Studio</a>.</p>
<h4 id="cmake-presets-in-the-cmake-tools-extension-for-visual-studio-code">CMake Presets in the CMake Tools extension for Visual Studio Code</h4>
<p>The best resource to learn about CMake Presets integration in the CMake Tools extension is our <a href="https://github.com/microsoft/vscode-cmake-tools/blob/develop/docs/cmake-presets.md">documentation</a>. CMake Presets integration in the CMake Tools extension is still in preview.</p>
<p>CMakePresets.json will be a recommended alternative to kits and variants files. CMake Tools will never read from both CMakePresets.json and kits and variants files at the same time. You can enable CMake Presets integration by modifying the value of cmake.useCMakePresets in settings.json.</p>
<table>
<tbody>
<tr>
<td width="163">
<p style="text-align: center;"><strong>Setting</strong></p>
</td>
<td width="221">
<p style="text-align: center;"><strong>Description</strong></p>
</td>
<td width="144">
<p style="text-align: center;"><strong>Accepted values</strong></p>
</td>
<td width="96">
<p style="text-align: center;"><strong>Default value</strong></p>
</td>
</tr>
<tr>
<td style="text-align: center;" width="163">cmake.useCMakePresets</td>
<td style="text-align: center;" width="221">Use CMakePresets.json to drive CMake configure, build, and test</td>
<td style="text-align: center;" width="144">always, never, auto</td>
<td style="text-align: center;" width="96">auto</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><strong>auto </strong>evaluates to <strong>always</strong> if there’s a CMakePresets.json in the cmake.sourceDirectory of the active folder. It evaluates to <strong>never</strong> if there isn’t a CMakePresets.json file in the cmake.sourceDirectory of the active folder. Set cmake.useCMakePresest to <strong>always </strong>or <strong>never</strong> to explicitly enable or disable CMake Presets integration for all CMake projects. See <a href="https://github.com/microsoft/vscode-cmake-tools/blob/develop/docs/cmake-presets.md#enable-cmakepresetsjson-in-the-cmake-tools-extension">Enable CMake Presets in the CMake Tools extension</a> for more information.</p>
<p>Once CMake Presets integration is enabled, you can run several new commands.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette.png"><img class="aligncenter size-full wp-image-27915" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette.png" alt="The command palette is open in Visual Studio Code and reads &quot;&gt;CMake: Preset&quot;. Several commands specific to CMake Presets are available including &quot;CMake: Add Configure Preset&quot; and &quot;CMake: Select Build Preset&quot;. " width="619" height="189" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette.png 619w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette-300x92.png 300w" sizes="(max-width: 619px) 100vw, 619px" /></a></p>
<p>Use the commands <strong>CMake: Select Configure Preset</strong>, <strong>CMake: Select Build Preset</strong>, and <strong>CMake: Select Test Preset</strong> to select your active presets. Your active presets are displayed in the status bar.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar.png"><img class="aligncenter size-full wp-image-27916" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar.png" alt="Image status bar" width="863" height="41" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar.png 863w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar-300x14.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar-768x36.png 768w" sizes="(max-width: 863px) 100vw, 863px" /></a></p>
<p>In the image above, <strong>[active-configure-preset]</strong> indicates the active Configure Preset, <strong>[active-build-preset] </strong>indicates the active Build Preset, and <strong>[active-test-preset] </strong>indicates the active Test Preset.</p>
<p>For more information on adding presets, editing presets, running CMake, and more, see our documentation on <a href="https://github.com/microsoft/vscode-cmake-tools/blob/develop/docs/cmake-presets.md">CMake Presets integration in Visual Studio Code</a>.</p>
<h4 id="whats-next">What&#8217;s next?</h4>
<p>CMake Presets integration in Visual Studio and Visual Studio Code is still in preview. We’ll continue to add to our integration and address your feedback in future release of Visual Studio and the CMake Tools extension for VS Code.</p>
<p>In Visual Studio, the best way to file a bug or suggest a feature is with the <strong>Send Feedback</strong> button in the upper right-hand corner of the IDE. See <a href="https://docs.microsoft.com/en-us/visualstudio/ide/feedback-options?view=vs-2019#:~:text=In%20Visual%20Studio%2C%20choose%20the%20feedback%20icon%20in,information%2C%20see%20Suggest%20a%20feature%20for%20Visual%20Studio.">Visual Studio feedback options</a> for more information.</p>
<p>In VS Code, the best way to file a bug or suggest a feature is by creating (or upvoting) an issue in the <a href="https://github.com/microsoft/vscode-cmake-tools/issues">extension’s GitHub repository</a>.</p>
<p>We’d love to learn how your team is adopting CMakePresets.json. If you have feedback or a success story to share, you can contact us at <a href="mailto:cmake@microsoft.com">cmake@microsoft.com</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">CMake Presets integration in Visual Studio and Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/feed/</wfw:commentRss>
			<slash:comments>11</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ Extension April 2021 Update: CUDA C/C++ IntelliSense and Apple Silicon Support</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Thu, 15 Apr 2021 14:45:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27888</guid>

					<description><![CDATA[<p>The April 2021 update of the Visual Studio Code C++ extension is now available! This latest release offers brand new features—such as IntelliSense for CUDA C/C++ and native language server support for Apple Silicon— along with a bunch of enhancements and bug fixes. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/">Visual Studio Code C++ Extension April 2021 Update: CUDA C/C++ IntelliSense and Apple Silicon Support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">The April 2021 update of the </span><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"><span data-contrast="none">Visual Studio Code C++ extension</span></a><span data-contrast="auto"> is now available! This latest release offers brand new features—such as IntelliSense for CUDA C/C++ and native language server support for Apple Silicon— along with a bunch of enhancements and bug fixes. To find out more about all the enhancements, check out our </span><a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.3.0"><span data-contrast="none">release notes on GitHub.</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h2 aria-level="1" aria-level="1" id="cuda-c-c-intellisense"><b><span data-contrast="auto">CUDA C/C++ IntelliSense</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">We’re excited to announce that the C++ extension now provides IntelliSense for CUDA C/C++! CUDA is a parallel programming platform, enabling developers to interact with the GPU. Microsoft and NVIDIA have partnered together to light up the CUDA C/C++ development experience in VS Code. IntelliSense for CUDA C/C++ is currently available with <a href="https://code.visualstudio.com/insiders/">Visual Studio Code Insiders</a>. Build and debug support for GPU kernels is coming soon with NVIDIA Nsight Visual Studio Code Edition— check out </span><a href="https://developer.nvidia.com/blog/announcing-nvidia-nsight-visual-studio-code-edition-new-addition-to-the-nsight-developer-tools-suite"><span data-contrast="none">NVIDIA’s Developer Blog</span></a><span data-contrast="auto"> to learn more!</span></p>
<h2 aria-level="1" aria-level="1" id="apple-silicon-arm64-support"><b><span data-contrast="auto">Apple Silicon ARM64 support</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">In February, Visual Studio Code announced </span><a href="https://code.visualstudio.com/updates/v1_54#_apple-silicon"><span data-contrast="none">its first release of stable Apple Silicon builds</span></a><span data-contrast="none">.</span><span data-contrast="auto"> With this latest release, the C++ extension’s language server binaries also run natively on Apple Silicon. Running the language server natively on Apple Silicon is more efficient than running it with an emulator, leading to better performance and longer battery life.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="auto">The C++ extension language server provides IntelliSense (code editing features like Quick Info and Autocomplete), code navigation (Go to Definition/Declaration, Find All References), and some refactoring features (like Rename symbol). Debugging C++ projects natively on Apple Silicon will be supported in the future, and you can check out this </span><a href="https://github.com/microsoft/vscode-cpptools/issues/7035"><span data-contrast="none">GitHub issue (#7035)</span></a><span data-contrast="auto"> for updates.</span></p>
<h2 aria-level="1" aria-level="1" id="additional-enhancements"><b><span data-contrast="auto">Additional enhancements</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">In addition to supporting CUDA C/C++ IntelliSense and Apple Silicon ARM64 architecture, the April 2021 update comes with a bunch of enhancements! We’re especially excited about </span><a href="https://github.com/microsoft/vscode-cpptools/issues/882"><span data-contrast="none">Auto-adding parentheses for function calls (#882)</span></a><span data-contrast="auto">, which was one of our top voted GitHub issues!</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="auto">To enable automatically adding parentheses after function calls, go to </span><b><span data-contrast="auto">File</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Preferences</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Settings</span></b><span data-contrast="auto"> and under </span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">C/C++, </span></b><span data-contrast="auto">check the box under</span><b><span data-contrast="auto"> “C_cpp: Autocomplete Add Parentheses.” </span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis.png"><img class="alignnone size-full wp-image-27891" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis.png" alt="Screenshot of the C++ extension's setting called Autocomplete Add Parenthesis in VS Code's Preferences UI. The setting is enabled by marking the checkbox." width="1812" height="193" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis.png 1812w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-300x32.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-1024x109.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-768x82.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-1536x164.png 1536w" sizes="(max-width: 1812px) 100vw, 1812px" /></a></p>
<p><span class="TextRun SCXW229310597 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">Then, when you insert a function call, </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">parentheses will </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">be added automatically</span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">,</span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3"> with the cursor placed inside or outside depending on </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">whether</span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3"> the function requires </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">parameters.</span></span><span class="EOP SCXW229310597 BCX8" data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/completion-list-parentheses.gif"><img class="alignnone size-full wp-image-27892" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/completion-list-parentheses.gif" alt="GIF that shows a member function being selected from a completion list, and then parentheses being added automatically after the function call" width="1816" height="1020" /></a></p>
<p><span data-contrast="auto">The April 2021 release also offers:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Highlighting of matching conditional preprocessor statements. </span><a href="https://github.com/microsoft/vscode-cpptools/issues/2565"><span data-contrast="none">#2565</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="auto">Commands for navigating to matching preprocessor directives in conditional groups. </span><a href="https://github.com/microsoft/vscode-cpptools/issues/4779"><span data-contrast="none">#4779</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Auto-closing of include completion brackets. </span><a href="https://github.com/microsoft/vscode-cpptools/issues/7054"><span data-contrast="none">#7054</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></li>
</ul>
<p><span data-contrast="auto">And more! Check out our </span><a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.3.0"><span data-contrast="none">release notes</span></a><span data-contrast="auto"> to learn about additional enhancements and over 25 bug fixes.</span><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></p>
<h2 aria-level="1" aria-level="1" id="what-do-you%e2%80%afthink"><b><span data-contrast="auto">What do you think?</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"><span data-contrast="none">Download the C++ extension for Visual Studio Code</span></a><span data-contrast="auto"> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the </span><a href="https://github.com/Microsoft/vscode-cpptools/issues"><span data-contrast="none">Issues section of our GitHub repository</span></a><span data-contrast="auto">. You can also join our Insiders program and get access to early builds of our release by going to </span><b><span data-contrast="auto">File</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Preferences</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Settings</span></b><span data-contrast="auto"> and under </span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">C/C++,</span></b><span data-contrast="auto"> change the “</span><b><span data-contrast="auto">C_Cpp: Update Channel</span></b><span data-contrast="auto">” to “</span><b><span data-contrast="auto">Insiders</span></b><span data-contrast="auto">.” Then under </span><b><span data-contrast="auto">Features </span></b><span data-contrast="auto">&gt; </span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto">, enable “</span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto">:</span><b><span data-contrast="auto"> Auto Update</span></b><span data-contrast="auto">.”</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="auto">We can be reached via the comments below or in email at </span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="auto">. You can also find our team on Twitter at </span><a href="https://twitter.com/visualc"><span data-contrast="none">@</span></a><a href="https://twitter.com/visualc"><span data-contrast="none">VisualC</span></a><span data-contrast="none">.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/">Visual Studio Code C++ Extension April 2021 Update: CUDA C/C++ IntelliSense and Apple Silicon Support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC Backend Updates in Visual Studio 2019 version 16.10 Preview 2</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/#comments</comments>
		
		<dc:creator><![CDATA[Helena Gregg]]></dc:creator>
		<pubDate>Wed, 14 Apr 2021 17:27:30 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27875</guid>

					<description><![CDATA[<p>In Visual Studio 2019 version 16.10 Preview 2 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a brief list of improvements for you to review. </p>
<p>Address Sanitizer </p>
<p>Fixed false negative bugs, </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/">MSVC Backend Updates in Visual Studio 2019 version 16.10 Preview 2</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="none">In </span><a href="https://visualstudio.microsoft.com/vs/preview/"><span data-contrast="none">Visual Studio 2019</span></a><span data-contrast="none"> version 16.10 Preview 2 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a brief list of improvements for you to review.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><b><span data-contrast="none">Address Sanitizer</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="2"><span data-contrast="auto">Fixed false negative bugs, fixed false positive bugs, and improved debugger step-over fidelity of ASan-instrumented code.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><b><span data-contrast="auto">ARM64 support for /guard:ehcont</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="2"><span data-contrast="auto">The /guard:ehcont flag can be added to both compilation and linking of an executable to generate metadata that could be used by the OS to perform security checks at exception handling continuation points. Previously, this was only generated and supported for AMD64, but with 16.10 it is also possible to compile ARM64 executables with this metadata.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="3" data-aria-level="2"><span data-contrast="auto">Documentation for this switch: </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/guard-enable-eh-continuation-metadata?view=msvc-160"><span data-contrast="none">/guard:ehcont (Enable EH Continuation Metadata) | Microsoft Docs</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="4" data-aria-level="2"><span data-contrast="auto">See Windows blog for Control-Flow Integrity (CFI) mitigations using ehcont: </span><a href="https://techcommunity.microsoft.com/t5/windows-kernel-internals/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340"><span data-contrast="none">Developer Guidance for Hardware-enforced Stack Protection &#8211; Microsoft Tech Community</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><b><span data-contrast="auto">OpenMP</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="5" data-aria-level="2"><span data-contrast="auto">Made /openmp:llvm available on x86 and ARM64</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><b><span data-contrast="auto">Bigger stack reserve for link.exe and mspdbsrv.exe</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="2"><span data-contrast="auto">Increased stack reserve for link.exe and mspdbsrv.exe (x86 and amd64 hosted only) from the default 1MB to 4MB, to accommodate recursive type merging at link time.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="2"><span data-contrast="auto">Feedback: </span><a href="https://developercommunity2.visualstudio.com/t/Unhandled-Exception-During-Linking-IN-li/1300875"><span data-contrast="none">Unhandled Exception During Linking IN link.exe &#8211; Visual Studio Feedback</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><b><span data-contrast="auto">Added flags to enable/disable the SSA peeps for amd64 and x86 </span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="3" data-aria-level="2"><span data-contrast="auto">Added retail flags (-post-color-ssa-peeps, post-color-ssa-peeps-) to allow users to disable post-color ssa peeps and -pre-color-ssa-peeps and -pre-color-ssa-peeps- to enable them. This should allow users affected by an overly aggressive peep to work around their issue without having to completely disable the optimizer.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><b><span data-contrast="auto">Avoid PDB size overgrowth from incremental linking</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="2"><span data-contrast="auto">Feedback: </span><a href="https://developercommunity2.visualstudio.com/t/PDBs-keep-growing-in-size-on-incremental/1307614"><span data-contrast="none">PDBs keep growing in size on incremental links &#8211; Visual Studio Feedback</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="4" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><b><span data-contrast="auto">Debug mode performance improvements</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="4" aria-setsize="-1" data-aria-posinset="2" data-aria-level="2"><span data-contrast="auto">Removed unnecessary overhead due to </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks?view=msvc-160"><span data-contrast="none">runtime checks</span></a><span data-contrast="auto">. This may increase performance of your code compiled in debug mode by up to 3x.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><strong>Added additional peephole optimizations for ARM64</strong><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><strong>Enabled volatile metadata by default when targeting x64 to improve emulation performance</strong></li>
</ul>
<p><span data-contrast="none">Do you want to experience the new improvements of the C++ backend? Please download </span><a href="https://visualstudio.microsoft.com/vs/preview/"><span data-contrast="none">the latest Visual Studio 2019</span></a><span data-contrast="none"> and give it a try! Any feedback is welcome. We can be reached via the comments below, </span><a href="https://developercommunity.visualstudio.com/spaces/8/index.html"><span data-contrast="none">Developer Community</span></a><span data-contrast="none">, email (</span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="none">), and Twitter (</span><a href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span data-contrast="none">).</span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/">MSVC Backend Updates in Visual Studio 2019 version 16.10 Preview 2</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
	</channel>
</rss>
