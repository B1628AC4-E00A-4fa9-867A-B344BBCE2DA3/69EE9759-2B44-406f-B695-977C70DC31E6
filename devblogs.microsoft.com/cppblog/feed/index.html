<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Mon, 04 Apr 2022 23:28:38 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Using GitHub Codespaces and Visual Studio Code for C++ Development</title>
		<link>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/#comments</comments>
		
		<dc:creator><![CDATA[Michael Price]]></dc:creator>
		<pubDate>Mon, 04 Apr 2022 22:22:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Containers]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30359</guid>

					<description><![CDATA[<p>GitHub Codespaces and Visual Studio Code lower the barrier to entry for developing C++-based applications and libraries.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/">Using GitHub Codespaces and Visual Studio Code for C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Whether you are just learning the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1000r4.pdf">quickly evolving C++ programming language</a>, an open-source developer patching a zero-day vulnerability in a low-level C++ library, or an experienced professional writing software in C or C++ for <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">embedded devices</a> or enterprise applications, <a href="https://github.com/features/codespaces">GitHub Codespaces</a> and <a href="https://code.visualstudio.com/">Visual Studio Code</a> combine to significantly lower the costs associated with configuring your environment, building, and testing your code. It doesn&#8217;t matter whether your computer&#8217;s operating system is Microsoft Windows, Apple macOS, or your favorite Linux distribution, Visual Studio Code works on them all. You can even work from the web browser of your mobile iOS or Android device.</p>
<h2 id="visual-studio-code-and-github-dev">Visual Studio Code and github.dev</h2>
<p>GitHub offers built-in support for Visual Studio Code developers via <a href="https://github.dev">github.dev</a>. For any repository hosted on GitHub, you can nearly instantly open an instance of Visual Studio Code directly in your web browser. In this environment, many of Visual Studio Code&#8217;s <a href="https://code.visualstudio.com/docs/editor/codebasics">navigation and editing features</a> are fully functional. You can search for strings in your repository or edit files and commit them to new branches. You can even install many of the great Visual Studio Code extensions from the <a href="https://marketplace.visualstudio.com/VSCode">Visual Studio Code Marketplace</a>.</p>
<h2 id="visual-studio-code-and-github-codespaces">Visual Studio Code and GitHub Codespaces</h2>
<p>Once you push changes to your repository using <a href="https://github.dev">github.dev</a>, any <a href="https://docs.github.com/en/actions">GitHub Actions</a> that are registered for your branch will execute, including any build or test actions such as the <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions">Microsoft C++ Code Analysis action</a>. But you might want to build and test your changes before pushing your changes up to GitHub. For this, you can
<a href="https://docs.github.com/en/codespaces/developing-in-codespaces/creating-a-codespace">create</a> or <a href="https://docs.github.com/en/codespaces/developing-in-codespaces/developing-in-a-codespace">connect</a> to an existing GitHub Codespace directly from Visual Studio Code (including the in-browser instance loaded by github.dev) or from the normal GitHub web page for the repository. <em>NOTE: GitHub Codespaces is currently only available to members of eligible organizations. See <a href="#known-limitations">Known Limitations</a> for more information.</em></p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/04/vscode-remotes-codespaces.png" alt="Screenshot of Visual Studio Code showing available Codespaces. A popout is displaying properties of the selected codespace." /></p>
<h3 id="visual-studio-code-is-a-first-class-ide-for-c-and-c">Visual Studio Code is a <a href="https://code.visualstudio.com/docs/languages/cpp">First-Class IDE for C and C++</a></h3>
<p>The extensibility model for Visual Studio Code is one of its most powerful features. It enables developers across the globe to produce terrific extensions. Microsoft has bundled many of the best extensions for C and C++ development into the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ Extension Pack</a>, which makes developing for one of the world&#8217;s most versatile programming languages as easy as it&#8217;s ever been. From extensions for build systems like <a href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code">Make</a> and build system generators like <a href="https://devblogs.microsoft.com/cppblog/cmake-tools-extension-for-visual-studio-code">CMake</a>, to debugging and C++ static analysis tools and rich editor features like syntax highlighting and <a href="https://code.visualstudio.com/docs/editor/intellisense">IntelliSense</a> code completion, Visual Studio Code has what you need to get the job done, and it continues to improve with every release. Combining Visual Studio Code&#8217;s terrific support for C++ development with GitHub Codespaces&#8217; ease-of-use and portability, means that it&#8217;s easier than ever before to deliver your product or solution.</p>
<h3 id="true-portability-with-codespaces">True Portability with Codespaces</h3>
<p>Since Codespaces are development environments in the cloud, they are accessible from practically any system or device with a web browser and an Internet connection. And when you disconnect from your Codespace, its state is saved so that when you reconnect, potentially from a different device in potentially a very different location, you&#8217;ll be right back where you left off. When you are <a href="https://www.bing.com/images/search?q=beach+images">relaxing on the white sands of a beach resort</a>, you no longer need to run back to your office (or home office) in order to fix that critical zero-day bug that just read about on Reddit.</p>
<h3 id="managing-your-codespace-instances">Managing Your Codespace Instances</h3>
<p>Managing your Codespace instances can be done <a href="https://github.com/codespaces">directly from GitHub</a> or from within the Visual Studio Code Remote Explorer. From there, you can see the properties of your Codespaces or create, delete, or connect to your Codespaces. You can even change the machine type of an existing Codespace from the GitHub page or via the Command Palate in Visual Studio Code after connecting to a Codespace.</p>
<p>A machine type is a system configuration specifying the number of CPU cores, memory capacity, and storage capacity for a Codespace. GitHub Codespaces are provisioned in the cloud with the machine type you select. Depending on the organizations you are a member of, the repository a Codespace is being created for, and details about your GitHub account, different machine types might be available to you. To start, don&#8217;t worry about selecting the perfect machine type for your Codespace. You can always change your machine type later and retain all of your code changes without having to stash or commit them into the repository. Since less powerful machine types are <a href="https://docs.github.com/en/billing/managing-billing-for-github-codespaces/about-billing-for-codespaces#codespaces-pricing">billed at a lower rate</a>, you can leverage this to really optimize the tradeoff between time and cost as you see fit. For instance, you might choose a powerful machine type in order to complete an initial build of your project, then switch to a less powerful machine type while you are only making changes that cause smaller, incremental builds, only to switch back to a more powerful machine when you&#8217;d like to run a compute intensive task like running a static analysis tool.</p>
<p>The creation of your Codespaces are also customizable with <a href="https://code.visualstudio.com/docs/remote/create-dev-container">devcontainer</a> configuration files checked directly into your repository. You can provide a custom Dockerfile to use when spinning up your Codespace, pre-install Visual Studio Code extensions, forward ports from your Codespace instance to your local machine, or even run a tool every time a connection is made to the Codespace. You can even <a href="https://docs.github.com/en/codespaces/prebuilding-your-codespaces/about-codespaces-prebuilds">pre-build your Codespace containers using GitHub Actions</a> to make Codespace startup very fast!</p>
<h2 id="known-limitations">Known Limitations</h2>
<ul>
<li>Access to GitHub Codespaces feature is limited to users who are members of organizations on a GitHub Teams or GitHub Enterprise Cloud plan. Organization owners can <a href="https://docs.github.com/en/codespaces/managing-codespaces-for-your-organization/enabling-codespaces-for-your-organization">enable the feature</a> in only a few steps. Access for individual users is currently in beta, to <a href="https://github.com/features/codespaces/signup">which you can easily request access</a>.</li>
<li>All GitHub Codespace instances run various <a href="https://github.com/github/feedback/discussions/9977">Linux distributions</a>.</li>
<li>The largest available machine type is: 32 cores, 64 GB RAM, 128 GB storage.</li>
<li>Changing machine type is only allowed between types that have the same amount of storage capacity.</li>
</ul>
<h2 id="call-to-action">Call to Action</h2>
<p>Try out the combination of Visual Studio Code and GitHub today, by going to your favorite C or C++ project on GitHub, and press the <strong>.</strong> (period) key to open up <a href="https://github.dev">github.dev</a>. Browse around. Experiment with the IDE features of Visual Studio Code. When you&#8217;re ready to try compiling some code get started with GitHub Codespaces by accessing the Command Palate by pressing <strong>Ctrl+Shift+P</strong> (<strong>Cmd+Shift+P</strong> on macOS) and run the <strong>Codespaces: Create New Codespace</strong> command. Install the C/C++ Extension Pack and find out just how easy C++ development can be with Visual Studio Code and GitHub Codespaces. You can also follow the instructions in our <a href="https://github.com/microsoft/vscode-remote-try-cpp">example repository</a> that demonstrates Visual Studio Code&#8217;s remote container capabilities for a quick tour of the features.</p>
<h2 id="send-us-your-feedback">Send us your feedback</h2>
<p>We are always interested in your feedback. If you have a use case that we haven&#8217;t thought of, we&#8217;d love to hear from you. Want to complain that something isn&#8217;t working as you expected? We want to hear that too! Already using the product and want to tell us your successes? We definitely want to hear your story! You can comment below, and you can reach us via email at <a href="mailto://visualcpp@microsoft.com">visualcpp@microsoft.com</a> or on Twitter <a href="https://twitter.com/visualc">@VisualC</a>. For issues with the GitHub Codespaces service, you can also provide <a href="https://github.com/github/feedback/discussions/categories/codespaces-feedback">feedback directly to the GitHub Codespaces team</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/">Using GitHub Codespaces and Visual Studio Code for C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/using-github-codespaces-and-visual-studio-code-for-cplusplus-development/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Enhancing Game Developer Productivity with Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/</link>
					<comments>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Thu, 31 Mar 2022 16:18:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[game dev]]></category>
		<category><![CDATA[productivity]]></category>
		<category><![CDATA[unreal engine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30338</guid>

					<description><![CDATA[<p>In this blog, we will discuss how much faster you can get to code with speedier C++ IntelliSense ready and opening a file. Learn how search improved with faster with C++ Find All References and indexed Find in Files.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/">Enhancing Game Developer Productivity with Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Since the launch of Visual Studio 2022, we have been continuously making performance improvements to enhance game developer productivity. In my <a href="https://www.youtube.com/watch?v=y8kt5842PT4">Microsoft Game Dev talk for GDC</a>, I shared why Visual Studio is the ultimate IDE for game developers. I also partnered with the folks at Double Fine Productions to <a href="https://developer.microsoft.com/en-us/games/events/gdc/psychonauts2">demonstrate their most loved features when developing the Award-winning Psychonauts 2.</a> Next, I shared features that Double Fine is most excited for in VS2022. Lastly, <a href="https://developer.microsoft.com/en-us/games/blog/microsoft-perforce-reimagining-game-production/">Microsoft Game Dev announced</a> that a set of GitHub Actions for Perforce Helix Core on Azure, authored directly by Perforce, is now available.</p>
<p>In this blog, I will show you some amazing speed improvements when searching and getting to code by discussing our measurements from large codebases such as Unreal Engine and Chromium. See how much faster you can get to code with speedier C++ IntelliSense ready and opening a file. Search faster with C++ Find All References and indexed Find in Files.</p>
<p>While game developers and developers with large codebases will benefit from these improvements the most, all C++ developers will gain increased productivity with these changes.</p>
<h1 id="testing-methodology">Testing Methodology</h1>
<p>We tested using an Unreal Engine 4 sample project on a desktop with an Intel Core i7-9700 @ 3Ghz, 64GB RAM, and an SSD. The tests took place on Visual Studio 2019 16.11 and Visual Studio 2022 17.1. The results were averaged over 3 runs. For Find in Files, we benchmarked using the Chromium repo, with more than 300,000 files.</p>
<h1 id="results">Results</h1>
<h2 id="getting-to-code">Getting to Code</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png"><img class="aligncenter size-full wp-image-30340" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png" alt="Image gettocodevs2022" width="1652" height="992" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022.png 1652w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/gettocodevs2022-1536x922.png 1536w" sizes="(max-width: 1652px) 100vw, 1652px" /></a></p>
<p>When opening a file on Visual Studio 2019, it took 2.02 seconds for code to show up. In Visual Studio 2022, you can see the same action completing in only 0.82 seconds, resulting in a 2.44X speed up. In Visual Studio 2019, the time it took for semantic colorization to show up after opening a file was 12.9 seconds. You will experience that the same action is 2.22X faster in VS2022, taking 5.8 seconds.</p>
<p>For Unreal Engine projects, you will experience additional speed up for IntelliSense readiness. <a href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">Learn more in this blog post.</a></p>
<h2 id="code-search">Code Search</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png"><img class="aligncenter size-full wp-image-30341" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png" alt="Image searchvs2022" width="1652" height="992" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022.png 1652w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/searchvs2022-1536x922.png 1536w" sizes="(max-width: 1652px) 100vw, 1652px" /></a></p>
<p>In Visual Studio 2022, you will see a speed up of 1.74X when using C++ Find All References (Shift + F12). The action was completed in 17.36 seconds; compared to Visual Studio 2019, the action took a little over half a minute.
For Find in Files in Visual Studio 2019, searching through 300,000 files in the Chromium repo took 30 seconds. In Visual Studio 2022, you will notice that the same action will take 1.5 seconds, a 20X improvement!</p>
<h1 id="analysis">Analysis</h1>
<p>You will notice several optimizations to the IntelliSense engine that created more efficiency in getting to code scenarios. Find All References was also enhanced by eliminating inefficiencies during search.</p>
<p>For Find in Files, you can now take advantage of indexed search. To enable indexed searching, go to <em>Tools &gt; Options &gt; Environment &gt; Preview Features</em> and ensure “Enable indexing for faster find experience” is checked. For more details, <a href="https://devblogs.microsoft.com/visualstudio/code-search-in-visual-studio-is-about-to-get-much-faster/">please see this blog post.</a></p>
<h1 id="feedback-wanted">Feedback Wanted!</h1>
<p>Your feedback through <a href="https://developercommunity.visualstudio.com/">Developer Community</a>, surveys, and social media channels has made these improvements possible. We thank you for your valuable comments.
These enhancements are a continuation of our focus on improving productivity for game developers. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like ones detailed in this blogpost. If you are a game developer, <a href="http://aka.ms/VSGameDevSurvey">let us know your thoughts in our 2022 Visual Studio Game Developer Survey</a>.</p>
<p>In addition, please continue to help shape the development of Visual Studio by talking to us in the comments below, on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h1 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h1>
<p><a href="https://visualstudio.microsoft.com/downloads/">Download the latest version of Visual Studio 2022</a> to take advantage of these productivity benefits today!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/">Enhancing Game Developer Productivity with Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/enhancing-game-developer-productivity/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>C++ Modules in CMake with Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/#comments</comments>
		
		<dc:creator><![CDATA[Will Buik]]></dc:creator>
		<pubDate>Thu, 17 Mar 2022 22:31:30 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30295</guid>

					<description><![CDATA[<p>We’ve seen a lot of excitement around C++ modules since we announced support in the Microsoft C++ compiler and Visual Studio. Ever since, the community has been asking us when CMake support was coming. I am happy to announce that Visual Studio 2022 17.2 Preview 2 has experimental support for C++ modules in CMake projects.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/">C++ Modules in CMake with Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We’ve seen a lot of excitement around C++ modules since we announced support in the Microsoft C++ compiler and Visual Studio. Ever since, the community has been asking us when CMake support was coming. I am happy to announce that Visual Studio 2022 17.2 Preview 2 has experimental support for C++ modules in CMake projects. One caveat for this early support, is that you must use the Visual Studio (MSBuild) generator. If you want to try it out, you can <a href="https://visualstudio.com/preview">download the latest preview of Visual Studio</a> today. We are looking forward to hearing your feedback about how modules work in your CMake projects.</p>
<p><a href="https://docs.microsoft.com/en-us/cpp/cpp/modules-cpp">C++ modules</a> are a new feature in C++20. They can help you compartmentalize your code, speed up build times, and they work seamlessly, side-by-side with your existing code. To learn more, I would recommend checking <a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/">A Tour of C++ Modules in Visual Studio</a>. That post explores the details of how and when to use modules and some of the ways Visual Studio can help you do it.</p>
<p>For an even deeper dive into modules, you can also explore the following series:</p>
<ul>
<li><a href="https://devblogs.microsoft.com/cppblog/standard-c20-modules-support-with-msvc-in-visual-studio-2019-version-16-8/">Standard C++20 Modules support with MSVC</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/moving-a-project-to-cpp-named-modules/">Moving a project to C++ named Modules</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</a></li>
</ul>
<h3 id="getting-started-with-modules-and-cmake">Getting Started with Modules and CMake</h3>
<p>While CMake support for modules in Visual Studio is still experimental, it is straightforward to start using it. You don’t need to do anything special in your CMake project files. Just make sure you have enabled the C++20 language standard. Starting in this preview, our CMake project template will do that for you, but if you are working with an existing project you will need to add this to your CMakeLists.txt:</p>
<p><code>set_property(TARGET $TargetName PROPERTY CXX_STANDARD 20)</code></p>
<p><strong><em>Note:</em></strong><em> Enabling C++20 requires CMake 3.12 or higher. Visual Studio ships with the latest version of CMake, but this may be a consideration if you use this project across operating systems or need to use an older version of CMake.</em></p>
<p>You will also need to make sure you are using the Visual Studio generator with CMake. Support for other generators, such as Ninja, is planned but it isn’t available yet. Ninja is the default generator when working with CMake projects in Visual Studio so you will need to modify your project’s <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-170">CMakePresets.json</a> or <a href="https://docs.microsoft.com/en-us/cpp/build/customize-cmake-settings?view=msvc-170">CMakeSettings.json</a> file to change this.</p>
<p><strong><em>CMake Presets:</em></strong></p>
<p>If your project is using CMake Presets, in CMakePresets.json, find the “windows-base” configure preset. It will have a “generator” property that is most likely set to “Ninja”. Update it to this:</p>
<pre>{
  "version": 3,
  "configurePresets": [ {
    "name": "windows-base",
    "hidden": true,
    "generator": "Visual Studio 17 2022",
    //…
  }]
}</pre>
<p><strong><em>CMake Settings:</em></strong></p>
<p>If your project is using CMake Settings, you can open the CMakeSettings.json editor and change the Generator setting (under Advanced) to “Visual Studio 17 2022:”</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png"><img class="alignnone size-full wp-image-30300" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png" alt="CMake Settings &gt; Advanced &gt; CMake generator" width="1425" height="826" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator.png 1425w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-300x174.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-1024x594.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/CMake-Settings-Generator-768x445.png 768w" sizes="(max-width: 1425px) 100vw, 1425px" /></a></p>
<p>You will need to do this for each of your project’s configurations.</p>
<p>And that’s it, once the Visual Studio generator is selected and the C++20 language standard is enabled for your target you can use modules in your project.</p>
<h3 id="creating-modules-in-a-cmake-project">Creating Modules in a CMake Project</h3>
<p>To add a module to your project, just right click on any folder and select “Add New Item:”</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png"><img class="alignnone size-full wp-image-30301" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png" alt="CMake Context Menu &gt; Add &gt; Add New Item..." width="1972" height="665" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item.png 1972w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-300x101.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-1024x345.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-768x259.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Item-1536x518.png 1536w" sizes="(max-width: 1972px) 100vw, 1972px" /></a></p>
<p>And select the “C++ Module Interface Unit (.ixx)” template in in the “Visual C++” category:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png"><img class="alignnone size-full wp-image-30302" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png" alt="New File &gt; Visual C++ &gt; C++ Module Interface Unit (.ixx)" width="1253" height="490" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item.png 1253w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-300x117.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-1024x400.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/New-Module-Interface-Item-768x300.png 768w" sizes="(max-width: 1253px) 100vw, 1253px" /></a></p>
<p>If you are using the <a href="https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio-targets-view-single-file-compilation-and-cache-generation-settings/#cmake-targets-view">Targets View</a>, it is even easier. Just click “Add -&gt; New Module…” in the context menu on any target:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png"><img class="alignnone size-full wp-image-30303" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png" alt="CMake Targets View Context Menu &gt; Add &gt; New Module..." width="1232" height="667" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View.png 1232w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-300x162.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-1024x554.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Add-New-Module-Targets-View-768x416.png 768w" sizes="(max-width: 1232px) 100vw, 1232px" /></a></p>
<h3 id="exporting-and-using-modules">Exporting and Using Modules</h3>
<p>Once you have created a Module interface (.ixx) file, you can export functions, classes, and structs. The example below defines a simple module called <code>Printers</code> and exports a single struct:</p>
<pre>// Printers.ixx
// 
// The .ixx extension lets the build system know this file contains
// a module interface.

// Begin global module fragment.
module;

// Headers included in the global module fragment (between "module;" and
// "export module Printers;") can be used by the module implementation but
// are not exported. These included headers are invisible to translation
// units that import the Printers module.
#include &lt;iostream&gt;

// Creates the Printers module. This can be imported into other translation
// units with "import Printers;" Any items marked with the export keyword
// will be available in translation units that import the Printers module.
export module Printers;

// This only applies to this module's translation unit. It does not leak
// into translation units that import the Printers module.
using namespace std;

// These constants are not exported, they are invisible from translation
// units that import the Printer module.
const string default_spacer = " ";
const string default_separator = ",\n";

// SimplePrinter is exported and accessible to any code that imports the
// Printers module.
export struct SimplePrinter
{
    string element_spacer;
    string separator;

    void print_element(int e)
    {
        std::cout &lt;&lt; e &lt;&lt; element_spacer;
    }

    void print_separator()
    {
        std::cout &lt;&lt; separator;
    }
};

// Exports the function get_default_printer.
// This is accessible from translation units that import the Printers module.
export SimplePrinter get_default_printer()
{
    return SimplePrinter {
        .element_spacer = default_spacer,
        .seperator = default_seperator
    };
}</pre>
<p>Once you define the module, other source files and module interfaces can consume it with the <code>import</code> keyword. It is possible to import any modules declared in the current target or any of its imports. For example, “PrintVector.cpp” below uses the <code>Printers</code> module we defined above:</p>
<pre>// PrintVector.cpp

// Conventional #includes and module imports can be freely mixed.
#include &lt;vector&gt;

// Import the Printers module defined in Printers.ixx.
import Printers;

using namespace std;

void print_vector(const vector &amp;list)
{
    // SimplePrinter and get_default_printer are imported from the
    // Printers module.
    SimplePrinter printer = get_default_printer();

    for (auto i : list) {
        printer.print_element(i);
    }
    printer.print_separator();
}</pre>
<p>You can do a lot with C++ modules. To learn more, I would recommend reading <a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/">A Tour of C++ Modules in Visual Studio</a> which goes into much more detail about how to use modules. For instance, it is possible to split module interfaces from their implementations. That post has been updated with some of the latest details about using modules with CMake.</p>
<h3 id="feedback">Feedback</h3>
<p>If you are interested in trying out C++ modules in your own CMake projects, please <a href="https://visualstudio.com/preview">download the latest Visual Studio Preview</a>. Try it out and let us know if you have any questions or feedback. If you find any issues or have a suggestion, the best way to reach out to us is to <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio">Report a Problem</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/">C++ Modules in CMake with Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp20-modules-in-cmake-with-vs/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio for remote macOS C++ development</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/#comments</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Wed, 16 Mar 2022 18:17:45 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30167</guid>

					<description><![CDATA[<p>The latest preview version of Visual Studio is now available to download. In this latest release, users wishing to develop cross platform C++ applications for macOS can now make use of Visual Studio’s Linux tools with CMake to target the Mac.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/">Visual Studio for remote macOS C++ development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW190762823 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentStart SCXW190762823 BCX8">The latest preview version of Visual Studio is now <a href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noopener">available to download</a>. In this latest release, users</span><span class="NormalTextRun SCXW190762823 BCX8"> wishing to develop cross platform C++ applications for </span><span class="NormalTextRun SCXW190762823 BCX8">macOS</span><span class="NormalTextRun SCXW190762823 BCX8"> can </span><span class="NormalTextRun SCXW190762823 BCX8">now </span><span class="NormalTextRun SCXW190762823 BCX8">make use of Visual Studio’s Linux tools with CMake to target </span><span class="NormalTextRun SCXW190762823 BCX8">the Mac. There is some setup required on the Mac side to enable the support, but then the Mac is treated just as any other remote (Linux) target by Visual Studio.</span></span><span class="EOP SCXW190762823 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1.png"><img class="alignnone size-full wp-image-30175" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1.png" alt="Example of an application targeting MacOS from Windows Visual Studio" width="1428" height="892" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1.png 1428w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1-1024x640.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/MacOS-Target-Example-1-768x480.png 768w" sizes="(max-width: 1428px) 100vw, 1428px" /></a></p>
<h4 id="installation">Installation</h4>
<p>To get started install the latest preview release of Visual Studio 2022 and select the Linux and embedded development with C++ workload. The components you need are selected by default.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1.png"><img class="alignnone size-full wp-image-30173" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1.png" alt="Select Linux and embedded development in C++ workload in latest preview release of Visual Studio 2022" width="910" height="460" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1.png 910w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1-300x152.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Linux-Selection-1-768x388.png 768w" sizes="(max-width: 910px) 100vw, 910px" /></a></p>
<h4 id="setup-on-the-mac">Setup on the Mac</h4>
<p>Visual Studio requires certain tools to be present on the Mac to enable the remote development experience.</p>
<h5 id="c-tools">C++ Tools</h5>
<p>If you have used your Mac for C++ development before you likely have everything installed that you need. If not, some of these tools should already be present (for example rsync) but some may need to be installed, typically the compiler command line tools, <em>cmake</em>, <em>ninja-build</em>, and <em>lldb-mi</em>. The following step should be performed in a terminal window on the Mac to set up the development environment.</p>
<ol>
<li>Make sure you have enabled your Mac for development:</li>
</ol>
<pre style="padding-left: 40px;"><em>DevToolsSecurity --enable</em></pre>
<ol start="2">
<li>Download the latest version of XCode from the App Store (<a href="https://apps.apple.com/us/app/xcode/id497799835?mt=12&amp;msclkid=506bfed6b46e11ecaf2b0760ad457b77">Xcode on the App Store (apple.com)</a>), or an older version through the <a href="https://developer.apple.com/xcode/downloads/">Apple Developer page</a>Use <em>xcode-select</em> to install the compiler tools:</li>
</ol>
<pre style="padding-left: 40px;"><em>xcode-select --install</em></pre>
<ol start="3">
<li>Install CMake from cmake.org. Follow the instructions here (<a href="https://cmake.org/install">Installing | CMake</a>) to copy and install the latest CMake. Make sure to update the PATH variable to include the CMake location. For example when using <em>zsh</em> add the line below to ~/.zshenv; when using <em>bash</em> add the line to ~/.bashrc.</li>
</ol>
<pre style="padding-left: 40px;">export PATH=/Applications/CMake.app/Contents/bin:$PATH</pre>
<ol start="4">
<li>Install ninja-build from <em>github</em> or using a package manager such as <em>brew</em>. If installing directly from GitHub use the following commands:</li>
</ol>
<pre style="padding-left: 40px;"><em>git clone https://</em><em>github.com/ninja-build/ninja.git</em>

<em>cd ninja</em>

<em>./configure.py --bootstrap</em>

<em>sudo cp ninja /usr/local/bin</em></pre>
<ol start="5">
<li>Install <em>lldb-mi</em>, a command line interface to the lldb debugger. Use a browser to download from <a href="https://go.microsoft.com/fwlink/?linkid=2154927">https://go.microsoft.com/fwlink/?linkid=2154927</a> . Then copy the binary to <em>/usr/local/bin</em> and set its execute permissions.</li>
</ol>
<pre style="padding-left: 40px;"><em>sudo cp ~/Downloads</em><em>/debugAdapters/lldb-mi/bin/lldb-mi /usr/local/bin</em> 
<em>sudo chmod +x /usr/local/bin
</em></pre>
<p style="padding-left: 40px;">Note: if you do not have a /usr/local/bin directory, this command will not work. You can create it using terminal command:</p>
<pre style="padding-left: 40px;">dir mkdir /usr/local/bin</pre>
<h5 id="remote-connection-enablement">Remote connection enablement</h5>
<p>Make sure you have enabled your Mac to allow remote connections. From System Preferences select Sharing, then ensure that Remote Login is selected, and your user has access. If you need to interact with an app that has UI remotely on the Mac you also need to enable Remote Management and under Computer Settings enable VNC viewers. You should then be able to access the Mac from Windows using a VNC client.</p>
<h4 id="connect-from-visual-studio">Connect from Visual Studio</h4>
<p>Once the necessary tools are installed on the Mac then Visual Studio can access the Mac using the Connection Manager.</p>
<p style="padding-left: 40px;">On a Windows machine open Visual Studio (with C++ and Linux workloads installed) and open the Connection Manager from Tools&gt;Options&gt;Cross Platform&gt;Connection Manager. Add a new connection using the Mac machine name or IP address, username, and password.</p>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3.png"><img class="alignnone size-full wp-image-30181" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3.png" alt="Image Picture3" width="623" height="364" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3.png 623w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-300x175.png 300w" sizes="(max-width: 623px) 100vw, 623px" /></a></p>
<p>Once a connection has been set up in Visual Studio it can be used as a CMake target in either a CMakeSettings.json or CMakePresets.json configuration. Below I’ll walk through setting up a new CMake project using CMakePresets.json.</p>
<h4 id="a-sample-cmake-project">A Sample CMake Project</h4>
<ol>
<li>Since we will use CMake presets for this example, first ensure that CMakePresets is enabled in your Visual Studio installation. Go to Tools&gt;Options&gt;CMake&gt;General and check “Always use CMakePresets.json”.</li>
<li>From File&gt;New&gt;Project select CMake Project to create a new project (in this example “CMakeProject90”). The project will open targeting the “Local Machine” by default. From the “Target System” dropdown select the connection to the Mac system that was made in the previous step.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4.png"><img class="alignnone size-full wp-image-30183" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4.png" alt="In the top bar of a CMake project, &quot;Target Machine&quot; will be automatically selected as well as x64 Debug and Default. Select connection to MacOS machine from &quot;Target System&quot; dropdown" width="624" height="90" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture4-300x43.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></li>
</ol>
<p style="padding-left: 40px;">The target for the project will now reflect this choice and identify it as a Mac target.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png"><img class="alignnone size-full wp-image-30187" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png" alt="The top bar for the CMake project will now show the Mac machine you connected to after selection" width="624" height="82" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6-300x39.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p style="padding-left: 40px;">The CMake pane of the Output Window will contain a log of the copy and CMake configure operations.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7.png"><img class="alignnone wp-image-30188" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7.png" alt="Output window containing the log of the copy and Cmake configure operations" width="658" height="272" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture7-300x124.png 300w" sizes="(max-width: 658px) 100vw, 658px" /></a></p>
<p style="padding-left: 40px;">At this point the project is ready to build and debug.</p>
<ol start="3">
<li>From the Solution Explorer open CMakeProject.cpp and place a breakpoint on the first line of <em>main</em>. From the “Select Startup Item” dropdown select “CMakeProject90”. Start debugging (F5). Visual Studio will build the project (see the Build pane of the Output Window) and start the debugger on the Mac. The debugger will halt the application pointing to the location of the breakpoint just set.<a style="background-color: #f7f7f9; font-size: 1rem;" href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture6.png"> </a><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8.png"><img class="alignnone size-full wp-image-30190" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8.png" alt="The application is being debugged with a breakpoint set. The debugger hit the breakpoint and now debugging capabilities, such as call stack pictured, are able to be viewed." width="780" height="347" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8.png 780w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8-300x133.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture8-768x342.png 768w" sizes="(max-width: 780px) 100vw, 780px" /></a></li>
</ol>
<p style="padding-left: 40px;">The debugging capabilities of Visual Studio (for example, the locals, watch, and call stack windows) may now be used to examine the application.</p>
<h4 id="attach-debugging-on-the-mac">Attach Debugging on the Mac</h4>
<p>The Visual Studio debugger’s attach-to-process function also works for Mac targets.</p>
<ol>
<li>Change the main function of the above C++ application as follows:</li>
</ol>
<pre style="padding-left: 40px;">#include "CMakeProject90.h"
#include &lt;unistd.h&gt;
using namespace std;
int main()
{
       cout &lt;&lt; "Hello CMake." &lt;&lt; endl;
       while (true)
       {
             sleep(1);
       }
       return 0;
}</pre>
<p style="padding-left: 40px;">Save the file and select Debug&gt;Start Without Debugging.</p>
<ol start="2">
<li>Select Debug&gt;Attach to Process… On the “Attach to Process” dialog select Connection type “SSH”. Then Select the Mac connection from the “Connection target” dropdown. The dialog will populate the “Available process” display with the processes running on the Mac.</li>
</ol>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1.png"><img class="alignnone size-full wp-image-30198" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1.png" alt="Attach to Process Window with the Mac machine connection selected under Connection target and the available processes populated underneath, including the sample CMakeProject" width="780" height="644" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1.png 780w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1-300x248.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture-1-768x634.png 768w" sizes="(max-width: 780px) 100vw, 780px" /></a></p>
<p style="padding-left: 40px;">Select “Attach”. A “Select Code Type” dialog will pop-up. Select “Native (LLDB)” and click OK.</p>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2.png"><img class="alignnone size-full wp-image-30200" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2.png" alt="In Attach to Process window, after selecting &quot;Attach&quot; on the target available process the &quot;Select Code Type&quot; window will pop up. Native LLDB is selected for this example." width="624" height="442" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture2-300x213.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p style="padding-left: 40px;">The debugger is now attached to the remote process on the Mac. Select Debug&gt;Break All to begin debugging.</p>
<p style="padding-left: 40px;"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1.png"><img class="alignnone size-full wp-image-30201" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1.png" alt="Image Picture3" width="624" height="335" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/Picture3-1-300x161.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<h4 id="caveats">Caveats</h4>
<p>Currently only x64 Macs are fully supported for debugging. This means that when attempting to debug on an ARM64 Mac, Rosetta must be installed and only applications that are cross compiled for x64 can be debugged. The Mac must have an OS Version of at least 10.15 to install all of the debugger tools.</p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your macOS C++ development needs. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>A special thanks to Paul Maybee for authoring this post.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/">Visual Studio for remote macOS C++ development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Embedded Software Development in Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Thu, 10 Mar 2022 00:01:39 +0000</pubDate>
				<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30142</guid>

					<description><![CDATA[<p>In this post we will walk through the new Visual Studio Code Embedded Tools extension. We'll show how to acquire embedded tool dependencies with vcpkg then edit, build, deploy, and debug an Azure RTOS ThreadX project highlighting the new peripheral register and RTOS object views.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Embedded Software Development in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that we have released the Embedded Tools extension for Visual Studio Code. These capabilities are the same as what we recently announced for <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Visual Studio 2022</a>. Used in conjunction with the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifact capabilities</a> you can quickly bootstrap an embedded development machine and get started.</p>
<p>In this post we will walk you through how to acquire embedded tool dependencies with vcpkg, then demonstrate edit, build, deploy, and debugging directly in VS Code with new peripheral register and RTOS object views. We will demonstrate all of this with an Azure RTOS ThreadX project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png"><img class="alignnone size-full wp-image-30146" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png" alt="VS Code embedded development screenshot" width="1671" height="1044" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png 1671w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-1024x640.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-768x480.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-1536x960.png 1536w" sizes="(max-width: 1671px) 100vw, 1671px" /></a></p>
<p>Azure RTOS ThreadX is a widely used Real Time Operating System (RTOS) used on billions of microcontrollers (MCUs) in products around the world. We have dedicated pages for VS Code usage in the getting started guides for the <a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/vscode.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/blob/master/NXP/MIMXRT1060-EVK/vscode.md">NXP 1060</a>, and STMicro STM32L4_L4+ IOT01A boards (<a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L475E-IOT01A/vscode.md">L475E</a> or <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L4S5I-IOT01A/vscode.md">L4S5I</a>). The techniques used for interacting with these boards should be applicable to other targets by changing configuration information we’ll highlight throughout.</p>
<h4 id="installation">Installation</h4>
<p>To get started install VS Code, then in the extensions side bar search for Embedded Tools and install it.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png"><img class="alignnone size-full wp-image-30147" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png" alt="Embedded Tools extension page screenshot" width="624" height="167" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools-300x80.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<h4 id="using-vcpkg-to-acquire-embedded-tools">Using vcpkg to acquire embedded tools</h4>
<p>One of the challenges in embedded development is getting the tools necessary installed and configured. It is not uncommon to have different compilers used for different projects, custom debug tools, etc. This is where the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">artifact capabilities in vcpkg</a>  can help us. Today we’ll demonstrate using vcpkg from a PowerShell prompt to activate our embedded development environment, but you can use the shell you prefer on your platform. In a future release this will be integrated into a Visual Studio Code extension for a more seamless experience.</p>
<p>From a PowerShell prompt, clone the Azure RTOS getting started repo. This sample will serve as our example project for the remainder of this post.</p>
<pre>git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Navigate to the subfolder for the board you are using, here I’m using the Azure IoT DevKit.</p>
<pre>cd ./getting-started/MXChip/AZ3166</pre>
<p>If you haven’t already, install vcpkg.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre>iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>CMD Shell</p>
<pre>curl -LO https://aka.ms/vcpkg-init.cmd &amp;&amp; .\vcpkg-init.cmd</pre>
<p>In the project folder, there is a file vcpkg_configuration.json. This manifest file was created with vcpkg and has recorded the tools you need to build and debug this project. See the <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifacts post</a> for details on how to create your own manifest. Running the vcpkg activate command will use this file to determine if I have those tools, install them if I do not, then activate them in my environment for use.</p>
<pre>vcpkg activate</pre>
<p>So, in three commands we have cloned our embedded project, installed vcpkg, acquired and activated the necessary tools for building the project.</p>
<h4 id="using-vs-code-for-embedded-development">Using VS Code for embedded development</h4>
<p>In the previous section we used vcpkg to acquire the tools for our embedded project. Today vcpkg is not integrated in Visual Studio Code. So, at present we need to launch VS Code from the environment we activated at the command line so those tools are available for its use as well.</p>
<pre>code .</pre>
<p>Now that we have the project open in VS Code it is ready to go as any other CMake project. <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">VS Code can run the CMake build using the preconfigured CMakePresets file</a> with the compilers vcpkg acquired. Select the preset arm-gcc-cortex-m4 when prompted on opening the folder.</p>
<p>All the editing power of VS Code is now available for use with the embedded project. With this Azure RTOS project we’ll cover code navigation, IntelliSense, build, deploy, debugging. We’ll also cover new diagnostic capabilities around peripheral registers and RTOS object views.</p>
<h5 id="code-navigation-and-intellisense">Code Navigation and IntelliSense</h5>
<p>Use Ctrl + T to open symbol search and type button_a_callback, select the button_a_callback function to navigate to it. Note on hover that this function expands to TIM3-&gt;CCR1 which is a peripheral register on the board which we’ll inspect while we are debugging.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png"><img class="alignnone size-full wp-image-30148" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png" alt="IntelliSense function expansion screenshot" width="538" height="327" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png 538w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef-300x182.png 300w" sizes="(max-width: 538px) 100vw, 538px" /></a></p>
<h5 id="build-deploy-and-debug-on-hardware">Build, Deploy, and Debug on hardware</h5>
<p>Set a breakpoint on RGB_LED_SET_R().</p>
<p>To see how the launch is controlled in the sidebar open .vscode/launch.json and look at the launch configuration. You can see the miDebuggerPath set to use arm-none-eabi-gdb while the debugServerPath is set to invoke openocd with the configuration script in debugServerArgs. The information for describing peripheral registers is provided by the MCU manufacturer in an SVD file that we point to with svdPath. This project is configured to break on entry with the property stopAtConnect.</p>
<p>Now, with your board plugged into the PC with <a href="https://www.st.com/en/development-tools/stsw-link009.html">ST-LINK drivers installed</a>, select the debug icon in the activity bar and make sure Run and Debug is set to Launch. Now F5 will work using openocd acquired by vcpkg to flash and debug the attached board. Execution stops at the entry function, so here we see the assembly code for that. We can also view the disassembly by right clicking the function in the call stack window, Open Disassembly View.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png"><img class="alignnone size-full wp-image-30149" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png" alt="Assembly source and disassembly screenshot" width="1047" height="177" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png 1047w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-300x51.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-1024x173.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-768x130.png 768w" sizes="(max-width: 1047px) 100vw, 1047px" /></a></p>
<p>Press continue to let execution continue.</p>
<h5 id="peripheral-registers">Peripheral Registers</h5>
<p>Now press the A button on the board. This has triggered our breakpoint. We can now go to the command palette Ctrl + Shift + P  and enter “peripheral”, select Focus on Peripheral View View. This opens the peripheral register view using the information from our SVD file specified in the launch configuration. We can now scroll through this list to find the register we are interested in, here TIM3-&gt;CCR1 which will update when we step over the RGB_LED_SET_R function.</p>
<p>On break</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png"><img class="alignnone wp-image-30259 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png" alt="Register before stepping" width="847" height="405" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png 847w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new-300x143.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new-768x367.png 768w" sizes="(max-width: 847px) 100vw, 847px" /></a></p>
<p>After stepping</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png"><img class="alignnone wp-image-30260 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png" alt="Register after stepping" width="898" height="410" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png 898w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new-300x137.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new-768x351.png 768w" sizes="(max-width: 898px) 100vw, 898px" /></a></p>
<h5 id="rtos-object-views">RTOS Object Views</h5>
<p>VS Code threads view won’t show you the threads in our Azure RTOS application. Why not? A good explanation can be found in this <a href="https://azure.microsoft.com/resources/real-time-operating-system">white paper on Real Time Operating Systems</a>.</p>
<p>“A Real-Time Operating System is system software that provides services and manages processor resources for applications. These resources include processor cycles, memory, peripherals, and interrupts. The main purpose of a Real-Time Operating System is to allocate processing time among various duties the embedded software must perform. This typically involves a division of the software into pieces, commonly called “tasks” or “threads,” and creating a run-time environment that provides each thread with its own virtual microprocessor (“Multithreading”). Basically, a virtual microprocessor consists of a virtual set of microprocessor resources, e.g., register set, program counter, stack memory area, and a stack pointer. Only while executing does a thread use the physical microprocessor resources, but each thread retains its own copy of the contents of these resources as if they were its own private resources (the thread”s “context”).”</p>
<p>So for embedded development ideally you would have views that could show you information about these RTOS objects. To see the new available RTOS objects views, go to the command palate Ctrl + Shift + P  and enter “rtos” then select Focus on RTOS viewer view</p>
<p>This will open the threads view that shows at a glance much of the information you would commonly need during embedded development, thread ids and names, how many times they have run, where the stack starts, ends, and its size as well as the maximum stack usage.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png"><img class="alignnone size-full wp-image-30153" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png" alt="RTOS threads window" width="1277" height="167" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png 1277w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-300x39.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-1024x134.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-768x100.png 768w" sizes="(max-width: 1277px) 100vw, 1277px" /></a></p>
<p>There are other views for additional ThreadX objects like block and byte pools, events, mutexes, queues, and timers. You can find these by selecting the three dots in the RTOS Viewer panel.</p>
<p>We also have RTOS object views for FreeRTOS though the available objects there differ based on what it supports.</p>
<h5 id="hardware-breakpoint-limits">Hardware breakpoint limits</h5>
<p>One last debugging capability to call out is that embedded hardware targets commonly have a limited set of hardware breakpoints available. Setting too many can corrupt the debugger state. As such we have added hardwareBreakpoints to launch.json. For this board that is set to what it supports which is 6. If we set more than that we will see the breakpoint is not set but will show as a gray empty circle.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png"><img class="alignnone size-full wp-image-30154" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png" alt="Hardware breakpoint example screenshot" width="328" height="66" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png 328w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint-300x60.png 300w" sizes="(max-width: 328px) 100vw, 328px" /></a></p>
<p>If you mouse over the breakpoint in the breakpoints view you will see a warning that it won’t be hit. This prevents corrupting the connection to the board and allows us the opportunity to unset some other breakpoints and continue debugging uninterrupted.</p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose VS Code for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Embedded Software Development in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Execution and Static Analysis Support for MSVC on Compiler Explorer</title>
		<link>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/</link>
					<comments>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 01 Mar 2022 18:41:11 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30113</guid>

					<description><![CDATA[<p>Compiler Explorer is a popular resource for visualizing the assembly output of various compilers, trying out different compiler versions and flags, and testing many popular libraries.<br />
We&#8217;re pleased to announce that, as of today, code execution and static analysis are now available for MSVC on Compiler Explorer.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/">Execution and Static Analysis Support for MSVC on Compiler Explorer</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://godbolt.org/">Compiler Explorer</a> is a popular resource for visualizing the assembly output of various compilers, trying out different compiler versions and flags, and testing many popular libraries.</p>
<p>We&#8217;re pleased to announce that, as of today, code execution and static analysis are now available for MSVC on Compiler Explorer. Execution on CE has been one of our <a href="https://developercommunity.visualstudio.com/t/allow-code-execution-on-godboltorg-for-msvc-compil/663829">highest voted tickets on Developer Community</a>, so we hope many of you will find it useful. The static analysis tool provided is the same as offered in <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">GitHub Actions</a> and in the IDE as <a href="https://devblogs.microsoft.com/cppblog/in-editor-code-analysis-in-visual-studio-2019-preview-2/">background code analysis</a>.</p>
<p>To enable code execution, tick the &#8220;Execute the code&#8221; box in the &#8220;Output…&#8221; menu. Now, every time the code is compiled, it will be run and the output will be displayed in the Output window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png"><img class="aligncenter wp-image-30121 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png" alt="Execute the code and compile to binary options highlighted in the output menu" width="866" height="308" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png 866w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-300x107.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-768x273.png 768w" sizes="(max-width: 866px) 100vw, 866px" /></a></p>
<p>To enable static analysis, select &#8220;Static Analysis&#8221; from the &#8220;Add tool…&#8221; menu. Output from the tool will be written to a new Static Analysis window. You can find out more about our toolchain&#8217;s static analysis capabilities in our <a href="https://docs.microsoft.com/en-us/cpp/code-quality/code-analysis-for-c-cpp-overview?view=msvc-170">code analysis documentation</a>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png"><img class="aligncenter wp-image-30122 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png" alt="Static analysis highlighted in the add tool menu" width="849" height="311" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png 849w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1-300x110.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1-768x281.png 768w" sizes="(max-width: 849px) 100vw, 849px" /></a></p>
<p>You can see the static analysis in action below.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png"><img class="aligncenter wp-image-30128 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png" alt="Static analysis finding an issue with the code" width="3838" height="874" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png 3838w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-300x68.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-1024x233.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-768x175.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-1536x350.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-2048x466.png 2048w" sizes="(max-width: 3838px) 100vw, 3838px" /></a></p>
<p>A huge thanks to Matt Godbolt and Patrick Quist from the Compiler Explorer team for their support. On the Microsoft side, much of this work was done by Tim Myers and Dale Hirt.</p>
<p>You can let us know what you think of the new support on Twitter <a href="https://twitter.com/visualc">@visualc</a> or in the comments below.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/">Execution and Static Analysis Support for MSVC on Compiler Explorer</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>GSL 4.0.0 is Available Now</title>
		<link>https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/</link>
		
		<dc:creator><![CDATA[Dmitry Kobets]]></dc:creator>
		<pubDate>Tue, 01 Feb 2022 15:45:22 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[Writing Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30051</guid>

					<description><![CDATA[<p>GSL 4.0.0 has been released! Here is a summary of the changes.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/">GSL 4.0.0 is Available Now</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Version 4.0.0 of Microsoft’s implementation of the <a href="https://github.com/microsoft/GSL">C++ Core Guidelines Support Library</a> (GSL) is now available for you to download on the <a href="https://github.com/microsoft/gsl/releases">releases page</a>. This release maintains the safety guarantees that we have always offered and adds improvements to various parts of the library.</p>
<h2 id="what-changed-in-this-release">What changed in this release?</h2>
<ul>
<li><a href="#deprecation-of-gslstring_span">Deprecation of <code>gsl::string_span</code></a></li>
<li><a href="#removal-of-gsl-multi_span">Removal of <code>&lt;gsl/multi_span&gt;</code></a></li>
<li><a href="#header-files-dropped-the-gsl_-prefix">Header files dropped the <code>gsl_</code> prefix</a></li>
<li><a href="#changes-to-not_null">Changes to <code>not_null</code></a></li>
<li><a href="#gslspan-and-stdspan-now-use-the-correct-specialization-of-gslat"><code>gsl::span</code> and <code>std::span</code> now use the correct specialization of <code>gsl::at</code></a></li>
<li>The <code>zstring</code> family no longer requires empty brackets to be used: <a href="https://github.com/microsoft/GSL/issues/992">issue#992</a>
<ul>
<li>for example, <code>void foo(zstring&lt;&gt; str);</code> should now be <code>void foo(zstring str);</code></li>
</ul>
</li>
<li><code>gsl::narrowing_error</code> now has a helpful <code>what()</code> message</li>
<li><code>finally</code> and <code>final_action</code> are now <code>[[nodiscard]]</code></li>
<li><a href="#gsl-will-work-in-environments-where-exceptions-are-disabled-with-some-caveats">GSL will work in environments where exceptions are disabled, with some caveats</a></li>
<li>GSL will work in environments which do not support iostreams, via the addition of the <code>GSL_NO_IOSTREAMS</code> flag: <a href="https://github.com/microsoft/GSL/pull/935">#953</a></li>
<li><a href="#C-compilers">Updated compiler support</a></li>
<li><a href="#cmake-and-build-improvements">CMake and build improvements</a></li>
</ul>
<h2 id="deprecation-of-gslstring_span">Deprecation of <code>gsl::string_span</code></h2>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/pull/1680">isocpp/CppCoreGuidelines#1680</a> removed <code>string_span</code> from the C++ Core Guidelines. The recommendation is to use <code>std::string_view</code>, <code>std::span&lt;char&gt;</code> or <code>gsl::span&lt;char&gt;</code> instead. To more closely align Microsoft’s GSL with the C++ Core Guidelines, we deprecated our implementation of <code>string_span</code> and <code>zstring_span</code>, including <code>basic_string_span</code>, <code>basic_zstring_span</code>, and all related types. For the time being, we will continue to provide the <code>&lt;gsl/string_span&gt;</code> header, but it will not be actively worked on or maintained. A table of all supported and unsupported types/features can be found in the <a href="https://github.com/microsoft/GSL/blob/main/README.md">README.md</a>.</p>
<h2 id="removal-of-gsl-multi_span">Removal of <code>&lt;gsl/multi_span&gt;</code></h2>
<p><code>multi_span</code>, <code>strided_span</code>, and everything else in <code>&lt;gsl/multi_span&gt;</code> were deprecated over a year ago in <a href="https://github.com/microsoft/GSL/releases/tag/v3.0.0">GSL 3.0.0</a>, and it is time for them and their associated tests to be removed from the library.</p>
<h2 id="header-files-dropped-the-gsl_-prefix">Header files dropped the <code>gsl_</code> prefix</h2>
<p>All headers which previously contained a <code>gsl_</code> prefix in their name have had this prefix removed. For example, <code>&lt;gsl/gsl_algorithm&gt;</code> is now <code>&lt;gsl/algorithm&gt;</code>. The <code>gsl_</code> prefixed files still exist and pass through to the updated files, but will be removed in a future release.</p>
<h2 id="changes-to-not_null">Changes to <code>not_null</code></h2>
<p>To more closely align Microsoft’s GSL with the C++ Core Guidelines, <code>gsl::not_null</code> now accepts only types which are <em>comparable</em> to <code>nullptr</code>. Previously, it accepted only types which are <em>assignable</em> from <code>nullptr</code>, but this was stricter than what was intended by the <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#gslview-views">Core Guidelines</a>.</p>
<p>The functions <code>make_not_null</code> and <code>make_strict_not_null</code>, and the <code>not_null</code> comparison operators, are now all <code>noexcept</code>.</p>
<h2 id="gslspan-and-stdspan-now-use-the-correct-specialization-of-gslat"><code>gsl::span</code> and <code>std::span</code> now use the correct specialization of <code>gsl::at</code></h2>
<p><code>gsl::span</code> and <code>std::span</code> now have their own separate specializations of <code>gsl::at</code>, to ensure consistent behavior between the two versions of span. Both overloads are included when importing <code>&lt;gsl/span&gt;</code>. The <code>std::span</code> overload can be separately included from <code>&lt;gsl/util&gt;</code>.</p>
<h2 id="gsl-will-work-in-environments-where-exceptions-are-disabled-with-some-caveats">GSL will work in environments where exceptions are disabled, with some caveats</h2>
<p><code>gsl::narrow</code> is the only part of the library which may throw exceptions and has been moved into its own header <code>&lt;gsl/narrow&gt;</code>. This header is included in <code>&lt;gsl/gsl&gt;</code> only if exceptions are enabled. This allows users of the library who are working in environments without exceptions to use all of the other components of the library.</p>
<p>Note: <code>gsl::narrow_cast</code> is still in <code>&lt;gsl/util&gt;</code>, since it does not throw exceptions.</p>
<h2 id="updated-compiler-support">Updated compiler support</h2>
<p>The list of supported compilers/toolsets has been updated with newer versions. More info on compiler support can be found in the <a href="https://github.com/microsoft/GSL/blob/main/README.md#supported-compilers--toolsets">README.md</a>.</p>
<table>
<thead>
<tr>
<th>Compiler/Toolset</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>XCode</td>
<td>13.2.1 &amp; 12.5.1</td>
</tr>
<tr>
<td>GCC</td>
<td>11.1.0 &amp; 10.3.0</td>
</tr>
<tr>
<td>Clang</td>
<td>12.0.0 &amp; 11.0.0</td>
</tr>
<tr>
<td>Visual Studio with MSVC</td>
<td>VS2022 (17.0) &amp; VS2019 (16.11)</td>
</tr>
<tr>
<td>Visual Studio with LLVM</td>
<td>VS2022 (17.0) &amp; VS2019 (16.11)</td>
</tr>
</tbody>
</table>
<h2 id="cmake-and-build-improvements">CMake and build improvements</h2>
<ul>
<li>GSL Install logic is now guarded by a cmake option <code>GSL_INSTALL</code>: <a href="https://github.com/microsoft/GSL/pull/964">#964</a></li>
<li>Fix bug which prevented the library from being built on a 32-bit host and then being used on a 64-bit machine: <a href="https://github.com/microsoft/GSL/pull/893">#893</a></li>
<li>Build will now use <code>CMAKE_CXX_STANDARD</code> if it&#8217;s provided <a href="https://github.com/microsoft/GSL/pull/953">#953</a></li>
<li>Clean up <code>GSL_SUPPRESS</code> warning for intel compilers: <a href="https://github.com/microsoft/GSL/pull/906">#906</a></li>
<li>Fix build failure for C++20 compilers which don&#8217;t have <code>std::span</code>: <a href="https://github.com/microsoft/GSL/pull/993">#993</a></li>
<li>Cleaned up some static analysis warnings</li>
<li>The cmake cache variable <code>VS_ADD_NATIVE_VISUALIZERS</code> has been renamed to <code>GSL_VS_ADD_NATIVE_VISUALIZERS</code>: <a href="https://github.com/microsoft/GSL/pull/941">#941</a></li>
</ul>
<h2 id="summary">Summary</h2>
<p>This has been a list of the changes in the GSL 4.0.0 release. You can download the code at the <a href="https://github.com/microsoft/GSL">GSL GitHub page</a>. Please stay tuned for future releases!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/">GSL 4.0.0 is Available Now</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>How we used C++20 to eliminate an entire class of runtime bugs</title>
		<link>https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/</link>
					<comments>https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Thu, 13 Jan 2022 17:52:08 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[compiler]]></category>
		<category><![CDATA[constexpr]]></category>
		<category><![CDATA[safety]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29981</guid>

					<description><![CDATA[<p>C++20 is here and has been supported in MSVC since 16.11, but today&#8217;s post is not about how you can use it, but rather how we used it to effectively eliminate an entire class of runtime bugs by hoisting a check into compile-time.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/">How we used C++20 to eliminate an entire class of runtime bugs</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>C++20 is here and has been supported in MSVC since <a href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">16.11</a>, but today&#8217;s post is not about how you can use it, but rather how <em>we</em> used it to effectively eliminate an entire class of runtime bugs by hoisting a check into compile-time. Let&#8217;s get right into it!</p>
<h4><span id="humble-beginnings">Humble beginnings</span></h4>
<p>In compiler design one of the very first things you need is a way to convey to the programmer that their source code has an error or warn them if their code might not behave as expected. In MSVC our error infrastructure looks something like this:</p>
<pre>enum ErrorNumber {
    C2000,
    C2001,
    C2002,
    ...
};
void error(ErrorNumber, ...);</pre>
<p>The way <code>error</code> works is that each <code>ErrorNumber</code> has a corresponding string entry which represents the text we want to display to the user. These text strings can be anything from: <code>C2056 -&gt; "illegal expression"</code> to: <code>C7627 -&gt; "'%1$T': is not a valid template argument for '%2$S'"</code>, but what are these <code>%1$T</code> and <code>%2$S</code> things? These are some of the compiler&#8217;s format-specifiers to display certain types of structures in the compiler to the user in a readable way.</p>
<h4><span id="double-edged-sword">The double-edged sword of format-specifiers</span></h4>
<p>Format-specifiers provide a lot of flexibility and power to us as compiler developers. Format-specifiers can more clearly illustrate why a diagnostic was issued and provide the user with more context into the problem. The problem with format-specifiers is that they are not type checked in the call to <code>error</code>, so if we happen to get an argument type wrong or did not pass an argument at all it will almost certainly end up in a runtime error later for the user. Other problems arise when you want to refactor a diagnostic message into something clearer, but to do that you need to query every caller of that diagnostic message and ensure that the refactor agrees with the arguments being passed to <code>error</code>.</p>
<p>We have three high-level goals when designing a system that can check our format-specifiers:</p>
<ol>
<li>Validate that argument types passed into our diagnostic APIs at compile-time so authoring a mistake is caught as early as possible.</li>
<li>Minimize changes made to callers of diagnostic APIs. This is to ensure well-formed calls retain their original structure (no disruption to future calls as well).</li>
<li>Minimize changes made to implementation details of the callee. We should not change the behavior of the diagnostic routines at runtime.</li>
</ol>
<p>There are, of course, some solutions introduced with later C++ standards which could aid in trying to remedy this problem. For one, once variadic templates were introduced into the language we could have tried some template metaprogramming to try and type check the calls to <code>error</code>, but that would require a separate lookup table since constexpr and templates were limited in what they could do. C++14/17 both introduced a lot of improvements to constexpr and non-type template arguments. Something like this would work great:</p>
<pre>constexpr ErrorToMessage error_to_message[] = {
    { C2000, fetch_message(C2000) },
    { C2001, fetch_message(C2001) },
    ...
};

template &lt;typename... Ts&gt;
constexpr bool are_arguments_valid(ErrorNumber n) {
    /* 1. fetch message
       2. parse specifiers
       3. check each specifier against the parameter pack Ts... */
    return result;
}</pre>
<p>So we finally had the tools to try and check the format-specifiers at compile-time. But there was still a problem: we still did not have a way to silently check all the existing calls to <code>error</code> meaning that we would have to add an extra layer of indirection between the call sites of <code>error</code> to ensure that the <code>ErrorNumber</code> could fetch the string at compile-time and check the argument types against it. In C++17 this will not work:</p>
<pre>template &lt;typename... Ts&gt;
void error(ErrorNumber n, Ts&amp;&amp;... ts) {
    assert(are_arguments_valid&lt;Ts...&gt;(n));
    /* do error stuff */
}</pre>
<p>And we cannot make <code>error</code> itself constexpr because it does a lot of constexpr-unfriendly things. Additionally, adjusting all the call sites to something like: <code>error&lt;C2000&gt;(a, b, c)</code> so that we can check the error number as a compile-time expression is unsavory and would cause a lot of unnecessary churn in the compiler.</p>
<h4><span id="cpp20">C++20 to the rescue!</span></h4>
<p>C++20 introduced an important tool for us to enable compile-time checking, <code>consteval</code>. <code>consteval</code> is in the family of constexpr but the language guarantees that a function adorned with <code>consteval</code> will be evaluated at compile-time. A well-known library by the name of <a href="https://github.com/fmtlib/fmt">fmtlib</a> introduced compile-time checking as part of the <a href="https://fmt.dev/latest/api.html#core-api">core API</a> and it did so without changing any call sites, assuming the call site was well-formed according to the library. Imagine a simplified version of <code>fmt</code>:</p>
<pre>template &lt;typename T&gt;
void fmt(const char* format, T);

int main() {
    fmt("valid", 10);    // compiles
    fmt("oops", 10);     // compiles?
    fmt("valid", "foo"); // compiles?
}</pre>
<p>Where the intent is that <code>format</code> should always be equal to <code>"valid"</code> and <code>T</code> should always be an <code>int</code>. The code in <code>main</code> is ill-formed according to the library in this case, but nothing validates that at compile-time. fmtlib accomplished compile-time checking using a little trick with user-defined types:</p>
<pre>#include &lt;string_view&gt;
#include &lt;type_traits&gt;

// Exposition only
#define FAIL_CONSTEVAL throw

template &lt;typename T&gt;
struct Checker {
    consteval Checker(const char* fmt) {
        if (fmt != std::string_view{ "valid" }) // #1
            FAIL_CONSTEVAL;
        // T must be an int
        if (!std::is_same_v&lt;T, int&gt;)            // #2
            FAIL_CONSTEVAL;
    }
};

template &lt;typename T&gt;
void fmt(std::type_identity_t&lt;Checker&lt;T&gt;&gt; checked, T);

int main() {
    fmt("valid", 10);    // compiles
    fmt("oops", 10);     // fails at #1
    fmt("valid", "foo"); // fails at #2
}</pre>
<p>Note: you need to use the <code>std::type_identity_t</code> trick to keep <code>checked</code> from participating in type deduction. We only want it to deduce the rest of the arguments and use their deduced types as template arguments to <code>Checker</code>.</p>
<p>You can fiddle with the example for yourself using <a href="https://godbolt.org/z/baPvojah1">Compiler Explorer</a>.</p>
<h4><span id="tying-it-together">Tying it all together</span></h4>
<p>The code above is powerful in that it gives us a tool which can perform additional safety checking without changing any caller which is well-formed. Using the technique above we applied compile-time checking to all our <code>error</code>, <code>warning</code>, and <code>note</code> message routines. The code used in the compiler is nearly identical to the <code>fmt</code> above except that the argument to <code>Checker</code> is an <code>ErrorNumber</code>.</p>
<p>In total we identified <b>~120</b> instances where we were either passing the incorrect number of arguments to a diagnostic API or where we passed the wrong type for a particular format-specifier. Over the years we have received bugs regarding strange compiler behavior when emitting a diagnostic or a straight-up ICE (Internal Compiler Error) because the format-specifiers were looking for arguments which were incorrect or did not exist. Using C++20 we have largely eliminated possibility of such bugs happening in the future and while offering the ability for us to safely refactor diagnostic messages, made possible by one little keyword: <code>consteval</code>.</p>
<h4 id="closing">Closing</h4>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow me on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/">How we used C++20 to eliminate an entire class of runtime bugs</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ December 2021 Update: clang-tidy</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Tue, 14 Dec 2021 19:26:50 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++ extension]]></category>
		<category><![CDATA[clang]]></category>
		<category><![CDATA[clang-tidy]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[CPP]]></category>
		<category><![CDATA[cpptools]]></category>
		<category><![CDATA[linter]]></category>
		<category><![CDATA[static analysis]]></category>
		<category><![CDATA[tidy]]></category>
		<category><![CDATA[vs code]]></category>
		<category><![CDATA[VSCode]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29926</guid>

					<description><![CDATA[<p>The latest insiders release of the C++ extension is here, bringing clang-tidy support to VS Code! Clang-tidy is a clang-based C++ linter tool that detects common errors in your code, like style violations and bugs that can be deduced via static analysis.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/">Visual Studio Code C++ December 2021 Update: clang-tidy</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The latest <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.8.0-insiders2">insiders release</a> of the C++ extension is here, bringing clang-tidy support to VS Code! <a href="https://clang.llvm.org/extra/clang-tidy/">Clang-tidy</a> is a clang-based C++ linter tool that detects common errors in your code, like style violations and bugs that can be deduced via static analysis. <a href="https://github.com/microsoft/vscode-cpptools/issues/2908">Clang-tidy integration</a> was one of our top asks on GitHub, so we’re excited to announce that it’s ready for you to try!</p>
<h1 id="getting-started">Getting started</h1>
<h2 id="do-i-need-to-install-clang-tidy">Do I need to install clang-tidy?</h2>
<p>Nope! Clang-tidy now comes bundled with the C++ extension. But if you already have clang-tidy installed (and it’s on your environment’s path), the C++ extension will use that one instead. You can point the C++ extension to any clang-tidy binary by editing the C++ extension’s <strong>Clang Tidy: Path</strong> setting.</p>
<h2 id="how-do-i-run-clang-tidy-in-vs-code">How do I run clang-tidy in VS Code?</h2>
<p>To manually run clang-tidy, open the <strong>Command Palette (Ctrl + Shift + P)</strong> and type <strong>“Run Code Analysis.” </strong>You can run clang-tidy on the active file, on all open files, or on the entire workspace.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png"><img class="alignnone size-full wp-image-29937" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png" alt="Screenshot showing how to manually run clang-tidy from the Command Palette" width="2024" height="380" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png 2024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-300x56.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-1024x192.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-768x144.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-1536x288.png 1536w" sizes="(max-width: 2024px) 100vw, 2024px" /></a></p>
<p>If there are certain workspace files or folders that you <em>don’t</em> want to run clang-tidy on, add them to the <strong>Clang Tidy: Exclude</strong> setting (C_Cpp.codeAnalysis.exclude in settings.json).</p>
<p>You can also set clang-tidy to run automatically whenever you open or save a file. To turn on automatic code analysis, open your project settings by selecting <strong>“Preferences: Open Settings (UI)”</strong> from the <strong>Command Palette (Ctrl + Shift + P).</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png"><img class="alignnone size-full wp-image-29936" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png" alt="Screenshot showing how to open VS Code settings from the Command Palette" width="1742" height="184" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png 1742w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-300x32.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-1024x108.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-768x81.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-1536x162.png 1536w" sizes="(max-width: 1742px) 100vw, 1742px" /></a></p>
<p>Then search for <strong>“code analysis” </strong>to find all the clang-tidy settings and set <strong>Clang Tidy: Enabled</strong> to true.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png"><img class="alignnone size-full wp-image-29929" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png" alt="Screenshot of the Clang Tidy: Enabled setting in VS Code, which must be set to true in order for code analysis to run automatically in the background" width="1770" height="284" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png 1770w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-300x48.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-1024x164.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-768x123.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-1536x246.png 1536w" sizes="(max-width: 1770px) 100vw, 1770px" /></a></p>
<p><strong>Note:</strong> You can set clang-tidy settings globally (in the User tab) or at the workspace level.</p>
<p>You can check if clang-tidy is running by looking for the fire icon in the blue status bar at the bottom of the window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png"><img class="alignnone size-full wp-image-29935" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png" alt="Screenshot of the fire icon in the status bar. Users can hover over this icon to see the status of clang-tidy." width="590" height="192" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png 590w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover-300x98.png 300w" sizes="(max-width: 590px) 100vw, 590px" /></a></p>
<p>To pause or cancel clang-tidy, click on the fire icon and then choose an option from the drop down.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png"><img class="alignnone size-full wp-image-29927" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png" alt="Screenshot showing the Cancel and Pause options for clang-tidy from a dropdown in VS Code" width="1746" height="242" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png 1746w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-300x42.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-1024x142.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-768x106.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-1536x213.png 1536w" sizes="(max-width: 1746px) 100vw, 1746px" /></a></p>
<h2 id="how-do-i-configure-clang-tidy-checks-and-check-options">How do I configure clang-tidy checks and check options?</h2>
<p>If you have a .clang-tidy configuration file in your project directory, the C++ extension will honor the checks and options defined in that file. If you have multiple .clang-tidy configuration files in your workspace, clang-tidy will use the configuration file closest to the source file by searching up the path in its parent directories. Alternatively, you can specify a clang-tidy configuration with the <strong>Clang Tidy: Config</strong> setting. <strong>Clang Tidy: Config</strong> accepts checks and check options as a YAML/JSON-formatted string.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png"><img class="alignnone size-full wp-image-29928" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png" alt="Screenshot of the Clang Tidy: Config setting in VS Code, where users can pass a string in YAML/JSON format to specify clang-tidy checks and options" width="1860" height="376" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png 1860w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-300x61.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-1024x207.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-768x155.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-1536x311.png 1536w" sizes="(max-width: 1860px) 100vw, 1860px" /></a></p>
<p>If a source file doesn’t have a .clang-tidy configuration file in any of its parent directories, and the <strong>Clang Tidy: Config</strong> property is left empty, then the fallback configuration (defined in C_Cpp.codeAnalysis.clangTidy.fallbackConfig) will be used for that file.</p>
<p>You can enable and disable more checks by using the <strong>Clang Tidy &gt; Checks: Enabled</strong> and <strong>Clang Tidy &gt; Checks: Disabled</strong> settings. The checks defined in these settings are run in addition to the checks in the .clang-tidy file.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png"><img class="alignnone size-full wp-image-29934" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png" alt="Screenshot of the Clang Tidy &gt; Checks: Enabled setting in VS Code, where users pick which clang-tidy settings to run on their project" width="1558" height="504" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png 1558w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-300x97.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-1024x331.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-768x248.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-1536x497.png 1536w" sizes="(max-width: 1558px) 100vw, 1558px" /></a></p>
<p>Selecting <strong>Add Item</strong> shows a list of all clang-tidy checks.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png"><img class="alignnone size-full wp-image-29940" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png" alt="Screenshot showing the list of available clang-tidy checks after selecting Add Item in the Clang Tidy &gt; Checks: Enabled settings" width="1630" height="1162" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-300x214.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-1024x730.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-768x547.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-1536x1095.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></a></p>
<p>You can add as many checks as you’d like to both the <strong>Clang Tidy &gt; Checks: Enabled</strong> and <strong>Clang Tidy &gt; Checks: Disabled</strong> settings.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png"><img class="alignnone size-full wp-image-29933" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png" alt="Screenshot of the Clang Tidy &gt; Checks: Disabled and Clang Tidy &gt; Checks: Disabled settings in VS Code, where users can choose which clang-tidy checks to run or not run for their workspace" width="1602" height="1244" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png 1602w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-300x233.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-1024x795.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-768x596.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-1536x1193.png 1536w" sizes="(max-width: 1602px) 100vw, 1602px" /></a></p>
<h2 id="how-do-i-pass-command-line-args-to-clang-tidy">How do I pass command line args to clang-tidy?</h2>
<p>If you typically pass <a href="https://clang.llvm.org/extra/clang-tidy/">command line options</a> to clang-tidy, you can specify those in the <strong>Clang Tidy: Args</strong> property. The <strong>Clang Tidy: Args</strong> setting takes precedence over the equivalent Clang Tidy settings in the editor (such as Clang Tidy &gt; Checks: Enabled and Clang Tidy &gt; Checks: Disabled).</p>
<h1 id="viewing-check-results-in-the-editor">Viewing check results in the editor</h1>
<p>The results of clang-tidy checks (warnings and errors) are displayed in the <strong>Problems panel</strong> and as squiggles beneath relevant sections of code.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png"><img class="alignnone size-full wp-image-29930" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png" alt="Screenshot of the results of clang-tidy checks showing up in the Problems pane in VS Code" width="1646" height="1312" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png 1646w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-300x239.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-1024x816.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-768x612.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-1536x1224.png 1536w" sizes="(max-width: 1646px) 100vw, 1646px" /></a></p>
<p>Clicking on the problem in the Problems panel takes you to the issue in your source file. To clear the code analysis squiggles, click on the Quick Actions lightbulb, and then select <strong>Clear code analysis squiggles.</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png"><img class="alignnone size-full wp-image-29931" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png" alt="Screenshot of the &quot;Clear Code Analysis Squiggles&quot; Quick Action, which is visible when selecting the lightbulb next to underlined code " width="1172" height="388" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png 1172w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-300x99.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-1024x339.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-768x254.png 768w" sizes="(max-width: 1172px) 100vw, 1172px" /></a></p>
<h1 id="clang-tidy-settings">Clang-tidy settings</h1>
<p>Here’s a list of new VS Code settings to help you configure clang-tidy for your workspace.</p>
<table>
<tbody>
<tr>
<td width="282"><strong>Setting name</strong></td>
<td width="60"><strong>Type</strong></td>
<td width="84"><strong>Default value</strong></td>
<td width="198"><strong>Description</strong></td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.enabled</p>
<p>&nbsp;</td>
<td width="60">Boolean</td>
<td width="84">False</td>
<td width="198">When true, clang-tidy will be enabled and run automatically if C_Cpp.codeAnalysis.runAutomatically is set to true</p>
<p>&nbsp;</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.runAutomatically</td>
<td width="60">Boolean</td>
<td width="84">True</td>
<td width="198">When true, runs clang-tidy on file open and file save.</p>
<p>&nbsp;</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.path</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">The full path to the clang-tidy executable.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.checks.enabled</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">List of enabled clang-tidy checks. The values are appended to the Checks in a .clang-tidy file or C_Cpp › Code Analysis › Clang Tidy: Config.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.checks.disabled</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">List of disabled clang-tidy checks. The values are appended to the Checks in a .clang-tidy file or C_Cpp › Code Analysis › Clang Tidy: Config, if any.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.config</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Specifies a clang-tidy configuration in YAML/JSON format: {Checks: &#8216;-*,clang-analyzer-*&#8217;, CheckOptions: [{key: x, value: y}]}. When empty, any found .clang-tidy files will be used.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.fallbackConfig</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Specifies a clang-tidy configuration in YAML/JSON format to be used as a fallback when C_Cpp › Code Analysis › Clang Tidy: Config is not set and no .clang-tidy file is found.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.args</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">Command line arguments to pass to clang-tidy. These take precedence over the equivalent C_Cpp.codeAnalysis.clangTidy.* settings.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.exclude</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Configure glob patterns for excluding folders and files for code analysis.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.headerFilter</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">A POSIX extended regular expression (ERE) matching the names of the headers to output diagnostics from. It overrides the HeaderFilterRegex option in a .clang-tidy file, if any.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.maxConcurrentThreads</p>
<p>(User level only)</td>
<td width="60">Int</td>
<td width="84">Null (empty)</td>
<td width="198">The maximum number of concurrent threads to use for code analysis. The default of null (empty) uses half the value inherited from C_Cpp: Max Concurrent Threads.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.maxMemory</p>
<p>(User level only)</td>
<td width="60">Int</td>
<td width="84">Null (empty)</td>
<td width="198">Fewer code analysis processes will run concurrently after this memory usage (in MB) is exceeded. The default of null (empty) uses the value inherited from C_Cpp: Max Memory.</td>
</tr>
</tbody>
</table>
<h1 id="coming-soon">Coming soon</h1>
<p>Hang tight! Applying suggested fixes in the editor is coming soon.</p>
<h1 id="what-do-you-think">What do you think?</h1>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today and join our Insiders program to access this initial release of clang-tidy integration. To join our Insiders program, go to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/">Visual Studio Code C++ December 2021 Update: clang-tidy</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>The /fp:contract flag and changes to FP modes in VS2022</title>
		<link>https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/</link>
		
		<dc:creator><![CDATA[Gautham Beeraka (Intel Americas Inc)]]></dc:creator>
		<pubDate>Tue, 14 Dec 2021 00:25:13 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[Floating Point]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29915</guid>

					<description><![CDATA[<p>The /fp:contract flag and changes to FP modes in VS2022<br />
In this blog we will cover a new feature we have added to the MSVC version 17.0 compiler in VS2022 that impacts the generation of Floating-Point contractions such as Fused Multiply Add (FMA) instructions.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022">The /fp:contract flag and changes to FP modes in VS2022</h1>
<p>In this blog we will cover a new feature we have added to the MSVC version 17.0 compiler in VS2022 that impacts the generation of Floating-Point contractions such as Fused Multiply Add (FMA) instructions. We will cover how FMA contractions are supported in pre-VS2022 MSVC compiler releases, a new /fp:contract flag and changes to existing Floating-Point pragmas in VS2022 MSVC compiler allowing explicit control over generation of contractions</p>
<p>A contraction, as used here, is where two operations in the source code are performed by a single instruction in the executable code. Examples are Fused Multiply-Add (FMA) and reciprocal square root. The former computes ((a * b) + c), while the later computes (1/sqrt(a)). The advantages of contractions are increased speed of calculations involved and decrease in the code size of your application. The reason you might not want to use a contraction is because the intermediate result isn’t rounded, so the result might differ slightly from what you would get from separate instructions. That is often not a problem, but we’re particular about what we mean by “precise” and don’t want to promise something we’re not delivering. Giving you control over whether contractions are used or not gives the best of both worlds, where you can get consistent results when you need them and can use contractions when you don’t.</p>
<h2 id="pre-vs2022-behavior-for-contractions">Pre-VS2022 behavior for contractions</h2>
<p>In the versions of Visual Studio prior to VS2022, under the default FP mode of /fp:precise, the generation of contractions was inconsistent. This inconsistency was between different platforms and between scalar and vector versions of FMAs. The compiler could generate both scalar and vector versions of FMAs on the ARM and ARM64 platforms. On x86 and x64 platforms supporting FMA instructions, the compiler could only generate vector FMA instructions. We are addressing this inconsistency and updating the documentation on FP modes in VS2022.</p>
<h2 id="vs2022-behavior-for-contractions">VS2022 behavior for contractions</h2>
<p>Although contractions tend to improve the performance of your application, they can produce inconsistent results between debug and release builds and ISA targeting (example: SSE2 vs AVX2) and may result in breaking existing assumptions in test coverage. To account for this and address the aforementioned inconsistency, contractions will not be generated by default under the /fp:precise mode on all platforms starting from VS2022 version 17.0. We have introduced a new /fp:contract flag which can be used along with /fp:precise to enable contractions. The /fp:contract flag will enable both vector and scalar contractions on all platforms. The /fp:contract flag and the updated behavior for /fp:precise is documented <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fp-specify-floating-point-behavior?view=msvc-170">here</a>. The table below summarizes the behavior for VS2022.</p>
<table>
<tbody>
<tr>
<td><strong>Compiler FP-mode flag</strong></td>
<td><strong>VS2022 17.0 default behavior</strong></td>
<td><strong>VS2022 17.0 behavior with /fp:contract</strong></td>
</tr>
<tr>
<td>/fp:strict</td>
<td>No contractions</td>
<td>Incompatible (compiler error)</td>
</tr>
<tr>
<td>/fp:precise</td>
<td>No contractions</td>
<td>Allow contractions</td>
</tr>
<tr>
<td>/fp:fast</td>
<td>Allow contractions</td>
<td>Allow contractions</td>
</tr>
</tbody>
</table>
<p>The behavior of Floating-Point pragmas was also modified to agree with the behavior of the Floating-Point flags. The float_control pragmas will now disable contractions when turned on and will restore the previous setting for contractions when turned off. This new behavior is documented for <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/float-control?view=msvc-170">float_control</a>, <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/fenv-access?view=msvc-170">fenv_access</a> and <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/fp-contract?view=msvc-170">fp_contract</a> pragmas.</p>
<p>With this new behavior, there can be performance regressions since contractions are no longer generated by default. Adding the /fp:contract flag should mitigate this. The behavior of contractions can be further controlled at a function level using the Floating-Point pragmas.</p>
<p>Note that intrinsic functions such as: fma<em>, </em>fmaf<em> and </em>fmal can still be used to generate FMA machine instructions if the target architecture supports them.</p>
<h2 id="how-to-enable-fpcontract-in-vs2022">How to enable /fp:contract in VS2022</h2>
<p>To enable /fp:contract for your project:</p>
<p>In Visual Studio, add the /fp:contract option in the Additional Options box (Project|Properties|Configuration Properties|C/C++|Command Line|Additional Options)</p>
<p><img width="796" height="553" class="wp-image-29916" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1.png" alt="Graphical user interface, text, application, email Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1.png 796w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1-768x534.png 768w" sizes="(max-width: 796px) 100vw, 796px" /></p>
<p>Figure 1. Add the /fp:contract compiler option for each desired configuration.</p>
<p>Since generation of contractions is an optimization, adding the /fp:contract flag may not produce contractions for debug builds.</p>
<p>If you are upgrading your project from VS2019 to VS2022 and see different floating-point results, these are the things you should check:</p>
<ul>
<li>If your code is built with /fp:fast, this can be the expected behavior. /fp:fast allows the compiler to optimize things more aggressively with some loss in FP precision. More optimizations are likely firing in this case.</li>
<li>If your code is built with /fp:precise (or no /fp model is specified), try throwing /fp:contract to confirm if contractions were the cause of the FP changes. If it was, see if that makes sense for your scenario to continue to throw /fp:contract.</li>
<li>If your code is built with /fp:strict then <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">let us know</a>, there may be a compiler bug.</li>
</ul>
<h2 id="closing-notes">Closing Notes</h2>
<p>We’d love for you to download <a href="https://visualstudio.microsoft.com/vs/">Visual Studio 2022</a> and give it a try to see how the changes described above affect your applications. Your feedback is key to deliver the best experience. If you have any questions, please feel free to ask us below. You can also send us your comments through <a href="mailto:visualcpp@microsoft.com">e-mail</a>. If you encounter problems with the experience or have suggestions for improvement, please <a href="mailto:https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report A Problem</a> or reach out via <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">Developer Community</a>. You can also find us on Twitter <a href="mailto:https://twitter.com/visualc">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
