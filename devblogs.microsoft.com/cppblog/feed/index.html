<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Wed, 30 Nov 2022 17:19:00 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>MSVC OpenMP Update</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-openmp-update/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-openmp-update/#respond</comments>
		
		<dc:creator><![CDATA[Tanveer Gani]]></dc:creator>
		<pubDate>Tue, 29 Nov 2022 16:00:19 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[OpenMP]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31286</guid>

					<description><![CDATA[<p>Summary of your post, shown on the home page next to the featured image</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-openmp-update/">MSVC OpenMP Update</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In our previous <a href="https://devblogs.microsoft.com/cppblog/openmp-task-support-for-c-in-visual-studio/">blog post</a>, we announced support for OpenMP tasks starting with Visual Studio 17.2. Now, we are pleased to announce we have added further OpenMP features to Visual Studio 17.4, which brings us closer to conformance with OpenMP 3.1.</p>
<h2 id="pragma-atomic-with-openmp-3-1-semantics"><code>#pragma atomic</code> with OpenMP 3.1 semantics</h2>
<p>We added support for <code>#pragma omp atomic</code> a while ago but we now also support the full OpenMP 3.1 syntax and semantics for atomic operations. Specifically, we now support a <code>read</code>, <code>write</code>, <code>update</code> or <code>capture</code> clause in the pragma while the pragma can now apply either to an expression-statement (as before) or a structured block, which has particular restrictions that the compiler will check.</p>
<p>When the compiler encounters the new OpenMP atomic clauses, it will make sure that the LLVM OpenMP runtime (<code>libomp</code>) is being used:</p>
<pre><code class="language-text">example.cpp(14): error C7660: '#pragma omp atomic update': requires '-openmp:llvm' command line option(s)</code></pre>
<p>This is because we support the newer semantics only on the new LLVM-based OpenMP runtime.</p>
<p><code>omp atomic</code> may seem like a duplication of <code>omp critical</code> but it is different in that <code>omp critical</code> is a generalized mutual exclusion mechanism and can wrap any kind of code, while <code>omp atomic</code> limits the kinds of operations that it supports. Based on these restrictions, the compiler can, in principle, generate more optimized code. For example, a critical section always requires acquiring a lock from the underlying operating system, but an atomic operation can use the underlying hardware guarantees to avoid such locking for, say, loads or stores of variables smaller than a register.</p>
<p>Consider this example from the OpenMP 3.1 Specification:</p>
<pre><code class="language-c++">int work1(int i);
int work2(int i);

void atomic_example(int* x, int* y, int* index, int n)
{
    int i;
    #pragma omp parallel for shared(x, y, index, n)
    for (i = 0; i &lt; n; i++) {
        #pragma omp atomic update
        x[index[i]] += work1(i);

        y[i] += work2(i);
    }
}</code></pre>
<p>Compiling the above for x86 with full optimizations, this is what gets generated:</p>
<pre><code class="language-nasm">    push    esi
    call    ?work1@@YAHH@Z              ; work1

; 9    : #pragma omp atomic update
; 10   : x[index[i]] += work1(i);

    mov ecx, DWORD PTR _x$[esp+20]
    push    eax
    mov eax, DWORD PTR _index$[esp+24]
    mov eax, DWORD PTR [eax+edi]
    lea eax, DWORD PTR [ecx+eax*4]
    push    eax
    push    ebx
    push    0
    call    ___kmpc_atomic_fixed4_add

; 11   :         y[i] += work2(i);

    push    esi
    call    ?work2@@YAHH@Z              ; work2
    add DWORD PTR [edi], eax</code></pre>
<p>Note that to update <code>x[index[i]]</code>, the code first calculates the address of that array location, and then calls the <code>libomp</code> API <code>__kpmc_atmoc_fixed4_add</code> to do the actual update atomically, while for the subsequent update of <code>y[i]</code>, the code is just an <code>add</code> instruction.</p>
<p>Given that the OpenMP atomic operations are meant to be an especially efficient form of critical section, it&#8217;s possible to optimize the above code by generating the code for the <code>__kmp_atomic_fixed4_add</code> library call inline and avoid a function call. We don&#8217;t currently do this but this work is planned for future versions of MSVC.</p>
<p>We now also support <code>capture</code> as a clause for <code>omp atomic</code>, with both the expression-statement and structured block syntax. Using the <code>capure</code> clause allows atomic update of an l-value while capturing its initial or final value at the same time. E.g., consider a team of threads which we have to allocate work to. Assume the work is allocated based on &#8220;slots&#8221; which are identified by a variable <code>slot</code>, with the idea being that each thread gets assigned a different value of this variable. This could be implemented using atomic capture in this way:</p>
<pre><code class="language-c++">void assign_work()
{
    int slot = 0;
    int my_slot;
    const int max_slot = 1'000'000;

    #pragma omp parallel private(my_slot)
    while (slot &lt; max_slot)
    {
        // Get the current value of slot and update it.
        // Note that all threads are going through the
        // slots in parallel
        #pragma omp atomic capture
        { my_slot = slot; ++slot; }
        do_work(my_slot);
    }
}</code></pre>
<p>Each parallel thread running the loop body will atomically save the current value of <code>slot</code> into its private variable <code>my_slot</code> and then increment <code>slot</code>, the whole operation being executed atomically with repect to other threads. Consequently, no two threads will get the same value of <code>slot</code> passed to <code>do_work</code> and eventually all values up to <code>max_slot</code> will be allocated.</p>
<p>We could also write the above atomic operation more compactly using the expression-statement version of <code>capture</code>:</p>
<pre><code class="language-c++">#pragma omp atomic capture
my_slot = slot++;</code></pre>
<p>The compiler has added diagnostics for required expression forms for <code>omp atomic</code>. E.g.,:</p>
<pre><code class="language-c++">#pragma omp atomic
{ v = x; +x; }</code></pre>
<p>produces:</p>
<pre><code class="language-text">.\atomic-capture-block.c(14,24): error C3048: '#pragma omp atomic capture': expression or block-statement following pragma does not conform to the OpenMP specification
            v = x; +x;
                   ^</code></pre>
<p>Attempting to use an overloaded operator in a capture block or expression gives:</p>
<pre><code class="language-text">.\atomic_capture_neg.cpp(18,11): error C3943: '#pragma omp atomic': operator '+=' is overloaded; only built-in operators are allowed
    x += s;
      ^</code></pre>
<p>We&#8217;ve added diagnostics to help with the validating the semantics and syntax of <code>#pragma omp atomic</code> but one thing should be borne in mind: because MSVC doesn&#8217;t print expressions in diagnostics, using <code>/diagnostics:caret</code> is helpful in getting the most from the new diagnostics. E.g.,</p>
<pre><code class="language-c++">int test(int initial)
{
    int v, x;
    #pragma omp atomic capture
    {
        v = x; v = v + 1;
    }
    return v;
}</code></pre>
<p>produces</p>
<pre><code class="language-text">.\atomic-capture-block.cpp(6,20): error C5300: '#pragma omp atomic capture': expression mismatch for lvalue being updated
            v = x; v = v + 1;
                   ^
.\atomic-capture-block.cpp(6,17): note: see the lvalue expression here
            v = x; v = v + 1;
                ^</code></pre>
<p>Without <code>/diagnostics:caret</code> we would have just the line numbers which don&#8217;t help in understanding the diagnostic.</p>
<h2 id="min-and-max-reduction-operators"><code>min</code> and <code>max</code> reduction operators</h2>
<p>MSVC has supported reduction operators since implementing OpenMP 2.0, to which we have now added support for <code>min</code> and <code>max</code> operations as well. Consider the simple case of determining the maximum of an array of values. Serial code to do this is given below:</p>
<pre><code class="language-c++">double serial_max(double* A, int size)
{
    int max = INT_MIN;
    for (int i = 0; i &lt; size; ++i)
        if (A[i] &gt; max)
            max = A[i];
    return max;
}</code></pre>
<p>Parallelizing this to run on multiple threads in a naive way requires a critical section to update <code>max</code>:</p>
<pre><code class="language-c++">double parallel_max(double* A, int size)
{
    int maxval = INT_MIN;
    #pragma omp parallel for shared(maxval)
    for (int i = 0; i &lt; size; ++i)
        #pragma omp critical
        if (A[i] &gt; maxval)
            maxval = A[i];
    return maxval;
}</code></pre>
<p>It&#8217;s obvious that the above version has a performance problem: every comparison of <code>max</code> to an array variable is being done in a critical section! To improve this, we can have each parallel thread maintain its own maximum and merge them at the end into one maximum for all of them. This will require maintaining an auxiliary vector of maximum values, one per thread, updating the right ones per thread and finally merging the maximum values into a single one, quite a chore if written out by hand. Instead, we can take advantage of the new <code>max</code> reduction operator and write a simple loop:</p>
<pre><code class="language-c++">double parallel_max(double* A, int size)
{
    int maxval = INT_MIN;
    #pragma omp parallel for reduction(max : maxval)
    for (i = 0; i &lt; size; ++i)
        if (A[i] &gt; maxval) maxval = A[i];
    return maxval;
}</code></pre>
<p>The above version creates a private <code>maxval</code> for each thread, which avoids the need for a critical section in the loop and at the end merges them all into a single maximum. Computing the minimum would use the <code>min</code> reduction operator in an analogous fashion.</p>
<h2 id="pointers-as-loop-index-variables-for-pragma-omp-for">Pointers as loop-index variables for <code>#pragma omp for</code></h2>
<p>MSVC has hitherto restricted loop variables to integral types while the OpenMP specification allowed pointer types as well. We have now implemented this feature and it is now possible to loop over arrays in parallel using either pointers or integer indices. E.g.,</p>
<pre><code class="language-c++">void test()
{
    int a[100];
    int *p, *begin = &amp;a[0], *end = &amp;a[100];
    int k = 0;

    #pragma omp parallel for
    for (p = begin; p &lt; end; ++p) 
        *p = k;
}</code></pre>
<p>As part of a general policy of supporting newer OpenMP features only on the LLVM <code>libomp</code> runtime, pointer loop variables require the compiler option <code>/openmp:llvm</code> to be used.</p>
<p>Note: C++ iterator support is not yet implemented but is planned for the future.</p>
<h2 id="miscellaneous-improvements-diagnostic-messages-and-bug-fixes">Miscellaneous improvements: diagnostic messages and bug fixes</h2>
<p>We&#8217;ve improved the accuracy or user friendliness of OpenMP diagnostic messages in several places. E.g., for loops, we&#8217;ve added checks for loop comparison operators:</p>
<pre><code class="language-c++">    #pragma omp parallel for
    for (p = begin; p &gt; end; ++p) *p = k;  // C5301</code></pre>
<p>produces:</p>
<pre><code class="language-text">.\loop_warnings_ptr.cpp(10,23): warning C5301: '#pragma omp for': 'p' increases while loop condition uses '&gt;'; non-terminating loop?
    for (p = begin; p &gt; end; ++p) *p = k;  // C5301
                      ^</code></pre>
<p>We&#8217;ve also fixed several bugs reported by users or discovered during our testing.</p>
<h2 id="a-note-about-the-llvm-runtime">A note about the LLVM runtime</h2>
<p>Currently, the LLVM runtime matching compiler is based on version 11. We plan to upgrade the runtime to a more recent version in a future release, but meanwhile we&#8217;ve ported a couple of critical bug fixes: <a href="https://reviews.llvm.org/rGb7b498657685d7a305987b9140253523e77fd4e1">rGb7b498657685 (llvm.org)</a> and <a href="https://reviews.llvm.org/rG1b968467c057df980df214a88cddac74dccff15e">rG1b968467c057 (llvm.org)</a>. Many thanks to <a href="https://reviews.llvm.org/p/jlpeyton/">Jonathan Peyton</a> who provided these fixes!</p>
<p>With the help of our colleague <a href="https://reviews.llvm.org/p/vadikp-intel/">Vadim Paretsky</a> from Intel, we&#8217;ve upstreamed changes (<a href="https://github.com/llvm/llvm-project/commit/f58fe2e1865d631b228d0bc78ebd4d95f752c51b">1</a>, <a href="https://github.com/llvm/llvm-project/commit/43d5c4d5394e522be87a9a1dfda24f5ce0e3a855">2</a>) to <code>main</code> that we&#8217;ve made so far to the <code>libomp</code> runtime. The only missing change is for atomics for ARM64.</p>
<p>We&#8217;re interested in hearing from you if you want to build your own <code>libomp</code> for Windows. Please reply in the blog comments in this case.</p>
<p>A word of caution: we had to accept a breaking change where ordinals for the exported symbols were changed in 17.4. Due to this, older <code>libomp140</code> runtime binaries won&#8217;t work with code if it&#8217;s built with newer <code>libomp.lib</code>, or vice versa. The best thing to do is to re-build all code using <code>/openmp:llvm</code>.</p>
<h2 id="summary">Summary</h2>
<p>MSVC continues to improve its OpenMP support and a full, optimized implementation of 3.1 is planned for the future. Based on user feedback, we may consider support for further versions or selected features from newer versions of OpenMP. Please use <a href="https://developercommunity.visualstudio.com/cpp">Developer Community</a> to add your voice to feature requests or report bugs.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-openmp-update/">MSVC OpenMP Update</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-openmp-update/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>A Tour of 4 MSVC Backend Improvements</title>
		<link>https://devblogs.microsoft.com/cppblog/a-tour-of-4-msvc-backend-improvements/</link>
					<comments>https://devblogs.microsoft.com/cppblog/a-tour-of-4-msvc-backend-improvements/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 28 Nov 2022 15:58:27 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31340</guid>

					<description><![CDATA[<p>This blog post presents some of the optimizations the backend team has implemented for Visual Studio 2022.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-tour-of-4-msvc-backend-improvements/">A Tour of 4 MSVC Backend Improvements</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We hear that many of you would like to see more details of the improvements which the MSVC backend team have been working on recently. This blog post presents some of the optimizations the team has implemented for Visual Studio 2022. It was co-written by one of our backend team leads, Eric Brumer, and our developer advocate, Sy Brand. Keep an eye out for more posts in the future which will dig into other optimizations!</p>
<h2 id="byteswap-identification">Byteswap Identification</h2>
<p>Changing the <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a> of an integer can be an important operation in contexts where data is being transmitted between processors with different byte orders, or over the network. This is often referred to as a &#8220;byteswap&#8221;. C++23 will add a <a href="https://en.cppreference.com/w/cpp/numeric/byteswap"><code>std::byteswap</code></a> function to the standard library (already implemented in VS2022 17.1), but for codebases today it&#8217;s common to see custom implementations, which might look something like this:</p>
<pre><code class="language-c++">int byteswap(int n) {
    return  ((n &amp; 0xff) &lt;&lt; 24u) |
            ((n &amp; 0xff00) &lt;&lt; 8u) |
            ((n &amp; 0xff0000) &gt;&gt; 8u) |
            ((n &amp; 0xff000000) &gt;&gt; 24u);
}</code></pre>
<p>In Visual Studio 2019 16.11, this generated the following code for x64, and a similarly long sequence of instructions for Arm64:</p>
<pre><code class="language-asm">        mov     eax, ecx
        mov     edx, ecx
        and     eax, 65280
        shl     edx, 16
        or      eax, edx
        mov     edx, ecx
        shl     eax, 8
        sar     edx, 8
        and     edx, 65280
        shr     ecx, 24
        or      eax, edx
        or      eax, ecx
        ret     0</code></pre>
<p>x64 and Arm64 both have instructions which carry out a byteswap, which should ideally be used instead. Visual Studio 2022 17.3 introduced automatic byteswap identification, and now outputs the following on x64 with <code>/O2</code>:</p>
<pre><code class="language-asm">        bswap   ecx
        mov     eax, ecx
        ret     0</code></pre>
<p>On Arm64, the results are much the same:</p>
<pre><code class="language-asm">        rev         w0,w0
        ret</code></pre>
<p>This optimization isn&#8217;t just doing a simple pattern match on your code, it&#8217;s a generalized bit tracker. For example, this bit order reverser gets optimized to a single <span style="color: #222222; font-family: Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;"><span style="font-size: 14.4px; background-color: #f2f4f5;">rbit</span></span> on Arm64:</p>
<pre><code class="language-c++">unsigned __int64 bitswap(unsigned __int64 x) {
    x = _byteswap_uint64(x);
    x = (x &amp; 0xaaaaaaaaaaaaaaaa) &gt;&gt; 1 | (x &amp; 0x5555555555555555) &lt;&lt; 1;
    x = (x &amp; 0xcccccccccccccccc) &gt;&gt; 2 | (x &amp; 0x3333333333333333) &lt;&lt; 2;
    x = (x &amp; 0xf0f0f0f0f0f0f0f0) &gt;&gt; 4 | (x &amp; 0x0f0f0f0f0f0f0f0f) &lt;&lt; 4;
    return x;
}</code></pre>
<h2 id="loop-unswitching">Loop Unswitching</h2>
<p>For sake of code simplicity, we may choose to write a branch inside a loop whose condition is invariable in each iteration. For example, if we want to pet all our cats, and if it&#8217;s feeding time, we also want to feed them, we could write this:</p>
<pre><code class="language-cpp">void process_cats(std::span&lt;cat&gt; cats, bool is_feeding_time) {
    for (auto&amp;&amp; c : cats) {
        if (is_feeding_time) {
            feed(c);
        }
        pet(c);
    }
}</code></pre>
<p>Since <code>is_feeding_time</code> never changes inside the function and has no side-effects, it may be wasteful to carry out that check every iteration. Better hardware <a href="https://en.wikipedia.org/wiki/Branch_predictor">branch predictors</a> will minimize this impact, but in many cases we can see performance wins by carrying out <a href="https://en.wikipedia.org/wiki/Loop_unswitching">loop unswitching</a>. This hoists the branch outside of the loop, generating code similar to this C++:</p>
<pre><code class="language-cpp">void process_cats(std::span&lt;cat&gt; cats, bool is_feeding_time) {
    if (is_feeding_time) {
        for (auto&amp;&amp; c : cats) {
            feed(c);
            pet(c);
        }
    }
    else {
        for (auto&amp;&amp; c : cats) {
            pet(c);
        }
    }
}</code></pre>
<p>As of Visual Studio 2022 version 17.1, MSVC may carry out loop unswitching at <code>/O2</code>. This is a <a href="https://en.wikipedia.org/wiki/Heuristic_(computer_science)">heuristic</a>-driven optimization which may or may not be carried out depending on analysis results. This is because loop unswitching duplicates the loop body, which may affect instruction cache performance. You may pass the <code>/Qvec-report:1</code> flag to see a report on which loops were unswitched.</p>
<p>Here is the x64 generated by Visual Studio 2019 version 16.11 with <code>/O2</code>:</p>
<pre><code class="language-asm">$LN15:
        mov     QWORD PTR [rsp+8], rbx
        mov     QWORD PTR [rsp+16], rsi
        push    rdi
        sub     rsp, 32   
        mov     rbx, QWORD PTR [rcx]
        movzx   esi, dl
        mov     rax, QWORD PTR [rcx+8]
        lea     rdi, QWORD PTR [rbx+rax*4]
        cmp     rbx, rdi
        je      SHORT $LN3@process_ca
$LL4@process_ca:
        test    sil, sil
        je      SHORT $LN5@process_ca
        mov     ecx, DWORD PTR [rbx]
        call    void feed(cat)              
$LN5@process_ca:
        mov     ecx, DWORD PTR [rbx]
        call    void pet(cat)               
        add     rbx, 4
        cmp     rbx, rdi
        jne     SHORT $LL4@process_ca
$LN3@process_ca:
        mov     rbx, QWORD PTR [rsp+48]
        mov     rsi, QWORD PTR [rsp+56]
        add     rsp, 32   
        pop     rdi
        ret     0</code></pre>
<p>The key part to note here are the lines directly under the <code>$LL4@process_ca</code> label, which carry out the test on <code>is_feeding_time</code> and branch on the result, all inside the loop.</p>
<p>Here is the code generated now with <code>/O2</code>:</p>
<pre><code class="language-asm">$LN22:
        mov     QWORD PTR [rsp+8], rbx
        push    rdi
        sub     rsp, 32  
        mov     rbx, QWORD PTR [rcx]
        mov     rax, QWORD PTR [rcx+8]
        lea     rdi, QWORD PTR [rbx+rax*4]
        cmp     rbx, rdi
        je      SHORT $LN14@process_ca
        test    dl, dl
        je      SHORT $LL11@process_ca
        npad    2
$LL4@process_ca:
        mov     ecx, DWORD PTR [rbx]
        call    void feed(cat)
        mov     ecx, DWORD PTR [rbx]
        call    void pet(cat)     
        add     rbx, 4
        cmp     rbx, rdi
        jne     SHORT $LL4@process_ca
        mov     rbx, QWORD PTR [rsp+48]
        add     rsp, 32      
        pop     rdi
        ret     0
$LL11@process_ca:
        mov     ecx, DWORD PTR [rbx]
        call    void pet(cat)
        add     rbx, 4
        cmp     rbx, rdi
        jne     SHORT $LL11@process_ca
$LN14@process_ca:
        mov     rbx, QWORD PTR [rsp+48]
        add     rsp, 32    
        pop     rdi
        ret     0</code></pre>
<p>The code is now longer because two versions of the loop body are now generated, under the <code>$LL4@process_ca</code> and <code>$LL11@process_ca</code> labels. But also note that the branch occurs in the entry block of the function and selects between the two loop body versions:</p>
<pre><code class="language-asm">        cmp     rbx, rdi
        je      SHORT $LN14@process_ca
        test    dl, dl
        je      SHORT $LL11@process_ca</code></pre>
<h2 id="min-max-chains">Min/Max Chains</h2>
<p>We have improved optimization of chains of <code>std::min</code> and <code>std::max</code> as of Visual Studio 2022 version 17.0.</p>
<p>Say we have three blankets and we want to give one to our cat. The one we pick shouldn&#8217;t be too hard. It shouldn&#8217;t be too soft. It should be just right.</p>
<p>We could write a function to give us the Just Right blanket from three, by picking the middle one. It could look something like this:</p>
<pre><code class="language-c++">using softness = float;
softness just_right_blanket(softness a, softness b, softness c) {
    return std::max(std::min(a,b), std::min(std::max(a,b),c));
}</code></pre>
<p>In VS2019, this code was generated for x64 with <code>/O2 /fp:fast</code>:</p>
<pre><code class="language-asm">        comiss  xmm1, xmm0
        lea     rcx, QWORD PTR a$[rsp]
        lea     rax, QWORD PTR b$[rsp]
        lea     rdx, QWORD PTR a$[rsp]
        movss   DWORD PTR [rsp+16], xmm1
        movss   DWORD PTR [rsp+8], xmm0
        cmovbe  rax, rcx
        movss   DWORD PTR [rsp+24], xmm2
        lea     rcx, QWORD PTR c$[rsp]
        comiss  xmm2, DWORD PTR [rax]
        cmovae  rcx, rax
        lea     rax, QWORD PTR b$[rsp]
        comiss  xmm0, xmm1
        cmovbe  rax, rdx
        movss   xmm1, DWORD PTR [rax]
        comiss  xmm1, DWORD PTR [rcx]
        cmovb   rax, rcx
        movss   xmm0, DWORD PTR [rax]
        ret     0</code></pre>
<p>Arm64 codegen is similarly inefficient. Both x64 and Arm64 have single instructions for scalar floating point min and max, which we now use in VS2022 at <code>/O2</code> and above with <code>/fp:fast</code>. Here is the x64 code now:</p>
<pre><code class="language-asm">        movaps  xmm3, xmm0
        maxss   xmm0, xmm1
        minss   xmm3, xmm1
        minss   xmm0, xmm2
        maxss   xmm0, xmm3
        ret     0</code></pre>
<p>And for Arm64:</p>
<pre><code class="language-asm">        fmax        s16,s0,s1
        fmin        s17,s0,s1
        fmin        s18,s16,s2
        fmax        s0,s18,s17
        ret</code></pre>
<h2 id="backwards-loop-vectorization">Backwards Loop Vectorization</h2>
<p>Say I run a cat shelter with 32 cats and want to count how many crunchies they leave behind in their bowls after mealtime. So I write a function which takes a pointer to the first bowl, and sum it like so (yes, I know I could use <code>std::accumulate</code>):</p>
<pre><code class="language-c++">int count_leftovers(int* bowl_ptr) {
    int result = 0;

    for (int i = 0; i &lt; 32; ++i, ++bowl_ptr) {
        result += *bowl_ptr;
    }
    return result;
}</code></pre>
<p>This all works and generates good code! But then I realize that my desk is actually at the far end of the room, so I need to walk all the way to the start of the line to begin counting. I decide to instead take a pointer to the <em>last</em> bowl and work backwards:</p>
<pre><code class="language-c++">int count_leftovers(int* bowl_ptr) {
    int result = 0;

    // change ++bowl_ptr to --bowl_ptr
    for (int i = 0; i &lt; 32; ++i, --bowl_ptr) {
        result += *bowl_ptr;
    }
    return result;
}</code></pre>
<p>Unfortunately, if I was using VS2019, this loop would not be <a href="https://en.wikipedia.org/wiki/Automatic_vectorization">vectorized</a>. Here is the code generated with <code>/O2</code>:</p>
<pre><code class="language-asm">        xor     eax, eax
        mov     edx, eax
        mov     r8d, eax
        mov     r9d, eax
        add     rcx, -8
        lea     r10d, QWORD PTR [rax+8]
$LL4@count_left:
        add     eax, DWORD PTR [rcx+8]
        add     r9d, DWORD PTR [rcx+4]
        add     r8d, DWORD PTR [rcx]
        add     edx, DWORD PTR [rcx-4]
        lea     rcx, QWORD PTR [rcx-16]
        sub     r10, 1
        jne     SHORT $LL4@count_left
        lea     ecx, DWORD PTR [rdx+r8]
        add     ecx, r9d
        add     eax, ecx
        ret     0</code></pre>
<p>The loop is <a href="https://en.wikipedia.org/wiki/Loop_unrolling">unrolled</a> but it is not vectorized.</p>
<p>We enabled vectorization for backwards-strided loops in VS2022 17.1. The code generated will depend a lot on the flags you use, particularly the <a href="https://learn.microsoft.com/cpp/build/reference/arch-x64?view=msvc-170"><code>/arch</code></a> flag for enabling use of <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> instructions instead of the default <a href="https://en.wikipedia.org/wiki/SSE2">SSE2</a> ones.</p>
<p>Here is the code generated for <code>/O2 /arch:AVX2</code>:</p>
<pre><code class="language-asm">        vpxor   xmm2, xmm2, xmm2
        vpxor   xmm3, xmm3, xmm3
        mov     eax, 2
        npad    3
$LL4@count_left:
        vmovd   xmm1, DWORD PTR [rcx]
        vpinsrd xmm1, xmm1, DWORD PTR [rcx-4], 1
        vpinsrd xmm1, xmm1, DWORD PTR [rcx-8], 2
        vpinsrd xmm1, xmm1, DWORD PTR [rcx-12], 3
        vmovd   xmm0, DWORD PTR [rcx-16]
        vpinsrd xmm0, xmm0, DWORD PTR [rcx-20], 1
        vpinsrd xmm0, xmm0, DWORD PTR [rcx-24], 2
        vpinsrd xmm0, xmm0, DWORD PTR [rcx-28], 3
        lea     rcx, QWORD PTR [rcx-64]
        vinsertf128 ymm0, ymm1, xmm0, 1
        vmovd   xmm1, DWORD PTR [rcx+32]
        vpinsrd xmm1, xmm1, DWORD PTR [rcx+28], 1
        vpinsrd xmm1, xmm1, DWORD PTR [rcx+24], 2
        vpinsrd xmm1, xmm1, DWORD PTR [rcx+20], 3
        vpaddd  ymm2, ymm0, ymm2
        vmovd   xmm0, DWORD PTR [rcx+16]
        vpinsrd xmm0, xmm0, DWORD PTR [rcx+12], 1
        vpinsrd xmm0, xmm0, DWORD PTR [rcx+8], 2
        vpinsrd xmm0, xmm0, DWORD PTR [rcx+4], 3
        vinsertf128 ymm0, ymm1, xmm0, 1
        vpaddd  ymm3, ymm0, ymm3
        sub     rax, 1
        jne     $LL4@count_left
        vpaddd  ymm0, ymm3, ymm2
        vphaddd ymm1, ymm0, ymm0
        vphaddd ymm2, ymm1, ymm1
        vextracti128 xmm0, ymm2, 1
        vpaddd  xmm0, xmm2, xmm0
        vmovd   eax, xmm0
        vzeroupper
        ret     0</code></pre>
<p>This both unrolls and vectorizes the loop. Fully explaining AVX2 vector instructions is a job for a different blog post (maybe check out <a href="https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX">this one</a>), but the basic idea is that all those <a href="https://www.felixcloutier.com/x86/pinsrb:pinsrd:pinsrq"><code>vpinsrd</code></a> instructions are loading the data from memory into vector registers, then the <a href="https://www.felixcloutier.com/x86/paddb:paddw:paddd:paddq"><code>vpaddd</code></a>/<a href="https://www.felixcloutier.com/x86/phaddw:phaddd"><code>vphaddd</code></a> instructions carry out addition on big chunks of data all at the same time.</p>
<h2 id="send-us-your-feedback">Send us your feedback</h2>
<p>We hope you found these details interesting! If you have ideas for similar posts you&#8217;d like to see, please let us know. We are also interested in your feedback to continue to improve our tools. The comments below are open. Feedback can also be shared through <a href="https://developercommunity.visualstudio.com/cpp">Developer Community</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-tour-of-4-msvc-backend-improvements/">A Tour of 4 MSVC Backend Improvements</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/a-tour-of-4-msvc-backend-improvements/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg 2022.11.14 and 2022.10.19 Releases: Localization for 14 Languages, Overlay Ports/Triplets in Manifests, acquire-project Command, and More…</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 16 Nov 2022 01:29:51 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31329</guid>

					<description><![CDATA[<p>The 2022.11.14 release of the vcpkg package manager is available. This blog post summarizes changes from September 27th, 2022 to November 13th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>47 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/">vcpkg 2022.11.14 and 2022.10.19 Releases: Localization for 14 Languages, Overlay Ports/Triplets in Manifests, acquire-project Command, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.11.14">2022.11.14 release of the vcpkg package manager is available</a>. This blog post summarizes changes from September 27<sup>th</sup>, 2022 to November 13<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>47 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>519 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>2,069 total libraries</strong> available in the vcpkg public registry. There are a total of <strong>10,964</strong> ports if each library version is counted uniquely.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.11.14">2022.11.14 release of the main vcpkg repo</a> includes <strong>65 commits</strong>.</li>
<li><strong>68 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has over <strong>4,900 forks</strong> and <strong>17,100 stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<p>Notable changes for this release are summarized below:</p>
<p>&nbsp;</p>
<h4 id="localized-vcpkg-output-is-now-available">Localized vcpkg output is now available</h4>
<p>One of the steps required for us to ship vcpkg in Visual Studio was to localize its output to a variety of languages. This experience is now enabled in the tool for 14 languages – the same languages available for Visual Studio. You can change the language of vcpkg’s output (even if you’re not using Visual Studio) by setting an environment variable called VSLANG to a 4-digit LCID (locale identifier) code. For example, setting this variable to 1033 sets the language to English. For more details, including a list of available LCIDs, <a href="https://github.com/microsoft/vcpkg-tool/blob/main/docs/localization.md">see our documentation</a> on this.</p>
<p>&nbsp;</p>
<h4 id="configuring-overlay-ports-and-triplets-in-a-manifest-file">Configuring overlay ports and triplets in a manifest file</h4>
<p><strong>Overlay ports</strong> is a feature of vcpkg that allows the user to override the default port vcpkg would have installed with a custom one. This can be useful when the user needs to patch a library and deviate from the default experience. Note: this is very different from installing a different version of a library, which does not require creating a custom port.</p>
<p><strong>Overlay triplets</strong> work similarly by overriding default vcpkg triplets with customized ones. A use case for this can be if you require additional compile flags for your build over what vcpkg would run by default.</p>
<p>Historically, it was only possible to set overlay ports and triplets on the command line, via environment variables, or through the build system. Now, it is possible to configure these in a vcpkg-configuration.json file by enabling an optional object to the schema which receives a path or list of paths. This provides a better experience when a user wants to provide multiple additional paths for one install. Ports are resolved from top to bottom. Here is an example:</p>
<pre class="prettyprint">{
    "default-registry": {
    "kind": "git",
    "repository": "&lt;https://internal/mirror/of/github.com/Microsoft/vcpkg&gt;",
    "baseline": "eefee7408133f3a0fef711ef9c6a3677b7e06fd7"
    },
    "registries": [{
        "kind": "git",
        "repository": "&lt;https://github.com/my-repository/vcpkg-registry&gt;",
        "baseline": "xxxxxxx000000000000000000000000000000000",
        "packages": [ "my", "packages" ]
    }],
    "overlay-ports": [
    "./my-ports/fmt",
    "custom-ports",
    "../share/team-ports"
    ],
    "overlay-triplets" : [ "./my-triplets" ]
}</pre>
<p><strong>Note:</strong> if overlay ports are configured in multiple ways, we prioritize them in the following order:</p>
<ol>
<li>Command line</li>
<li>Manifest (vcpkg-configuration.json)</li>
<li>Environment variables</li>
</ol>
<p>In other words, a port configured in the command line will always override the same port being configured in a manifest or an environment variable, and ports configured in the manifest override the same ports being configured as environment variables.</p>
<p>See our <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">article on registries</a> for additional documentation on this feature.</p>
<p>&nbsp;</p>
<h4 id="new-artifact-command-acquire-project">New artifact command: acquire-project</h4>
<p>A new command for managing vcpkg artifacts has been added: acquire-project. Like the activate command, it affects all artifact dependencies listed in the manifest, but it only downloads and extracts them without activating them in the environment. Functionally like running vcpkg acquire once for each dependency.</p>
<p>&nbsp;</p>
<h4 id="console-output-less-verbose-in-manifest-mode">Console output less verbose in manifest mode</h4>
<p>The option &#8211;no-print-usage now supports manifest mode (by @demianmnave-pti in <a href="https://github.com/microsoft/vcpkg-tool/pull/721">Microsoft/vcpkg-tool#721</a>). This switch suppresses the printing of usage text at the end of a port installation.</p>
<p>&nbsp;</p>
<h4 id="get-current-port-version-in-portfile-cmake">Get current port version in portfile.cmake</h4>
<p>It is now possible to reference a port’s current version when authoring ports in their portfile.cmake using a variable called VERSION. Implemented by @autoantwort.</p>
<p>&nbsp;</p>
<h4 id="ignore-the-vcpkg_root-environment-variable-when-we-already-detected-a-vcpkg-root">Ignore the VCPKG_ROOT environment variable when we already detected a vcpkg root</h4>
<p>The VCPKG_ROOT environment variable can be used to point to the location of a vcpkg instance. This is useful for example in pre-configured CI systems so the user can run vcpkg commands without having to go looking for vcpkg first. However, this can be problematic if the user is consuming vcpkg as a git submodule and doesn’t want to use the default machine-wide instance. Now, if a vcpkg root directory is detected, we will no longer override it with the VCPKG_ROOT environment variable. vcpkg will output a warning when the environment variable is ignored.</p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation Changes</h4>
<p>We are continuing to improve our vcpkg documentation:</p>
<ol>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/list.md">Added reference documentation for vcpkg list command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/version.md">Added reference documentation for vcpkg version command</a>.</li>
<li>Added reference documentation for three topics:
<ol>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/manifests.md">Embedding vcpkg-configuration.json contents in vcpkg.json</a></li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">Overlay ports in vcpkg-configuration.json</a></li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">Overlay triplets in vcpkg-configuration.json</a></li>
</ol>
</li>
</ol>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,860</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,924</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,826</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,839</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>971</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,497</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>924</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,791</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,867</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank You to Our Contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>autoantwort (54 commits)</li>
<li>dg0yt (35 commits)</li>
<li>Neumann-A (17 commits)</li>
<li>AtariDreams (10 commits)</li>
<li>Honeybunch (9 commits)</li>
<li>Thomas1664 (9 commits)</li>
<li>SchaichAlonso (8 commits)</li>
<li>Tradias (7 commits)</li>
<li>RT222 (6 commits)</li>
<li>Osyotr (3 commits)</li>
<li>m-kuhn (4 commits)</li>
<li>chausner (4 commits)</li>
<li>luncliff (4 commits)</li>
<li>gjasny (3 commits)</li>
<li>past-due (3 commit)</li>
<li>AenBleidd (3 commits)</li>
<li>coryan (2 commit)</li>
<li>wrobelda (1 commit)</li>
<li>daschuer (1 commit)</li>
<li>longnguyen2004 (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>klalumiere (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.11.14">full 2022.11.14 release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<h3 id="interested-in-vcpkg-but-not-sure-where-to-start">Interested in vcpkg but not sure where to start?</h3>
<p>Is your company experiencing challenges managing C/C++ libraries? Perhaps you’re curious if a package manager is the right choice to you? Please reach out to <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a> and we’d be happy to help!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/">vcpkg 2022.11.14 and 2022.10.19 Releases: Localization for 14 Languages, Overlay Ports/Triplets in Manifests, acquire-project Command, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio 2022 Performance: Faster C++ Source Code Indexing</title>
		<link>https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/</link>
					<comments>https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/#respond</comments>
		
		<dc:creator><![CDATA[Victor Ciura]]></dc:creator>
		<pubDate>Tue, 15 Nov 2022 16:00:21 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31318</guid>

					<description><![CDATA[<p>Building on top of our performance wins in Visual Studio 2022 version 17.3, we are excited to announce additional improvements in version 17.4.<br />
Whether you are a game developer, work with large codebases, or have solutions with many C++ projects, your development experience in Visual Studio 2022 17.4 will feel even faster.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/">Visual Studio 2022 Performance: Faster C++ Source Code Indexing</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Building on top of <a id="post-31318-_Int_H4uFQVnC"></a>our <a href="https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/">performance wins</a> in Visual Studio 2022 version 17.3, we are excited to announce additional improvements in version 17.4.</p>
<p>Whether you are a game developer, work with large codebases, or have solutions with many C++ projects, your development experience in Visual Studio 2022 17.4 will feel <em>even faster</em>.</p>
<p>In 17.4 we significantly reduced the time it takes to open a C++ project for the first time (cold load).</p>
<p>While working on these improvements, we constantly check our performance against real-life large projects, including some of our own, as well as several C++ codebases for popular games from our partner game studios.</p>
<p>Large C++ projects could see a 20-36% speed improvement over 17.3 when populating the source code database used for browsing and navigation.</p>
<p>When compared to VS 2019, the cumulative performance gains for this scenario should be between 2X-6X depending on the project structure and size.</p>
<p>In this post, we want to highlight the C++ project indexing scenario for the <a href="https://en.wikipedia.org/wiki/Gears_of_War">Gears of War</a> source code and a generic Unreal Engine 5 starter project.</p>
<h2 id="testing-methodology">Testing Methodology</h2>
<p>Hardware: AMD Ryzen PRO 3945WX 12/24, 128GB RAM, 2.5TB SSD, RTX 3080</p>
<p>Projects/source code: Gears of War, Unreal Engine 5 starter project, Chromium</p>
<p>Visual Studio: VS2019 v16.11 and VS2022 v17.4</p>
<p>For all scenarios, we used VS system events/logs to track the duration of the operations.</p>
<h3 id="results">Results</h3>
<p>Let’s see the cumulative effect of all the improvements we made in this area for C++ projects, for the past year.</p>
<p><img decoding="async" width="1431" height="1080" class="wp-image-31319" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1.png" alt="Chart, bar chart Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1.png 1431w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1-300x226.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1-1024x773.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1-768x580.png 768w" sizes="(max-width: 1431px) 100vw, 1431px" /></p>
<p>In Visual Studio 2019 16.11, it takes roughly <a id="post-31318-OLE_LINK1"></a>6½ minutes for Gears of War to fully index. In Visual Studio 2022 17.4, waiting for indexing to finish will only take a bit over <a id="post-31318-OLE_LINK2"></a>2½ minutes, resulting in a <strong>2.5X</strong> speed up.</p>
<p><img decoding="async" width="1431" height="1080" class="wp-image-31320" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2.png 1431w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2-300x226.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2-1024x773.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2-768x580.png 768w" sizes="(max-width: 1431px) 100vw, 1431px" /></p>
<p>When getting to code in a new Unreal Engine 5 solution, you will see a huge improvement in the latest version of VS2022 versus VS2019. In VS2019 16.11, fully indexing a brand-new C++ UE5 solution took a bit over 2½ minutes. When using VS2022 17.4, fully indexing the same UE5 solution is now <strong>2.7X</strong> faster at just 1 minute. Whether you are creating a new UE5 project or cloning from an existing repo, your code will index much faster in 17.4.</p>
<h3 id="pushing-the-limits">Pushing the limits</h3>
<p>Few open-source projects reach the scale of <a href="https://chromium.googlesource.com/chromium/src.git">Chromium</a> with over 12,000 projects in one single Visual Studio solution, so naturally it’s an irresistible target for stress testing the components we’re improving. Let’s see how we did.</p>
<p><img decoding="async" width="1431" height="1080" class="wp-image-31321" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3.png 1431w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3-300x226.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3-1024x773.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3-768x580.png 768w" sizes="(max-width: 1431px) 100vw, 1431px" /></p>
<p>In Visual Studio 2019 16.11, it takes roughly 31 minutes for the Chromium repo to fully index. In Visual Studio 2022 17.4, waiting for indexing to finish will only take just 5 minutes, a <strong>6X</strong> speed up. When indexing a large solution like the Chromium repo for the first time, you will save up to 26 minutes with the latest version of Visual Studio.</p>
<h3 id="try-it-out">Try it out</h3>
<p>Although everyone should see considerable improvements for these scenarios, the magnitude of the gains is dependent on your source code, project layout, include graph, etc. So, try it out on your codebase and let us know about your project load/parsing gains for IntelliSense start-up.</p>
<h2 id="feedback-wanted">Feedback Wanted!</h2>
<p>Your feedback through <a href="https://developercommunity.visualstudio.com/" target="_blank" rel="noopener">Developer Community</a>, surveys, and social media channels has made these improvements possible. We thank you for your valuable comments. These enhancements are a continuation of our focus on improving productivity for game developers. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like ones detailed in this blogpost. If you are a game developer, <a href="http://aka.ms/VSGameDevSurvey" target="_blank" rel="noopener">let us know your thoughts in our 2022 Visual Studio Game Developer Survey</a>.</p>
<p>In addition, please continue to help shape the development of Visual Studio by talking to us in the comments below, on Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h2 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h2>
<p><a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">Download the latest version of Visual Studio 2022</a> to take advantage of these productivity benefits today!</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/">Visual Studio 2022 Performance: Faster C++ Source Code Indexing</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New for C++ Developers in Visual Studio 2022 17.4</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 08 Nov 2022 10:30:45 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31267</guid>

					<description><![CDATA[<p>We are happy to announce that Visual Studio 2022 version 17.4 is now generally available! This post summarizes the new features you can find in this release for C++. You can download Visual Studio 2022 from the Visual Studio downloads page or upgrade your existing installation by following the Update Visual Studio Learn page.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/">What’s New for C++ Developers in Visual Studio 2022 17.4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that Visual Studio 2022 version 17.4 is now generally available! This post summarizes the new features you can find in this release for C++. You can download Visual Studio 2022 from the <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio downloads page </a>or upgrade your existing installation by following the <a href="https://learn.microsoft.com/en-us/visualstudio/install/update-visual-studio?view=vs-2022">Update Visual Studio Learn page</a>.</p>
<h1 id="arm64">Arm64</h1>
<p>In 17.3, Visual Studio became available as a native Arm64 application. We have continued work on supporting more development scenarios and are pleased to announce that the native Arm64 toolchain is now ready for production use!</p>
<p>The “Desktop development with C++” and “Game development with C++” workloads are enabled for native Arm64 development. Please give them a try and let us know your feedback!</p>
<h1 id="msvc">MSVC</h1>
<p>One of our major investments for this release has been in improved compiler diagnostics. New C++ features like concepts and ranges present the opportunity for more expressive code and better-defined APIs. However, to make the most of them, better diagnostics are required from tooling so that constraint failures can be pinpointed and resolved. See Xiang Fan’s blog post on <a href="https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/">The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</a> for all the details, but here’s a quick example of the improvement, showing more complete information on overload resolution failures, and information on why a given constraint failed:</p>
<pre class="prettyprint language-cpp"><code class="language-cpp">struct cat {};
struct dog {};

// can pet cats and dogs
void pet(cat);
void pet(dog);

template &lt;class T&gt;
concept has_member_pettable = requires (T t) { t.pet(); };

// allow calling as a non-member
template &lt;has_member_pettable T&gt;
void pet(T);

int main() {
    pet(0); //oh no
}</code></pre>
<p><strong>Error in 17.3</strong></p>
<pre class="prettyprint language-default"><code class="language-default">&lt;source&gt;(16,10): error C2665: 'pet': none of the 2 overloads could convert all the argument types
    pet(0); //oh no
         ^
&lt;source&gt;(6,6): note: could be 'void pet(dog)'
void pet(dog);
     ^
&lt;source&gt;(5,6): note: or 'void pet(cat)'
void pet(cat);
     ^
&lt;source&gt;(16,5): note: 'void pet(cat)': cannot convert argument 1 from 'int' to 'cat'
    pet(0); //oh no
    ^
&lt;source&gt;(16,10): note: No constructor could take the source type, or constructor overload resolution was ambiguous
    pet(0); //oh no
         ^
&lt;source&gt;(5,6): note: see declaration of 'pet'
void pet(cat);
     ^
&lt;source&gt;(16,10): note: while trying to match the argument list '(int)'
    pet(0); //oh no</code></pre>
<p><strong>Error in 17.4</strong></p>
<pre>&lt;source&gt;(16,5): error C2665: 'pet': no overloaded function could convert all the argument types
    pet(0); //oh no
    ^
&lt;source&gt;(6,6): note: could be 'void pet(dog)'
void pet(dog);
     ^
&lt;source&gt;(16,5): note: 'void pet(dog)': cannot convert argument 1 from 'int' to 'dog'
    pet(0); //oh no
    ^
&lt;source&gt;(16,9): note: No constructor could take the source type, or constructor overload resolution was ambiguous
    pet(0); //oh no
        ^
&lt;source&gt;(5,6): note: or 'void pet(cat)'
void pet(cat);
     ^
&lt;source&gt;(16,5): note: 'void pet(cat)': cannot convert argument 1 from 'int' to 'cat'
    pet(0); //oh no
    ^
&lt;source&gt;(16,9): note: No constructor could take the source type, or constructor overload resolution was ambiguous
    pet(0); //oh no
        ^
&lt;source&gt;(13,6): note: or 'void pet(T)'
void pet(T);
     ^
&lt;source&gt;(16,5): note: the associated constraints are not satisfied
    pet(0); //oh no
    ^
&lt;source&gt;(12,11): note: the concept 'has_member_pettable&lt;int&gt;' evaluated to false
template &lt;has_member_pettable T&gt;
          ^
&lt;source&gt;(9,48): note: the expression is invalid
concept has_member_pettable = requires (T t) { t.pet(); };
                                               ^
&lt;source&gt;(16,5): note: while trying to match the argument list '(int)'
    pet(0); //oh no
    ^</pre>
<p>Here is a <a href="https://godbolt.org/z/a85z9d5qd">Compiler Explorer link</a> to see the difference.</p>
<p>As part of this work, we’ve also added experimental support for outputting compiler diagnostics as <a href="https://sarifweb.azurewebsites.net/">SARIF</a>. This is accessible with the experimental flag /experimental:log&lt;directory&gt;.</p>
<p>In addition to improved diagnostics, we’ve expanded the compiler’s Named Return Value Optimization (NRVO) capabilities. See Bran Hagger’s blog post <a href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> for details. The main improvements are in enabling NRVO for cases which involve exception handling or loops. For example, in 17.3, the copy/move of result when returning it would not be elided, but now will be.</p>
<pre class="prettyprint language-cpp"><code class="language-cpp">Foo ReturnInALoop(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        Foo result;
        if (i == (iterations / 2)) {
            return result; //copy/move elided
        }
    }
}</code></pre>
<p>You can see the difference in generated assembly at <a href="https://godbolt.org/z/jrP4jcz3G">this Compiler Explorer link</a>.</p>
<h1 id="cmake-cross-platform">CMake &amp; Cross Platform</h1>
<p>Containers are a great way to package up everything for running an application. Through a Dockerfile, all prerequisites are captured so that there is a consistent runtime environment anywhere the container is deployed and run. Dev Containers expand this concept to capture everything necessary for developing and building an application in the container. You can now use Dev Containers for your C++ projects in Visual Studio. You can learn more about this feature in our <a href="https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/" target="_blank" rel="noopener">Dev Containers for C++ blog post</a>.</p>
<p><img decoding="async" class="alignnone wp-image-31268" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-1.png" alt="Alert box saying &quot;Folder contains a dev container configuration file&quot; Options are &quot;Reopen folder in container&quot;, &quot;Settings&quot;, and &quot;Learn more&quot;" width="744" height="40" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-1.png 744w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-1-300x16.png 300w" sizes="(max-width: 744px) 100vw, 744px" /></p>
<p>Connecting to remote systems with the <a href="https://learn.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-170" target="_blank" rel="noopener">Connection Manager</a> now supports SSH ProxyJump, which is used to access a SSH host via another SSH host (for example, to access a host behind a firewall).</p>
<p>Test Explorer used to expose internal prefixes of CTest tests, making the list harder to read and navigate. We’ve improved this, grouping all of them under a single header. Here is the before and after:</p>
<p><img decoding="async" class="alignnone wp-image-31269" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-2.png" alt="List from test explorer showing the weird prefixes " width="251" height="201" /> <img decoding="async" class="alignnone wp-image-31270" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-3.png" alt="Cleaner list under a ctest header" width="170" height="124" /></p>
<h2 id="bundled-tools">Bundled tools</h2>
<p>We made several updates to the additional tools which are shipped with Visual Studio in some workloads.</p>
<p>If you’re using Visual Studio on Arm64 machines, you will now get Arm64 builds of CMake and Ninja through the CMake components in the Visual Studio installer.</p>
<p>We’ve updated the version of CMake which we ship to version 3.24.1. This release comes with many new features, including a &#8211;fresh CLI flag for removing the CMake cache, path comparison in if expressions, and version 5 of CMakePresets.json. We’ll be adding support for CMakePresets.json version 5 in our 17.5 release of Visual Studio 2022, but 17.4 comes with added support for version 4. See the <a href="https://cmake.org/cmake/help/latest/release/3.24.html">CMake release notes</a> for all the new goodies.</p>
<p>We also updated the version of LLVM which we ship to version 15.0.1. See the <a href="https://releases.llvm.org/15.0.0/docs/ReleaseNotes.html" target="_blank" rel="noopener">LLVM</a> and <a href="https://releases.llvm.org/15.0.0/tools/clang/docs/ReleaseNotes.html" target="_blank" rel="noopener">Clang</a> release notes for what is available.</p>
<h1 id="productivity">Productivity</h1>
<p>When using the “Create Declaration/Definition” feature, it used to be that the new code would open up in a small window to give you a “peek”. This is now configurable: you can select between peeking (the default), or opening the document,, or no navigation. The setting is under Options &gt; Text Editor &gt; C/C++ &gt; Advanced &gt; Refactoring.</p>
<p><img decoding="async" class="alignnone wp-image-31271" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-4.png" alt="Options pane showing &quot;None&quot;, &quot;Peek document&quot;, and &quot;Open document&quot; as the options for the setting &quot;Navigation after create declaration/definition&quot;" width="749" height="161" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-4.png 749w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-4-300x64.png 300w" sizes="(max-width: 749px) 100vw, 749px" /></p>
<p>We fixed a consistency gap between IntelliSense and MSBuild for pre-compiled headers. It used to be that, when a PCH was used via /Yu and force-included via /FI, IntelliSense would always process it first, before any other headers included via /FI. This did not match the build behavior, so with this change /FI headers are processed in the order they are specified.</p>
<h1 id="ide-performance">IDE Performance</h1>
<p>We are also continuing to improve the performance of the IDE. In this release, we improved indexing performance when opening a new solution. Large projects could see a 20-35% improvement from 17.3. Read more in Victor Ciura&#8217;s blog post, <a href="https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/">Visual Studio 2022 Performance: Faster C++ Source Code Indexing</a>.</p>
<h1 id="code-safety">Code Safety</h1>
<p>We enrich some of our code analysis warnings with “key events” information which describes how the result of the analysis was arrived at. We improved and expanded this feature by adding this information to more analyses and giving you new ways to visualize it in Visual Studio.</p>
<p>For example, when the <a href="https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer">SARIF Viewer extension</a> is installed, the key event information will now be used to annotate the source directly.</p>
<p><img decoding="async" class="alignnone wp-image-31272" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5.png" alt="Code annotated with reasoning behind an initialization code analysis warning" width="920" height="199" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5.png 920w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5-300x65.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5-768x166.png 768w" sizes="(max-width: 920px) 100vw, 920px" /></p>
<p>See the <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/">Microsoft C++ Code Analysis Warnings with Key Events </a>blog post for all the details.</p>
<h1 id="conformance">Conformance</h1>
<p>We’re continuing to track the latest developments in C++ standardization. You can see the latest and upcoming STL features in our <a href="https://github.com/microsoft/STL/wiki/Changelog">Changelog on GitHub</a>, but here are some of the ones I’m most excited about:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r7.html" target="_blank" rel="noopener">P0881R7</a>  &lt;stacktrace&gt;</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1328r1.html" target="_blank" rel="noopener">P1328R1</a>  constexpr type_info::operator==()</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2440r1.html" target="_blank" rel="noopener">P2440R1</a>  ranges::iota, ranges::shift_left, ranges::shift_right</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2441r2.html" target="_blank" rel="noopener">P2441R2</a>  views::join_with</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2302r4.html">P2302R4</a>  ranges::contains, ranges::contains_subrange</li>
<li style="list-style-type: none;"></li>
</ul>
<p>Conformance work also extends to IntelliSense, which now has support for C23 attributes, and we are continuing to improve the support for C++20 modules.</p>
<h1 id="vcpkg">vcpkg</h1>
<p>vcpkg is now 6 years old and has over 2000 open-source libraries available!</p>
<p>We’re continuing to add new features both to vcpkg itself, and to Visual Studio to improve integration. For example, vcpkg artifacts is a feature which allows you to describe the tools and environment necessary to build your application. We have now added support to Visual Studio for vcpkg artifacts with CMake projects, such that if your project includes a vcpkg manifest, the environment will be activated automatically on project open. You can learn more about this in the <a href="https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/">vcpkg environment activation in Visual Studio blog post</a>.</p>
<p><img decoding="async" class="alignnone wp-image-31273" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/text-description-automatically-generated.png" alt="Popup saying &quot;vcpkg environment activation. vcpkg activated successfully. C/C++ development actions will now run in the vcpkg environment.&quot;" width="383" height="202" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/text-description-automatically-generated.png 383w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/text-description-automatically-generated-300x158.png 300w" sizes="(max-width: 383px) 100vw, 383px" /></p>
<p>Other notable improvements since the last release are making the “name” and “version” fields in vcpkg.json optional, adding schemata for all vcpkg json formats, and improving cross-compilation for macOS. You can read more details about these and more in our monthly blog posts from <a href="https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/">August</a> and <a href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">September</a>.</p>
<h1 id="game-development">Game Development</h1>
<p>We’re working hard on the Unreal Engine integration into Visual Studio. As of 17.4, you can now see which Unreal Engine Blueprints reference, use, and inherit from C++ classes, directly in the IDE. To enable this feature, ensure that the “IDE support for Unreal Engine” component is enabled in the VS Installer, and download <a href="https://www.unrealengine.com/marketplace/en-US/product/362651520df94e4fa65492dbcba44ae2">the Visual Studio Integration Tool</a> from the Unreal Marketplace.</p>
<p><img decoding="async" class="alignnone wp-image-31274" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7.png" alt="Popup showing the references to a given blueprint" width="837" height="271" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7.png 837w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7-300x97.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7-768x249.png 768w" sizes="(max-width: 837px) 100vw, 837px" /></p>
<p>Keep an eye out for more new features in 17.5, and please let us know what you think of the Blueprints integration!</p>
<h1 id="send-us-your-feedback">Send us your feedback</h1>
<p>We are very much interested in your feedback to continue to improve this experience. The comments below are open. Feedback can also be shared through the <a href="https://developercommunity.visualstudio.com/cpp">Developer Community</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/">What’s New for C++ Developers in Visual Studio 2022 17.4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Fix for High Risk OpenSSL Security Vulnerabilities Announced – Guidance for vcpkg Users</title>
		<link>https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/</link>
					<comments>https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 02 Nov 2022 23:27:22 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31246</guid>

					<description><![CDATA[<p>OpenSSL.org announced the release of OpenSSL 3.0.7 to address two security vulnerabilities rated as high risk. This patch is now available, including via vcpkg. The vulnerabilities impact users of OpenSSL 3.0.0 &#8211; 3.0.6. If you are relying on a version of OpenSSL in this range,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/">Fix for High Risk OpenSSL Security Vulnerabilities Announced – Guidance for vcpkg Users</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://www.openssl.org/blog/blog/2022/11/01/email-address-overflows/">OpenSSL.org announced the release of OpenSSL 3.0.7</a> to address two security vulnerabilities rated as high risk. This patch is now available, including via vcpkg. The vulnerabilities impact users of OpenSSL 3.0.0 &#8211; 3.0.6. If you are relying on a version of OpenSSL in this range, it is <strong>strongly recommended</strong> to upgrade to 3.0.7 as soon as possible. We also recommend reviewing Microsoft Security Response Center&#8217;s central blog post on awareness and guidance related to these two CVEs: <a href="https://msrc-blog.microsoft.com/2022/11/02/microsoft-guidance-related-to-openssl-risk-cve-2022-3786-and-cve-2202-3602/">Awareness and guidance related to OpenSSL 3.0 – 3.0.6 risk (CVE-2022-3786 and CVE-2202-3602) – Microsoft Security Response Center</a>.</p>
<p>If you are a vcpkg user or port author depending on the OpenSSL vcpkg port, below are instructions on how to upgrade to the new version.</p>
<p>&nbsp;</p>
<h3 id="vcpkg-users-check-if-you-are-using-a-vulnerable-version-of-openssl">vcpkg users: check if you are using a vulnerable version of OpenSSL</h3>
<p><strong>WARNING: </strong>It is possible that OpenSSL is a part of your dependency graph even if your project does not directly depend on it. This is because other vcpkg ports may transitively depend on OpenSSL and thus vcpkg will install it for you. For example, users of the <a href="https://azure.github.io/azure-sdk-for-cpp/index.html">Azure C++ SDK</a> port transitively depend on OpenSSL and should verify the version of OpenSSL installed on their system.</p>
<p>There are several methods that can help you identify the version of OpenSSL installed by vcpkg (if it exists), depending on your scenario:</p>
<ol>
<li>If you install your libraries via the command line, use <code>vcpkg list openssl</code>​ to list all installed versions of OpenSSL.</li>
<li>If you use a <em>vcpkg.json</em> manifest that installs dependencies during your build, use <code>vcpkg install --dry-run</code>​ to list the versions of every library that will be installed.</li>
<li>Finally, you can also directly verify the installed version of OpenSSL from an installed tree by looking at the version macros in the header &#8220;<em>openssl/opensslv.h</em>&#8220;.
<ul>
<li>These are the macros, denoting the major, minor, and patch versions (3.0.5 in this case):</li>
<li><code># define OPENSSL_VERSION_MAJOR 3</code></li>
<li><code># define OPENSSL_VERSION_MINOR 0</code></li>
<li><code># define OPENSSL_VERSION_PATCH 5</code></li>
</ul>
</li>
</ol>
<p>If you find that you are using a vulnerable version of OpenSSL, read on to find out how to upgrade.</p>
<p>&nbsp;</p>
<h3 id="classic-mode-command-line-users">Classic Mode (Command Line) Users</h3>
<p>If you are consuming vcpkg dependencies and don’t use a <em>vcpkg.json</em> manifest, you are using classic mode, which involves running commands of the nature <code>vcpkg install &lt;library_name&gt;</code>. To get the latest version of OpenSSL, you have several options. Pick the one that works best for you:</p>
<p>&nbsp;</p>
<h4 id="classic-mode-option-1-upgrade-all-dependencies-at-once">Classic Mode Option 1: Upgrade all dependencies at once</h4>
<p>If you are using classic mode and are okay with updating all your vcpkg dependencies at once, the fastest solution is to update your local copy of the vcpkg git repo to a newer version. Just open a terminal to your copy of vcpkg and run the following commands:</p>
<pre class="prettyprint">git fetch https://github.com/microsoft/vcpkg 09adfdc8cdad76345b7cc7f3305899e1cbd66297
git checkout 09adfdc8cdad76345b7cc7f3305899e1cbd66297
vcpkg upgrade
vcpkg upgrade --no-dry-run</pre>
<p><strong>Notes: </strong></p>
<ul>
<li><code>09adfdc8cdad76345b7cc7f3305899e1cbd66297</code> is a vcpkg commit ID containing the patched version of OpenSSL. You can also use a newer commit ID than this.</li>
<li>After running the git checkout line with that commit ID, you should see <code>HEAD</code> is now at <code>09adfdc8c [OpenSSL] Update to 3.0.7. (#27594)</code></li>
<li>After running <code>vcpkg upgrade</code>, you should see that OpenSSL will be updated to 3.0.7, along with other affected dependencies.</li>
<li>The last line with <code>--no-dry-run</code> will update your dependencies for real.</li>
<li>If you are not bothered about which commit to update to, you can just run a general git pull to get the very latest version of vcpkg and skip having to provide a commit ID altogether. You will still need to run <code>vcpkg upgrade</code> after.</li>
</ul>
<p>&nbsp;</p>
<h4 id="classic-mode-option-2-update-your-local-openssl-port-files-to-the-new-version">Classic Mode Option 2: Update your local OpenSSL port files to the new version</h4>
<p>If you want to update just OpenSSL and nothing else, open a terminal to your copy of vcpkg and run the following commands:</p>
<pre class="prettyprint">git fetch https://github.com/microsoft/vcpkg 09adfdc8cdad76345b7cc7f3305899e1cbd66297
git checkout 09adfdc8cdad76345b7cc7f3305899e1cbd66297 -- ports/openssl
vcpkg upgrade
vcpkg upgrade --no-dry-run</pre>
<p><strong>Notes: </strong></p>
<ul>
<li><code>09adfdc8cdad76345b7cc7f3305899e1cbd66297</code> is a vcpkg commit ID containing the patched version of OpenSSL. You can also use a newer commit ID than this.</li>
<li>In contrast to the previous example, this approach lets you update just the OpenSSL portion of the vcpkg repo while leaving everything else alone.</li>
<li>After running <code>vcpkg upgrade</code>, you should see that OpenSSL will be updated to 3.0.7, along with other affected dependencies.</li>
<li>The last line with <code>--no-dry-run</code> will update your dependencies for real.</li>
</ul>
<p>This approach will only update the OpenSSL port, but keep in mind that future general git fetches on the repo will apply a new commit ID globally, so you’ll need to make sure you don’t accidentally pull a version of OpenSSL within the 3.0.0 &#8211; 3.0.6 range.</p>
<p>&nbsp;</p>
<h3 id="manifest-mode-users">Manifest Mode Users</h3>
<p>If you are consuming vcpkg dependencies via a manifest file (recommended for any advanced users and professional projects), you just need to update your <em>vcpkg.json</em> file to set a different OpenSSL version.</p>
<p>&nbsp;</p>
<h4 id="manifest-mode-option-1-upgrade-all-dependencies-at-once">Manifest Mode Option 1: Upgrade all dependencies at once</h4>
<p>In general, we recommend updating all open-source dependencies at once rather than one at a time since that allows you to benefit from vcpkg’s version conflict resolution to avoid things like diamond dependencies in your dependency graph.</p>
<p>If this works for you, open a terminal to your vcpkg install location and run the following command:</p>
<p><code>git pull origin 09adfdc8cdad76345b7cc7f3305899e1cbd66297</code></p>
<p>Then (still in your terminal), navigate to your project containing the vcpkg.json, and run:</p>
<p><code>vcpkg x-update-baseline</code></p>
<p>You can git pull to a newer commit ID if you prefer (or just not specify a commit ID and get the latest), but the commit ID in the example above is the earlier one with the patch applied.</p>
<p>The <a href="https://vcpkg.io/en/docs/commands/update-baseline.html">x-update-baseline</a> command moves your registry baseline forward to the baseline set for the vcpkg repo. This is why you must run git pull on the main repo to sync it to the baseline you need.</p>
<p>You can alternatively go into your <em>vcpkg.json</em> and <em>vcpkg-configuration.json</em> files to set baselines manually if you’re having trouble running <code>x-update-baseline</code>:</p>
<h5 id="example-with-baseline-field">Example with baseline field</h5>
<pre class="prettyprint"><strong>vcpkg.json:
</strong>{
    "name": "example",
    "version": "1.0.0",
    "dependencies": [
        "curl"
    ]
}

<strong>vcpkg-configuration.json:
</strong>{
    "default-registry": {
        "kind": "git",
        "baseline": "09adfdc8cdad76345b7cc7f3305899e1cbd66297",
        "repository": "https://github.com/microsoft/vcpkg"
    }
}</pre>
<p>The baseline field is used when the registry location is defined in a separate <em>vcpkg-configuration.json</em> file. This is common for custom registries, though you can configure the public registry this way as well. If you just want to use the default registry and don’t have it separately configured in <em>vcpkg-configuration.json</em>, follow the next example instead using the builtin-baseline field.</p>
<h5 id="example-with-builtin-baseline-field">Example with builtin-baseline field</h5>
<pre class="prettyprint"><strong>vcpkg.json:
</strong>{
    "name": "example",
    "version": "1.0.0",
    "builtin-baseline": "09adfdc8cdad76345b7cc7f3305899e1cbd66297",
    "dependencies": [
        "curl"
    ]
}</pre>
<p>See the <a href="https://vcpkg.io/en/docs/users/versioning.html&quot; \l &quot;baselines">vcpkg versioning documentation</a> for details on how baselines work.</p>
<p>&nbsp;</p>
<h4 id="manifest-mode-option-2-upgrade-openssl-using-an-override">Manifest Mode Option 2: Upgrade OpenSSL using an override</h4>
<p>If you need fine-grained control over the versions of your libraries, you can</p>
<p>set the version of OpenSSL to stay at exactly 3.0.7 using the overrides field. The limitations of this approach are that you won’t get the automatic version conflict resolution (as you would with baselines) and must manually track the package version. In addition, if your project that consumes OpenSSL will itself be packaged as a vcpkg port, your downstream consumers will <strong>not</strong> automatically get the version of OpenSSL you specify. Your downstream consumers must also update their version of OpenSSL.</p>
<h5 id="registries-example-with-overrides">Registries example with overrides</h5>
<pre class="prettyprint"><strong>vcpkg.json:
</strong>{
    "name": "example",
    "version": "1.0.0",
    "dependencies": [
        "curl"
    ],
    "overrides": [
    {
        "name": "openssl",
        "version": "3.0.7"
    }]
}
<strong>vcpkg-configuration.json:
</strong>{
    "default-registry": {
        "kind": "git",
        "baseline": "fcfda3c78c474aec7187299b684258855259a7a6",
        "repository": "https://github.com/microsoft/vcpkg"
    }
}</pre>
<p>Please see our <a href="https://vcpkg.io/en/docs/users/versioning.html">versioning documentation</a> if you need a refresher on these vcpkg features.</p>
<p>&nbsp;</p>
<h3 id="questions">Questions?</h3>
<p>We will monitor this blog post for comments in case there are any questions. Please also feel free to email us at <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a> if you need additional guidance.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/">Fix for High Risk OpenSSL Security Vulnerabilities Announced – Guidance for vcpkg Users</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft Office team uses Remote MacOS Debugging Capability in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 01 Nov 2022 18:18:54 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31240</guid>

					<description><![CDATA[<p>The Microsoft Office team approached the C++ team after seeing the Visual Studio announcement for support for debugging applications running on C++ from Windows through the Blizzard blog post. They had a need for a similar workflow, but for Macs instead of Linux.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/">Microsoft Office team uses Remote MacOS Debugging Capability in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW1907738 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW1907738 BCX8">The Microsoft Office team approached the </span><span class="NormalTextRun SCXW1907738 BCX8">C++ </span><span class="NormalTextRun SCXW1907738 BCX8">team after seeing the Visual Studio announcement for support for debugging applications running on </span><span class="NormalTextRun SCXW1907738 BCX8">C++ </span><span class="NormalTextRun SCXW1907738 BCX8">from Windows through </span></span><a class="Hyperlink SCXW1907738 BCX8" href="https://devblogs.microsoft.com/cppblog/blizzard-diablo-iv-debugs-linux-core-dumps-from-visual-studio/" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW1907738 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW1907738 BCX8" data-ccp-charstyle="Hyperlink">the Blizzard blog post</span></span></a><span class="TextRun SCXW1907738 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW1907738 BCX8">. They had a need for a similar workflow, but for Macs instead of Linux. The </span><span class="NormalTextRun SCXW1907738 BCX8">C++ </span><span class="NormalTextRun SCXW1907738 BCX8">team worked closely with the Office engineers to adapt</span><span class="NormalTextRun CommentStart SCXW1907738 BCX8"> the same underlying technology for Mac. </span></span><span class="EOP SCXW1907738 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1.png"><img decoding="async" class="alignnone size-full wp-image-31241" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1.png" alt="Image Picture1" width="1100" height="687" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1.png 1100w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1-1024x640.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1-768x480.png 768w" sizes="(max-width: 1100px) 100vw, 1100px" /></a></p>
<p>The following blog post is written in conjunction with Anthony Penniston, an Office engineer we worked closely with to deliver this capability. <em>Thank you, Anthony, for working with us!</em></p>
<h5 id="what-does-this-team-do"><strong><u>What does this team do?</u></strong></h5>
<p>Anthony’s team in Office works on delivering core productivity verticals such as document storage and syncing, collaboration, predictive intelligence, authentication, and single sign on. Due to the nature of working on Microsoft Office, the team is very much cross-platform oriented in the products they deliver and feels a lot of unique pains.</p>
<p>Specifically, since Office delivers scalable, robust, responsive, and cross-platform products, the team must build their products natively in C++, using several different compilers and build systems, while still operating on the same unified codebase. As a result, every change they make typically affects the same product on multiple platforms.</p>
<h5 id="how-does-this-team-accomplish-their-work"><strong><u>How does this team accomplish their work?</u></strong></h5>
<p>Before working with the C++ team on a remote debugging solution for Mac, Office engineers looking to investigate Apple-specific behavior really faced some challenges. They had to either attempt to guess the behavior from source code and logs or acquire a Mac system and learn how to use XCode to debug the behavior natively. Additionally, investigating platform-specific behavior ended up compounding in difficulty because much of the team primarily has expertise and experience in Windows. Neither of these workflows were practical for ad-hoc investigations by the engineers. As a result, a lot of investigations ended up being often delayed and Apple-specific issues were resolved by less-than-ideal workarounds and through many iterations of trial-and-error guesswork. This was by far an unproductive way to move forward in their work. For many Windows engineers who may only briefly need to investigate one-off issues for Apple-specific behavior, being able to use the familiar Windows tooling is a huge benefit and timesaver.</p>
<p>The team really wanted to stay developing in Visual Studio for all their needs because it has the reputation as an industry-standard and industry-leading tool for developing and debugging C++ applications on Windows. Visual Studio helps them make sense of their codebase and quickly turn around questions into answers and ideas into implementation through features they use like IntelliSense, code browsing and navigation, and auto-completion. Since the Microsoft Office organization primarily develops on Windows, alongside several other platforms, it takes a great deal of investment to build proficiency in any tool ecosystem. Being able to reuse the skills they’ve built with their Windows tooling and apply that across platforms is incredibly valuable to the engineers. So, when Anthony saw that the C++ team developed functionality to allow users to debug Linux from the comfort of Visual Studio, he was super excited to reach out to the team and learn more about how this functionality could possibly be adapted for Mac.</p>
<h5 id="adopting-the-mac-targeting-support"><strong><u>Adopting the Mac targeting support</u></strong></h5>
<p>Once Anthony contacted the C++ team with his request, the C++ engineers were able to engage and collaborate with the Office team to produce a prototype that would fit his needs for remote Mac development in Visual Studio. This was done pretty rapidly and within a few weeks. Since the C++ team was able to move quickly on this request, by the time a one-week hackathon was over, they had that they were able to demo to the Office team and raise awareness of this new product effort. At the demo, they were able to attract a lot of other Office engineers to this idea and these engineers were keen on seeing more, so over the course of the year, the C++ team continued to collaborate with the Office team to further refine the experience into the <a href="https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/">out-of-box remote debugging functionality for LLDB in Visual Studio 2022</a> present today, which not only met all of the team’s technical requirements, and addressed all the feedback given, but was also easy to onboard engineers unfamiliar with the workflow.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager.png"><img decoding="async" class="alignnone size-full wp-image-31242" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager.png" alt="Connection Manager in Visual Studio with remote Mac connections" width="720" height="388" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager.png 720w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager-300x162.png 300w" sizes="(max-width: 720px) 100vw, 720px" /></a></p>
<p>We spoke to Anthony after this experience, and he stated: “End-to-end it was an engaging and energizing experience to see an ambitious idea turned into reality.“ Also, Anthony pointed out that “[what stood out to me the most was] the engagement, responsiveness, and attention to user feedback of the VS team to improve and iterate on the design. The VS team had the polished feature ready-to-go in VS 2022 with all our asks in place and checked in with us to make sure our use cases were covered and our path to adoption was smooth and unblocked”</p>
<p>This concept not only improved their specific workflow but will also improve others’. This Office engineering team had some initial apprehension towards cross-platform development on Mac, specifically worries about encountering Mac-specific failures or behaviors, as this meant either investigation through guesswork or a considerable time investment into setting up a Mac system and learning the toolset, for what is often a one-off investigation. However, now, with VS 2022’s remote debugging capability for Mac, combined with being able to easily provision Mac systems in Office, the engineering team feels empowered to take on platform-specific investigations using the VS toolchain that they are already familiar and comfortable with.</p>
<h5 id="conclusion"><strong><u>Conclusion</u></strong>:</h5>
<p>A special thanks to Erika Sweet, Paul Maybee, Sinem Akinci, Ion Todirel, and the rest of the Visual Studio C++ team who, over the course of a several months to a year, helped make the Office team’s cross-platform ideal workflow a reality. The Office team left with an overwhelmingly positive experience and hopes for more collaboration in the future (and looking forward to soon leveraging this same VS technology to debug Mac core dumps on Windows).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/">Microsoft Office team uses Remote MacOS Debugging Capability in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Improving Copy and Move Elision</title>
		<link>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/#comments</comments>
		
		<dc:creator><![CDATA[Bran Hagger]]></dc:creator>
		<pubDate>Mon, 24 Oct 2022 16:00:31 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31231</guid>

					<description><![CDATA[<p>With Visual Studio 2022 version 17.4 Preview 3, we&#8217;ve significantly increased the number of situations where we do copy or move elision and given users more control over whether these transformations are enabled.<br />
What are copy and move elision?<br />
When a return keyword in a C++ function is followed by an expression of non-primitive type,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>With Visual Studio 2022 version 17.4 Preview 3, we&#8217;ve significantly increased the number of situations where we do copy or move elision and given users more control over whether these transformations are enabled.</p>
<h2 id="what-are-copy-and-move-elision">What are copy and move elision?</h2>
<p>When a <code>return</code> keyword in a C++ function is followed by an expression of non-primitive type, the execution of that return statement copies the result of the expression into the return slot of the calling function. To do this, the copy or move constructor of the non-primitive type is called. Then, as part of exiting the function, destructors for function-local variables are called, likely including any variables named in the expression following the <code>return</code> keyword.</p>
<p>The C++ specification allows the compiler to construct the returned object directly in the return slot of the calling function, eliding the copy or move constructor executed as part of the return. Unlike most other optimizations, this transformation is allowed to have an observable effect on the program&#8217;s output &#8211; namely, the copy or move constructor and associated destructor are called one less time.</p>
<h2 id="mandatory-copy-move-elision-in-visual-studio">Mandatory copy/move elision in Visual Studio</h2>
<p>The C++ standard <em>requires</em> copy or move elision when the returned value is initialized as part of the <code>return</code> statement (such as when a function with return type <code>Foo</code> returns <code>return Foo()</code>). The Microsoft Visual C++ compiler always performs copy and move elision for return statements where it is required to do so, regardless of the flags passed to the compiler. This behavior is unchanged.</p>
<h2 id="changes-to-optional-copy-move-elision-in-visual-studio-17-4-preview-3">Changes to optional copy/move elision in Visual Studio 17.4 Preview 3</h2>
<p>When the returned value is a named variable, the compiler <em>may</em> elide the copy or move but is not required to do so. The standard still requires a copy or move constructor to be defined for the named return variable, even if the compiler elides the constructor in all cases. Prior to Visual Studio 2022 version 17.4 Preview 3, when optimizations were disabled (such as with the <code>/Od</code> compiler flag or for functions marked with <code>#pragma optimize("", off)</code>) the compiler would only perform mandatory copy and move elision. With the <code>/O2</code> flag, the compiler would perform optional copy or move elision for optimized functions with simple control flow.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, we are giving developers the option for consistency with the new <code>/Zc:nrvo</code> compiler flag. The <code>/Zc:nrvo</code> flag will be passed by default when code is compiled with the <code>/O2</code> flag, the <code>/permissive-</code> flag, or when compiling for <code>/std:c++20</code> or later. When this flag is passed, copy and move elision will be performed wherever possible. We would like to turn <code>/Zc:nrvo</code> on by default in a future release.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, optional copy/move elision can also be explicitly disabled with the <code>/Zc:nrvo-</code> flag. It is impossible to disable mandatory copy/move elision.</p>
<p>In Visual Studio 2022 version 17.4 Preview 3, we are also increasing the number of places where we do copy/move elision when optional copy/move elision is enabled with the <code>/Zc:nrvo</code>, <code>/O2</code>, <code>/permissive-</code>, or <code>/std:c++20</code> or later flags.</p>
<table>
<thead>
<tr>
<th></th>
<th>Earlier versions of Visual Studio</th>
<th>Visual Studio 17.4 Preview 3 and later</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mandatory copy/move elision</td>
<td>Always occurs.</td>
<td>Always occurs.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in function without loops or exception handling</td>
<td>Occurs under <code>/O2</code> unless the function has multiple returned symbols with overlapping lifetimes or the type&#8217;s copy or move constructor has default arguments.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in a loop</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in functions with exception handling</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable when the copy or move constructor has additional default arguments</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for throw of a named variable</td>
<td>Never occurs.</td>
<td>Never occurs.</td>
</tr>
</tbody>
</table>
<h2 id="examples-of-optional-copy-move-elision">Examples of optional copy/move elision</h2>
<p>The simplest example of optional copy or move elision is a function such as:</p>
<pre><code class="language-C++">Foo SimpleReturn() {
    Foo result;
    return result;
}</code></pre>
<p>Earlier versions of the MSVC compiler already elided the copy or move of <code>result</code> into the return slot in this case if the <code>/O2</code> flag was passed. In Visual Studio 2022 version 17.4 Preview 3, the copy or move is also elided if the <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed, and retained if the <code>/Zc:nrvo-</code> flag is passed.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, we now perform copy/move elision in the following additional cases if the <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed to the compiler and the <code>/Zc:nrvo-</code> flag is not:</p>
<h3 id="return-inside-a-loop">Return inside a loop</h3>
<pre><code class="language-C++">Foo ReturnInALoop(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        Foo result;
        if (i == (iterations / 2)) {
            return result;
        }
    }
}</code></pre>
<p>The <code>result</code> object will be properly constructed at the start of each iteration of the loop and destructed at the end of each iteration. On the iteration where <code>result</code> is returned, its destructor will not be called on exit from the function. The function&#8217;s caller will destroy the returned object when it falls out of scope in that function.</p>
<h3 id="return-with-exception-handling">Return with exception-handling</h3>
<pre><code class="language-C++">Foo ReturnInTryCatch() {
    try {
        Foo result;
        return result;
    } catch (...) {}
}</code></pre>
<p>The copy or move of the <code>result</code> object will now be elided if the <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed and the <code>/Zc:nrvo-</code> flag is not. We also now properly handle more complex cases such as:</p>
<pre><code class="language-C++">int n;

void throwFirstThreeIterations() {
    ++n;
    if (n &lt;= 3) throw n;
}

Foo ComplexTryCatch()
{
Label1:
    Foo result;

    try {
        throwFirstThreeIterations();
        return result;
    }
    catch(...) {
        goto Label1;    
    }
}</code></pre>
<p>The <code>result</code> object will be constructed in the return slot for the caller function and no copy/move constructor or destructor will be called for it on a successful return. When an exception is thrown, whether or not the <code>result</code> object is destructed is determined by which exception-handling flags are passed to the compiler. By default, no stack-unwinding will occur and therefore no destructors will be called. However, if stack-unwinding exception handling is enabled with the <code>/EHs</code>, <code>/EHa</code>, or <code>/EHr</code> flags, <code>goto Label1</code> will cause <code>result</code>&#8216;s destructor to be called because it jumps to before <code>result</code> is initialized. Either way, when the expression <code>Foo result</code> is reached again, the object will be constructed again in the return slot.</p>
<h3 id="copy-constructors-with-default-arguments">Copy constructors with default arguments</h3>
<p>We now properly detect that a copy or move constructor with default arguments is still a copy or move constructor, and therefore can be elided in the cases above. A copy constructor with default parameters will look something like the following:</p>
<pre><code class="language-C++">struct StructWithCopyConstructorDefaultParam {
   int X;

   StructWithCopyConstructorDefaultParam(int x) : X(x) {}
   StructWithCopyConstructorDefaultParam(StructWithCopyConstructorDefaultParam const&amp; original, int defaultParam = 0) :
      X(original.X + defaultParam) {
      printf("Copy constructor called.\n");
   }
};
</code></pre>
<h2 id="limitations-on-nrvo">Limitations on NRVO</h2>
<p>Although the MSVC compiler now performs copy and move elision in many more situations, it is not always possible to perform copy/move elision. To see why this is true, consider the following function:</p>
<pre><code class="language-C++">Foo WhichShouldIReturn(bool condition) {
    Foo resultA;
    if (condition) {
        Foo resultB;
        return resultB;
    }
    return resultA;
}</code></pre>
<p>Copy elision constructs the object to be returned in the return slot, but which object should be constructed in the return slot in this case? For the copy of <code>resultA</code> to be elided at <code>return resultA</code>, it must be constructed in the return slot. However, if <code>condition</code> is true, <code>resultB</code> will need to be constructed in the return slot before <code>resultA</code> is destroyed. There is no way to perform copy elision for both paths.</p>
<p>We currently choose to avoid doing optional copy/move elision on all paths in a function if copy/move elision is impossible on any path. However, changes to inlining decisions, dead code elimination, and other optimizations can change whether copy or move elision is possible. For this reason, it is never safe to write code that depends on certain behavior for copy/move elision of named variables unless all optional copy/move elision is disabled with <code>/Zc:nrvo-</code>.</p>
<p>As long as stack-unwinding exception handling is enabled or no exceptions are thrown, it is still safe to assume that every constructer call has a matching destructor call.</p>
<h2 id="feedback">Feedback</h2>
<p>We encourage you to try out this update in the latest Visual Studio 2022 version 17.4 Preview. Please let us know what you think or any issues you encounter. We can be reached via the comments below, via twitter (<a href="https://twitter.com/visualc">@visualC</a>) or via <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 06 Oct 2022 18:02:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31188</guid>

					<description><![CDATA[<p>The September 2022 release of the vcpkg package manager is available. This blog post summarizes changes from August 15th, 2022 to September 27th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
&#160;<br />
vcpkg now has over 2,000 unique libraries in its open-source registry<br />
With this release,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">September 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from August 15<sup>th</sup>, 2022 to September 27<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>&nbsp;</p>
<h3 id="vcpkg-now-has-over-2000-unique-libraries-in-its-open-source-registry">vcpkg now has over 2,000 unique libraries in its open-source registry</h3>
<p>With this release, and the 6<sup>th</sup> anniversary of the launch of vcpkg, we are proud to hit a new milestone:<strong> over 2,000 unique open-source libraries</strong> are available in the vcpkg catalog! vcpkg continues to maintain the largest catalog of any C/C++ package manager with over 10,000 unique library versions with built-in support for many popular architectures, operating systems, and compilers, including x64, x86, arm, arm64, WebAssembly, Linux, macOS, Windows, iOS, Android, FreeBSD, UWP, MSVC, Clang, gcc, mingw, as well as static and shared (dynamic) libraries and more! And of course, since vcpkg is configured to build all these libraries from source, you can make further customizations as needed for your unique workflow.</p>
<p>From the beginning, we have invested extensively in building a large ecosystem of libraries supporting as many development workflows as possible, and we will continue to honor that commitment. While the C++ ecosystem is incredibly diverse, we will rise to the challenge and try to make as many developers as possible more productive. Managing libraries is well understood as a top C++ pain point in annual ISO C++ surveys, but we hope that will change over the next several years.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>48 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>419 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>2,022 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are over <strong>10,839 port versions</strong>.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">September release of the main vcpkg repo</a> includes <strong>249 commits</strong>.</li>
<li><strong>95 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.8k forks</strong> and <strong>16.8k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<p>While last month was relatively quiet, this month’s update includes several vcpkg tool changes. See the full tool <a href="https://github.com/microsoft/vcpkg-tool/compare/2022-07-21...2022-09-20">commit changelog</a> for details. Notable changes are summarized below.</p>
<p>&nbsp;</p>
<h4 id="optional-name-and-version-fields-in-vcpkg-json">Optional name and version fields in vcpkg.json</h4>
<p><code>vcpkg.json</code> is the manifest file for specifying library dependencies, versions, optional features and other metadata required for acquiring ports. Previously, two fields were always mandatory for this file:</p>
<ul>
<li><code>name</code>: specifies a name for the project this manifest resides in.</li>
<li><code>version</code>: specifies a version for the project this manifest resides in.</li>
</ul>
<p>These fields are only really useful if your project is a library or other port that you want to package with vcpkg. However, we required the same schema for all projects consuming vcpkg ports (even if they themselves are not a port), which may be confusing for users. From now on, these fields are optional for projects that are only consuming ports, but not producing one. If you’re packaging a library for use in vcpkg however, you absolutely still need to specify these fields as they are critical for consumers to be able to consume your library via vcpkg.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/605">Microsoft/vcpkg-tool#605</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-artifacts-improvements">vcpkg artifacts improvements</h4>
<p>We are continuing to improve our preview experience for vcpkg artifacts, which enable acquisition of developer tools like compilers and debuggers from vcpkg. These are some changes in this release, especially for multiple registry scenarios:</p>
<ul>
<li>The <code>--registry</code>switch has been removed as registries are required to have a name.</li>
<li>Commands which take as input registry names or IDs now combine the set of registry names from the global set and the local project.</li>
<li>Console output now always displays registries using the following rules:
<ul>
<li>If the registry URI is in the project, the name of the project is used.</li>
<li>If the registry URI is not in the project, and the name of the registry in the global configuration does not conflict with the project, the global configuration’s name is used.</li>
<li>Otherwise, the URI enclosed in []s is used. This is a signal to vcpkg users that they will need to provide an appropriate registry name if they want something different.</li>
</ul>
</li>
<li>The command x-regenerate I now requires a local file path.</li>
<li>Several places that used to break when handling relative paths now tolerate the situation correctly, including x-regenerate.</li>
<li>If an artifact declares a dependency from a particular registry, and that registry’s name is not declared in the artifact itself, resolution fails. Vcpkg will no longer try to find the name in the project/global configuration.</li>
<li>Commands that need activation like add and remove no longer try to activate the project automatically.</li>
<li>Artifacts are now installed and enumerated in topological sorted order.</li>
<li>There is no longer a built-in registry named “default”.</li>
<li>Except for index.yaml, all remaining YAML files have been replaced with JSON. This may invalidate existing installed artifacts. This change was necessary in order to make the artifacts experience more consistent with our existing experience for managing ports.</li>
<li>Output messages have been cleaned up, including the removal of several newlines.</li>
<li>Bug fix: the console output no longer gets confused around registry names and no longer displays names using a “[URL]” format when it is unnecessary to do so.</li>
</ul>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/690">Microsoft/vcpkg-tool#690</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/693">Microsoft/vcpkg-tool#693</a></p>
<p>&nbsp;</p>
<h4 id="cleaned-up-console-output-when-not-connected-to-a-console">Cleaned up console output when not connected to a console</h4>
<p>We fixed some console output bugs when vcpkg is not connected to a console/TTY. Specifically:</p>
<ul>
<li>VT codes when showing tables should now be displayed correctly.</li>
<li>Progress bars are no longer displayed as the extra output may be undesirable in CI systems and also was not displaying correctly at times.</li>
</ul>
<p><strong>Before (non-TTY): </strong></p>
<p><img decoding="async" width="1489" height="191" class="wp-image-31202" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4.png" alt="Graphical user interface Description automatically generated with low confidence" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4.png 1489w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-300x38.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-1024x131.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-768x99.png 768w" sizes="(max-width: 1489px) 100vw, 1489px" /></p>
<p><strong>After (non-TTY): </strong></p>
<p><img decoding="async" width="1393" height="661" class="wp-image-31203" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2.png" alt="Text Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2.png 1393w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-300x142.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-1024x486.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-768x364.png 768w" sizes="(max-width: 1393px) 100vw, 1393px" /></p>
<p><strong>In TTY: </strong></p>
<p><img decoding="async" width="1630" height="412" class="wp-image-31204" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5.png" alt="Graphical user interface Description automatically generated with low confidence" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-300x76.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-1024x259.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-768x194.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-1536x388.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/702">Microsoft/vcpkg-tool#702</a></p>
<p>&nbsp;</p>
<h4 id="added-schemata-for-vcpkg-json-vcpkg-configuration-json-and-artifacts">Added schemata for vcpkg.json, vcpkg-configuration.json, and artifacts</h4>
<p>We added official schemas for our manifest files to make it easier to validate that files are authored correctly. In the future, we will also be using this experience to validate manifest files opened in Visual Studio and Visual Studio Code and notify users if errors are present using the IntelliSense experience.</p>
<p>You can try it yourself for the vcpkg.json and vcpkg-configuration.json manifests by</p>
<p>adding the following to the appropriate .json file:</p>
<p><code>"$schema": https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/vcpkg.schema.json</code></p>
<p><img decoding="async" width="1018" height="677" class="wp-image-31205" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2.png 1018w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2-300x200.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2-768x511.png 768w" sizes="(max-width: 1018px) 100vw, 1018px" /></p>
<p>To try it out on JSON files describing artifacts,</p>
<p>add the following to the file:</p>
<p><code>"$schema": https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/artifact.schema.json</code></p>
<p><img decoding="async" width="1050" height="562" class="wp-image-31206" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2.png 1050w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-300x161.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-1024x548.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-768x411.png 768w" sizes="(max-width: 1050px) 100vw, 1050px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/650">Microsoft/vcpkg-tool#650</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,823</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,879</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,784</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,795</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>956</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,444</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>910</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,738</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,810</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>Thomas1664 (21 commits)</li>
<li>dg0yt (16 commits)</li>
<li>Neumann-A (14 commits)</li>
<li>wrobelda (5 commits)</li>
<li>autoantwort (4 commits)</li>
<li>m-kuhn (4 commits)</li>
<li>coryan (4 commits)</li>
<li>RT222 (2 commits)</li>
<li>eao197 (2 commits)</li>
<li>chausner (2 commits)</li>
<li>Osyotr (2 commits)</li>
<li>daschuer (1 commit)</li>
<li>ekilmer (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>myd7349 (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>past-due (1 commit)</li>
<li>DragonJoker (1 commit)</li>
<li>xvitaly (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">full September release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue </a><span style="color: #00a9e0;">tracker </span>or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<h3 id="interested-in-vcpkg-but-not-sure-where-to-start">Interested in vcpkg but not sure where to start?</h3>
<p>Is your company experiencing challenges managing C/C++ libraries? Perhaps you&#8217;re curious if a package manager is the right choice to you? Please reach out to vcpkg@microsoft.com and we&#8217;d be happy to help!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</title>
		<link>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/</link>
					<comments>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Mon, 03 Oct 2022 21:59:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31177</guid>

					<description><![CDATA[<p>One of the new features for C++ developers in Visual Studio 2022 version 17.3 is NuGet PackageReference support for C++/CLI MSBuild projects that target .NET Core and .NET 5 or higher. More specifically, this impacts CLR Class Library (.NET) and CLR Empty Project (.NET) project templates.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/">Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>One of the new features for C++ developers in Visual Studio 2022 version 17.3 is <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files">NuGet PackageReference</a> support for <strong>C++/CLI MSBuild projects that target .NET Core and .NET 5 or higher</strong>. More specifically, this impacts <em>CLR Class Library (.NET)</em> and <em>CLR Empty Project (.NET)</em> project templates. This functionality allows you to manage NuGet packages while bringing the <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/migrate-packages-config-to-package-reference">benefits of PackageReference</a> support to your dependencies. This feature is on by default for new projects. To enable this feature for your existing projects, add the following property to your project file:</p>
<p><code>&lt;PropertyGroup Label="Globals"&gt;</code></p>
<p><code>&lt;EnableManagedPackageReferenceSupport&gt;true&lt;/EnableManagedPackageReferenceSupport&gt; &lt;/PropertyGroup&gt;</code></p>
<p>In most cases, you will want to enable this for the whole codebase. You can do this by setting the property in a <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2022">Directory.Build.props file</a> instead.</p>
<p>When this property is set to <strong>true</strong>, NuGet will recognize on project load that the project is participating in the PackageReference experience and begin restoring packages just as it would for a .NET project.</p>
<p><strong>Note:</strong> in order to modify this setting in any way, it is required to unload the project file, make the change, then reload it for the change to take effect. This setting cannot be changed for an actively loaded project.</p>
<p>&nbsp;</p>
<h3 id="is-packagereference-support-limited-to-managed-c-cli-projects">Is PackageReference support limited to managed C++/CLI projects?</h3>
<p>In short, yes. It is important to support NuGet PackageReference for projects that touch .NET code since NuGet is the recommended dependency management solution for .NET. Furthermore, the C++ team will continue supporting C++/CLI projects as an interop story between C++ and .NET.</p>
<p>For native C++ projects, we recommend using vcpkg for both C++ open-source and closed source libraries. With compilation from source, binary caching, custom registries, version conflict resolution, and more, we believe this will provide the best experience for managing C/C++ dependencies. vcpkg can also target a large variety of platforms and architectures natively and works with any C++ build system.</p>
<p>With that said, we would love to hear your feedback on language interop scenarios with C++: <a href="https://developercommunity.visualstudio.com/report?space=8&amp;ftype=idea&amp;entry=suggestion">please file suggestion tickets</a> on Developer Community.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback</h3>
<p>We would love to hear from you! <a id="post-31177-_Hlk110857813"></a><a href="https://visualstudio.microsoft.com/">Download Visual Studio 2022</a>, give it a try, and file bugs or feature requests on <a href="https://developercommunity.visualstudio.com/home">Visual Studio Developer Community</a>. For new issues within NuGet, please report a <a href="https://github.com/NuGet/Home/issues/new/choose">GitHub Issue</a>. For general NuGet experience issues, let us know via the <a href="https://learn.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022">Report a Problem</a> option in Visual Studio found under the <em>Help &gt; Report A Problem </em>menu.</p>
<p>Feel free to leave comments in this blog post with your thoughts or reach out to us at <a href="mailto:visualc@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/">Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
	</channel>
</rss>
