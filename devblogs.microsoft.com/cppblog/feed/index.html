<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Thu, 18 Aug 2022 07:36:06 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>proxy: Runtime Polymorphism Made Easier Than Ever</title>
		<link>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/</link>
					<comments>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/#comments</comments>
		
		<dc:creator><![CDATA[Mingxin Wang]]></dc:creator>
		<pubDate>Mon, 15 Aug 2022 15:00:41 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Experimental]]></category>
		<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30853</guid>

					<description><![CDATA[<p>proxy is a single-header cross-platform library that facilitates runtime polymorphism.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/">proxy: Runtime Polymorphism Made Easier Than Ever</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><code>proxy</code> is an open-source, cross-platform, single-header C++ library, making runtime polymorphism easier to implement and faster, empowered by our breakthrough innovation of Object-oriented Programming (OOP) theory in recent years. Consider three questions:</p>
<ol>
<li>Do you want to facilitate architecture design and matainance by writing non-intrusive polymorphic code in C++ as easily as in Rust or Golang?</li>
<li>Do you want to facilitate lifetime management of polymorphic objects as easily as in languages with runtime Garbage Collection (GC, like Java or C#), <em>without</em> compromising performance?</li>
<li>Have you tried other polymorphic programming libraries in C++ but found them deficient?</li>
</ol>
<p>If so, this library is for you. You can find the implementation at <a href="https://github.com/microsoft/proxy">our GitHub repo</a>, integrate with your project using <a href="https://github.com/microsoft/vcpkg">vcpkg</a> (search for <code>proxy</code>), or learn more about the theory and technical specifications from <a href="https://wg21.link/p0957">P0957</a>.</p>
<h2 id="overview">Overview</h2>
<p>In C++ today, there are certain architecture and performance limitations in existing mechanisms of polymorphism, specifically, virtual functions (based on inheritance) and various polymorphic wrappers (with value semantics) in the standard. As a result, <code>proxy</code> can largely replace the existing &#8220;virtual mechanism&#8221; to implement your vision in runtime polymorphism, while having no intrusion on existing code, with even better performance.</p>
<p>All the facilities of the library are defined in namespace <code>pro</code>. The 3 major class templates are <code>dispatch</code>, <code>facade</code> and <code>proxy</code>. Here is a demo showing how to use this library to implement runtime polymorphism in a different way from the traditional inheritance-based approach:</p>
<pre><code class="language-cpp">// Abstraction
struct Draw : pro::dispatch&lt;void(std::ostream&amp;)&gt; {
  template &lt;class T&gt;
  void operator()(const T&amp; self, std::ostream&amp; out) { self.Draw(out); }
};
struct Area : pro::dispatch&lt;double()&gt; {
  template &lt;class T&gt;
  double operator()(const T&amp; self) { return self.Area(); }
};
struct DrawableFacade : pro::facade&lt;Draw, Area&gt; {};

// Implementation (No base class)
class Rectangle {
 public:
  void Draw(std::ostream&amp; out) const
      { out &lt;&lt; "{Rectangle: width = " &lt;&lt; width_ &lt;&lt; ", height = " &lt;&lt; height_ &lt;&lt; "}"; }
  void SetWidth(double width) { width_ = width; }
  void SetHeight(double height) { height_ = height; }
  double Area() const { return width_ * height_; }

 private:
  double width_;
  double height_;
};

// Client - Consumer
std::string PrintDrawableToString(pro::proxy&lt;DrawableFacade&gt; p) {
  std::stringstream result;
  result &lt;&lt; "shape = ";
  p.invoke&lt;Draw&gt;(result);  // Polymorphic call
  result &lt;&lt; ", area = " &lt;&lt; p.invoke&lt;Area&gt;();  // Polymorphic call
  return std::move(result).str();
}

// Client - Producer
pro::proxy&lt;DrawableFacade&gt; CreateRectangleAsDrawable(int width, int height) {
  Rectangle rect;
  rect.SetWidth(width);
  rect.SetHeight(height);
  return pro::make_proxy&lt;DrawableFacade&gt;(rect);  // No heap allocation is expected
}</code></pre>
<h2 id="configure-your-project">Configure your project</h2>
<p>To get started, set the language level of your compiler to at least C++20 and get the header file (<a href="https://github.com/microsoft/proxy/blob/main/proxy.h">proxy.h</a>). You can also install the library via <a href="https://github.com/microsoft/vcpkg/">vcpkg</a>, which is a C++ library management software invented by Microsoft, by searching for &#8220;proxy&#8221;.</p>
<p>To integrate with CMake, 3 steps are required:</p>
<ol>
<li>Set up the vcpkg manifest by adding &#8220;proxy&#8221; as a dependency in your <code>vcpkg.json</code> file:
<pre><code class="language-json">{
"name": "&lt;project_name&gt;",
"version": "0.1.0",
"dependencies": [
{
  "name": "proxy"
}
]
}</code></pre>
</li>
<li>Use <code>find_package</code> and <code>target_link_libraries</code> commands to reference to the library <code>proxy</code> in your <code>CMakeLists.txt</code> file:
<pre><code class="language-cmake">find_package(proxy CONFIG REQUIRED)
target_link_libraries(&lt;target_name&gt; PRIVATE msft_proxy)</code></pre>
</li>
<li>Run CMake with vcpkg toolchain file:
<pre><code class="language-cmake">cmake &lt;source_dir&gt; -B &lt;build_dir&gt; -DCMAKE_TOOLCHAIN_FILE=&lt;vcpkg_dir&gt;/scripts/buildsystems/vcpkg.cmake</code></pre>
</li>
</ol>
<h2 id="what-makes-the-proxy-so-charming">What makes the &#8220;proxy&#8221; so charming</h2>
<p>As a polymorphic programming library, <code>proxy</code> has various highlights, including:</p>
<ol>
<li>being <em>non-intrusive</em></li>
<li>allowing lifetime management <em>per object</em>, complementary with smart pointers</li>
<li>high-quality code generation</li>
<li>supporting flexible composition of abstractions</li>
<li>optimized syntax for Customization Point Objects (CPO) and modules</li>
<li>supporting general-purpose static reflection</li>
<li>supporting expert performance tuning</li>
<li>high-quality diagnostics.</li>
</ol>
<p>In this section, we will briefly introduce each of the highlights listed above with concrete examples.</p>
<h3 id="highlight-1-being-non-intrusive">Highlight 1: Being non-intrusive</h3>
<p>Designing polymorphic types with inheritance usually requires careful architecting. If the design is not thought through enough early on, the components may become overly complex as more and more functionality is added, or extensibility may be insufficient if polymorphic types are coupled too closely. On the other hand, some libraries (including the standard library) may not have proper polymorphic semantics even if they, by definition, satisfy same specific constraints. In such scenarios, users have no alternative but to design and maintain extra middleware themselves to add polymorphism support to existing implementations.</p>
<p>For example, some programming languages provide base types for containers, which makes it easy for library authors to design APIs without binding to a specific data structure at runtime. However, this is not feasible in C++ because most of the standard containers are not required to have a common base type. I do not think this is a design defect of C++, on the contrary, I think it is reasonable not to overdesign for runtime abstraction before knowing the concrete requirements both for the simplicity of the semantics and for runtime performance. With <code>proxy</code>, because it is non-intrusive, if we want to abstract a mapping data structure from indices to strings for localization, we may define the following facade:</p>
<pre><code class="language-cpp">struct at : pro::dispatch&lt;std::string(int)&gt; {
  template &lt;class T&gt;
  auto operator()(T&amp; self, int key) { return self.at(key); }
};
struct ResourceDictionaryFacade : pro::facade&lt;at&gt; {};</code></pre>
<p>It could proxy any potential mapping data structure, including but not limited to <code>std::map&lt;int, std::string&gt;</code>, <code>std::unordered_map&lt;int, std::string&gt;</code>, <code>std::vector&lt;std::string&gt;</code>, etc.</p>
<pre><code class="language-cpp">// Library
void DoSomethingWithResourceDictionary(pro::proxy&lt;ResourceDictionaryFacade&gt; p) {
  try {
    std::cout &lt;&lt; p.invoke(1) &lt;&lt; std::endl;
  } catch (const std::out_of_range&amp; e) {
    std::cout &lt;&lt; "No such element: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}

// Client
std::map&lt;int, std::string&gt; var1{{1, "Hello"}};
std::vector&lt;std::string&gt; var2{"I", "love", "Proxy", "!"};
DoSomethingWithResourceDictionary(&amp;var1);  // Prints "Hello"
DoSomethingWithResourceDictionary(&amp;var2);  // Prints "love"
DoSomethingWithResourceDictionary(std::make_shared&lt;std::unordered_map&lt;int, std::string&gt;&gt;());  // Prints "No such element: {implementation-defined error message}"</code></pre>
<p>Overall, inheritance-based polymorphism has certain limitations in usability. As <a href="https://www.youtube.com/watch?v=QGcVXgEVMJg">Sean Parent commented on NDC 2017</a>: <em>The requirements of a polymorphic type, by definition, comes from its use, and there are no polymorphic types, only polymorphic use of similar types. Inheritance is the base class of evil</em>.</p>
<h3 id="highlight-2-evolutionary-lifetime-management">Highlight 2: Evolutionary lifetime management</h3>
<p>It is such a pain to manage lifetime of objects in large systems written in C++. Because C++ does not have built-in GC support due to performance considerations, users need to beware of lifetime management of every single object. Although we have smart pointers since C++11 (i.e., <code>std::unique_ptr</code> and <code>std::shared_ptr</code>), and various 3rd-party fancy pointers like <code>boost::interprocess::offset_ptr</code>, they are not always sufficient for polymorphic use with inheritance. By using the <code>proxy</code> complementary with smart pointers, clients could care less about lifetime management as if there is runtime GC, but without compromising performance.</p>
<p>Before using any polymorphic object, the first step is always to create it. In other programming languages like Java or C#, we can <code>new</code> an object at any time and runtime GC will take care of lifetime management when it becomes unreachable, at the cost of performance. But how should we implement it in C++? Consider the <code>drawable</code> example in the &#8220;Overview&#8221; section: given there are 3 <code>drawable</code> types in a system: <code>Rectangle</code>, <code>Circle</code>, and <code>Point</code>. Specifically,</p>
<ul>
<li><code>Rectangle</code>s have width, height, transparency, and area</li>
<li><code>Circle</code>s have radius, transparency, and area</li>
<li><code>Point</code>s do not have any property; its area is always zero</li>
</ul>
<p>A library function <code>MakeDrawableFromCommand</code> shall be defined as a factory function responsible for creating a <code>drawable</code> instance by parsing the command line.</p>
<p>Here is how we usually define the types with inheritance:</p>
<pre><code class="language-cpp">// Abstraction
class IDrawable {
 public:
  virtual void Draw(std::ostream&amp; out) const = 0;
  virtual double Area() const = 0;
  // Don't forget the virtual destructor, otherwise `delete`ing a pointer of `IDrawable` may result in memory leak!
  virtual ~IDrawable() {}  
};

// Implementation
class Rectangle : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  void SetWidth(double width);
  void SetHeight(double height);
  void SetTransparency(double);
  double Area() const override;
};
class Circle : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  void SetRadius(double radius);
  void SetTransparency(double transparency);
  double Area() const override;
};
class Point : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  constexpr double Area() const override { return 0; }
};</code></pre>
<p>If we use <code>std::string</code> to represent the command line, the parameter type of <code>MakeDrawableFromCommand</code> could be <code>const std::string&amp;</code>, where there should not be much debate. But what should the return type be? <code>IDrawable*</code>? <code>std::unique_ptr&lt;IDrawable&gt;</code>? Or <code>std::shared_ptr&lt;IDrawable&gt;</code>? Specifically,</p>
<ul>
<li>If we use <code>IDrawable*</code>, the semantics of the return type is ambiguous because it is a raw pointer type and does not indicate the lifetime of the object. For instance, it could be allocated via <code>operator new</code>, from a memory pool or even a global object. Clients always need to learn the hidden contract from the author (or even need to learn the implementation details if the author and documentation are not available for consulting) and properly disposing of the object when the related business has finished via <code>operator delete</code> or some other way corresponding to how it was allocated.</li>
<li>If we use <code>std::unique_ptr&lt;IDrawable&gt;</code>, it means every single object is allocated individually from the heap, even if the value is potentially immutable or reusable (&#8220;flyweight&#8221;), which is potentially bad for performance.</li>
<li>If we use <code>std::shared_ptr&lt;IDrawable&gt;</code>, the performance could become better for flyweight objects due to the relatively low cost of copying, but the ownership of the object becomes ambiguous (a.k.a. &#8220;ownership hell&#8221;), and the thread-safety guarantee of copy-construction and destruction of <code>std::shared_ptr</code> may also add to runtime overhead. On the other hand, if we prefer <code>std::shared_ptr</code> across the whole system, every polymorphic type is encouraged to inherit <code>std::enable_shared_from_this</code>, which may significantly affect the design and maintenance of a large system.</li>
</ul>
<p>For <code>proxy</code>, with the definition from the &#8220;Overview&#8221; section, we can simply define the return type as <code>pro::proxy&lt;DrawableFacade&gt;</code> without further concern. In the implementation, <code>pro::proxy&lt;DrawableFacade&gt;</code> could be instantiated from all kinds of pointers with potentially different lifetime management strategy. For example, <code>Rectangle</code>s may be created every time when requested from a memory pool, while the value of <code>Point</code>s could be cached throughout the lifetime of the program:</p>
<pre><code class="language-cpp">pro::proxy&lt;DrawableFacade&gt; MakeDrawableFromCommand(const std::string&amp; s) {
  std::vector&lt;std::string&gt; parsed = ParseCommand(s);
  if (!parsed.empty()) {
    if (parsed[0u] == "Rectangle") {
      if (parsed.size() == 3u) {
        static std::pmr::unsynchronized_pool_resource rectangle_memory_pool;
        std::pmr::polymorphic_allocator&lt;&gt; alloc{&amp;rectangle_memory_pool};
        auto deleter = [alloc](Rectangle* ptr) mutable
            { alloc.delete_object&lt;Rectangle&gt;(ptr); };
        Rectangle* instance = alloc.new_object&lt;Rectangle&gt;();
        std::unique_ptr&lt;Rectangle, decltype(deleter)&gt; p{instance, deleter};  // Allocated from a memory pool
        p-&gt;SetWidth(std::stod(parsed[1u]));
        p-&gt;SetHeight(std::stod(parsed[2u]));
        return p;  // Implicit conversion happens
      }
    } else if (parsed[0u] == "Circle") {
      if (parsed.size() == 2u) {
        Circle circle;
        circle.SetRadius(std::stod(parsed[1u]));
        return pro::make_proxy&lt;DrawableFacade&gt;(circle);  // SBO may apply
      }
    } else if (parsed[0u] == "Point") {
      if (parsed.size() == 1u) {
        static Point instance;  // Global singleton
        return &amp;instance;
      }
    }
  }
  throw std::runtime_error{"Invalid command"};
}</code></pre>
<p>The full implementation of the example above could be found in our <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_integration_tests.cpp#L87-L116">integration tests</a>. In this example, there are 3 <code>return</code> statements in different branches and the return types are also different. Lifetime management with inheritance-based polymorphism is error-prone and inflexible, while <code>proxy</code> allows easy customization of any lifetime management strategy, including but not limited to raw pointers and various smart pointers with potentially pooled memory management.</p>
<p>Specifically, Small Buffer Optimization (SBO, a.k.a., SOO, Small Object Optimization) is a common technique to avoid unnecessary memory allocation (see the second <code>return</code> statement). However, for inheritance-based polymorphism, there are few facilities in the standard that support SBO; for other standard polymorphic wrappers, implementations may support SBO, but there is no standard way to configure it so far. For example, if the size of <code>std::any</code> is <code>n</code>, it is theoretically impossible to store the concrete value whose size is larger than <code>n</code> without external storage.</p>
<p><strong>The top secret making <code>proxy</code> both easy-to-use and fast is that it allows lifetime management <em>per object</em></strong>, which had not been addressed in traditional OOP theory (inheritance-based polymorphism) ever before.</p>
<p>If you have tried other polymorphic programming libraries in C++ before, you may or may not find this highlight of lifetime management unique to <code>proxy</code>. Some of these libraries claim to support various lifetime management model, but do not allow <em>per-object</em> customization like <code>proxy</code> does.</p>
<p>Take <a href="https://github.com/ldionne/dyno"><code>dyno</code></a> as an example. <code>dyno</code> is another non-intrusive polymorphic programming library in C++. Given an &#8220;interface&#8221; type <code>I</code>, <code>dyno</code> does not allow <code>dyno::poly&lt;I&gt;</code> to have a different lifetime management model. By default, <code>dyno::poly&lt;I&gt;</code> always allocates from the heap by the time this blog was written (see <a href="https://github.com/ldionne/dyno/blob/b05a51eeaa4ddd7deb9e3100984bf20cfbf94eab/include/dyno/poly.hpp#L64">typename Storage = dyno::remote_storage</a>). For example, if we want to take advantage of SBO, it is needed to override the <code>Storage</code> type, i.e., <code>dyno::poly&lt;I, dyno::sbo_storage&lt;...&gt;&gt;</code>, which is a different type from <code>dyno::poly&lt;I&gt;</code>. Therefore, <code>dyno::poly&lt;I&gt;</code> could not be used to implement features like <code>MakeDrawableFromCommand</code> above, where the optimal lifetime management model of each branch may differ. Whereas <code>proxy</code> does not have a second template parameter. Given a facade type <code>F</code>, <code>pro::proxy&lt;F&gt;</code> is compatible with <em>any</em> lifetime management model within the constraints of the facade.</p>
<h3 id="highlight-3-high-quality-code-generation">Highlight 3: High-quality code generation</h3>
<p>Not only does <code>proxy</code> allow efficient lifetime management per object, but also it could generate high quality code for every indirect call. Specifically,</p>
<ol>
<li>Invocations from <code>proxy</code> could be properly inlined, except for the virtual dispatch on the client side, similar to the inheritance-based mechanism.</li>
<li>Because <code>proxy</code> is based on pointer semantics, the &#8220;dereference&#8221; operation may happen inside the virtual dispatch, which always generates different instructions from the inheritance-based mechanism.</li>
<li>As tested, with &#8220;clang 13.0.0 (x86-64)&#8221; and &#8221; clang 13.0.0 (RISC-V RV64)&#8221;, <code>proxy</code> generates one more instruction than the inheritance-based mechanism, while the situation is reversed with &#8220;gcc 11.2 (ARM64)&#8221;. This may infer that <code>proxy</code> could have similar runtime performance in invocation with the inheritance-based mechanism at least on the 3 processor architectures (x86-64, ARM64, RISC-V RV64).</li>
</ol>
<p>More details of code generation analysis could be found in <a href="https://wg21.link/p0957">P0957</a>.</p>
<h3 id="highlight-4-composition-of-abstractions">Highlight 4: Composition of abstractions</h3>
<p>To support reuse of declaration of expression sets, like inheritance of virtual base classes, the <code>facade</code> allows combination of different dispatches with <code>std::tuple</code>, while duplication is allowed. For example,</p>
<pre><code class="language-cpp">struct D1;
struct D2;
struct D3;
struct FA : pro::facade&lt;D1, D2, D3&gt; {};
struct FB : pro::facade&lt;D1, std::tuple&lt;D3, D2&gt;&gt; {};
struct FC : pro::facade&lt;std::tuple&lt;D1, D2, D3&gt;, D1, std::tuple&lt;D2, D3&gt;&gt; {};</code></pre>
<p>In the sample code above, given <code>D1</code>, <code>D2</code> and <code>D3</code> are well-formed dispatch types, <code>FA</code>, <code>FB</code> and <code>FC</code> are equivalent. This allows &#8220;diamond inheritance&#8221; of abstraction without</p>
<ul>
<li>syntax ambiguity</li>
<li>coding techniques like &#8220;virtual inheritance&#8221;</li>
<li>extra binary size</li>
<li>runtime overhead</li>
</ul>
<h3 id="highlight-5-syntax-for-cpos-and-modules">Highlight 5: Syntax for CPOs and modules</h3>
<p>Along with the standardization of Customization Point Objects (CPO) and improved syntax for Non-Type Template Parameters (NTTP), there are two recommended ways to define a &#8220;dispatch&#8221; type:</p>
<p>The first way is to manually overload <code>operator()</code> as demonstrated before. This is useful when a dispatch is intended to be defined in a header file shared with multiple translation units, e.g., in <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_invocation_tests.cpp#L25-L33">tests/proxy_invocation_tests.cpp</a>:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct ForEach : pro::dispatch&lt;void(pro::proxy&lt;CallableFacade&lt;void(T&amp;)&gt;&gt;)&gt; {
 template &lt;class U&gt;
 void operator()(U&amp; self, pro::proxy&lt;CallableFacade&lt;void(T&amp;)&gt;&gt;&amp;&amp; func) {
  for (auto&amp; value : self) {
   func.invoke(value);
  }
 }
};</code></pre>
<p>The second way is to specify a <code>constexpr</code> callable object as the second template parameter. It provides easier syntax if a corresponding CPO is defined before, or the &#8220;dispatch&#8221; is intended to be defined in a module with lambda expressions, e.g. in <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_invocation_tests.cpp#L23">tests/proxy_invocation_tests.cpp</a>:</p>
<pre><code class="language-cpp">struct GetSize : pro::dispatch&lt;std::size_t(), std::ranges::size&gt; {};</code></pre>
<h3 id="highlight-6-static-reflection">Highlight 6: Static reflection</h3>
<p>Reflection is an essential requirement in type erasure, and <code>proxy</code> welcomes general-purpose static (compile-time) reflection other than <code>std::type_info</code>.</p>
<p>In other languages like C# or Java, users are allowed to acquire detailed metadata of a type-erased type at runtime with simple APIs, but this is not true for <code>std::function</code>, <code>std::any</code> or inheritance-based polymorphism in C++. Although these reflection facilities add certain runtime overhead to these languages, they do help users write simple code in certain scenarios. In C++, as the reflection TS keeps evolving, there will be more static reflection facilities in the standard with more specific type information deduced at compile-time than <code>std::type_info</code>. It becomes possible for general-purpose reflection to become zero-overhead in C++ polymorphism.</p>
<p>As a result, we decided to make <code>proxy</code> support general-purpose static reflection. It&#8217;s off by default, and theoretically won&#8217;t impact runtime performance other than the target binary size if turned on. Here is an example to reflect the given types to <code>MyReflectionInfo</code>:</p>
<pre><code class="language-cpp">class MyReflectionInfo {
 public:
  template &lt;class P&gt;
  constexpr explicit MyReflectionInfo(std::in_place_type_t&lt;P&gt;) : type_(typeid(P)) {}
  const char* GetName() const noexcept { return type_.name(); }

 private:
  const std::type_info&amp; type_;
};

struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  using reflection_type = MyReflectionInfo;
};</code></pre>
<p>Users may call <code>MyReflectionInfo::GetName()</code> to get the implementation-defined name of a type at runtime:</p>
<pre><code class="language-cpp">pro::proxy&lt;MyFacade&gt; p;
puts(p.reflect().GetName());  // Prints typeid(THE_UNDERLYING_POINTER_TYPE).name()</code></pre>
<h3 id="highlight-7-performance-tuning">Highlight 7: Performance tuning</h3>
<p>To allow implementation balance between extensibility and performance, a set of constraints to a pointer is introduced, including maximum size, maximum alignment, minimum copyability, minimum relocatability and minimum destructibility. The term &#8220;relocatability&#8221; was introduced in <a href="https://wg21.link/p1144">P1144</a>, &#8220;equivalent to a move and a destroy&#8221;. This blog uses the term &#8220;relocatability&#8221; but does not depend on the technical specifications of <a href="https://wg21.link/p1144">P1144</a>.</p>
<p>While the size and alignment could be described with <code>std::size_t</code>, the constraint level of copyability, relocatability and destructibility are described with enum <code>pro::constraint_level</code>, which includes <code>none</code>, <code>nontrivial</code>, <code>nothrow</code> and <code>trivial</code>, matching the standard wording. The defaults are listed below:</p>
<table>
<thead>
<tr>
<th><strong>Constraints</strong></th>
<th><strong>Defaults</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Maximum size</td>
<td>The size of two pointers</td>
</tr>
<tr>
<td>Maximum alignment</td>
<td>The alignment of a pointer</td>
</tr>
<tr>
<td>Minimum copyability</td>
<td>None</td>
</tr>
<tr>
<td>Minimum relocatability</td>
<td>Nothrow</td>
</tr>
<tr>
<td>Minimum destructibility</td>
<td>Nothrow</td>
</tr>
</tbody>
</table>
<p>We can assume the default maximum size and maximum alignment greater than or equal to the implementation of raw pointers, <code>std::unique_ptr</code> with default deleters, <code>std::unique_ptr</code> with any one-pointer-size of deleters and <code>std::shared_ptr</code> of any type.</p>
<p>Note that the default minimum copyability is &#8220;None&#8221;, which means <code>proxy</code> could be instantiated from a non-copyable type like <code>std::unique_ptr</code>. However, if we never want to instantiate a <code>proxy</code> with non-copyable types (including <code>std::unique_ptr</code>) and want the <code>proxy</code> to be copyable, it is allowed to customize it in a facade definition:</p>
<pre><code class="language-cpp">// Abstraction
struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  static constexpr auto minimum_copyability = pro::constraint_level::nontrivial;
};

// Client
pro::proxy&lt;MyFacade&gt; p0 = /* Omitted */;
auto p1 = p0;  // Calls the constructor of the underlying pointer type</code></pre>
<p>In some cases where we clearly know we always instantiate a <code>proxy</code> with a raw pointer, and want to optimize the performance to the limit, it is allowed to add even more constraints in a facade definition, at the cost of reducing the scope of feasible pointer types:</p>
<pre><code class="language-cpp">// Abstraction
struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  static constexpr auto minimum_copyability = pro::constraint_level::trivial;
  static constexpr auto minimum_relocatability = pro::constraint_level::trivial;
  static constexpr auto minimum_destructibility = pro::constraint_level::trivial;
  static constexpr auto maximum_size = sizeof(void*);
  static constexpr auto maximum_alignment = alignof(void*);
};

// Client
static_assert(std::is_trivially_copy_constructible_v&lt;pro::proxy&lt;MyFacade&gt;&gt;);
static_assert(std::is_trivially_destructible_v&lt;pro::proxy&lt;MyFacade&gt;&gt;);</code></pre>
<p><strong>IMPORTANT NOTICE</strong>: clang will fail to compile if the <strong>minimum_destructibility</strong> is set to <strong>constraint_level::trivial</strong> in a facade definition. The root cause of this failure is that the implementation requires the language feature defined in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0848r3.html">P0848R3: Conditionally Trivial Special Member Functions</a>, but it has not been implemented in clang, according to its <a href="https://clang.llvm.org/cxx_status.html">documentation</a>, at the time this blog was written.</p>
<h3 id="highlight-8-diagnostics">Highlight 8: Diagnostics</h3>
<p>The design of <code>proxy</code> is SFINAE-friendly, thanks to the Concepts feature since C++20. If it is used incorrectly, compile error messages could be generated accurately at the spot. For example, if we call the constructor of <code>proxy</code> with a pointer, whose type does not meet the facade definition:</p>
<pre><code class="language-cpp">pro::proxy&lt;MyFacade&gt; p;
p.invoke&lt;nullptr_t&gt;();  // nullptr_t is not a valid dispatch type</code></pre>
<p>Here is the error message gcc 11.2 will report:</p>
<pre><code class="language-text">&lt;source&gt;:550:22: error: no matching function for call to 'pro::proxy&lt;MyFacade&gt;::invoke&lt;nullptr_t&gt;()'
  550 |   p.invoke&lt;nullptr_t&gt;();
      |   ~~~~~~~~~~~~~~~~~~~^~
&lt;source&gt;:445:18: note: candidate: 'template&lt;class D, class ... Args&gt; decltype(auto) pro::proxy&lt;F&gt;::invoke(Args&amp;&amp; ...) requires (pro::details::dependent_traits&lt;pro::details::facade_traits&lt;F&gt;, D&gt;::dependent_t&lt;pro::details::facade_traits&lt;F&gt;, D&gt;::applicable) &amp;&amp; (pro::details::BasicTraits::has_dispatch&lt;D&gt;) &amp;&amp; (is_convertible_v&lt;std::tuple&lt;_Args2 ...&gt;, typename D::argument_types&gt;) [with D = D; Args = {Args ...}; F = MyFacade]'
  445 |   decltype(auto) invoke(Args&amp;&amp;... args)
      |                  ^~~~~~
&lt;source&gt;:445:18: note:   template argument deduction/substitution failed:
&lt;source&gt;:445:18: note: constraints not satisfied</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>We hope this has helped clarify how to take advantage of the library &#8220;proxy&#8221; to write polymorphic code easier. If you have any questions, comments, or issues with the library, you can comment below, file issues in <a href="https://github.com/microsoft/proxy">our GitHub repo</a>, or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/">proxy: Runtime Polymorphism Made Easier Than Ever</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Official Support for Arm64EC is Here </title>
		<link>https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/</link>
					<comments>https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/#respond</comments>
		
		<dc:creator><![CDATA[Pranav Srinivasan]]></dc:creator>
		<pubDate>Tue, 09 Aug 2022 15:00:54 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30839</guid>

					<description><![CDATA[<p>Last year, Microsoft announced x64 compatibility for Windows 11 on Arm, along with the new Arm64EC ABI, a new way to bring apps to Windows on Arm. With Arm64EC you can mix Arm and x64 code in the same process, allowing you to port existing x64 apps to Arm in an incremental way.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/">Official Support for Arm64EC is Here </a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW73064057 BCX8">Last year, Microsoft announced x64 </span><span class="NormalTextRun SCXW73064057 BCX8">compatibility</span><span class="NormalTextRun SCXW73064057 BCX8"> for Windows </span><span class="NormalTextRun SCXW73064057 BCX8">11</span><span class="NormalTextRun SCXW73064057 BCX8"> on Arm, along with the new </span></span><a class="Hyperlink SCXW73064057 BCX8" href="https://aka.ms/arm64ecannounceblog" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW73064057 BCX8" data-ccp-charstyle="Hyperlink">Arm64EC ABI</span></span></a><span class="TextRun SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW73064057 BCX8">, a new way to </span><span class="NormalTextRun SCXW73064057 BCX8">bring apps to Windows on Arm</span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW73064057 BCX8">. </span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW73064057 BCX8">With</span><span class="NormalTextRun SCXW73064057 BCX8"> Arm64EC you can mix Arm and x64 code in the same process</span><span class="NormalTextRun SCXW73064057 BCX8">, allowing you to </span><span class="NormalTextRun SCXW73064057 BCX8">port </span><span class="NormalTextRun SCXW73064057 BCX8">existing </span><span class="NormalTextRun SCXW73064057 BCX8">x64 </span><span class="NormalTextRun SCXW73064057 BCX8">apps </span><span class="NormalTextRun SCXW73064057 BCX8">to </span><span class="NormalTextRun CommentStart CommentHighlightPipeRest CommentHighlightRest SCXW73064057 BCX8">A</span><span class="NormalTextRun CommentHighlightRest SCXW73064057 BCX8">rm</span> <span class="NormalTextRun CommentHighlightPipeRest SCXW73064057 BCX8">in an incremental </span><span class="NormalTextRun SCXW73064057 BCX8">way</span><span class="NormalTextRun SCXW73064057 BCX8">.</span> <span class="NormalTextRun SCXW73064057 BCX8">We also announced experimental support for </span></span><a class="Hyperlink SCXW73064057 BCX8" href="https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW73064057 BCX8" data-ccp-charstyle="Hyperlink">Arm64EC development in Visual Studio</span></span></a><span class="TextRun SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW73064057 BCX8">.</span></span><span class="EOP SCXW73064057 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Now, after a year of bug fixes and product stabilization, we are here to announce that this toolset is leaving experimental mode in the 17.3 release, making it possible to build fully-supported Arm64EC applications for Windows 11 on Arm. We hope that using Arm64EC makes it easier for developers to target Windows on Arm, especially for applications that are blocked today from moving to Arm due to x64 plugins or dependencies.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="learn-more-about-arm64ec"><span data-contrast="none">Learn More about Arm64EC</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">Want to learn more about Arm64EC to determine if it is the best solution for your porting efforts? We have several resources detailing how Arm64EC works and how to use it, compiled here for your convenience.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ol>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">For getting started on building Arm64EC applications, check out this </span><a href="https://aka.ms/arm64ecgettingstarted"><span data-contrast="none">documentation</span></a><span data-contrast="auto"> on how to get the tools you’ll need.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">To see an end-to-end example of using x64 plugins for digital audio workstations, check out this post: </span><a href="https://devblogs.microsoft.com/windows-music-dev/load-x64-plug-ins-like-vsts-from-your-arm-code-using-arm64ec"><span data-contrast="none">Load x64 Plug-ins (like VSTs) from your Arm Code using Arm64EC</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">You can also build binaries that can be used by both Arm64 and Arm64EC/x64 processes on Windows on Arm devices. To learn more about this binary format and how to build them, check out this </span><a href="https://aka.ms/arm64xbinaryintro"><span data-contrast="none">documentation on Arm64X binaries</span></a><span data-contrast="auto">. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">For a more in-depth understanding of Arm64EC as an ABI and how the interoperability with emulated x64 works, check out the documentation on </span><a href="https://docs.microsoft.com/windows/arm/arm64ec-abi"><span data-contrast="none">Arm64EC assembly</span></a><span data-contrast="auto"> and the </span><a href="https://docs.microsoft.com/cpp/build/arm64ec-windows-abi-conventions"><span data-contrast="none">ABI</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ol>
<h1 aria-level="1" aria-level="1" id="whats-next"><span data-contrast="none">What’s Next?</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We are planning continued support for the toolchain in upcoming releases, with the intent of supporting the <code>__vectorcall</code> calling convention in Arm6EC as well as tackling performance optimizations. If you want to get in contact with us regarding issues with the toolchain or any feedback about its usage, we’re always listening on Developer Community.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/">Official Support for Arm64EC is Here </a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC Backend Updates in Visual Studio 2022 version 17.3</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/#respond</comments>
		
		<dc:creator><![CDATA[Chris Pulido]]></dc:creator>
		<pubDate>Tue, 09 Aug 2022 15:00:49 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[OpenMP]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30829</guid>

					<description><![CDATA[<p>In Visual Studio 2022 version 17.3 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a list of improvements for you to review.</p>
<p>Native Arm64 Visual Studio is now available for 17.3!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/">MSVC Backend Updates in Visual Studio 2022 version 17.3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In <a href="https://visualstudio.microsoft.com/vs/">Visual Studio 2022</a> version 17.3 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a list of improvements for you to review.</p>
<ul>
<li>Native Arm64 Visual Studio is now available for 17.3! See the <a href="https://devblogs.microsoft.com/visualstudio/arm64-visual-studio/">Visual Studio blog post</a> for details on how to install Arm64 Visual Studio, and what workloads are available for 17.3.</li>
<li>The C++ ARM64EC target is available for production development. To learn more about the ARM64EC ABI, see <a href="https://docs.microsoft.com/en-us/cpp/build/arm64ec-windows-abi-conventions?view=msvc-170">Overview of ARM64EC ABI conventions</a>, and <a href="https://docs.microsoft.com/en-us/windows/arm/arm64ec-abi">Understanding Arm64EC ABI and assembly code</a>. To learn more about using ARM64EC in Visual Studio, see <a href="https://docs.microsoft.com/en-us/windows/arm/arm64ec">Using Arm64EC to build apps for Windows 11 on Arm devices</a>.</li>
<li>The ARM64EC toolchain now emits an error when vectorcall semantics, <code>__m256</code> types or <code>__m512</code> types are used when compiling for ARM64EC as these are unsupported scenarios. Full vectorcall support is planned for a future release.</li>
<li>More progress has been made towards implementing OpenMP Standard 3.1 under the experimental <code>-openmp:llvm</code> switch, building on the <a href="https://devblogs.microsoft.com/cppblog/openmp-task-support-for-c-in-visual-studio/">previous release</a>:
<ul>
<li>Implemented atomics-related features from OpenMP 3.1.</li>
<li>Enabled use of pointers as induction variables in OpenMP loops.</li>
</ul>
</li>
<li>[Credit to our friends at AMD] Improved Superword-Level Parallelism (SLP) vectorizer, handling more types and vector widths. More details to come in a future blog post. Add the <code>/Qvec-report:1</code> switch and look for <code>info C5003: block vectorized</code> for more SLP vectorization.</li>
<li>Support for recognizing and building ARM64 NEON vector fused multiply-add (FMA) instructions after loop vectorization. Floating-point vector FMA instructions are only built under <code>/fp:fast</code>, or <code>/fp:contract</code> if <code>/fp:precise</code> is also specified. More details about <code>/fp</code> can be found in <a href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS 2022</a>, and the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fp-specify-floating-point-behavior?view=msvc-170">MSVC compiler options reference for /fp</a>.</li>
<li>More peephole optimizations. Here are some cases that were improved:
<ul>
<li><a href="https://developercommunity.visualstudio.com/t/Release-build-of-SSE-code-is-inserting-u/1536674">Release build of SSE code is inserting unnecessary shufps</a></li>
<li><a href="https://developercommunity2.visualstudio.com/t/string-view:-suboptimal-forwarding-of-va/1306660">string-view: suboptimal forwarding of values through vector registers</a></li>
<li><a href="https://developercommunity.visualstudio.com/t/Suspicious-codegen-for-assignment-of-ret/1695810">Suspicious codegen for assignment of return value with __vectorcall and /arch:AVX</a></li>
</ul>
</li>
</ul>
<p>Do you want to experience the new improvements of the C++ backend? Please <a href="https://visualstudio.microsoft.com/vs/">download the latest Visual Studio 2022</a> and give it a try! Any feedback is welcome. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc">@VisualC</a>)</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/">MSVC Backend Updates in Visual Studio 2022 version 17.3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSBuild Low Priority Builds in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/#respond</comments>
		
		<dc:creator><![CDATA[Felix Huang]]></dc:creator>
		<pubDate>Wed, 27 Jul 2022 15:00:07 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30732</guid>

					<description><![CDATA[<p>The C++ team is happy to announce the completion of a highly upvoted C++ feedback ticket from Developer Community – Low Priority Builds. With your feedback and collaboration from our partner teams, you can now start Low Priority Builds within Visual Studio.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/">MSBuild Low Priority Builds in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ team is happy to announce the completion of a highly upvoted <a href="https://developercommunity.visualstudio.com/t/Limit-CPU-usage-of-Visual-Studio-during/436208">C++ feedback ticket</a> from Developer Community – Low Priority Builds. With your feedback and collaboration from our partner teams, you can now start Low Priority Builds within Visual Studio. This will ensure the MSBuild node spawns with a lower priority, affecting all compile and link processes. If the build is affecting you from having a responsive work environment, then this is the feature for you! </p>
<p>Internally, VS interfaces with MSBuild like a service. The <a href="https://github.com/dotnet/msbuild">MSBuild team</a> has added new API functionality to switch the priority of the MSBuild nodes. Starting in Visual Studio 2022 version 17.3 Preview 1, a new option under the Tools -&gt; Options -&gt; &#8220;Projects and Solutions&#8221; -&gt; &#8220;Build And Run&#8221; -&gt; &#8220;Run build at low process priority&#8221; allows you to lower the priority of the your next builds. If a MSBuild node is already running with the previous priority, then give them a few minutes to time out or restart the IDE to close them.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS.png"><img class="size-medium wp-image-30740 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS-300x96.png" alt="Image lowpriSS" width="300" height="96" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS-300x96.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS-768x247.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS.png 989w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>For building directly on the command line, use msbuild.exe -lowPriority or -low for similar effect.<img class="size-medium wp-image-30748 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_cl-300x118.png" alt="Image lowpri taskman cl" width="300" height="118" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_cl-300x118.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_cl.png 714w" sizes="(max-width: 300px) 100vw, 300px" /></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild.png"><img class="size-medium wp-image-30749 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild-300x95.png" alt="Image lowpri taskman msbuild" width="300" height="95" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild-300x95.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild.png 719w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>Try out low-priority MSBuild tasks by downloading the latest <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2022 Preview</a>! Any feedback is welcome. We can be reached via the comments below, Developer Community, reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>, and Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>For other build performance tips and tools: <br /><a href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/</a> </p>
<p>Thank you, </p>
<p>Felix Huang,<br />VC++</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/">MSBuild Low Priority Builds in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg July 2022 Release is Now Available: Shared Libraries on Linux, Improved vcpkg new, Optional name and version Fields, and More…</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Mon, 25 Jul 2022 18:23:53 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30808</guid>

					<description><![CDATA[<p>The July 2022 release of the vcpkg package manager is available. This blog post summarizes changes from June 16th, 2022 to July 24th, 2022 for the microsoft/vcpkg and microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>15 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/">vcpkg July 2022 Release is Now Available: Shared Libraries on Linux, Improved vcpkg new, Optional name and version Fields, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.07.25">July 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from June 16<sup>th</sup>, 2022 to July 24<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>15 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>360 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,967 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are <strong>10,106 port versions</strong>.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.07.25">July release of the main vcpkg repo</a> includes <strong>278 commits</strong>.</li>
<li><strong>90 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.7k forks</strong> and <strong>16.3k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<h4 id="better-support-for-shared-libraries-on-linux">Better support for shared libraries on Linux</h4>
<p>This update includes a community triplet for installing shared libraries on Linux: x64-linux-dynamic. This was made possible by adding rpath support to make ports relocatable. After building a port, the binaries are patched to have correct rpath values relative to lib/ (or debug/lib/). This update is significant because it makes it much easier to handle shared libraries on Linux, meaning users don’t have to install libraries statically on Linux to get the best user experience.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/23035">Microsoft/vcpkg#23035</a> (thank you @<a href="https://github.com/Osyotr">Osyotr</a>!)</p>
<p>&nbsp;</p>
<h4 id="vcpkg-new-now-generates-both-port-and-artifact-manifest-files">‘vcpkg new’ now generates both port and artifact manifest files</h4>
<p>As part of the vcpkg artifacts experience, a new command called new was added that can generate a vcpkg-configuration.json file. The file is a manifest for artifacts that vcpkg can install for a project. In this update, the implementation was re-written in C++ and the command now also generates a vcpkg.json file for declaring ports for a project. It also fills in the default registry with the current baseline git SHA. Going forward, vcpkg new will be useful for configuring a project for use with vcpkg, whether it requires ports or artifacts.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/613">Microsoft/vcpkg-tool#613</a></p>
<p>&nbsp;</p>
<h4 id="name-and-version-fields-are-no-longer-required-in-vcpkg-json-files">name and version fields are no longer required in vcpkg.json files</h4>
<p>We sometimes get asked by users why vcpkg.json files require a name and a version field to be filled in. This is a consequence of the same file being used both for authoring ports and for consuming them in an application. These fields are required metadata for ports so they can be organized and referenced appropriately by end users. However, it is clear that these fields don’t serve much purpose if you are only using vcpkg to acquire other dependencies and aren’t producing your own vcpkg ports.</p>
<p>As a result, we have made these fields optional in vcpkg.json. This is also consistent with how vcpkg-configuration.json is structured for artifacts. However, there are implications when generating manifests using vcpkg new – this command should be called with either a pair of &#8211;name and &#8211;version properties or with &#8211;application, which designates the manifest as one that won’t need these fields.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/605">Microsoft/vcpkg-tool#605</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-find-artifact-can-be-filtered-by-registry">vcpkg find artifact can be filtered by registry</h4>
<p>It is now possible to search for artifacts under a specific registry by running</p>
<p><code>vcpkg find artifact:&lt;registry name&gt;</code></p>
<p>Example:</p>
<p><img width="1439" height="221" class="wp-image-30810" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated.png" alt="Text Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated.png 1439w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated-300x46.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated-1024x157.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated-768x118.png 768w" sizes="(max-width: 1439px) 100vw, 1439px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/608">Microsoft/vcpkg-tool#608</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-init-ps1-installer-now-works-with-powershell-on-linux">vcpkg-init.ps1 installer now works with PowerShell on Linux</h4>
<p>When we announced the vcpkg artifacts experience, there were two ways to install vcpkg with this support. On Linux/macOS, we provided a bash script, and on Windows, a PowerShell script. In this release of vcpkg, the PowerShell installer script now also works on macOS and Linux, so you can freely use it in these environments. For updated instructions on how to install, use, or remove vcpkg using one of these scripts, see: <a href="https://github.com/microsoft/vcpkg-tool#installuseremove">microsoft/vcpkg-tool: Components of microsoft/vcpkg &#8216;s binary. (github.com)</a></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/611">Microsoft/vcpkg-tool#611</a></p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation changes</h4>
<p>The following documentation changes were made this release:</p>
<ul>
<li>Added documentation for remove command.</li>
<li>Added documentation for x-update-baseline command, used to update version baselines for configured registries.</li>
<li>Revised documentation for vcpkg_cmake_configure, a port helper function.</li>
<li>Revised documentation for vcpkg_extract_source_archive, a port helper function:
<ul>
<li>Don’t list deprecated overload first</li>
<li>Documents REF</li>
<li>Document each option in a list for improved discoverability, instead of a large block</li>
<li>Replace static list of ports with a GitHub query that will find uses in all ports</li>
</ul>
</li>
</ul>
<p>PRs: <a href="https://github.com/microsoft/vcpkg/pull/25264">Microsoft/vcpkg#25264</a>, <a href="https://github.com/microsoft/vcpkg/pull/25256">Microsoft/vcpkg#25256</a>, <a href="https://github.com/microsoft/vcpkg/pull/25255">Microsoft/vcpkg#25255</a>, <a href="https://github.com/microsoft/vcpkg/pull/25178">Microsoft/vcpkg#25178</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,772</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,820</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,719</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,733</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>936</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,362</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>887</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,688</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,754</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is routinely tested to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>dg0yt (22 commits)</li>
<li>autoantwort (22 commits)</li>
<li>Osyotr (12 commits)</li>
<li>Thomas1664 (10 commits)</li>
<li>Neumann-A (4 commits)</li>
<li>coryan (3 commits)</li>
<li>AenBleidd (3 commits)</li>
<li>ekilmer (2 commits)</li>
<li>m-kuhn (2 commits)</li>
<li>eao197 (2 commits)</li>
<li>myd7349 (2 commits)</li>
<li>RT222 (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>cenit (1 commit)</li>
<li>Be-ing (1 commit)</li>
<li>bsiegert (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.07.25">full July release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/">vcpkg July 2022 Release is Now Available: Shared Libraries on Linux, Improved vcpkg new, Optional name and version Fields, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>New std::optional Checks in Visual Studio 2022 version 17.3 Preview 3</title>
		<link>https://devblogs.microsoft.com/cppblog/new-stdoptional-checks-in-visual-studio-2022-version-17-3-preview-3/</link>
					<comments>https://devblogs.microsoft.com/cppblog/new-stdoptional-checks-in-visual-studio-2022-version-17-3-preview-3/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Thu, 14 Jul 2022 19:35:58 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30706</guid>

					<description><![CDATA[<p>New std::optional Checks in Visual Studio 2022</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-stdoptional-checks-in-visual-studio-2022-version-17-3-preview-3/">New std::optional Checks in Visual Studio 2022 version 17.3 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/search?space=62">C++ Developer Community</a> page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the detailed overview of some new experimental code analysis checks that can detect unwrapping of empty <code>std::optional</code>s. The experimental checks can be enabled by using the <code>CppCoreCheckExperimentalRules</code> ruleset. Note that the experimental checks are not part of the <code>Microsoft All Rules</code> ruleset. While these checks are marked experimental, they look promising in our internal, preliminary testing. Unless we get reports about crashes or excessive number of false positives, we plan to move these checks to the <code>NativeRecommendedRules</code> ruleset (which is the default ruleset) in the next release.</p>
<h2 id="overview">Overview</h2>
<p><code>std::optional</code> <a href="https://en.cppreference.com/w/cpp/utility/optional">was introduced in C++17</a> to represent a value that may or may not be present. It is often used as the return type for a function that may fail.
We introduced two new checks, <code>C26829</code> and <code>C26830</code>, to find unwrap operations of empty <code>std::optional</code>s. Unwrapping an empty optional is undefined behavior. It can result in a crash, or worse, reading uninitialized memory
depending on the implementation. In some cases, the latter is a vulnerability that an adversarial actor could exploit. The <a href="https://developercommunity.visualstudio.com/t/Detect-unguarded-dereferences-of-std::op/1430703">C++ Developer Community ask</a> was one of the top voted feature requests for the static analysis team as dereferencing empty optionals has been a major source of real errors in many C++ projects.</p>
<h2 id="modeling-optionals">Modeling optionals</h2>
<p>In order to warn when (potentially) empty optionals are unwrapped, the analyzer needs to precisely model the semantics of <code>std::optional</code>.</p>
<h3 id="basic-assumptions">Basic assumptions</h3>
<p>Usually, the use of <code>std::optional</code>s is a stronger signal about the presence of values compared to pointer types. Let us look at the following code snippet:</p>
<pre><code class="language-cpp">void f(int* p);
void g(std::optional&lt;int&gt;&amp; p);</code></pre>
<p>In many codebases, we cannot know whether <code>nullptr</code> is a valid argument to function <code>f</code>. The function might have a precondition that it does not accept null pointers and the codebase might never pass a null value to <code>f</code>. A warning for null pointer dereference in the body of function <code>f</code> would be considered false positives by some developers.
Usually, marking such pointers with <code>gsl::not_null</code> (<code>void f(gsl::not_null&lt;int*&gt; p);</code>) or replacing them with references (<code>void f(int&amp; p);</code>) can make the code clearer.</p>
<p>In case of function <code>g</code>, however, the use of <code>std::optional</code> makes it explicit that it handles the lack of values gracefully. Therefore, while we tend to not warn on pointer parameters that don&#8217;t have null checks, we will warn on unwrapping <code>std::optional</code>s that might be empty.
Unfortunately, there are some rare cases where this assumption would not hold. Let us look at the code snippet below:</p>
<pre><code class="language-cpp">std::optional&lt;int&gt; lookup(std::string_view key) {
    const static std::map myMap{std::pair{"Foo"sv, 1}, std::pair{"Bar"sv, 2}};
    auto it = myMap.find(key);
    return it == myMap.end() ? std::nullopt : std::optional{it-&gt;second};
}</code></pre>
<p>While the function <code>lookup</code> might fail in the general case, a particular invocation of the function might have an argument that guarantees success (e.g., it might be <code>lookup("Foo")</code>). This guarantee is an invariant of the program that we currently cannot express using <a href="https://docs.microsoft.com/cpp/c-runtime-library/sal-annotations">SAL annotations</a> and cannot infer using function-local reasoning. The experimental versions of these checks might emit false positive warnings in those cases. We are actively looking into ways to mitigate this problem. Some of the options are improving existing annotations to be able to communicate this invariant, or believe certain assertions. Until we settle on a solution, it is always possible to either suppress these warnings or to check that the optional has a value before unwrapping it make the warning disappear.</p>
<p>Our modeling also assumes that whenever an optional is passed to a function by non-const reference, the called function might reset the optional. This assumption helps us catch more problems at the cost of more false positives.
As we gain more real-world experience with these checks we might revisit some of these assumptions/decisions in the future.</p>
<h3 id="basic-operations">Basic operations</h3>
<p>This section describes the details of the modeling using a notation borrowed from our automatic regression tests. This notation helps us document our expectations regarding the semantics of the analyzed program and check whether the analyzer&#8217;s understanding matches our intuition.
Program points that should be deduced as reachable are annotated with <code>__espx_expect_reached()</code>. On the other hand, program points that should be deduced as unreachable are annotated with <code>__espx_expect_unreached()</code>.
Looking at the reachability of certain program points can help us understand how the analysis engine reasoned about the values in the program. We can also query some values directly using annotations like <code>__espx_expect_always_true(cond)</code>. Our analysis tool will evaluate the expression <code>cond</code> and will report a failure when it cannot prove that the value always evaluates to true.</p>
<p>Our analysis engine understands that the default constructor of <code>std::optional</code> will create an empty optional. Moreover, it understands the basic ways to check if an optional is empty:</p>
<pre><code class="language-cpp">void default_ctor_creates_empty()
{
    std::optional&lt;int&gt; opt;
    if (opt)
        __espx_expect_unreached();
    else
        __espx_expect_reached();

    if (opt.has_value())
        __espx_expect_unreached();
    else
        __espx_expect_reached();

    int x = opt.value_or(5);
    __espx_expect_always_true(x == 5);
}</code></pre>
<p>The test case above shows that the engine can discover that <code>opt</code> evaluates to false, so the true branch of the first if statement is never reached, and the false branch is always reached. The engine also understands that the <code>value_or</code> will return its argument when it is invoked on an empty optional. Conversely, it also understands that <code>value_or</code> will return the internal value of an optional when it had a value:</p>
<pre><code class="language-cpp">void value_ctor_creates_non_empty()
{
    std::optional&lt;int&gt; opt{2};
    __espx_expect_always_true((bool)opt);

    int x = opt.value_or(5);
    __espx_expect_always_true(x == 2);
}</code></pre>
<p>Our analyzer also understand value types. It knows that the copy of an optional has a value if and only if the copied optional also had a value. Moreover, the contained value is the copy of the original:</p>
<pre><code class="language-cpp">void copied_non_empty_optional_is_not_empty()
{
    std::optional&lt;int&gt; opt{2};
    auto opt2 = opt;
    __espx_expect_always_true((bool)opt);
    __espx_expect_always_true((bool)opt2);

    __espx_expect_always_true(opt.value() == opt2.value());
}</code></pre>
<p>The analyzer also understands that the value inside an optional is always at the same address and two different optional objects are living at different addresses:</p>
<pre><code class="language-cpp">void accessor_produces_stable_addresses()
{
    std::optional&lt;int&gt; opt{2};
    __espx_expect_always_true(&amp;opt.value() == &amp;opt.value());
    int* ptr = &amp;opt.value();
    opt = std::optional&lt;int&gt;{2};
    __espx_expect_always_true(&amp;opt.value() == ptr);
    std::optional&lt;int&gt; opt2{opt};
    __espx_expect_always_true(&amp;opt.value() != &amp;opt2.value());
}</code></pre>
<p>Surprisingly, a moved-from optional that used to have a valid value is not empty. It holds the moved-from value:</p>
<pre><code class="language-cpp">void moved_from_optional_is_not_empty()
{
    std::optional&lt;int&gt; opt{2};
    auto opt2 = std::move(opt);
    __espx_expect_always_true((bool)opt);
    __espx_expect_always_true(*opt2 == 2);
}</code></pre>
<p>This might be a potential source of confusion. While we currently will not warn for using the moved-from object in the original optional, we are looking into how can we teach our existing <a href="https://devblogs.microsoft.com/cppblog/new-code-analysis-checks-in-visual-studio-2019-use-after-move-and-coroutine/">use-after-move check</a> to find such errors by piggy-backing on the engine&#8217;s understanding of <code>std::optional</code>.</p>
<h3 id="symbolic-reasoning">Symbolic reasoning</h3>
<p>Our analysis engine is using symbolic reasoning to model the emptiness of optionals. Whenever the engine learns new facts about these symbols, this knowledge automatically and retroactively applied to the state of the objects. Consider the following example:</p>
<pre><code class="language-cpp">void constraints_correctly_applied(std::optional&lt;int&gt; optVal)
{
    bool b = (bool)optVal;                         // Program point: A.
    if (b)                                         // Program point: B.
    {
       __espx_expect_always_true((bool)optVal);    // Program point: C.
    }
}</code></pre>
<p>In the code snippet above, we have no information about the emptiness of <code>optVal</code> at program point <code>A</code>. However, the analyzer knows that the value of the variable <code>b</code> is inherently entangled to the emptiness of <code>optVal</code>. We branch on <code>b</code> at program point <code>B</code>. In the true branch, we know that the value of <code>b</code> is true. As a result, we also learned that <code>optVal</code> is not empty. As a result, <code>(bool)optVal</code> will evaluate to true at program point <code>C</code>. To summarize, we might learn new facts about the state of <code>optVal</code> from expressions that will not even refer to <code>optVal</code> syntactically. This is the power of symbolic reasoning.</p>
<h3 id="modeling-exceptions">Modeling exceptions</h3>
<p>The analyzer understands whether accessor methods like <code>std::optional::value</code> will or will not throw an exception based on the known state of the object. It can use this information to help the analysis skip certain execution paths that cannot happen at runtime. This helps reducing the number of false positives and improve the performance of the analysis. The code snippet below demonstrates the behavior of the analysis.</p>
<pre><code class="language-cpp">void exception_modeling(std::optional&lt;int&gt; unknown)
{
    std::optional&lt;int&gt; nonEmpty{2};
    std::optional&lt;int&gt; empty{};

    try
    {
        unknown.value();
        __espx_expect_reached();
    }
    catch(...)
    {
        __espx_expect_reached();
    }

    try
    {
        nonEmpty.value();
        __espx_expect_reached();
    }
    catch(...)
    {
        __espx_expect_unreached();
    }

    try
    {
        empty.value();
        __espx_expect_unreached();
    }
    catch(...)
    {
        __espx_expect_reached();
    }
}</code></pre>
<h3 id="other-considerations">Other considerations</h3>
<p>Our analysis engine also understands nested optionals. There are many more modeled methods that we did not mention explicitly, including <code>swap</code>. Unfortunately, the current version of our modeling will not precisely model the semantics of free functions operating on <code>std::optional</code>s, like <code>std::swap</code> or the comparison operators. We have partial modeling in place for <code>std::make_optional</code> and <code>std::in_place</code> constructors. We plan to make the modeling more comprehensive in the future, but we feel like the current modeling should be sufficient to find most errors.</p>
<h2 id="emitting-warnings">Emitting warnings</h2>
<p>The analyzer will emit <code>C26829</code> when an empty optional is unwrapped. On the other hand, it will emit <code>C26830</code> when a <strong>potentially</strong> empty optional is unwrapped. The emitted warnings will also include a path that describes the execution that could trigger the problem. In the future, we plan to include key events in the emitted diagnostics that will highlight parts of the code that are important to understand the warning. The highlighted snippets might include the program points where the emptiness of the optional was checked and calls where the emptiness of the optional might have been changed.</p>
<pre><code class="language-cpp">void unwrap_empty()
{
  std::optional&lt;int&gt; o;
  *o = 5; // C26829 emitted
}

void unwrap_maybe_empty(std::optional&lt;int&gt; o)
{
  *o = 5; // C26830 emitted
}</code></pre>
<p>In function <code>unwrap_empty</code> above, we will see a <code>C26829</code>. In this case the analyzer is confident that the optional was empty. This usually happens when we forget to initialize an optional or accidentally write a negated condition.
In function <code>unwrap_maybe_empty</code>, however, we will see a <code>C26830</code>. In this case the engine is not sure whether the optional is empty, and the unwrap operation is not guarded.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The upcoming Visual Studio 2022 17.3 Preview 3 will feature new checks to find hard-to-find misuses of <code>std::optional</code>s. These are experimental checks that need to be enabled explicitly by using the <code>CppCoreCheckExperimentalRules</code> ruleset or adding <code>C26829</code> and <code>C26830</code> to your custom ruleset. <code>C26829</code> is a high-confidence warning that should have very few false positives. <code>C26830</code> is a medium confidence check that should not be too noisy for most projects.
Depending on the bugs reported and our experience with these checks in the coming weeks, either <code>C26829</code> only or both of these warnings might be turned on by default in 17.4.</p>
<h2 id="try-it-out-and-let-us-know-what-you-think">Try it out and let us know what you think:</h2>
<p>The work that we do is heavily influenced by feedback we receive on the <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Checks. Stay tuned for more C++ static analysis blogs. In the meanwhile, we would love to learn more about your experience with our static analysis tools. Comment below, or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-stdoptional-checks-in-visual-studio-2022-version-17-3-preview-3/">New std::optional Checks in Visual Studio 2022 version 17.3 Preview 3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/new-stdoptional-checks-in-visual-studio-2022-version-17-3-preview-3/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Integrated Terminal in Visual Studio: New SSH integration for Linux targeting</title>
		<link>https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/</link>
					<comments>https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/#comments</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 12 Jul 2022 18:07:10 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30770</guid>

					<description><![CDATA[<p>In the latest version of Visual Studio, users are now able to leverage the integrated terminal to access their remote targets when developing for remote machines from Windows. This updated terminal includes an interactive SSH shell. It can be accessed by going to View-&#62;Terminal in Visual Studio. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/">Integrated Terminal in Visual Studio: New SSH integration for Linux targeting</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW224106047 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW224106047 BCX8">In the </span></span><a class="Hyperlink SCXW224106047 BCX8" href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW224106047 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW224106047 BCX8" data-ccp-charstyle="Hyperlink">latest version of Visual Studio</span></span></a><span class="TextRun SCXW224106047 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW224106047 BCX8">, users are </span><span class="NormalTextRun SCXW224106047 BCX8">now </span><span class="NormalTextRun SCXW224106047 BCX8">able</span><span class="NormalTextRun SCXW224106047 BCX8"> to </span><span class="NormalTextRun SCXW224106047 BCX8">leve</span><span class="NormalTextRun SCXW224106047 BCX8">rage</span><span class="NormalTextRun SCXW224106047 BCX8"> the integrated terminal to access their remote targets</span><span class="NormalTextRun SCXW224106047 BCX8"> when developing for </span><span class="NormalTextRun SCXW224106047 BCX8">remote machines from Windows</span><span class="NormalTextRun SCXW224106047 BCX8">. This </span><span class="NormalTextRun SCXW224106047 BCX8">updated terminal</span><span class="NormalTextRun SCXW224106047 BCX8"> includes an interactive SSH shell.</span> <span class="NormalTextRun SCXW224106047 BCX8">I</span><span class="NormalTextRun SCXW224106047 BCX8">t</span><span class="NormalTextRun SCXW224106047 BCX8"> can be accessed by going to View-&gt;Terminal in Visual Studio</span><span class="NormalTextRun CommentStart SCXW224106047 BCX8">.</span></span><span class="EOP SCXW224106047 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950.png"><img class="alignnone size-full wp-image-30775" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950.png" alt="New SSH Integrated Terminal in Visual Studio" width="1023" height="574" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950.png 1023w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950-300x168.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950-768x431.png 768w" sizes="(max-width: 1023px) 100vw, 1023px" /></a></p>
<p><span class="TextRun SCXW167861519 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW167861519 BCX8">Now, </span><span class="NormalTextRun CommentStart SCXW167861519 BCX8">instead of </span><span class="NormalTextRun SCXW167861519 BCX8">starting an SSH session inside of </span><span class="NormalTextRun SpellingErrorV2Themed SCXW167861519 BCX8">PowerShell</span><span class="NormalTextRun SCXW167861519 BCX8"> or WSL and </span><span class="NormalTextRun SCXW167861519 BCX8">having to re-authenticate</span><span class="NormalTextRun SCXW167861519 BCX8">,</span><span class="NormalTextRun SCXW167861519 BCX8"> you can select one of your existing connections with one click</span><span class="NormalTextRun SCXW167861519 BCX8">. The </span><span class="NormalTextRun SCXW167861519 BCX8">integrated terminal pulls from the stored connections </span><span class="NormalTextRun SCXW167861519 BCX8">established</span><span class="NormalTextRun SCXW167861519 BCX8"> in your Connection Manager</span><span class="NormalTextRun SCXW167861519 BCX8">. You only </span><span class="NormalTextRun AdvancedProofingIssueV2Themed SCXW167861519 BCX8">have to</span><span class="NormalTextRun SCXW167861519 BCX8"> authenticate once when you add a stored connection</span><span class="NormalTextRun SCXW167861519 BCX8"> and </span><span class="NormalTextRun CommentStart SCXW167861519 BCX8">the</span><span class="NormalTextRun SCXW167861519 BCX8">n this authentication information will remain stored in Visual Studio</span><span class="NormalTextRun SCXW167861519 BCX8">,</span><span class="NormalTextRun SCXW167861519 BCX8"> allowing for</span><span class="NormalTextRun SCXW167861519 BCX8"> less downtime spent managing SSH</span><span class="NormalTextRun SCXW167861519 BCX8"> connections that have timed out</span><span class="NormalTextRun SCXW167861519 BCX8">.</span><span class="NormalTextRun SCXW167861519 BCX8"> </span></span><span class="EOP SCXW167861519 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401.png"><img class="alignnone size-full wp-image-30776" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401.png" alt="Connection Manager in Visual Studio" width="753" height="490" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401.png 753w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401-300x195.png 300w" sizes="(max-width: 753px) 100vw, 753px" /></a></p>
<p><span class="TextRun SCXW3747466 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW3747466 BCX8">In the upper left corner</span><span class="NormalTextRun SCXW3747466 BCX8"> of the integrated terminal</span><span class="NormalTextRun SCXW3747466 BCX8">, </span><span class="NormalTextRun SCXW3747466 BCX8">you can click on the SSH</span><span class="NormalTextRun SCXW3747466 BCX8"> connection selected and see </span><span class="NormalTextRun SCXW3747466 BCX8">the profile </span><span class="NormalTextRun CommentStart SCXW3747466 BCX8">dropdown</span><span class="NormalTextRun SCXW3747466 BCX8"> entrie</span><span class="NormalTextRun SCXW3747466 BCX8">s </span><span class="NormalTextRun SCXW3747466 BCX8">available that show connections </span><span class="NormalTextRun SCXW3747466 BCX8">enumerated</span><span class="NormalTextRun SCXW3747466 BCX8"> from your Connection Manager.</span></span><span class="EOP SCXW3747466 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626.png"><img class="alignnone size-full wp-image-30778" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626.png" alt="SSH dropdown in Integrated Terminal" width="1029" height="562" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626.png 1029w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626-300x164.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626-1024x559.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626-768x419.png 768w" sizes="(max-width: 1029px) 100vw, 1029px" /></a></p>
<p><span data-contrast="auto">When you click on a connection from the dropdown, the terminal will spawn a new terminal instance that will remain docked next to your current terminal instance in the tabs below. </span><span data-ccp-props="{}"> </span></p>
<p><span data-contrast="auto">Additionally, the new integrated terminal now supports manipulating files, running background tasks, configuring your remote system, and testing your deployed code all from inside of VS instead of having to use an external SSH client. This terminal also supports color and command sequences, so for example, copy, paste, and find shortcuts will work, as well as interactive programs like vim.</span><span data-ccp-props="{}"> </span></p>
<h4 id="send-us-your-feedback">Send us your feedback!</h4>
<p><span class="TextRun SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW169529413 BCX8">Download the latest version of Visual Studio and give the latest integrated terminal a try. </span><span class="NormalTextRun CommentStart SCXW169529413 BCX8">Let us know </span><span class="NormalTextRun SCXW169529413 BCX8">your thoughts,</span><span class="NormalTextRun SCXW169529413 BCX8"> and whether there is anything </span><span class="NormalTextRun SCXW169529413 BCX8">you’d</span><span class="NormalTextRun SCXW169529413 BCX8"> like to see. </span></span><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8"> </span></span><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8">We are </span><span class="NormalTextRun SCXW169529413 BCX8">very interested</span><span class="NormalTextRun SCXW169529413 BCX8"> in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (</span></span><a class="Hyperlink SCXW169529413 BCX8" href="https://twitter.com/visualc" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8" data-ccp-charstyle="Hyperlink">@VisualC</span></span></a><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8">), or via email at </span></span><a class="Hyperlink SCXW169529413 BCX8" href="mailto:visualcpp@microsoft.com" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8" data-ccp-charstyle="Hyperlink">visualcpp@microsoft.com</span></span></a><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8">.</span><span class="NormalTextRun SCXW169529413 BCX8"> To open a bug, please see </span></span><a class="Hyperlink SCXW169529413 BCX8" href="https://developercommunity.visualstudio.com/report?space=8&amp;entry=problem" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8" data-ccp-charstyle="Hyperlink">Visual Studio Feedback</span></span></a><span class="EOP SCXW169529413 BCX8" data-ccp-props="{}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/">Integrated Terminal in Visual Studio: New SSH integration for Linux targeting</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/feed/</wfw:commentRss>
			<slash:comments>10</slash:comments>
		
		
			</item>
		<item>
		<title>VS2022 Performance Enhancements: Faster C++ Development</title>
		<link>https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Mon, 11 Jul 2022 16:04:16 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[game]]></category>
		<category><![CDATA[Game Development]]></category>
		<category><![CDATA[perf]]></category>
		<category><![CDATA[search]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30753</guid>

					<description><![CDATA[<p>Introduction<br />
Building on top of our performance wins in earlier releases of VS2022, we are excited to announce additional improvements in Visual Studio 2022 17.3! Whether you are a game developer, work with large codebases, or have a small C++ project,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/">VS2022 Performance Enhancements: Faster C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Building on top of our <a href="https://aka.ms/VS2022CppPerf1">performance wins</a> in earlier releases of VS2022, we are excited to announce additional improvements in Visual Studio 2022 17.3! Whether you are a game developer, work with large codebases, or have a small C++ project, your C++ development experience in Visual Studio 17.3 will feel even faster!</p>
<p>In this blog, I will share the incredible speed improvements you will experience when VS indexes your codebase and colorizes your C++ code for the first time. In addition, learn about the new Go to All experience that will show results as you type.</p>
<h1 id="testing-methodology">Testing Methodology</h1>
<p>Measuring indexing and time to colorization, we used an Unreal Engine 5 blank C++ project on a desktop with an Intel Core i7-9700 CPU @ 3Ghz, 64GB RAM, and an SSD. For indexing improvements, we benchmarked using both UE5 and the more than 300,000 file Chromium repo. The tests took place on Visual Studio 2019 16.11 and Visual Studio 2022 17.2 and 17.3. For both scenarios, we used system logs to track the duration of the operations.</p>
<h1 id="results">Results</h1>
<h2 id="population-indexing-improvements">Population (Indexing) Improvements</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium.png"><img class="aligncenter size-full wp-image-30755" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium.png" alt="Image indexchromium" width="2003" height="1376" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium.png 2003w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-300x206.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-1024x703.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-768x528.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-1536x1055.png 1536w" sizes="(max-width: 2003px) 100vw, 2003px" /></a></p>
<p>In Visual Studio 2019 16.11, it takes roughly 26 minutes for the Chromium repo to fully index. In Visual Studio 2022 17.3, waiting for indexing to finish will only take a bit over 6 minutes, a 4.17X speed up. When indexing a large solution like the Chromium repo for the first time, you will save up to 20 minutes with the latest version of Visual Studio.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5.png"><img class="aligncenter size-full wp-image-30756" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5.png" alt="Image indexue5" width="1836" height="1146" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5.png 1836w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-1024x639.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-768x479.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-1536x959.png 1536w" sizes="(max-width: 1836px) 100vw, 1836px" /></a></p>
<p>When getting to code in a new Unreal Engine 5 solution, you will see a huge improvement in the latest version of VS2022 versus VS2019. In VS2019 16.11, fully indexing a brand-new C++ UE5 solution took 144 seconds. When using VS2022 17.3, fully indexing the same UE5 solution is now 2X faster at 72 seconds. Whether you are creating a new UE5 project or cloning from an existing repo, your code will index much faster in 17.3.</p>
<h2 id="time-to-colorization">Time to Colorization</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5.png"><img class="aligncenter size-full wp-image-30754" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5.png" alt="Image colorue5" width="2001" height="1222" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5.png 2001w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-300x183.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-1024x625.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-768x469.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-1536x938.png 1536w" sizes="(max-width: 2001px) 100vw, 2001px" /></a></p>
<p>Building on top of the improvements in VS2022 17.2, time to colorization is even faster in Visual Studio 2022 17.3. Compared to VS2019 16.11, you will see your UE5 code colorize from a cold start in 7.6 seconds, a 4.3X improvement.</p>
<h2 id="go-to-responsiveness">Go To Responsiveness</h2>
<p>In Visual Studio 2022 17.3, your Go to All experience will feel faster! Previously, results appeared after you stopped typing. In the new experience, results will show as you type. You will now spend less time getting the result you desire.</p>
<p style="text-align: center;"><strong><span style="font-size: 18pt;">Before</span></strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotobefore.gif"><img class="aligncenter size-full wp-image-30766" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotobefore.gif" alt="Image gotobefore" width="454" height="385" /></a></p>
<p style="text-align: center;"><strong><span style="font-size: 18pt;">After</span></strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotoafter.gif"><img class="aligncenter size-full wp-image-30767" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotoafter.gif" alt="Image gotoafter" width="454" height="385" /></a></p>
<p>In addition to the new Go to All experience, you can now search and interact with code more efficiently with Contextual Code Previews in our All-In-One Search experience. For more information, please see this <a href="https://devblogs.microsoft.com/visualstudio/sneak-peek-and-edit-your-code-while-you-search/">blog</a>.</p>
<h2 id="git-branch-switching">Git Branch Switching</h2>
<p>In addition to C++ and search improvements, we have also significantly improved the branch switching experience. Please refer to this <a href="https://aka.ms/VS2022-BranchSwitchingPerformance">blog</a> for more information.</p>
<p>&nbsp;</p>
<h1 id="feedback-wanted">Feedback Wanted!</h1>
<p>Your feedback through <a href="https://developercommunity.visualstudio.com/">Developer Community</a>, surveys, and social media channels has made these improvements possible. We thank you for your valuable comments.
These enhancements are a continuation of our focus on improving productivity for game developers. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like ones detailed in this blogpost. If you are a game developer, <a href="http://aka.ms/VSGameDevSurvey">let us know your thoughts in our 2022 Visual Studio Game Developer Survey</a>.</p>
<p>In addition, please continue to help shape the development of Visual Studio by talking to us in the comments below, on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h1 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h1>
<p><a href="https://visualstudio.microsoft.com/downloads/">Download the latest version of Visual Studio 2022</a> to take advantage of these productivity benefits today!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/">VS2022 Performance Enhancements: Faster C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>C++23&#8217;s Deducing this: what it is, why it is, how to use it</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 27 Jun 2022 10:41:41 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30707</guid>

					<description><![CDATA[<p>Find out how C++23's Deducing this feature can help make your code better.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23&#8217;s Deducing this: what it is, why it is, how to use it</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://wg21.link/p0847">Deducing <code>this</code></a> (P0847) is a C++23 feature which gives a new way of specifying non-static member functions. Usually when we call an object&#8217;s member function, the object is <em>implicitly</em> passed to the member function, despite not being present in the parameter list. P0847 allows us to make this parameter <em>explicit</em>, giving it a name and <code>const</code>/reference qualifiers. For example:</p>
<pre><code class="language-cpp">struct implicit_style {
    void do_something(); //object is implicit
};

struct explicit_style {
    void do_something(this explicit_style&amp; self); //object is explicit
};</code></pre>
<p>The explicit object parameter is distinguished by the keyword <code>this</code> placed before the type specifier, and is only valid for the first parameter of the function.</p>
<p>The reasons for allowing this may not seem immediately obvious, but a bunch of additional features fall out of this almost by magic. These include de-quadruplication of code, recursive lambdas, passing <code>this</code> by value, and a version of the <a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/">CRTP</a> which doesn&#8217;t require the base class to be templated on the derived class.</p>
<p>This post will walk through an overview of the design, then many of the cases you can use this feature for in your own code.</p>
<p>For the rest of this blog post I&#8217;ll refer to the feature as &#8220;explicit object parameters&#8221;, as it makes more sense as a feature name than &#8220;deducing <code>this</code>&#8220;. Explicit object parameters are supported in MSVC as of Visual Studio 2022 version 17.2. A good companion to this post is Ben Deane&#8217;s talk <a href="https://www.youtube.com/watch?v=jXf--bazhJw">Deducing <code>this</code> Patterns</a> from CppCon.</p>
<h2 id="overview">Overview</h2>
<p>The paper which proposed this feature was written by <a href="https://twitter.com/atomgalaxy">Gašper Ažman</a>, <a href="https://twitter.com/ben_deane">Ben Deane</a>, <a href="https://twitter.com/BarryRevzin">Barry Revzin</a>, and <a href="https://twitter.com/TartanLlama">myself</a>, and was guided by the experience of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html#acknowledgements">many experts in the field</a>. Barry and I began writing a version of this paper after we each implemented <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a> and came across the same problem. We would be writing the <code>value</code> function of <code>optional</code> and, like good library developers, we&#8217;d try to make it usable and performant in as many use-cases as we could. So we&#8217;d want <code>value</code> to return a <code>const</code> reference if the object it was called on was <code>const</code>, we&#8217;d want it to return an rvalue if the object it was called on was an rvalue, etc. It ended up looking like this:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // version of value for non-const lvalues
  constexpr T&amp; value() &amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  // version of value for const lvalues
  constexpr T const&amp; value() const&amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  // version of value for non-const rvalues... are you bored yet?
  constexpr T&amp;&amp; value() &amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }

  // you sure are by this point
  constexpr T const&amp;&amp; value() const&amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }
  // ...
};</code></pre>
<p>(If you&#8217;re not familiar with the <code>member_function_name() &amp;</code> syntax, this is called &#8220;ref-qualifiers&#8221; and you can find more info <a href="https://akrzemi1.wordpress.com/2014/06/02/ref-qualifiers/">on Andrzej Krzemieński&#8217;s blog</a>. If you&#8217;re not familiar with rvalue references (<code>T&amp;&amp;</code>) you can read up on move semantics <a href="https://stackoverflow.com/questions/3106110/what-is-move-semantics">on this Stack Overflow question</a>)</p>
<p>Note the near-identical implementations of four versions of the same function, only differentiated on whether they&#8217;re <code>const</code> and whether they move the stored value instead of copying it.</p>
<p>Barry and I would then move on to some other function and have to do the same thing. And again and again, over and over, duplicating code, making mistakes, building maintenance headaches for the future versions of ourselves. &#8220;What if&#8221;, we thought, &#8220;you could just write this?&#8221;</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct optional {
  // One version of value which works for everything
  template &lt;class Self&gt;
  constexpr auto&amp;&amp; value(this Self&amp;&amp; self) {
    if (self.has_value()) {
        return std::forward&lt;Self&gt;(self).m_value;
    }
    throw bad_optional_access();
  }</code></pre>
<p>(If you&#8217;re not familiar with <code>std::forward</code>, you can read about perfect forwarding <a href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c">on Eli Bendersky&#8217;s blog</a>)</p>
<p>This does the same thing as the above four overloads, but in a single function. Instead of writing different versions of <code>value</code> for <code>const optional&amp;</code>, <code>const optional&amp;&amp;</code>, <code>optional&amp;</code>, and <code>optional&amp;&amp;</code>, we write one function template which <em>deduces</em> the <code>const</code>/<code>volatile</code>/reference (cvref for short) qualifiers of the object the it is called on. Making this change for almost every function in the type would cut down our code by a huge amount.</p>
<p>So we wrote a version of what eventually got standardised, soon discovered that Gašper and Ben were working on a different paper for the exact same feature, we joined forces, and here we all are several years later.</p>
<h3 id="design">Design</h3>
<p>The key design principle we followed was that it should <em>do what you expect</em>. To achieve this, we touched as few places in the standard as we possibly could. Notably, we didn&#8217;t touch overload resolution rules or template deduction rules, and name resolution was only changed a little bit (as a treat).</p>
<p>As such, say we have a type like so:</p>
<pre><code class="language-cpp">struct cat {
    template &lt;class Self&gt;
    void lick_paw(this Self&amp;&amp; self);
};</code></pre>
<p>The template parameter <code>Self</code> will be deduced based on all of the same template deduction rules you&#8217;re already familiar with. There&#8217;s no additional magic. You don&#8217;t have to use the names <code>Self</code> and <code>self</code>, but I think they&#8217;re the clearest options, and this follows what several other programming languages do.</p>
<pre><code class="language-cpp">cat marshmallow;
marshmallow.lick_paw();                         //Self = cat&amp;

const cat marshmallow_but_stubborn;
marshmallow_but_stubborn.lick_paw();            //Self = const cat&amp;

std::move(marshmallow).lick_paw();              //Self = cat
std::move(marshmallow_but_stubborn).lick_paw(); //Self = const cat</code></pre>
<p>One name resolution change is that inside such a member function, you are not allowed to explicitly or implicitly refer to <code>this</code>.</p>
<pre><code class="language-cpp">struct cat {
    std::string name;

    void print_name(this const cat&amp; self) {
        std::cout &lt;&lt; name;       //invalid
        std::cout &lt;&lt; this-&gt;name; //also invalid
        std::cout &lt;&lt; self.name;  //all good
    }
};</code></pre>
<h2 id="use-cases">Use Cases</h2>
<p>For the rest of this post, we&#8217;ll look at all the different uses of this feature (at least the ones discovered so far that I know of!) Many of these examples were taken straight from the paper.</p>
<h3 id="de-duplication-quadruplication">De-duplication/quadruplication</h3>
<p>We&#8217;ve already seen how the feature can be applied to a type such as <code>optional</code> to avoid having to write four overloads of the same function.</p>
<p>Note also that this lowers the burden on initial implementation and maintenance of dealing with rvalue member functions. Quite often developers will write only <code>const</code> and non-<code>const</code> overloads for member functions, since in many cases we don&#8217;t really want to write another two whole functions just to deal with rvalues. With deduced qualifiers on <code>this</code>, we get the rvalue versions for free: we just need to write <code>std::forward</code> in the right places to get the runtime performance gains which come with avoiding unnecessary copies:</p>
<pre><code class="language-cpp">class cat {
    toy held_toy_;

public:
    //Before explicit object parameters
    toy&amp; get_held_toy() { return held_toy_; }
    const toy&amp; get_held_toy() const { return held_toy_; }

    //After
    template &lt;class Self&gt;
    auto&amp;&amp; get_held_toy(this Self&amp;&amp; self) {
        return self.held_toy_;
    }

    //After + forwarding
    template &lt;class Self&gt;
    auto&amp;&amp; get_held_toy(this Self&amp;&amp; self) {
        return std::forward&lt;Self&gt;(self).held_toy_;
    }
};</code></pre>
<p>Of course for a simple getter like this, whether or not this change is worth it for your specific use case is up to you. But for more complex functions, or cases where you are dealing with large objects which you want to avoid copying, explicit object parameters make this much easier to handle.</p>
<h3 id="crtp">CRTP</h3>
<p>The Curiously Recurring Template Pattern (CRTP) is a form of compile-time polymorphism which allows you to extend types with common pieces of functionality without paying the runtime costs of virtual functions. This is sometimes referred to as <em>mixins</em> (this isn&#8217;t <em>all</em> the CRTP can be used for, but it is the most common use). For example, we could write a type <code>add_postfix_increment</code> which can be mixed in to another type in order to define postfix increment in terms of prefix increment:</p>
<pre><code class="language-cpp">template &lt;typename Derived&gt;
struct add_postfix_increment {
    Derived operator++(int) {
        auto&amp; self = static_cast&lt;Derived&amp;&gt;(*this);

        Derived tmp(self);
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment&lt;some_type&gt; {
    // Prefix increment, which the postfix one is implemented in terms of
    some_type&amp; operator++();
};</code></pre>
<p>Templating a base class on its derived cast and <code>static_cast</code>ing <code>this</code> inside the function can be a bit arcane, and the problem gets worse when you have multiple levels of CRTP. With explicit object parameters, since we didn&#8217;t change template deduction rules, <em>the type of the explicit object parameter can be deduced to a derived type</em>. More concretely:</p>
<pre><code class="language-cpp">struct base {
    template &lt;class Self&gt;
    void f(this Self&amp;&amp; self);
};

struct derived : base {};

int main() {
    derived my_derived;
    my_derived.f();
}</code></pre>
<p>In the call <code>my_derived.f()</code>, the type of <code>Self</code> inside <code>f</code> is <code>derived&amp;</code>, <em>not</em> <code>base&amp;</code>.</p>
<p>This means that we can define the above CRTP example like so:</p>
<pre><code class="language-cpp">struct add_postfix_increment {
    template &lt;typename Self&gt;
    auto operator++(this Self&amp;&amp; self, int) {
        auto tmp = self;
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment {
    // Prefix increment, which the postfix one is implemented in terms of
    some_type&amp; operator++();
};</code></pre>
<p>Note that now <code>add_postfix_increment</code> is not a template. Instead, we&#8217;ve moved the customisation to the postfix <code>operator++</code>. This means we don&#8217;t need to pass <code>some_type</code> as a template argument anywhere: everything &#8220;just works&#8221;.</p>
<h3 id="forwarding-out-of-lambdas">Forwarding out of lambdas</h3>
<p>Copying captured values out of a closure is simple: we can just pass around the object as usual. Moving captured values out of a closure is also simple: we can just call <code>std::move</code> on it. A problem occurs when we need to perfect-forward a captured value based on whether the closure is an lvalue or rvalue.</p>
<p>One use case I stole from <a href="https://wg21.link/p2445">P2445</a> is for lambdas which can be used in both &#8220;retry&#8221; and &#8220;try or fail&#8221; contexts:</p>
<pre><code class="language-cpp">auto callback = [m=get_message(), &amp;scheduler]() -&gt; bool {
    return scheduler.submit(m);
};
callback(); // retry(callback)
std::move(callback)(); // try-or-fail(rvalue)</code></pre>
<p>The question here is: how do we forward <code>m</code> based on the value category of the closure? Explicit object parameters give us the answer. Since a lambda generates a class with an <code>operator()</code> member function of the given signature, all the machinary I&#8217;ve just explained works for lambdas too.</p>
<pre><code class="language-cpp">auto closure = [](this auto&amp;&amp; self) {
    //can use self inside the lambda
};</code></pre>
<p>This means we can perfect-forward based on the value category of the closure inside the lambda. P2445 gives a <code>std::forward_like</code> helper, which forwards some expression based on the value category of another:</p>
<pre><code class="language-cpp">auto callback = [m=get_message(), &amp;scheduler](this auto &amp;&amp;self) -&gt; bool {
    return scheduler.submit(std::forward_like&lt;decltype(self)&gt;(m));
};</code></pre>
<p>Now our original use case works, and the captured object will be copied or moved depending on how we use the closure.</p>
<h3 id="recursive-lambdas">Recursive lambdas</h3>
<p>Since we now have the ability to name the closure object in a lambda&#8217;s parameter list, this allows us to do recursive lambdas! As above:</p>
<pre><code class="language-cpp">auto closure = [](this auto&amp;&amp; self) {
    self(); //just call ourself until the stack overflows
};</code></pre>
<p>There are more useful uses for this than just overflowing stacks, though. Consider, for example, the ability to do visitation of recursive data structures without having to define additional types or functions? Given the following definition of a binary tree:</p>
<pre><code class="language-cpp">struct Leaf { };
struct Node;
using Tree = std::variant&lt;Leaf, Node*&gt;;
struct Node {
    Tree left;
    Tree right;
};</code></pre>
<p>We can count the number of leaves like so:</p>
<pre><code class="language-cpp">int num_leaves(Tree const&amp; tree) {
    return std::visit(overload( //see below
        [](Leaf const&amp;) { return 1; },                       
        [](this auto const&amp; self, Node* n) -&gt; int {              
            return std::visit(self, n-&gt;left) + std::visit(self, n-&gt;right); 
        }
    ), tree);
}</code></pre>
<p><code>overload</code> here is some facility to create an overload set from multiple lambdas, and is commonly used for <code>variant</code> visitation. See <a href="https://en.cppreference.com/w/cpp/utility/variant/visit">cppreference</a>, for example.</p>
<p>This counts the number of leaves in the tree through recursion. For each function call in the call graph, if the current is a <code>Leaf</code>, it returns <code>1</code>. Otherwise, the overloaded closure calls itself through <code>self</code> and recurses, adding together the leaf counts for the left and right subtrees.</p>
<h3 id="pass-this-by-value">Pass <code>this</code> by value</h3>
<p>Since we can define the qualifiers of the now-explicit object parameter, we can choose to take it by value rather than by reference. For small objects, this can give us better runtime performance. In case you&#8217;re not familiar with how this affects code generation, here&#8217;s an example.</p>
<p>Say we have this code, using regular old implicit object parameters:</p>
<pre><code class="language-cpp">struct just_a_little_guy {
    int how_smol;
    int uwu();
};

int main() {
    just_a_little_guy tiny_tim{42};
    return tiny_tim.uwu();
}</code></pre>
<p>MSVC generates the following assembly:</p>
<pre><code class="language-asm">sub     rsp, 40                           
lea     rcx, QWORD PTR tiny_tim$[rsp]
mov     DWORD PTR tiny_tim$[rsp], 42     
call    int just_a_little_guy::uwu(void)  
add     rsp, 40                            
ret     0</code></pre>
<p>I&#8217;ll walk through this line-by-line.</p>
<ul>
<li><code>sub rsp, 40</code> allocates 40 bytes on the stack. This is 4 bytes to hold the <code>int</code> member of <code>tiny_tim</code>, 32 bytes of <a href="https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly"><em>shadow space</em> </a>for <code>uwu</code> to use, and 4 bytes of padding.</li>
<li>The <code>lea</code> instruction loads the address of the <code>tiny_tim</code> variable into the <code>rcx</code> register, which is where <code>uwu</code> is expecting the implicit object parameter (due to the <a href="https://docs.microsoft.com/cpp/build/x64-calling-convention?view=msvc-170">calling conventions</a> used).</li>
<li>The <code>mov</code> stores <code>42</code> into the <code>int</code> member of <code>tiny_tim</code>.</li>
<li>We then call the <code>uwu</code> function.</li>
<li>Finally we de-allocate the space we allocated on the stack before and return.</li>
</ul>
<p>What happens if we instead specify <code>uwu</code> to take its object parameter by value, like this?</p>
<pre><code class="language-cpp">struct just_a_little_guy {
    int how_smol;
    int uwu(this just_a_little_guy);
};</code></pre>
<p>In that case, the following code is generated:</p>
<pre><code class="language-asm">mov     ecx, 42                           
jmp     static int just_a_little_guy::uwu(this just_a_little_guy) </code></pre>
<p>We just move <code>42</code> into the relevant register and jump (<code>jmp</code>) to the <code>uwu</code> function. Since we&#8217;re not passing by-reference we don&#8217;t need to allocate anything on the stack. Since we&#8217;re not allocating on the stack we don&#8217;t need to de-allocate at the end of the function. Since we don&#8217;t need to deallocate at the end of the function we can just jump straight to <code>uwu</code> rather than jumping there and then back into this function when it returns, using <code>call</code>.</p>
<p>These are the kinds of optimisations which can prevent &#8220;death by a thousand cuts&#8221; where you take small performance hits over and over and over, resulting in slower runtimes that are hard to find the root cause of.</p>
<h3 id="sfinae-unfriendly-callables">SFINAE-unfriendly callables</h3>
<p>This issue is a bit more esoteric, but does actually happen in real code (I know because I got a bug report on my extended implementation of <code>std::optional</code> which hit this exact issue in production). Given a member function of <code>optional</code> called <code>transform</code>, which calls the given function on the stored value only if there is one, the problem looks like this:</p>
<pre><code class="language-cpp">struct oh_no {
    void non_const();
};

tl::optional&lt;oh_no&gt; o;
o.transform([](auto&amp;&amp; x) { x.non_const(); }); //does not compile</code></pre>
<p>The error which MSVC gives for this looks like:</p>
<blockquote><p>error C2662: &#8216;void oh_no::non_const(void)&#8217;: cannot convert &#8216;this&#8217; pointer from &#8216;const oh_no&#8217; to &#8216;oh_no &amp;&#8217;</p></blockquote>
<p>So it&#8217;s trying to pass a <code>const oh_no</code> as the implicit object parameter to <code>non_const</code>, which doesn&#8217;t work. But where did that <code>const oh_no</code> come from? The answer is inside the implementation of <code>optional</code> itself. Here is a deliberately stripped-down version:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct optional {
    T t;

    template &lt;class F&gt;
    auto transform(F&amp;&amp; f) -&gt; std::invoke_result_t&lt;F&amp;&amp;, T&amp;&gt;;

    template &lt;class F&gt;
    auto transform(F&amp;&amp; f) const -&gt; std::invoke_result_t&lt;F&amp;&amp;, const T&amp;&amp;&gt;;
};</code></pre>
<p>Those <code>std::invoke_result_t</code>s are there to make <code>transform</code> <a href="https://stackoverflow.com/questions/35033306/what-does-it-mean-when-one-says-something-is-sfinae-friendly">SFINAE-friendly</a>. This basically means that you can check whether a call to <code>transform</code> would compile and, if it wouldn&#8217;t, do something else instead of just aborting the entire compilation. However, there&#8217;s a bit of a hole in the language here.</p>
<p>When doing overload resolution on <code>transform</code>, the compiler has to work out which of those two overloads is the best match given the types of the arguments. In order to do so, it has to instantiate the declarations of both the <code>const</code> and non-<code>const</code> overloads. If you pass an invocable to <code>transform</code> which is not <em>itself</em> SFINAE-friendly, and isn&#8217;t valid for a <code>const</code> qualified implicit object (which is the case with my example) then instantiating the declaration of the <code>const</code> member function will be a hard compiler error. Oof.</p>
<p>Explicit object parameters allow you to solve this problem because the cvref qualifiers are <em>deduced</em> from the expression you call the member function on: if you never call the function on a <code>const optional</code> then the compiler never has to try and instantiate that declaration. Given <code>std::copy_cvref_t</code> from <a href="https://wg21.link/p1450">P1450</a>:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct optional {
    T t;

    template &lt;class Self, class F&gt;
    auto transform(this Self&amp;&amp; self, F&amp;&amp; f) 
    -&gt; std::invoke_result_t&lt;F&amp;&amp;, std::copy_cvref_t&lt;Self, T&gt;&gt;;
};</code></pre>
<p>This allows the above example to compile while still allowing <code>transform</code> to be SFINAE-friendly.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this has helped clarify the function and utility of explicit object parameters. You can try out the feature in <a href="https://visualstudio.microsoft.com/vs/features/cplusplus/">Visual Studio version 17.2</a>. If you have any questions, comments, or issues with the feature, you can comment below, or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23&#8217;s Deducing this: what it is, why it is, how to use it</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg June 2022 Release is Now Available: Force Download vcpkg Dependencies, Documentation Changes, and More</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 22 Jun 2022 01:29:22 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30681</guid>

					<description><![CDATA[<p>The June 2022 release of the vcpkg package manager is available. This includes a hotfix that fixed a regression in the binary caching experience. This blog post summarizes changes from May 11th, 2022 to June 15th, 2022 for the microsoft/vcpkg and microsoft/vcpkg-tool GitHub repos.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/">vcpkg June 2022 Release is Now Available: Force Download vcpkg Dependencies, Documentation Changes, and More</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.06.16.1">June 2022 release of the vcpkg package manager is available</a>. This includes a hotfix that fixed a regression in the binary caching experience. This blog post summarizes changes from May 11<sup>th</sup>, 2022 to June 15<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg/">microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>In the past month, the <a href="https://isocpp.org/blog/2022/06/results-summary-2022-annual-cpp-developer-survey-lite">ISO C++ 2022 Annual Developer Survey results</a> were released. We want to thank the C++ community for taking the time to provide feedback on vcpkg in the survey. This year, 19% (+4% year over year) of respondents indicated they were using vcpkg. We hope to see more and more of the community adopting package managers in their workflows going forward.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>20 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>292 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,956 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are <strong>10,016 port versions </strong>(new milestone!).</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.06.16.1">June release of the main vcpkg repo</a> includes <strong>247 commits</strong>.</li>
<li><strong>93 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.6k forks</strong> and <strong>15.9k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<h4 id="force-vcpkg-to-download-binary-dependencies-rather-than-use-system-ones">Force vcpkg to download binary dependencies rather than use system ones</h4>
<p>The vcpkg tool depends on several tools to do its work, including ninja and CMake. From the beginning, vcpkg has been able to download copies of these tools automatically does so by default if the tools are not detected on the system at an appropriate version. The downside of this is that in some cases, vcpkg may assume that an incompatible system version of a tool is valid and attempt to use it, only to fail.</p>
<p>In this release, we merged a PR from a community contributor that adds support for an environment variable called VCPKG_FORCE_DOWNLOADED_BINARIES. If this variable is set, vcpkg will ignore any existing system binaries and always download its own copies of the tools it depends on. This results in a more self-contained vcpkg that will reliably run across many machines with different OS flavors and system packages. This behavior is off by default however, so please set this variable if this is a scenario that interests you. Note: this environment variable is effectively the opposite of VCPKG_FORCE_SYSTEM_BINARIES, which always forces the use of system binaries.</p>
<p>PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/138">Microsoft/vcpkg-tool#138</a>, <a href="https://github.com/microsoft/vcpkg/pull/24674">Microsoft/vcpkg#24674</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/536">Microsoft/vcpkg-tool#536</a> (thank you @<a href="https://github.com/christophe-calmejane">christophe-calmejane</a>!)</p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation changes</h4>
<p>We are revamping our documentation based on user feedback. Here is a summary of changes made in this release:</p>
<ul>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/install.md">New documentation article for the vcpkg install command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/integrate.md">New documentation article for the vcpkg integrate command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/search.md">New documentation article for the vcpkg search command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/common-options.md">New documentation article for Common Command Options</a>. This provides a reference for different options available for vcpkg commands run in the command line.</li>
<li>New documentation in <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/config-environment.md">Environment and Configuration</a> on the new environment variable: VCPKG_FORCE_DOWNLOADED_BINARIES.</li>
<li>Split content on <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/cmake-integration.md">CMake</a>, <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/msbuild-integration.md">MSBuild</a>, <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/manual-integration.md">manual integration</a>, and the <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/export-command.md">export command</a> into separate documentation articles.</li>
<li>Added documentation describing criteria for vcpkg releases.</li>
<li>Wording changes, fixed links, and other improvements for several other articles.</li>
</ul>
<p>This is just the start of what will hopefully be a much longer list of changes over the coming months. We will continue to improve our documentation with each release.</p>
<p>PRs: <a href="https://github.com/microsoft/vcpkg/pull/24764">Microsoft/vcpkg#24764</a>, <a href="https://github.com/microsoft/vcpkg/pull/24756">Microsoft/vcpkg#24756</a>, <a href="https://github.com/microsoft/vcpkg/pull/24755">Microsoft/vcpkg#24755</a>, <a href="https://github.com/microsoft/vcpkg/pull/24754">Microsoft/vcpkg#24754</a>, <a href="https://github.com/microsoft/vcpkg/pull/24737">Microsoft/vcpkg#24737</a>, <a href="https://github.com/microsoft/vcpkg/pull/24649">Microsoft/vcpkg#24649</a>, <a href="https://github.com/microsoft/vcpkg/pull/24647">Microsoft/vcpkg#24647</a>, <a href="https://github.com/microsoft/vcpkg/pull/24456">Microsoft/vcpkg#24456</a></p>
<p>&nbsp;</p>
<h4 id="helper-port-for-less-common-build-systems">Helper port for less common build systems</h4>
<p>Through a community contribution by <a href="https://github.com/Neumann-A">Neumann-A</a>, the helper function vcpkg-cmake-get-vars was moved to its own port so it can be independently maintained and versioned. For context, this helper extracts compiler flags and paths to the compiler and linker so the user can build the port. If you are contributing or changing a port that uses a build system that we <a href="https://vcpkg.io/en/docs/maintainers/portfile-functions.html">do not already have a helper for</a>, this new port is for you.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/24636">Microsoft/vcpkg#24636</a> (thanks <a href="https://github.com/Neumann-A">@Neumann-A</a>!)</p>
<p>&nbsp;</p>
<h4 id="fixed-vcpkg-commands-failing-when-a-custom-port-is-installed">Fixed vcpkg commands failing when a custom port is installed</h4>
<p>Power users of vcpkg may be familiar with overlay ports, a feature that makes it possible to override ports with alternate versions. Users modifying the behavior of vcpkg itself may also be accustomed to switching between different branches in their fork of the vcpkg repo. Due to a bug, if you installed an overlay port or branch switched out of a branch with currently installed ports, then attempted to run a vcpkg command again (e.g. install or remove), vcpkg would throw an error, expecting the data about the custom-installed ports to be available despite the fact that it is no longer relevant to the new operation. Thanks to a community contribution, now when you run a command in this context, vcpkg will no longer fail.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/516">Microsoft/vcpkg-tool#516</a> (thanks <a href="https://github.com/Neumann-A">@Neumann-A</a>!)</p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,761</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,810</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,706</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,725</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>928</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,341</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>875</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,671</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,744</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is routinely tested to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>Thomas1664 (13 commits)</li>
<li>Neumann-A (10 commits)</li>
<li>autoantwort (10 commits)</li>
<li>dg0yt (10 commits)</li>
<li>Ryan-rsm-McKenzie (5 commits)</li>
<li>DragonJoker (5 commits)</li>
<li>m-kuhn (3 commits)</li>
<li>Hoikas (3 commits)</li>
<li>RT222 (3 commits)</li>
<li>myd7349 (2 commits)</li>
<li>winsoft666 (2 commits)</li>
<li>hmoffatt (2 commits)</li>
<li>AenBleidd (2 commits)</li>
<li>daschuer (1 commit)</li>
<li>eao197 (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>danielaparker (1 commit)</li>
<li>coryan (1 commit)</li>
<li>longhuan2018 (1 commit)</li>
<li>luncliff (1 commit)</li>
<li>klalumiere (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.06.15">full June release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/">vcpkg June 2022 Release is Now Available: Force Download vcpkg Dependencies, Documentation Changes, and More</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
