<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Tue, 23 Nov 2021 18:26:37 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>C++ build throughput investigation and tune up</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/#respond</comments>
		
		<dc:creator><![CDATA[olgaark]]></dc:creator>
		<pubDate>Fri, 19 Nov 2021 09:41:12 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29790</guid>

					<description><![CDATA[<p>Building C++ code is a complex process, launching many build tools in parallel and often running for a long time. It is always desirable to make it faster, but also a challenge to understand what the most effective way would be to achieve this.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">C++ build throughput investigation and tune up</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Building C++ code is a complex process, launching many build tools in parallel and often running for a long time. It is always desirable to make it faster, but also a challenge to understand what the most effective way would be to achieve this.</p>
<p>We’d like to share some techniques we use to get a “bigger” picture of the build, as well as tools that can help to see what is taking time in a particular part of the build. We’ll also talk about MSBuild project options which can improve build parallelism without overwhelming the system, as well as other (not immediately obvious) options which might affect build throughput.</p>
<p>This blog is more like a list of what is currently available, full of instructions and details. Some of the suggestions should be useful for any C++ build, but most of the measurements and tuning options are for MSBuild based projects (vcxproj).</p>
<p>As any performance improvement starts with the measurement, here we are – measure your build.</p>
<p>Note that the total build time can vary quite noticeably between several identical builds on the same machine – the system is adjusting to the active processes. So, if you compare builds before and after making some options changes, it is more reliable to run the build several times and get the average. It is also helpful to measure not only the total build time but get more detailed information, so if you get a surprising result, you can figure out why it happened. For MSBuild we recommend running it on the command line and collecting a <a href="http://www.msbuildlog.com/">binary log</a>.</p>
<h2 id="measure-your-build-time-using-msbuild-performance-summary">Measure your build time using MSBuild Performance Summary</h2>
<p>If your build is MSBuild based, the first thing to do when investigating build performance is to see which projects and which tasks/targets inside the projects are taking most of the build time. The performance summary data is also very useful for comparing builds using different options.</p>
<p>To get a performance summary for your full build, you can do the following: open a Developer (or MSBuild) Command Prompt and run the build of your solution with the following options (replace Configuration and Platform values with the ones your solution actually has):</p>
<pre class="prettyprint">msbuild /m /t:clean /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln 
msbuild  /m /fl  -flp:PerformanceSummary;v=q;LogFile=Perf.log /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln
</pre>
<p>The “quet” or “minimal” verbosity setting (<code>-flp:PerformanceSummary;v=q</code>) is recommended as console logging itself takes noticeable time. But you can set the verbosity to other levels if you want more build info in the Perf.log. You can also add <code>/detailedSummary</code> to see msbuild.exe <a href="https://devblogs.microsoft.com/visualstudio/msbuild-4-detailed-build-summary/#gimme-some-numbers">nodes utilization</a>).</p>
<p>The same information can be extracted from a binary log. We recommend creating binary logs when investigating your builds. To create a binary log, run:</p>
<pre><code class="language-txt">msbuild /m /t:clean /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln 
msbuild /m /bl:build.binlog /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln</code></pre>
<p>To extract the perf info into Perf.log, run:</p>
<pre><code class="language-txt">msbuild -noconlog -flp:PerformanceSummary -flp:v=q  build.binlog
ren msbuild.log Perf.log</code></pre>
<p>You can also enable “Build Timings” for VC projects in the IDE by setting “Tools/Options/Projects and Solutions/VC++ Project Settings/Build Timings” = “Yes”. This will create the Perf Summary for each project, but not for the whole solution build. Thus, using the command line is better to see the “whole picture”.</p>
<p>In the Perf.log you’ll find times (in ms) it took to build the whole solution, each project (in the time increasing order) and commutative time of all targets and tasks (also in the time increasing order). Note that project build time and some targets (like ResolveProjectReferences target) include the wait for referenced projects to be built. You can use the Timeline tab of the binlog viewer to see if other projects were built as a part of a particular project build.</p>
<p>For a solution containing mostly C++ projects, cl and link would usually be the tasks taking most of the time:</p>
<pre><code class="language-txt">Project Performance Summary:
…
    1100252 ms  d:testMySolution.sln          1 calls  solution build time (msbuild /m)

Task Performance Summary:
…
     22495731 ms  Link    250 calls 
    152500624 ms  CL      250 calls </code></pre>
<p>The task time is the sum of all times the task was executing for all projects and thus it can be bigger than the total build time. For CL and Link tasks their time is very close to the cl.exe and link.exe time.</p>
<h2 id="use-build-insights-to-see-the-build-timeline-for-cl-exe-and-link-exe">Use Build Insights to see the build timeline for cl.exe and link.exe</h2>
<p>Most of the C++ builds time is usually spent in the compiler. To visualize what is going on during the build, see the processes running in parallel and pivot on the parts that take most of the time, you can use the <a href="https://devblogs.microsoft.com/cppblog/introducing-c-build-insights/">Build Insights</a> tool.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/word-image.gif"><img class="alignnone wp-image-25179 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/word-image.gif" alt="" width="881" height="680" /></a></p>
<h2 id="change-options-to-improve-c-build-throughput">Change options to improve C++ build throughput</h2>
<p>There are many parameters which can affect build throughput and different codebases can benefit from different sets of options. Here we&#8217;ll talk about antivirus and project settings which are easy to change and which can potentially greatly improve your build throughput.</p>
<h3 id="1-check-your-antivirus-settings">1. Check your antivirus settings</h3>
<p>C++ builds produce a lot of intermediate files and we often see the file system as a bottleneck there. With your antivirus scanning all build outputs, the problem is greatly amplified.</p>
<p>Windows Defender Antivirus automatically excludes most of the common build tools when they are found in the default install locations. But if you install Visual Studio in a custom location or use many additional build tools, your build throughput might be affected.</p>
<p>To see if Windows Defender scans are impacting your build, you can use <a href="https://techcommunity.microsoft.com/t5/microsoft-defender-for-endpoint/announcing-performance-analyzer-for-microsoft-defender-antivirus/ba-p/2713911">Performance Analyzer for Microsoft Defender Antivirus</a>. The tool collects minimal data so you can run it for a good chunk of your build (10-20 min is usually enough) if not the whole build. We recommend closing all application unrelated to the build before collecting the data to avoid seeing unrelated to build processes in the report.</p>
<p>To collect the data and see the affected build processes:</p>
<ul>
<li>Open a Windows PowerShell and run:
<pre><code class="language-txt">New-MpPerformanceRecording -RecordTo MyBuild.etl</code></pre>
</li>
<li>Rebuild your code in the IDE or on the command line</li>
<li>After the build is finished (or after 10-20 min) go back to the PowerShell and stop the recording by hitting any key</li>
<li>In PowerShell run
<pre><code class="language-txt">Get-MpPerformanceReport -TopProcesses:20 MyBuild.etl</code></pre>
<p>This will give you the list of the affected processes, similar to the following one:</p>
<pre><code class="language-txt">TopProcesses
============

Count TotalDuration MinDuration AverageDuration MaxDuration MedianDuration ProcessPath
----- ------------- ----------- --------------- ----------- -------------- -----------
8193  62272.1020ms    0.1790ms        7.6006ms  119.5682ms       6.8465ms   D:Visual Studio 17VCToolsMSVC14.30.30528binHostx64x86cl.exe
1068  14587.9547ms    3.2531ms       13.6591ms 927.2716ms       6.0416ms    D:Visual Studio 17VCToolsMSVC14.30.30528binHostx64x86link.exe
…</code></pre>
<p>You can add the build tools from the trusted locations to the excluded files or directories list in the <a href="https://docs.microsoft.com/microsoft-365/security/defender-endpoint/configure-extension-file-exclusions-microsoft-defender-antivirus?view=o365-worldwide#exclusion-lists">Windows Defender settings.</a></li>
</ul>
<h3 id="2-redefine-tmp-directory">2. Redefine TMP directory.</h3>
<p>During compilation, cl.exe creates a tmp file per each source in the TMP folder. When many cl.exe processes are running in parallel and simultaneously creating a lot of files in the same folder it creates a lot of stress for the file system.</p>
<p>Using different TMP folders for different projects (and preferably not on the system drive) often makes the build faster, especially on powerful machines with many CPUs where disk I/O and file system are more often a bottleneck.</p>
<p>We are planning to address this problem in the future VS releases, but meanwhile you can redefine the TMP environment variable to be different for different projects. See the proposed <code>Directory.Build.props</code> sample at the end of the blog.</p>
<h3 id="3-tune-build-options-for-better-parallelism">3. Tune build options for better parallelism.</h3>
<p>Many C++ build operations support parallel execution. A general assumption is that the build should be faster when more build operations are running in parallel. This is true, but only to a point when the build is not overwhelming the system capacity to distribute machine resources between processes and threads.</p>
<p>Most of the build tools are heavy users of CPU, memory, and the file system. Depending on the number of source files, their size, and content, any of these components can be a bottleneck preventing the build from being faster when more tools are running in parallel. When a resource limit is hit, running more build operations in parallel will make the build slower, rather than faster, sometimes significantly. For instance, the <code>msbuild /m</code> + <code>cl /MP</code> resource overuse problem has been known for quite some time, but recently became more frequent as more and more computers have 32+ logical CPUs.
The problem of optimal build parallelism is quite complex as it is hard to predict up front the resource usage of a particular build operation and pretty much impossible to predict actual resource availability for the whole time of that build operation. But some heuristics can be used, at least for the number of running processes and threads.</p>
<h4 id="msbuild-resource-manager"><em>MSBuild Resource Manager</em></h4>
<p>In VS 2019 16.10, MSBuild introduced <a href="https://github.com/dotnet/msbuild/blob/main/documentation/specs/resource-management.md">cross-process resource management</a>, which allows build parts (tasks) of different projects communicating their anticipated CPU usage and limiting this usage if resources are already reserved by other build parts. All C++ build tasks that launch several processes (like cl.exe or custom build tools) or the ones that are known to use many threads (like link.exe) participate in this communication.</p>
<p>In VS 2022 17.0 VC project’s build uses the MSBuild Resource Manager by default. The MSBuild Resource Manager support is also available VS 2019 16.11, but off by default. To activate it the following property should be defined as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample):</p>
<p><code>set UseMSBuildResourceManager=true</code></p>
<p>If you don’t use <code>/MP</code> for your build currently, turn it on and give it a try. To affect all projects, define the following property as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample):</p>
<p><code>set CL_MP = true</code></p>
<p>By default, the MSBuild Resource Manager will allow maximum 2*(number of CPU cores) to be used simultaneously by all project’s tasks. The 2x cores (instead of just 1x) limit is partially dictated by the current MSBuild scheduler architecture, but also seems to allow better build throughput on average. Most of the time the build will use less than 2xCPUs and when it does, the system usually tolerates 2x CPU oversubscription quite well unless bottlenecks other than the CPU are hit by the build (see Many Cores Machines section).</p>
<p>There are also a couple of “knobs” to try if the default behavior is not good enough.
In addition to setting the maximum number of projects allowed to be built in parallel (<code>msbuild /m:nProjects</code>), you can set the following environment variables (cannot be MSBuild properties) to modify the behavior:</p>
<ul>
<li><code>MSBUILDCORELIMIT=N</code> where N is the max number of cores to be given to one project. By default it’s the number of logical CPUs on the machine</li>
<li><code>MSBUILDNODECOREALLOCATIONWEIGHT= [0 – 100]</code>
0% means that MSBuild nodes don’t consider using CPUs and 100% means that each MSBuild node would be considered using 1 CPU. In C++ builds, MSBuild processes CPU usage is small comparing to the compiler CPU usage, so 0 should be OK. But for mixed C# and C++ solutions it probably should be set to something between 50 and 100.</li>
</ul>
<p>If for some reason building with the MSBuild Resource Manager is slower for your build and you don’t want to experiment with other options, you can disable it by setting <code>UseMSBuildResourceManager</code> as false.</p>
<h4 id="multitooltask-mtt"><em>MultiToolTask (MTT)</em></h4>
<p>Other options which can be used to limit the number of cl.exe processes running in parallel are described in <a href="https://devblogs.microsoft.com/cppblog/improved-parallelism-in-msbuild/">Improve Parallelism in MSBuild</a>.</p>
<p>To activate MTT mode set the following properties as environment variables or as MSBuild properties for all projects (see also the <code>Directory.Build.props</code> sample below):</p>
<pre><code class="language-txt">set UseMultiToolTask=true
set EnforceProcessCountAcrossBuilds=true</code></pre>
<p>This will make the build launch a separate cl.exe process for each C/C++ source and limit the number of simultaneously running cl processes (across all project builds) to <code>CL_MPCOUNT</code>, which is by default set to the number of logical processors.</p>
<p>MultiToolTask mode can be also used together with the MSBuild Resource Manager. This might be beneficial for some builds as instead of asking the MSBuild Resource Manager for available resources only once before launching the top-level <code>cl.exe /MP</code>, the build will ask it before launching cl.exe for each source file.</p>
<p>Note, that for projects with many small and simple C/C++ files (i.e., when individual file compilation is not taking a long time), launching a separate cl.exe processes for each file would bring a noticeable overhead. So, this option is recommended to use when most of the source files are relatively large and complex.</p>
<p>In VS 2022, the new experimental &#8220;ClServer&#8221; mode has been added to address the process creation overhead in MTT mode by using server-client model similar to <code>cl.exe /MP</code>. The server would spawn worker cl.exe processes, then dispatch work via IPC. The server resides in MSBuild process so is in-sync with the resource manager while scheduling work dynamically—allocating more workers or freeing resources to scaling down to deal with &#8220;long pole&#8221; compiles.</p>
<p>To enable this mode the following property should be defined as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample below):</p>
<p><code>set EnableClServerMode=true</code></p>
<h4 id="increase-build-parallelism-for-native-c-projects-experimental"><em>Increase build parallelism for native C++ projects (experimental)</em></h4>
<p>This option is experimental and works only for command line builds currently (not supported for the IDE build).</p>
<p>By default, if project B is referencing project A, the build of project B will not start until project A’s build is finished.
This makes sense for managed projects where assemblies must exist before they can be used as references in the compilation.</p>
<p>But native C++ code compilation usually does not use any build outputs from the referenced projects, only the linker does.
Even with C++20 modules, where compilation does use the build outputs (modules) from the referenced projects, it only needs to wait for the referenced project compilation step to finish but does not need to wait for the link to be complete.</p>
<p>To allow the compilation step of the referencing projects to start as soon as the compilation step of the referenced projects is finished:</p>
<p><code>set BuildPassReferences=true</code></p>
<p>To allow parallel compilation of all native sources in spite of project references (implies <code>BuildPassReferences=true</code>): (Note that this mode won&#8217;t work if the code is using C++ 20 modules built as a part of the solution)</p>
<p><code>set AllowParallelCompileInReferencedProjects=true</code></p>
<p>As these options would allow more build parts running simultaneously, make sure to enable the MSBuild Resource Manager and/or MultiToolTask with <code>EnforceProcessCountAcrossBuilds</code>.</p>
<p>The command line should look like:</p>
<p><code>msbuild /p:Configuration=Debug;Platform= x64 /t:BuildGenerateSources;BuildCompile;BuildLink solution.sln</code></p>
<p>How it works:</p>
<p>By default, MSBuild starts project build execution after all projects it references finish building.
Each VC project build consists of BuildGenerateSources, BuildCompile and BuildLink targets executed one after another. They are historically called “build passes”.</p>
<p>The default build timeline for two projects where ProjectB is referencing ProjectA looks like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/Build.png" alt="Regular build" /></p>
<p>When <code>BuildPassReferences</code> is set to true, a project B’s <code>BuildGenerateSources</code> target will be executed as soon as project A’s <code>BuildGenerateSources</code> target finish building. The project B’s <code>BuildCompile</code> target will wait for project B’s <code>BuildGenerateSources</code> target to finish executing, as well as project A’s <code>BuildCompile</code> targets. Similarly, a project B’s <code>BuildLink</code> target will wait for project B’s <code>BuildCompile</code> target and project A’s <code>BuildLink</code> target.</p>
<p>So, with <code>BuildPassReferences = true</code>, the build timeline would look like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/BuildPasses.png" alt="Build with pass references" /></p>
<p>When <code>AllowParallelCompileInReferencedProjects</code> is true, the build will allow even the same targets of the referencing and referenced projects to run in parallel. This will only work if a target does not use outputs from the same target of the referenced project. Note, that .lib and .implib are created as a part of <code>BuildCompile</code> so they are always available for <code>BuildLink</code>.</p>
<p>The project B’s <code>BuildGenerateSources</code> target can be executed at the same time as project A&#8217;s <code>BuildGenerateSources</code> target.
The project B’s <code>BuildCompile</code> target will wait for project B’s and project A&#8217;s <code>BuildGenerateSources</code> targets to finish executing.
The project B’s <code>BuildLink</code> target will wait for project B’s and project A&#8217;s <code>BuildCompile</code> targets.</p>
<p>So, with <code>AllowParallelCompileInReferencedProjects=true</code> the timeline would look like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/ParallelCompile.png" alt="Build with parallel compilation" /></p>
<h3 id="4-tune-sources-includes-and-precompiled-headers-pch">4. Tune sources, includes and precompiled headers (PCH)</h3>
<p>To see which sources are taking most of the compiler time, use <a href="https://devblogs.microsoft.com/cppblog/introducing-c-build-insights/">Build Insights</a>. This tool will help you to see if adding a particular include to the pch would save a lot of compilation time. It will also allow you to view the build timeline.</p>
<p>Check the following blog post for adjusting PCH files:
<a href="https://devblogs.microsoft.com/cppblog/precompiled-header-pch-issues-and-recommendations/">Precompiled Header (PCH) issues and recommendations</a></p>
<p>If your files are well isolated, you can also try using Unity(Jumbo) builds:
<a href="https://devblogs.microsoft.com/cppblog/support-for-unity-jumbo-files-in-visual-studio-2017-15-8-experimental/">Support for Unity (Jumbo) Files in Visual Studio 2017 15.8 (Experimental)</a></p>
<h3 id="5-special-considerations-for-machines-with-64-cpus">5. Special considerations for machines with 64+ CPUs</h3>
<p>The following recommendations are based on the build time measurements performed on a 192 cores Windows Server machine.</p>
<ul>
<li>If you are running Windows Server 2016 on such a machine, it is highly recommended to upgrade it to WS2019. WS2016 was not optimized for launching many (64+) instances of the same exe, which resulted in poor performance of 64+ cl.exe running together.</li>
<li>When using Windows Server 2019, make sure that antivirus check is not affecting your build and TMP directory is redefined (i.e. follow recommendations #1 and #2 of this blog, see the chart below).</li>
<li>The build is likely to hit file system and disk I/O bottleneck when running a lot of build tools in parallel. If you’ve adjusted your build options for the best parallelism (#3), but still see low CPU utilization during build, it is likely that build is hitting a bottleneck other than CPU. Try limiting the number of projects running in parallel, as well as setting <code>MSBUILDCORELIMIT</code> to a lower number &#8211; this might actually improve your build throughput.</li>
</ul>
<p>In one of our tests, we’ve built a generated solution containing 250 projects, 250 cpp files each, with no project references. The C++ code was also generated and, admittedly, quite simple, containing one class per file, up to 30 methods each.</p>
<p>The following chart shows build times of this solution with different system and TMP options.
Each bar corresponds to the <code>msbuild /m:[nProjects]</code> build time, no other options were set. As the test projects did not have any project references, that was enough to achieve best parallelism.
Each series contains build times when number of projects built in parallel (and thus max number of cl.exe instances running together) was 10, 20, 30, 40, 60, 80, 100, 120, 140, 160, and 180.</p>
<p>The system/TMP setting for each series are:</p>
<ol>
<li>WS2016 Default settings</li>
<li>WS2019 Default settings, custom VS install location (Defender on, no exclusions, default TMP folder <code>c:users[username]AppDataLocalTemp</code>)</li>
<li>WS2019* Build tools are excluded from the Defender scan. Default TMP folder, not excluded from Defender scan.</li>
<li>WS2019** Build tools and default TMP folder are excluded from the Defender scan</li>
<li>WS2019*** Build tools are excluded from the Defender scan, TMP is set to project specific location, different for each project.</li>
</ol>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/Chart.png" alt="Build time (ms)" /></p>
<p>Note that in all series, build time did not improve much (and even got worse) when building more projects in parallel after some point. For this particular solution, building just ~40 projects in parallel showed the best results.</p>
<p>We’ve also tested other generated solutions with different number of projects, longer code, project references, etc. We also used different build options, especially the ones we recommend using in section#3.
The trends were quite similar, though the optimal number of parallel processes might differ.</p>
<p>The “real” code compilation usually takes much longer than the compilation of our small and simple generated files, so File System bottleneck might be not so pronounced there. But changing the antivirus and TMP settings improved the build times there as well, though not as much.</p>
<h2 id="directory-build-props-sample-to-set-options-for-all-projects">Directory.Build.props sample to set options for all projects</h2>
<p>Create<code> Directory.Build.props</code> in the root directory to affect all projects under this root.
This is a sample content of<code> Directory.Build.props</code> you can use to try different build settings.</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project&gt;
  &lt;PropertyGroup&gt;
    &lt;!-- To enable project specific directory for temporary files. --&gt;
    &lt;UseProjectTMPDirectory&gt;true&lt;/UseProjectTMPDirectory&gt;

    &lt;!-- To enable MSBuild Resource Manager in VS 2019 16.11 (on by default in VS 2022) --&gt;
    &lt;UseMSBuildResourceManager&gt;true&lt;/UseMSBuildResourceManager&gt;

    &lt;!-- Uncomment to enable MultiToolTask (MTT) mode. --&gt;
    &lt;!--&lt;UseMultiToolTask&gt;true&lt;/UseMultiToolTask&gt;
      &lt;EnforceProcessCountAcrossBuilds&gt;true&lt;/EnforceProcessCountAcrossBuilds&gt;--&gt;

    &lt;!-- Uncomment to enable experimental MTT ClServer mode, available in VS 2022. --&gt;
    &lt;!--&lt;EnableClServerMode&gt;true&lt;/EnableClServerMode&gt;--&gt;

    &lt;!-- Uncomment and change the value to control the maximum number of cl.exe processes running in parallel. 
         If using MTT without MSBuild Resource Manager, 10-20% oversubscription is often beneficial. --&gt;
    &lt;!--&lt;CL_MPCount&gt;20&lt;/CL_MPCount&gt;--&gt;

    &lt;!--Uncomment to allow executing more build operations in parallel--&gt;
    &lt;!--&lt;BuildPassReferences&gt;true&lt;/BuildPassReferences&gt; --&gt;
    &lt;!--&lt;AllowParallelCompileInReferencedProjects&gt;true&lt;/AllowParallelCompileInReferencedProjects&gt; --&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemDefinitionGroup&gt;
    &lt;!--  Enable parallel compilation (cl.exe /MP) --&gt;
    &lt;ClCompile&gt;
      &lt;MultiProcessorCompilation&gt;true&lt;/MultiProcessorCompilation&gt;
    &lt;/ClCompile&gt;
    &lt;!--  Enable parallel execution of a custom build tool--&gt;
    &lt;CustomBuild&gt;
      &lt;BuildInParallel&gt;true&lt;/BuildInParallel&gt;
    &lt;/CustomBuild&gt;
  &lt;/ItemDefinitionGroup&gt;

  &lt;!-- Define project specific directory for temporary files --&gt;
  &lt;Target Name="SetProjectTMPDirectory"
          Condition="'$(UseProjectTMPDirectory)' == 'true'"
          AfterTargets="SetBuildDefaultEnvironmentVariables"&gt;
    &lt;MakeDir Directories="$(IntDir)TMP"/&gt;
    &lt;SetEnv Name   ="TMP"
            Value  ="$(IntDir)TMP"
            Prefix ="false"&gt;
    &lt;/SetEnv&gt;
  &lt;/Target&gt;
&lt;/Project&gt;</code></pre>
<h2 id="send-us-feedback">Send Us Feedback</h2>
<p>Build is a complex process, and its performance depends on many factors and circumstances. Building different codebases on different hardware would benefit from different build settings. We hope you can try some of the options described in the blog and see if they improve your build time.</p>
<p>If you try any suggestions, please let us know, we love to hear from you! You can leave your comments below or email us at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">C++ build throughput investigation and tune up</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s new for C++ cross-platform developers in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/#comments</comments>
		
		<dc:creator><![CDATA[Erika Sweet]]></dc:creator>
		<pubDate>Thu, 18 Nov 2021 15:33:43 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29778</guid>

					<description><![CDATA[<p>Visual Studio 2022 is available now! Check out the video below to learn what’s new for C++ developers who are building for more than just Windows, or who are developing with an eye to open source. This video covers: </p>
<p>Building with Visual Studio’s CMake Presets integration  <br />
Managing dependencies with a vcpkg manifest file and binary caching  <br />
Editing CMake scripts with CMake in-editor documentation and language services for CMake <br />
Building and debugging a Linux GUI application on WSL 2 with Visual Studio’s native support for WSL 2  <br />
Reproducing local builds with CMake Presets and GitHub Actions <br />
Debugging a remote process with LLDB </p>
<p>Contact us<br />
Have questions or comments about Visual Studio 2022?</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/">What’s new for C++ cross-platform developers in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">Visual Studio 2022 is </span><a href="https://visualstudio.microsoft.com/downloads/"><span data-contrast="none">available now</span></a><span data-contrast="auto">! Check out the video below to learn what’s new for C++ developers who are building for more than just Windows, or who are developing with an eye to open source. This video covers:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Building with Visual Studio’s <a href="https://aka.ms/cmakepresetsvs">CMake Presets integration</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="auto">Managing dependencies with a <a href="https://vcpkg.io/en/index.html">vcpkg manifest file and binary caching</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Editing CMake scripts with <a href="https://devblogs.microsoft.com/cppblog/in-editor-documentation-for-cmake-in-visual-studio/">CMake in-editor documentation</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170#language-services-for-cmake">language services for CMake</a></span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Building and debugging a Linux GUI application on WSL 2 with <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-build-debug-wsl2?view=msvc-170">Visual Studio’s native support for WSL 2</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto"><a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-170#run-cmake-from-the-command-line-or-a-ci-pipeline">Reproducing local builds with CMake Presets</a> and GitHub Actions</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><a href="http://aka.ms/lldb"><span data-contrast="auto">Debugging a remote process with LLDB</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></a></li>
</ul>
<p><center>
<iframe src="//www.youtube.com/embed/yImev317_Ns" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></center></p>
<h3 id="contact-us">Contact us</h3>
<p><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">Have</span><span class="NormalTextRun SCXW106660144 BCX8"> </span><span class="NormalTextRun SCXW106660144 BCX8">questions or comments about</span><span class="NormalTextRun SCXW106660144 BCX8"> Visual Studio 2022? Want to </span><span class="NormalTextRun SCXW106660144 BCX8">share feedback with our team? </span><span class="NormalTextRun SCXW106660144 BCX8">You can contact us </span><span class="NormalTextRun SCXW106660144 BCX8">at </span></span><a class="Hyperlink SCXW106660144 BCX8" href="mailto:visualcpp@microsoft.com" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">visualcpp@microsoft.com</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> </span><span class="NormalTextRun SCXW106660144 BCX8">or</span><span class="NormalTextRun SCXW106660144 BCX8"> on Twitter (</span></span><a class="Hyperlink SCXW106660144 BCX8" href="https://twitter.com/visualc" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">@VisualC</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">). The best way to file a bug or suggest a feature is with the </span></span><strong><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">Send Feedback</span></span></strong><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> button in the upper right-hand corner of the IDE. See </span></span><a class="Hyperlink SCXW106660144 BCX8" href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">How to report a problem with Visual Studio or Visual Studio Installer</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> for more information. </span></span><span class="EOP SCXW106660144 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/">What’s new for C++ cross-platform developers in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Code Analysis with GitHub Actions</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Winsor]]></dc:creator>
		<pubDate>Tue, 26 Oct 2021 11:23:10 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29701</guid>

					<description><![CDATA[<p>We previously talked about GitHub Code Scanning capabilities which enabled developers to incorporate security checks into their CI/CD environment and developer workflow. CodeQL is the default analysis engine behind Code Scanning. Today we are introducing support for MSVC Code Analysis which will provide a great companion to CodeQL for C++ GitHub repos with Windows workflows.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">Microsoft C++ Code Analysis with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We previously talked about <a href="https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/">GitHub Code Scanning capabilities</a> which enabled developers to incorporate security checks into their CI/CD environment and developer workflow. <a href="https://codeql.github.com/">CodeQL</a> is the default analysis engine behind Code Scanning. Today we are introducing support for MSVC Code Analysis which will provide a great companion to CodeQL for C++ GitHub repos with Windows workflows.</p>
<p>This <a href="https://github.com/marketplace/actions/microsoft-c-code-analysis-action">Action</a> will take the variety of Code Quality and Security warnings available in Visual Studio today and process them as alerts, displaying them in the <a href="https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/managing-code-scanning-alerts-for-your-repository">Security view of a GitHub repository</a>. The code scanning alerts produced will power the <a href="https://github.com/features/security/code">existing features</a> available through GitHub. These include highlighting the source code of contributors’ PRs with any warnings they may have introduced or allowing repository owners to view and manage the backlog of alerts under the Security tab.</p>
<p><img class="alignnone" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/CodeScanning.png" alt="Analysis results annotated in Pull Request UI" width="933" height="557" /></p>
<p>Alongside the support for analysis alerts inside of GitHub, the results can also be published as workflow artifacts, allowing contributors to download and view them locally in the IDE. This is enabled by our <a href="https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/">support for SARIF</a>, which is a standardized file format for analysis tooling. This format can be viewed inside of Visual Studio Code using the <a href="https://marketplace.visualstudio.com/items?itemName=MS-SarifVSCode.sarif-viewer">SARIF Viewer extension</a>. This will provide additional information highlighted on the source code, allowing the developer to easily resolve any problems found.</p>
<p>The repository will need to support CMake to ensure information about how the project is built can be extracted. We chose CMake because it provides a good abstraction for the varied nature of C++ projects and due to its wide adoption in the open-source community. It also provides an easy path for teams not currently building with the Microsoft Compiler to get analysis setup and see the features it has to offer.</p>
<h2 id="setup-github-action">Setup GitHub Action</h2>
<p>To get started using this experience you can find an entry for Microsoft C++ Code Analysis on the Security (tab) -&gt; Setup up code scanning page if C++ is detected in your repository.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/WorkflowSetup.gif"><img class="alignnone wp-image-29704 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/WorkflowSetup.gif" alt="Setting up Code Scanning workflow (GIF)" width="1002" height="592" /></a></p>
<p>Once you have the template installed you can customize it to adapt to the specific needs of your repository. You can configure options such as ignoring a set of targets used for testing or changing the Ruleset file. The Ruleset file allows you to customize which warnings will be run beyond the default behavior. You can select a predefined ruleset available in a Visual Studio install (inside the ‘Team ToolsStatic Analysis ToolsRule Sets’ directory) or reference a customized file checked-in to the source. For the best results create a custom ruleset that adds/removes warnings from official rulesets in VS. This will ensure you receive updated checks as more are developed. Refer to the <a href="https://docs.microsoft.com/cpp/code-quality/using-rule-sets-to-specify-the-cpp-rules-to-run?view=msvc-160">documentation on rulesets</a> for more information.</p>
<h3 id="example-ruleset">Example Ruleset</h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;RuleSet Name="Example" Description="Enable Warnings" ToolsVersion="10.0"&gt; 
  &lt;!-- Default rules available in Visual Studio --&gt;
  &lt;Include Path="NativeRecommendedRules.ruleset" Action="Default" /&gt; 
  &lt;Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis"     
         RuleNamespace="Microsoft.Rules.Native"&gt; 
    &lt;Rule Id="C26440" Action="None" /&gt; &lt;!-- Exclude: Declare noexcept --&gt;
    &lt;Rule Id="C26492" Action="None" /&gt; &lt;!-- Include: No const_cast&lt;&gt; --&gt; 
  &lt;/Rules&gt; 
&lt;/RuleSet&gt; </code></pre>
<h2 id="feedback">Feedback</h2>
<p>The action is published under a pre-release status as it is tested on additional GitHub repositories and more features are added. We would love to hear feedback from you on how we can improve the Action to make it compatible with your GitHub projects. If you have a need for Native MSBuild support, please express your interest on the following <a href="https://developercommunity.visualstudio.com/t/Add-Native-MSBuild-support-for-GitHub-Ac/1563225">feature request ticket</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">Microsoft C++ Code Analysis with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Mon, 25 Oct 2021 13:53:40 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[gamedev]]></category>
		<category><![CDATA[Intellisense]]></category>
		<category><![CDATA[unreal engine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29655</guid>

					<description><![CDATA[<p>With Visual Studio, we want to build the best tools to empower game developers. We joined forces with Epic Games to bring faster semantic highlighting and IntelliSense ready to Visual Studio 2022 for Unreal Engine developers. In this blog post, we will detail how we worked with the Unreal Engine team to significantly speed up the time it takes IntelliSense to start when a new file is opened in the editor by an order of 18x.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>With Visual Studio, we want to build the best tools to empower game developers. We joined forces with Epic Games to bring faster semantic highlighting and IntelliSense ready to Visual Studio 2022 for Unreal Engine developers. In this blog post, we will detail how we worked with the Unreal Engine team to significantly speed up the time it takes IntelliSense to start when a new file is opened in the editor by an order of <strong>18x</strong>.</p>
<p><strong><em>&#8220;We&#8217;ve always struggled with Intellisense performance in the Unreal Engine solution, but these changes are a night-and-day improvement. Faster feedback and less waiting help devs stay focused on making amazing games.&#8221;</em></strong> – Ben Marsh, Lead Programmer at Epic Games</p>
<p><strong>The changes are available for Unreal Engine 4.27.1 projects using the latest Visual Studio 2022 Preview. The changes will be available for Unreal Engine 5 at a later date.</strong></p>
<h1 id=""><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHOld30s.gif"><img class="aligncenter size-full wp-image-29684" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHOld30s.gif" alt="Image UnrealPCHOld30s" width="1200" height="675" /></a></h1>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHNew15s.gif"><img class="aligncenter size-full wp-image-29685" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHNew15s.gif" alt="Image UnrealPCHNew15s" width="1200" height="675" /></a></p>
<h2 id="testing-methodology">Testing Methodology</h2>
<p>We tested using an Unreal Engine 4.27.1 sample project on a desktop with Intel Core i7-9700 @ 3Ghz, 64GB RAM, and an SSD. The tests took place on Visual Studio 2019 16.11.5 and Visual Studio 2022 Preview 6. The results were averaged over 4 runs.</p>
<h2 id="results">Results</h2>
<p>When opening a file on Visual Studio 2019, it took <strong>11.0</strong> seconds for IntelliSense to be ready and semantic code colorization to show up. Opening a different file took the same amount of time to get to the same state. Closing and reopening the same file took <strong>1.0</strong> seconds for the ready state.</p>
<p>In comparison, Visual Studio 2022 took <strong>7.2</strong> seconds for the first file to be ready and <strong>0.4</strong> seconds for any subsequent files.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png"><img class="aligncenter size-full wp-image-29671" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png" alt="Image UnrealPCH" width="2273" height="1393" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png 2273w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-300x184.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-1024x628.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-768x471.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-1536x941.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-2048x1255.png 2048w" sizes="(max-width: 2273px) 100vw, 2273px" /></a></p>
<h2 id="analysis">Analysis</h2>
<p>Prior to the change, each translation unit, the C++ and header files in your project, started from scratch with no state reuse between them. Reopening the same file took 1 second; however, because PCHs were not shared between files, opening any file for the first time took the same amount of time for semantic highlighting to show up and IntelliSense to be ready.</p>
<p>In Unreal Engine 4.27.1 projects using Visual Studio 2022, the generated project files are updated to configure IntelliSense to share compilation state across translation units. As a result, the semantic code colorization and IntelliSense completion will be available drastically quicker (<strong>0.4 seconds</strong>) when switching files in Visual Studio.</p>
<p>In addition, C++ IntelliSense improvements in VS2022 were able to bring down ready time by a factor of <strong>1.5x</strong> from 11 seconds to 7.4 seconds. This change will benefit all C++ developers using IntelliSense, not only Unreal Engine developers.</p>
<h2 id="applying-the-change-to-your-project">Applying The Change to Your Project</h2>
<p>Currently, you will need to manually make an update in the Unreal Engine Editor to apply the changes.</p>
<ol>
<li>Click Edit -&gt; Editor Preferences -&gt; Source Code</li>
<li>Change Source Code Editor to “Visual Studio 2022”</li>
<li>Click File -&gt; Refresh Visual Studio 2022 Project</li>
<li>Click File -&gt; Open Visual Studio 2022 to open the project in Visual Studio</li>
</ol>
<p><em>If you use GenerateProjectFiles.bat when working with Unreal Engine source code, use “GenerateProjectFiles.bat -2022” to generate project files with changes.</em></p>
<h2 id="feedback-wanted">Feedback Wanted!</h2>
<p>We received feedback about various ways of making the game developer experiences even better in Visual Studio. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like the one detailed in this blogpost.</p>
<p>How will these productivity enhancements impact you as a game developer? What other enhancements do you wish to see in Visual Studio? Talk to us in the comments below, on Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h2 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h2>
<p><strong><a href="https://visualstudio.microsoft.com/launch/">Visual Studio 2022</a> is now available! </strong></p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>13</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Team at CppCon 2021</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 25 Oct 2021 11:45:06 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29688</guid>

					<description><![CDATA[<p>The Microsoft C++ team has an exciting lineup of sessions at CppCon 2021. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/">Microsoft C++ Team at CppCon 2021</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><img class="size-full wp-image-24953 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png" alt="Microsoft @ CppCon" width="760" height="466" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png 760w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp-300x184.png 300w" sizes="(max-width: 760px) 100vw, 760px" /></p>
<p>The Microsoft C++ team has an exciting lineup of sessions at <a href="https://cppcon.org/">CppCon 2021</a>. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks, products, or anything else! You can also join the <a href="https://aka.ms/cppcon/discord">#visual_studio channel on the CppCon Discord</a> to talk to us.</p>
<p>We’re also running a survey on the C++ ecosystem. If you have a moment, <a href="https://aka.ms/cppcon" target="_blank" rel="noopener noreferrer">please take our survey</a>, it&#8217;s quick.</p>
<p>Here’s the lineup:</p>
<h1 id="monday-october-25th">Monday, October 25<sup>th</sup></h1>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv1r/implementing-c-modules-lessons-learned-lessons-abandoned">Implementing C++ Modules: Lessons Learned, Lessons Abandoned</a> by Gabriel Dos Reis and Cameron DaCamara</p>
<h1 id="tuesday-october-26th">Tuesday, October 26<sup>th</sup></h1>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a id="37d29d70768539d44c325dcb13429b97" class="name" href="https://cppcon2021.sched.com/event/nv4b/documentation-in-the-era-of-concepts-and-ranges">Documentation in the Era of Concepts and Ranges</a> by Sy Brand and Christopher Di Bella (Google)</p>
<p><a href="https://cppcon2021.sched.com/event/o66J/extending-and-simplifying-c-thoughts-on-pattern-matching-using-is-and-as">Extending and Simplifying C++: Thoughts on Pattern Matching using <code>is</code> and <code>as</code></a> by Herb Sutter</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv4x/static-analysis-and-program-safety-in-c-making-it-real">Static Analysis and Program Safety in C++: Making it Real</a> by Sunny Chatterjee</p>
<p><strong>16:45 – 17:45 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv55/in-memory-and-persistent-representations-of-c">In-memory and Persistent Representations of C++</a> (on-site edition) by Gabriel Dos Reis</p>
<h1 id="wednesday-october-27th">Wednesday, October 27<sup>th</sup></h1>
<p><strong>12:30 – 13:30 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv55/in-memory-and-persistent-representations-of-c">In-memory and Persistent Representations of C++</a> (online edition) by Gabriel Dos Reis</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvBW/whats-new-in-visual-studio-64-bit-ide-c20-wsl-2-and-more">What&#8217;s New in Visual Studio: 64-bit IDE, C++20, WSL 2, and more</a> by Sy Brand and Marian Luparu</p>
<h1 id="thursday-october-28th">Thursday, October 28<sup>th</sup></h1>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvCA/c20s-dyachronodyagg-calendars-and-time-zones-in-msvc">C++20’s &lt;chrono&gt; Calendars and Time Zones in MSVC</a> by Miya Natsuhara</p>
<p><strong>14:00 – 15:00 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvCL/an-editor-can-do-that-debugging-assembly-language-and-gpu-kernels-in-visual-studio-code">An Editor Can Do That? Debugging Assembly Language and GPU Kernels in Visual Studio Code</a> by Julia Reid</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvCV/why-does-stdformat-do-that">Why does std::format do that?</a> by Charlie Barto</p>
<p><strong>16:45 – 17:45 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv7V/finding-bugs-using-path-sensitive-static-analysis">Finding Bugs Using Path-Sensitive Static Analysis</a> (in-person edition) by Gabor Horvath</p>
<h1 id="friday-october-29th">Friday, October 29<sup>th</sup></h1>
<p><strong>12:00 – 13:00 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv7V/finding-bugs-using-path-sensitive-static-analysis">Finding Bugs Using Path-Sensitive Static Analysis</a> (online edition) by Gabor Horvath</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/">Microsoft C++ Team at CppCon 2021</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>A Race Condition in .NET Finalization and its Mitigation for C++/CLI</title>
		<link>https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/</link>
					<comments>https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/#comments</comments>
		
		<dc:creator><![CDATA[Tanveer Gani]]></dc:creator>
		<pubDate>Fri, 15 Oct 2021 15:00:12 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28733</guid>

					<description><![CDATA[<p>Abstract<br />
There is a dormant race condition in .NET which affects even single threaded code when finalizers are executed. The cause is primarily the fact that finalizers are called on a separate thread by .NET and may access objects which have already been garbage collected due to aggressive lifetime determination by the .NET JIT compiler in newer versions of the .NET runtime.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/">A Race Condition in .NET Finalization and its Mitigation for C++/CLI</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h2 id="abstract">Abstract</h2>
<blockquote><p>There is a dormant race condition in <code>.NET</code> which affects even single threaded code when finalizers are executed. The cause is primarily the fact that finalizers are called on a separate thread by <code>.NET</code> and may access objects which have already been garbage collected due to aggressive lifetime determination by the <code>.NET</code> JIT compiler in newer versions of the <code>.NET</code> runtime.
A solution for this problem, in the form of automatic generation of calls to <code>System::GC::KeepAlive</code>, has been implemented in the Microsoft C++ compiler and is available in version 16.10 and later.</p></blockquote>
<h2 id="introduction">Introduction</h2>
<p>C++/CLI is primarily meant to be an interop language bridging the native
and <code>.NET</code> worlds efficiently. Consequently, a frequently occuring code
pattern is wrapping of native pointers in managed classes. E.g.</p>
<pre><code class="language-cpp">class NativeClass { ... };
ref class ManagedClass {
    ...
private:
    NativeClass* ptr;
};</code></pre>
<p>Often, the managed wrapper class will <code>new</code> an instance of
<code>NativeClass</code>, which controls and accesses a system resource (e.g. a
file), uses the resources and to make sure that the resource is properly
released back, delegates this task to the finalizer. Elaborating the
above example, we could have code like:</p>
<pre><code class="language-cpp"> 1  using Byte = System::Byte;
 2  using String = System::String^;
 3  using Char = System::Char;
 4
 5  class File {
 6      FILE*   fp;
 7  public:
 8      explicit File(const Char* path, const Char* mode)
 9      {
10          fp = _wfopen(path, mode);
11      }
12      void Read() { ... }
13      void Write(const void*, size_t) { ... }
14      void Seek() { ... }
15      void Close()
16      {
17          if (fp) {
18              fclose(fp); fp = nullptr;
19          }
20      }
21      ~File() { Close(); }
22  };

26   ref class DataOnDisk
27   {
28   public:
29       DataOnDisk(String path, String mode)
30       {
31           cli::pin_ptr&lt;const Char&gt; path_ptr = PtrToStringChars(path);
32           cli::pin_ptr&lt;const Char&gt; mode_ptr = PtrToStringChars(mode);
33           ptr = new File(path_ptr, mode_ptr);
34       }
35       ~DataOnDisk() { this-&gt;!DataOnDisk(); }
36       !DataOnDisk()
37       {
38           if (ptr) {
39               delete ptr; ptr = nullptr;
40           }
41       }
42       void Close() { this-&gt;!DataOnDisk(); }
43       void WriteData(array&lt;Byte&gt;^ data) { ... }
44   private:
45       File*           ptr;  // Pointer to native implementation class.
46   };</code></pre>
<p>In the above code, class <code>File</code> controls the actual file via the native
C++ interface, while <code>DataOnDisk</code> uses the native class to read/write
structured data to file (details have been omitted for clarity). While
<code>Close</code> can be called explicitly when there is no more use for the file,
the finalizer is meant to do this when the <code>DataOnDisk</code> object is
collected.</p>
<p>As we shall see in the following section, while the above code appears
correct, there is a hidden race condition that can cause program errors.</p>
<h2 id="race-condition">Race Condition</h2>
<p>Let us define the member <code>WriteData</code> from the above code</p>
<pre><code class="language-cpp">49  void DataOnDisk::WriteData(array&lt;Byte&gt;^ buffer)
50  {
51      pin_ptr&lt;Byte&gt; buffer_ptr = &amp;buffer[0];
52      this-&gt;ptr-&gt;Write(buffer_ptr, buffer-&gt;Length);
53  } </code></pre>
<p>This function itself might be called in this context:</p>
<pre><code class="language-cpp">55  void test_write()
56  {
57      DataOnDisk^ dd = gcnew DataOnDisk(...);
58      array&lt;Byte&gt;^ buf = make_test_data();
59      dd-&gt;WriteData(buf);
60  } </code></pre>
<p>So far, nothing catches the eye or looks remotely dangerous. Starting
from <code>test_write</code>, let us examine what happens in detail.</p>
<ol>
<li>A <code>DataOnDisk</code> object is created (line 57), some test data is
created and <code>WriteData</code> is called to write this data to file (line
59).</li>
<li>The <code>WriteData</code> carefully pins the buffer array object (line 51)
before taking the address of an element and calling the <code>Write</code>
member function of the underlying native <code>File</code> object. The pinning
is important because we don&#8217;t want <code>.NET</code> to move the buffer bytes
while the write is happening.</li>
<li>However, since the <code>.NET</code> garbage collector knows nothing about
native types, the <code>ptr</code> field of <code>DataOnDisk</code> is just a bit pattern
with no other meaning attached. The <code>.NET</code> JIT compiler has analyzed
the code and determined that the last use of the <code>dd</code> object is to
access <code>ptr</code> (line 52), before its value is passed as the implicit
object parameter of <code>File::Write</code>. Following this reasoning by the
JIT compiler, once the value of <code>ptr</code> is fetched from the object,
<em>the object <code>dd</code> is no longer needed</em> and becomes eligible for
garbage collection.The fact that <code>ptr</code> points to a live native
object is opaque to <code>.NET</code> because it does not track native
pointers.</li>
<li>From here onward, things can go wrong. The object <code>dd</code> is scheduled
for collection and as part of the process, the finalizer is run,
typically on a second thread. Now, we have potentially two things
happening at the same time without any ordering between them, a
classic race condition: the <code>Write</code> member function is executing and
the finalizer <code>!DataOnDisk</code> is executing as well, the latter will
<code>delete</code> the file object referenced by <code>ptr</code> <em>while <code>File::Write</code> is
possibly still running</em>, which can then result in a crash or other
incorrect behavior.</li>
</ol>
<h2 id="wait-wha">Wait &#8212; Wha&#8230;?</h2>
<p>Several questions immediately come to mind:</p>
<ul>
<li><em>Is this a new bug?</em> Yes &#8212; and no. The issue has potentially been
around since <code>.NET</code> 2.0.</li>
<li><em>What changed?</em> The <code>.NET</code> JIT compiler started being aggressive
with lifetime determination in <code>.NET</code> 4.8. From the perspective of
managed code, it is doing the right thing.</li>
<li><em>But, this affects a core C++/CLI native interop scenario. What can
be done?</em> Read on.</li>
</ul>
<h2 id="solutions">Solutions</h2>
<p>It is easy to see that when the call to <code>Write</code> happens (line 52), if
<code>this</code> is kept alive, the race condition disappears since <code>dd</code> will no
longer be collected before the call to <code>Write</code> returns. This could be
done in several different ways:</p>
<ul>
<li><em>Treat the change in the behavior of the JIT compiler as a bug and
revert back to old behavior.</em> Doing this requires a system update
for <code>.NET</code> and potentially disables optimizations. Freezing the
<code>.NET</code> framework at version 4.7 is also an option but not one that
will work in the longer term, especially since the same JIT behavior
can happen in <code>.NET</code> <code>Core</code> as well.</li>
<li><em>Manually insert <code>System::GC::KeepAlive(this)</code> calls where needed</em>.
This works but is error prone and requires examining the user source
and changing it, so this is not a viable solution for large source
bases.</li>
<li><em>Have the compiler inject <code>System::GC::KeepAlive(this)</code> calls, when
needed</em>. This is the solution we have implemented in the Microsoft
C++ compiler.</li>
</ul>
<h2 id="details">Details</h2>
<p>We could brute-force a solution by issuing a call to <code>KeepAlive</code> every
time we see a call to native function, but for performance reasons we
want to be more clever. We want to issue such calls where there is a
possibility of a race condition but nowhere else. The following is the
algorithm that the Microsoft C++ compiler follows to determine if an
implicit <code>KeepAlive</code> call is to be issued at a point in the code where:</p>
<ul>
<li>We are at a return statement or implicit return from a member
function of a managed class;</li>
<li>The managed class has a member of type &#8216;reference or pointer to
unmanaged type&#8217;, including members in its direct or indirect base
classes, or embedded in members of class-types occuring anywhere in
the class hierarchy;</li>
<li>A call to a function <code>FUNC</code> is found in the current (managed member)
function, which satisfies one or more of these conditions:</p>
<ol>
<li><code>FUNC</code> doesn&#8217;t have a <code>__clrcall</code> calling convention, or</li>
<li><code>FUNC</code> doesn&#8217;t take <code>this</code> either as an implicit or explicit
argument, or</li>
<li>A reference to <code>this</code> doesn&#8217;t follow the call to <code>FUNC</code></li>
</ol>
</li>
</ul>
<p>In essence, we are looking for indicators that show <code>this</code> is in no
danger of getting garbage collected during the call to <code>FUNC</code>. Hence, if
the above conditions are satisfied, we insert a
<code>System::GC::KeepAlive(this)</code> call immediately following the call to
<code>FUNC</code>. Even though a call to <code>KeepAlive</code> looks very much like a
function call in the generated MSIL, the JIT compiler treats it as a
directive to consider the current object alive at that point.</p>
<h2 id="how-to-get-the-fix">How to get the fix</h2>
<p>The above Microsoft C++ compiler behavior is <strong>on by default</strong> in Visual
Studio <strong>version 16.10</strong> and up but in in cases where unforeseen
problems occur due to the new implicit emission of <code>KeepAlive</code> calls,
the Microsoft C++ compiler provides two escape hatches:</p>
<ul>
<li>the driver switch <code>/clr:implicitKeepAlive-</code>, which turns off all
such calls in the translation unit. This switch is not available in
project system settings but must be added explicitly to the
command-line option list
(<code>Property Pages &gt; Command Line &gt; Additional Options</code>).</li>
<li><code>#pragma implicit_keepalive</code>, which provides fine-grained control
over the emission of such calls at the function level.</li>
</ul>
<h2 id="a-final-nit">A Final Nit</h2>
<p>The astute reader will have noted that there is still a possible race
condition at line 39. To see why, imagine that both the finalizer thread
and user code call the finalizer at the same time. The possibility of a
double-delete in this case is obvious. Fixing this requires a critical
section but is beyond the scope of this article and left to the reader
as an exercise.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/">A Race Condition in .NET Finalization and its Mitigation for C++/CLI</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</title>
		<link>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Fri, 08 Oct 2021 18:50:59 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29173</guid>

					<description><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/">Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">C++ Developer Community</a> page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the detailed overview of a new experimental <a href="https://docs.microsoft.com/cpp/build/reference/analyze-code-analysis">code analysis</a> check that can detect null pointer dereference errors, along with a comparison to an existing check that has the same purpose.</p>
<h2 id="overview">Overview</h2>
<p>Internally, we have multiple analysis engines. This is opaque from the users’ point of view; warnings are surfaced identically regardless of the engine we used to implement them. One of our code analysis tools, has a number of checks to catch null pointer dereference errors. These include <a href="https://aka.ms/cpp/warnings/C6011">C6011</a>, <a href="https://aka.ms/cpp/warnings/C6387">C6387</a>, and <a href="https://aka.ms/cpp/warnings/C28196">C28196</a>. While these warnings have historically been successful and prevented many errors, they do not work well with some aspects of modern C++. Moreover, the data flow framework they are written in has its limitations. EspXEngine was created to solve most of these problems. We already ship many analyses that are based on EspXEngine’s powerful path-sensitive data flow analysis including <a href="https://devblogs.microsoft.com/cppblog/concurrency-code-analysis-in-visual-studio-2019/">Concurrency Check</a> and <a href="https://devblogs.microsoft.com/cppblog/new-code-analysis-checks-in-visual-studio-2019-use-after-move-and-coroutine/">Use After Move Check</a>. The success of these checks convinced us to port null pointer analysis to EspXEngine. We are excited to make the new version available to try which introduces many improvements compared to the old one. The rest of the blog post is an in-depth overview of some of the improvements and gives some hints how to use power-user features like annotations.</p>
<h2 id="path-sensitive-analysis">Path-sensitive analysis</h2>
<p>Both analysis engines are capable of path-sensitive analysis. Let’s consider the example below to understand what this means:</p>
<pre><code class="language-c++">void path_sensitive(int *p, bool cond) { 
    int state = 0; 

    // branch 1  
    if (p != nullptr) { 
        state = 1; 
    } 

    // branch 2 
    if (cond) { 
        state = 2; 
        p = nullptr; 
    } 

    // branch 3 
    if (state == 1) { 
        *p = 42; // Null dereference? 
    } 
} </code></pre>
<p>The code above has multiple branches. Some of those branches are correlated, but flow-sensitive analyses will not reason about these correlations. For instance, a flow-sensitive analysis might conclude that the code is unsafe due to a potential null-dereference, since <code>p</code> is set to <code>nullptr</code> in branch 2, and then dereferenced in branch 3. However, this would be a false positive because branch 3 <strong>cannot</strong> be reached if branch 2 has been taken. Path-sensitive analyses, on the other hand, do reason about these types of reachability conditions, and would therefore conclude that the code above is safe. As a result, path-sensitive analyses are more precise. But, this precision comes at the cost of analysis time and memory. Both engines have identical behavior on this code snippet.</p>
<h2 id="local-analysis">Local analysis</h2>
<p>Both engines are doing intraprocedural analysis. They cannot see across function boundaries and rely on types, type extensions, models and contracts to bridge the gap.</p>
<pre><code class="language-c++">void local_analysis(int *p, int *q, bool cond) { 
    if (p == nullptr) 
        return; 
    q = nullptr; 
    std::swap(p, q); 
    *p = 42; // Null dereference 
} </code></pre>
<p>The code above has a bug. The pointer <code>p</code> is <code>nullptr</code> due to the call to swap. This bug is not found by the current check. However, EspXEngine models some common APIs. As a result, it can figure out the bug and report a warning to the user.</p>
<p>Unfortunately, when we call our own APIs, EspXEngine will not know the semantics of the called function. In those cases, we can use types or <a href="https://docs.microsoft.com/cpp/code-quality/understanding-sal?view=msvc-160">SAL annotations</a> to describe the pre- and postconditions of our functions:</p>
<pre><code class="language-c++">_Notnull_ int *get_my_ptr(); 
gsl::not_null&lt;int *&gt; get_my_ptr2(); 
void local_analysis(int *p) { 
    _Analysis_assume_(p != nullptr); 
    *p = 42; 
} </code></pre>
<p>In the code above, we use the <code>_Notnull_</code> and <code>_Analysis_assume_</code> SAL annotations to describe the constraints on the values of some pointers. This is supported by both engines. A more modern approach is to use rich types to express these contracts. This is only supported in EspXEngine. Moreover, it will flag code where a null pointer is stored into a <a href="https://github.com/microsoft/GSL"><code>gsl::not_null</code></a> pointer:</p>
<pre><code class="language-c++">void assign_to_gsl_notnull() { 
    int* p = nullptr; 
    auto q = gsl::make_not_null(p); // C26822 warning 
} </code></pre>
<p>While types are great to encode our expectations, SAL has the power to express a wider range of contracts. Consider the example below:</p>
<pre><code class="language-c++">void postcondition_conditional(bool b, _When_(b == true, _Outptr_) int** p)  { 
    if (b == true) 
        *p = nullptr; // C26824 warning 
} </code></pre>
<p>This function has a complex postcondition. Whenever the first argument is true, the value at location <code>*p</code> must be not-<code>null</code> when the function exists. These contracts are understood by both engines (although the support in EspXEngine is more sophisticated) and many Windows APIs are annotated to describe their behavior. We would love to use a standard language facility, but the contracts proposal was not accepted for C++20 and we need a solution that work both for C and C++ APIs.</p>
<h2 id="some-problems-with-our-existing-null-pointer-checks">Some problems with our existing null pointer checks</h2>
<p>I wanted to showcase some examples where the null pointer check based on EspXEngine has better behavior than the current one. First of all, there are some low easy to catch null pointer dereferences that are not found by the current checks:</p>
<pre><code class="language-c++">void nullptr_constant_dereference() { 
    *(int*)nullptr = 5; // Previously, it was not found. 
} </code></pre>
<p>There are also cases where they were noisier:</p>
<pre><code class="language-c++">struct Node { 
    int number; 
    Node* next; 
}; 

void add_number(Node*&amp; head, Node*&amp; tail, int data) { 
    if (head != nullptr) { 
        tail-&gt;next = (Node*)malloc(sizeof(Node)); 
        tail = tail-&gt;next; 
    } else { 
        head = (Node*)malloc(sizeof(Node)); 
        tail = head; 
    } 
    tail-&gt;number = data; // C6011 warning 
    tail-&gt;next = nullptr; 
} </code></pre>
<p>In the code above the current version will give a null pointer dereference warning on the line with the comment. Technically, this warning could be a true positive when <code>malloc</code> fails and returns a <code>nullptr</code>. This is a scenario that is irrelevant for many applications. EspXEngine has both low and high confidence warnings and will only emit a low confidence warning in this case. Most users are probably only interested in the high confidence warnings that are expected to have less noise and turn the low confidence warnings off.</p>
<p>Moreover, we decided to make EspXEngine stricter detecting various undefined behavior:</p>
<pre><code class="language-c++">void method_null_dereference(Foo* p, Foo* q) { 
    if (p || q) 
        return; 

    p-&gt;method();            // C26822 warning 
    q-&gt;static_method(42);   // OK, not UB.  
} </code></pre>
<p>In the code above, contrary to EspXEngine, the current warning will not warn when we call a method on a null pointer. Strictly speaking, this code has undefined behavior, but many implementations will work fine when <code>method</code> does not dereference the <code>this</code> pointer.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The upcoming Visual Studio 2022 17.0 Preview 4 will feature new, experimental checks to find null pointer dereference errors. These checks are intended to be better versions of the current ones with improved precision and additional features. These new checks are doing in-depth analysis and are expected to increase the analysis time. They are off by default and can be enabled by using the <code>CppCoreCheckExperimentalRules</code> ruleset.</p>
<h2 id="try-it-out-and-let-us-know-what-you-think">Try it out and let us know what you think:</h2>
<p>The work that we do is heavily influenced by feedback we receive on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check. Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/">Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Static Analysis Fixes in Visual Studio 2019 version 16.11</title>
		<link>https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/</link>
					<comments>https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Mon, 13 Sep 2021 15:00:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28697</guid>

					<description><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/">Static Analysis Fixes in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/search?space=62">C++ Developer Community page</a>. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the compilation of bug fixes that were made from Visual Studio 2019 version 16.10 to 16.11 for code analysis.  Note that 16.11 is the last non-servicing release of Visual Studio 2019, so the focus was on stabilization and minor improvements rather than new features (stay tuned for updates in 17.0). We also found time to improve the performance of certain checks. The changes are summarized below:</p>
<ul>
<li>Clarified the warning message for <a href="https://aka.ms/cpp/warnings/C26445">C26445</a>. The old message implied that there is a lifetime problem. The new message is: “Do not assign <code>gsl::span</code> or <code>std::string_view</code> to a reference. They are cheap to construct and are not owners of the underlying data. (gsl.view)”</li>
<li>Fixed false positive due to not considering lifetime extension rules in <a href="https://aka.ms/cpp/warnings/C26444">C26444</a>. See the code example below:</li>
</ul>
<pre class="prettyprint">struct MyStruct { int i; }; 
void example() { 
  const MyStruct&amp; s = {}; // Previously, false positive C26444 was emitted. 
}</pre>
<ul>
<li>Fixed using <code>ALL_CPPCORECHECK_WARNINGS</code> in suppression would not suppress <a href="https://aka.ms/cpp/warnings/C26457">C26457</a>.</li>
<li>Fixed a problem where certain control flows could trick Concurrency Check into emitting false positive warnings.</li>
<li>Fixed a false positive in Concurrency Check due to incorrect modelling of unwinding paths (for exceptions). This fixed the false positive below. Previously, analysis would proceed along the exception path of the constructor call (no lock is acquired in the exception path), leading to a false warning.</li>
</ul>
<pre class="prettyprint">mutex mtx; 
mutex&amp; mutexRef() { return mtx; } 
void test() { 
  lock_guard&lt;mutex&gt; lock(mutexRef()); // No C26110 (failing to hold lock) 
}</pre>
<ul>
<li>Fixed a compilation failure of code snippets relying on guaranteed copy elision during code analysis.</li>
</ul>
<pre class="prettyprint">struct S { 
  S(const S&amp; o) = delete; 
  S&amp; operator=(const S&amp; o) = delete; 
  S(const S&amp;&amp; o) = delete; 
  S&amp; operator=(const S&amp;&amp; o) = delete; 
  static const S foo(); 
};

void bar() {
  S s = S::foo(); // Used to trigger compilation failure.
}

</pre>
<ul>
<li>Fixed a <a href="https://developercommunity.visualstudio.com/t/Codeanalysis-warning-C6285-in-STL-functi/1429721">bug</a> that caused the <a href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">/external</a> options for specifying external headers to override CAExcludePath and generate warnings for external files.</li>
<li>Performance improvements to the checker that reports warnings on misuse of `VARIANT`s (warnings <a href="https://docs.microsoft.com/cpp/code-quality/c33001?view=msvc-160">C33001</a>, <a href="https://docs.microsoft.com/cpp/code-quality/c33004?view=msvc-160">C33004</a>, and <a href="https://docs.microsoft.com/cpp/code-quality/c33005?view=msvc-160">C33005</a>). Please refer to &#8220;<a href="https://devblogs.microsoft.com/cppblog/new-safety-rules-in-c-code-analysis/">New Safety Rules for in C++ Code Analysis</a>&#8221; for more information on these warnings.</li>
<li>Performance improvements to the checker that reports warnings on misuse of enum values as an index (warnings <a href="https://docs.microsoft.com/cpp/code-quality/c33010?view=msvc-160">C33010</a> and <a href="https://docs.microsoft.com/cpp/code-quality/c33011?view=msvc-160">C33011</a>). Please refer to “<a href="https://devblogs.microsoft.com/cppblog/even-more-new-safety-rules-in-c-code-analysis/">Even More Safety Rules in C++ Code Analysis</a>” for more information on these warnings. Improved the performance of pointer safety related C++ Core Guidelines checks. See <code>OWNER_POINTER</code>, <code>RAW_POINTER</code>, <code>UNIQUE_POINTER</code>, and <code>SHARED_POINTER</code> groups here.</li>
<li>Fixed some memory leaks in some checks when multiple translation units are analyzed in a single compiler invocation.</li>
</ul>
<h2 id="fixes-in-16-11-1-to-16-11-3-servicing-releases">Fixes in 16.11.1 to 16.11.3 servicing releases</h2>
<ul>
<li>Fixed a crash when <code>__uuidof </code>was used in a template argument a certain way.</li>
<li>Fixed a rare crash when SAL annotations refer to fields of unnamed <code>struct</code>s.</li>
</ul>
<h2 id="try-it-out%e2%80%afand-let-us-know-what-you-think">Try it out and let us know what you think</h2>
<p>The work that we do is heavily influenced by feedback we receive on <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check.   Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or @VisualC on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/">Static Analysis Fixes in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/static%e2%80%afanalysis-fixes-in-visual-studio-2019-version-16-11/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC C++20 and the /std:c++20 Switch</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Griffing]]></dc:creator>
		<pubDate>Thu, 02 Sep 2021 21:18:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28674</guid>

					<description><![CDATA[<p>We are excited to announce that in Visual Studio 2019 version 16.11, we have added the /std:c++20 switch to the set of language mode switches available. The addition of this switch indicates that we’ve reached a point of sufficient stabilization of the MSVC C++20 feature set for it be used in production,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">MSVC C++20 and the /std:c++20 Switch</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are excited to announce that in Visual Studio 2019 version 16.11, we have added the <code>/std:c++20</code> switch to the set of language mode switches available. The addition of this switch indicates that we’ve reached a point of sufficient stabilization of the MSVC C++20 feature set for it be used in production, with full support in VS servicing updates.</p>
<p>This blog post focuses on describing our level of C++20 feature support, compiler-supported extensions, and the remaining feature set differences between MSVC and the ISO C++ standard as of Visual Studio 2019 version 16.11 and Visual Studio 2022 version 17.0</p>
<h2 id="c-language-modes-and-compatibility-guarantees"><span style="font-size: 18pt;">C++ Language Modes and Compatibility Guarantees</span></h2>
<p>First <a href="https://devblogs.microsoft.com/cppblog/standards-version-switches-in-the-compiler/">introduced in Visual Studio 2015</a>, the MSVC compiler has included C++ language mode switches to indicate the targeted level of standard conformance and we now support three stable language modes: <code>/std:c++14</code>, <code>/std:c++17</code>, <code>/std:c++20</code> (as of VS 2019 v16.11) and one preview mode (<code>/std:c++latest</code>).</p>
<p>The stable modes indicate that features under those modes are ready for production use and have ABI compatibility guarantees. The <code>/std:c++latest</code> mode contains ISO C++ features without strong guarantees for compatibility, allowing iteration based upon issues identified in testing, ISO C++ standard changes, and community feedback which may impact ABI stability of those features. Once stabilized, features under /std:c++latest will be moved under an applicable stable mode.</p>
<table>
<tbody>
<tr>
<td width="105"><strong>Language Mode</strong></td>
<td width="219"><strong>Language Mode enables strict-conformance (/permissive-)</strong></td>
<td width="91"><strong>ABI Stable</strong></td>
<td width="208"><strong>Notes</strong></td>
</tr>
<tr>
<td width="105">/std:c++14</td>
<td width="219">No</td>
<td width="91">Yes</td>
<td width="208">See <strong>**<em>Note A</em></strong></td>
</tr>
<tr>
<td width="105">/std:c++17</td>
<td width="219">No</td>
<td width="91">Yes</td>
<td width="208">See <strong>**<em>Note A</em></strong></td>
</tr>
<tr>
<td width="105">/std:c++20</td>
<td width="219">Yes</td>
<td width="91">Yes</td>
<td width="208">See <strong>**<em>Note B</em></strong></td>
</tr>
<tr>
<td width="105">/std:c++latest</td>
<td width="219">Yes</td>
<td width="91">No</td>
<td width="208">See <strong>**<em>Note B</em></strong></td>
</tr>
</tbody>
</table>
<p><strong><em>**</em></strong><strong><em>Note A</em></strong><em>: Strict conformance mode is opt-in via the /permissive- compiler switch</em></p>
<p><strong><em>**Note B</em></strong><em>: Some functionality such as C++20 Modules require strict-conformance mode to be enabled due to strong dependency on ISO C++ semantic behaviors. Compatibility mode (/permissive) is supported as an opt-in switch  with some C++20 functionality disabled.</em></p>
<h2 id="c20-features-added-in-vs-2019-v16-9-and-later"><span style="font-size: 18pt;">C++20 Features added in VS 2019 v16.9 and later</span></h2>
<p>Below is a summary of language and library C++20 features implemented since the last feature update.</p>
<p>A more detailed <a href="https://github.com/microsoft/STL/wiki/Changelog">changelog</a> is available for <a href="https://github.com/microsoft/STL">the STL on its GitHub repo</a> including information on the awesome community contributors who have provided feature implementations and bug fixes to the STL</p>
<h3 id="vs-2019-v16-9"><span style="font-size: 14pt;">VS 2019 v16.9</span></h3>
<p>C++20 Language Features</p>
<ul>
<li>Implemented <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0634r3.html">P0634R3</a> Down with typename!</li>
<li>Implemented <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0840r2.html">P0840R2</a> [[no_unique_address]] attribute (<em>please see below for more details</em>)</li>
<li>Implemented <a href="https://wg21.link/P1064R0">P1064R0</a> Allowing virtual function calls in constant expressions</li>
<li>Implemented <a href="https://wg21.link/P1141R2">P1141R2</a> Yet another approach for constrained declarations</li>
<li>Implemented <a href="https://wg21.link/P1327R1">P1327R1</a> Allowing dynamic_cast, polymorphic typeid in constant expressions</li>
<li>Implemented <a href="https://wg21.link/P1668R1">P1668R1</a> Permitting unevaluated inline assembly in constexpr functions</li>
<li>Implemented <a href="https://wg21.link/P0784R7">P0784R7</a> More constexpr containers</li>
</ul>
<p>C++20 Library Features</p>
<ul>
<li>Implemented <a href="https://wg21.link/P0339R6">P0339R6</a> polymorphic_allocator&lt;&gt;</li>
<li>Implemented <a href="https://wg21.link/P0660R10">P0660R10</a> &lt;stop_token&gt; And jthread</li>
<li>Implemented <a href="https://wg21.link/P0768R1">P0768R1</a> Library Support For The Spaceship Comparison Operator &lt;=&gt;</li>
<li>Implemented <a href="https://wg21.link/P1007R3">P1007R3</a> assume_aligned()</li>
<li>Implemented <a href="https://wg21.link/P1020R1">P1020R1</a> Smart Pointer Creation With Default Initialization</li>
<li>Implemented <a href="https://wg21.link/P1771R1">P1771R1</a> [[nodiscard]] For Constructors</li>
</ul>
<h3 id="vs-2019-v16-10-v16-11"><span style="font-size: 14pt;">VS 2019 v16.10 &amp; v16.11</span></h3>
<p>C++20 Language Features</p>
<ul>
<li>Implemented <a href="https://wg21.link/P1073R3">P1073R3</a> Immediate functions</li>
<li>Implemented <a href="https://wg21.link/P1143R2">P1143R2</a> constinit</li>
<li>Implemented <a href="https://wg21.link/P1353R0">P1353R0</a> Missing feature-test macros</li>
</ul>
<p>C++20 Library Features</p>
<ul>
<li>Implemented <a href="https://wg21.link/P0053R7">P0053R7</a>&lt;syncstream&gt;</li>
<li>Implemented <a href="https://wg21.link/P0355R7">P0355R7</a>&lt;chrono&gt; Calendars And Time Zones</li>
<li>Implemented <a href="https://wg21.link/P0408R7">P0408R7</a> Efficient Access To basic_stringbuf&#8217;s Buffer</li>
<li>Implemented <a href="https://wg21.link/P0466R5">P0466R5</a> Layout-Compatibility And Pointer-Interconvertibility Traits</li>
<li>Implemented <a href="https://wg21.link/P0475R1">P0475R1</a> Guaranteed Copy Elision For Piecewise Construction</li>
<li>Implemented <a href="https://wg21.link/P0591R4">P0591R4</a> Utility Functions For Uses-Allocator Construction</li>
<li>Implemented <a href="https://wg21.link/P0608R3">P0608R3</a> Improving variant&#8217;s Converting Constructor/Assignment</li>
<li>Implemented <a href="https://wg21.link/P0645R10">P0645R10</a> &lt;format&gt; Text Formatting</li>
<li>Implemented <a href="https://wg21.link/P0784R7">P0784R7</a> Library Support For More constexpr Containers</li>
<li>Implemented <a href="https://wg21.link/P0896R4">P0896R4</a> Ranges</li>
<li>Implemented <a href="https://wg21.link/P0980R1">P0980R1</a> constexpr std::string</li>
<li>Implemented <a href="https://wg21.link/P1004R2">P1004R2</a> constexpr std::vector</li>
<li>Implemented <a href="https://wg21.link/P1208R6">P1208R6</a> &lt;source_location&gt;</li>
<li>Implemented <a href="https://wg21.link/P1502R1">P1502R1</a> Standard Library Header Units</li>
<li>Implemented <a href="https://wg21.link/P1614R2">P1614R2</a> Adding Spaceship &lt;=&gt; To The Library</li>
</ul>
<h2 id="vs-2022-17-0-still-in-preview"><span style="font-size: 14pt;">VS 2022 17.0 (still in Preview)</span></h2>
<p>C++20 Language Features</p>
<ul>
<li>Completed implementation of <a href="https://wg21.link/P0734R0">P0734R0</a> Concepts</li>
</ul>
<p>C++20 Library DRs</p>
<ul>
<li>Implemented <a href="https://wg21.link/P2325R3">P2325R3</a> Views Should Not Be Required To Be Default Constructible</li>
</ul>
<h2 id="iso-c20-continuing-work-defect-reports-and-clarifications"><span style="font-size: 18pt;">ISO C++20  Continuing Work, Defect Reports, and Clarifications</span></h2>
<p>As part of implementing C++20, there were some late discoveries which required changes to the ISO C++20 standard via the standard committee’s Defect Report (DR) process. This included Existing implementations (pre-DR) for these features are available under the <code>/std:c++latest</code> switch.  We’re also tracking the DRs and are implementing those issue resolutions under <code>/std:c++latest</code>. Our plan is to make these capabilities available under the <code>/std:c++20</code> switch after implementation of the full set of Standard Library DRs has completed. Progress on these features can be tracked on the <a href="https://github.com/microsoft/STL">MSVC STL GitHub site</a> through its <a href="https://github.com/microsoft/STL/projects/9">C++20 DRs project</a>.</p>
<p>In the compiler, we are working with ISO C++ and other toolchain vendors to clarify expectations around allowing virtual functions to be <code>constexpr</code> (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1064r0.html">P1064R0</a>). There are a couple of possibilities for implementation, which have significant ABI implications as to whether this is implemented via vtable entry. In the interim, we have implemented two modes, under <code>/experimental:constevalVfuncVtable</code> and <code>/experimental:constevalVfuncNoVtable</code>, which implement the most likely resolutions to this ambiguity. Once a decision is made on how to proceed, we’ll bring that capability under <code>/std:c++20</code> and <code>/std:c++latest</code>.</p>
<p>Additionally, there were some feature areas that were unintentionally partially implemented. We are working to get those areas filled. For VS 2022 v17.0, we have implemented the requires-expression portion of the Concepts feature (<a href="https://wg21.link/P0734R0">P0734R0</a>), which is scheduled to ship in VS 2022 v17.0.  We’re also working to complete implementation of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0859r0.html">Core Issue 1581</a>: “When are constexpr member functions defined?,” which is tracking towards inclusion in a VS 2022 update after v17.0.</p>
<h2 id="msvc-extensions-and-abi"><span style="font-size: 18pt;">MSVC Extensions and ABI</span></h2>
<h3 id="c20-no_unique_address"><span style="font-size: 14pt;">C++20 <code>[[no_unique_address]]</code></span></h3>
<p>Implementation of C++20 <code>[[no_unique_address]]</code> included a couple of additional challenges due to the ABI-breaking impact (changing object layout) of applying this optimization. This is problematic due to the MSVC compiler ignoring attributes that are not known, as allowed by the standard, resulting in scenarios where MSVC ABI compatibility guarantees would be broken for standard C++ code:</p>
<ul>
<li>Compiling the same header/source under <code>/std:c++17</code> and <code>/std:c++20</code> would result in link-time incompatibilities due to object layout differences resulting in ODR violations.</li>
<li>Linking static libraries built with an older version of the MSVC compiler (VS 2015 through VS 2019 v16.8), within the v14x ABI-compatible family, would result in ODR violations and break our compatibility guarantees.</li>
</ul>
<p>It was decided to hold-off on enabling the optimization for the <code>[[no_unique_address]]</code> attribute in the MSVC compiler until our next ABI breaking revision of the MSVC toolset, where it will be enabled across all language modes.</p>
<p>However, we do recognize that there are some customers who are in a position to take advantage of this optimization without worrying about linking binaries across versions of the MSVC toolset.  For this audience, we have made this optimization available in VS 2019 v16.9 and later through an extension attribute that affects optimization across all compiler language modes, <code>[[msvc::no_unique_address]]</code>.</p>
<ul>
<li>There are portability concerns for customers who require ABI-compatiblity between MSVC and Clang for the STL. Please see <a href="https://github.com/microsoft/STL/issues/1364">https://github.com/microsoft/STL/issues/1364</a> for more details.</li>
<li>This extension attribute enables this optimization under all C++ language modes (e. <code>/std:c++14</code>, <code>/std:c++17</code>, <code>/std:c++20</code>, <code>/std:c++latest</code>.</li>
<li>We strongly recommend that any usage of this attribute is guarded by an MSVC version-check as demonstrated in the below example:</li>
</ul>
<pre class="prettyprint">#include &lt;iostream&gt;

#if _MSC_VER &gt;= 1929 // VS2019 v16.10 and later (_MSC_FULL_VER &gt;= 192829913 for VS 2019 v16.9)
// Works with /std:c++14 and /std:c++17, and performs optimization

#define NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]

#else

// no-op in MSVC v14x ABI
#define NO_UNIQUE_ADDRESS /* [[no_unique_address]] */

#endif


struct Empty {};

struct A
{
    int a;
    NO_UNIQUE_ADDRESS Empty b;
};

int main()
{
    A inst{ 0 };

    // [[msvc::no_unique_address]] : sizeof(inst) == 4.
    // [[no_unique_address]] : sizeof(inst) == 8.
    std::cout &lt;&lt; sizeof(inst) &lt;&lt; "\n";
}</pre>
<h3 id="c20-coroutine-support-for-c14-c17-awaitstrict"><span style="font-size: 14pt;">C++20 Coroutine support for C++14/C++17 (<code>/await:strict</code>)</span></h3>
<p>The <code>/await:strict</code> option can be used in place of <code>/await</code> for C++20 compatible coroutine support in projects that build in C++14 or C++17 mode. In <code>/await:strict</code> mode library support is provided in <code>&lt;coroutine&gt;</code> and in the std namespace. For full clarity, this behavior is on-by-default under <code>/std:c++20</code> without any <code>/await*</code> switch usage.</p>
<p>Strict mode disables language extensions present in <code>/await</code> that were not adopted into the C++20 standard. Use  of such features with <code>/await:strict</code> will result in a compiler error. Strict mode also implements coroutine behaviors such as promise parameter preview that are not available under <code>/await</code> due to binary compatibility issues with older releases.</p>
<p>Note: coroutine state objects obtained from <code>coroutine_handle&lt;T&gt;::address()</code> are not compatible between <code>/await</code> and <code>/await:strict</code> modes. Using <code>coroutine_handle&lt;T&gt;::from_address()</code> on an address obtained from a coroutine handle created in an incompatible mode will result in undefined behavior.</p>
<h2 id="more-information"><span style="font-size: 18pt;">More Information</span></h2>
<p>For Visual Studio changes (beyond the C++ toolset) and download links, see the <a href="https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes">VS 2019 Release Notes</a> and  <a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview">VS 2022 Preview Release Notes</a>. You can report bugs through <a href="https://developercommunity.visualstudio.com/spaces/62/index.html">Developer Community</a>, and you can also report STL bugs via <a href="https://github.com/microsoft/STL/issues">microsoft/STL GitHub issues</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">MSVC C++20 and the /std:c++20 Switch</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>C++20 Coroutine Improvements in Visual Studio 2019 version 16.11</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/#comments</comments>
		
		<dc:creator><![CDATA[Jonathan Emmett]]></dc:creator>
		<pubDate>Tue, 31 Aug 2021 14:32:18 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Coroutine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28354</guid>

					<description><![CDATA[<p>This post includes contributions from Terry Mahaffey and Ramkumar Ramesh.<br />
We last blogged about coroutine support in Visual Studio 2019 version 16.8. In the releases since 16.8 we&#8217;ve introduced several new coroutine features and improvements. This post is a round up of those improvements,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/">C++20 Coroutine Improvements in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><em>This post includes contributions from Terry Mahaffey and Ramkumar Ramesh.</em></p>
<p>We last blogged about coroutine support in <a href="https://devblogs.microsoft.com/cppblog/c-coroutines-in-visual-studio-2019-version-16-8/">Visual Studio 2019 version 16.8</a>. In the releases since 16.8 we&#8217;ve introduced several new coroutine features and improvements. This post is a round up of those improvements, all available in Visual Studio 2019 16.11.</p>
<div>
<h2 id="debugging-improvements">Debugging Improvements</h2>
</div>
<p>Since Visual Studio 2019 version 16.9, stepping into a coroutine call will now land directly in the coroutine body (unless it is set to initially suspend, in which case the step becomes a “step over”). Stepping over a <code>co_await</code> will land in the logical statement following <code>co_await</code> for the coroutine &#8211; which may be in a completely different execution context (even another thread)! This allows stepping through coroutines to seamlessly match the logical flow of the application and skip intermediate implementation details. For the best debugging experience, implementation details of the coroutine state should be marked as <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/just-my-code?view=vs-2019#BKMK_C___Just_My_Code">non-user code</a>. Stepping through coroutines now also shows function parameters as expected in the Locals window so you can see the state of the application, similar to stepping through synchronous functions.</p>
<p>Inspecting the state of a suspended coroutine is now easier with some improvements to the debugging visualizers for standard coroutines. The legacy <code>coroutine_handle</code> visualizers could display special indicators for the initial and final suspend points, but only showed a number for other suspend points. This number was not always easy to map back to a particular point in the original coroutine. The visualizer also showed the name of the coroutine but only as a modified, internal name generated by the implementation with no signature information.</p>
<p><figure id="attachment_28609" aria-describedby="caption-attachment-28609" style="width: 1446px" class="wp-caption aligncenter"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2.png"><img class="wp-image-28609 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2.png" alt="Image of legacy coroutine handle visualizer shows name as &quot;sample_coroutine$_ResumeCoro$1(void)&quot;" width="1446" height="106" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2.png 1446w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2-300x22.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2-1024x75.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/legacy_handle_visualizer_2-768x56.png 768w" sizes="(max-width: 1446px) 100vw, 1446px" /></a><figcaption id="caption-attachment-28609" class="wp-caption-text">Legacy visualizer shows the name as &#8220;sample_coroutine$_ResumeCoro$1(void)&#8221;</figcaption></figure></p>
<p>With the new coroutine handle visualizer introduced in Visual Studio 2019 16.10 the function name is now correct and includes full signature information to help distinguish overloaded coroutines. The suspend point information for suspend points other than initial and final suspend also includes the source line number to make it easier to find.</p>
<p><figure id="attachment_28608" aria-describedby="caption-attachment-28608" style="width: 1205px" class="wp-caption aligncenter"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2.png"><img class="wp-image-28608 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2.png" alt="Image of new coroutine handle visualizer with name &quot;sample_coroutine(int)&quot; and suspend point line number" width="1205" height="80" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2.png 1205w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2-300x20.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2-1024x68.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/08/new_handle_visualizer_2-768x51.png 768w" sizes="(max-width: 1205px) 100vw, 1205px" /></a><figcaption id="caption-attachment-28608" class="wp-caption-text">New visualizer shows the name as &#8220;sample_coroutine(int)&#8221; and is suspended on line 35</figcaption></figure></p>
<h2 id="awaitstrict">/await:strict</h2>
<p><span style="font-size: 1rem;">The <a href="https://devblogs.microsoft.com/cppblog/c-coroutines-in-visual-studio-2019-version-16-8/">earlier blog post</a> outlines some issues with legacy await mode and the rationale for keeping the <code>/await</code> switch distinct from C++20 coroutine support in <code>/std:c++latest</code>. Legacy mode is useful for users who were early adopters of C++ coroutines, but they are not standard coroutines. </span></p>
<div>
<div>The<code>/await</code> switch predates not only our <code>/std:c++latest</code> and <code>/std:c++20</code> switches but also <code>/std:c++17</code>. Early adopters were able to make use of coroutines long before they became part of the C++ standard. These users could use coroutines without requiring their code to be C++20 conformant or even necessarily C++17 conformant. With standard coroutines available only under C++20 and latest modes, early adopters of coroutines who cannot move their code to a more recent language version were stuck with the legacy implementation of coroutines under<code>/await</code>. They could not take advantage of some new features like symmetric transfer and improved debugger support, even if they were willing to make source changes to the coroutines themselves to bring them in line with the C++20 standard.</div>
<div>
<div>
<div></div>
<div>Starting in Visual Studio 2019 version 16.10 we introduced a new switch to help early coroutine adopters transition to conformant coroutines and use all features available in standard coroutines: <code>/await:strict</code>. Using this switch instead of <code>/await</code> enables the same C++20 coroutine support as standard mode but without all the other requirements of <code>/std:c++20</code>. This includes support for all standard C++20 coroutine features and debugger integration and disables all the legacy extensions still supported under <code>/await</code>. The only difference between <code>/std:c++20</code> coroutines and <code>/await:strict</code> is the latter does not define the spaceship operator for <code>std::coroutine_handle</code>. Instead, it defines individual relational operators.</div>
<div></div>
</div>
<div>
<div>
<div>Migrating from <code>/await</code> to <code>/await:strict</code> may require source changes if your code relies on extensions that were not adopted into C++20. Like Standard mode it uses the <code>&lt;coroutine&gt;</code> header and the <code>std </code>namespace, so your code will be drop-in ready for C++20. Code compiled with <code>/await:strict</code> uses the same coroutine ABI as <code>/std:c++latest</code>, so coroutine objects are compatible between the two modes.</div>
<div></div>
</div>
<div>
<div>
<div>We encourage all users of <code>/await</code> to migrate to <code>/await:strict</code>. You can take advantage of all new coroutine features as well as ensure your coroutine code is ready for C++20 when you can move to a C++ language version that officially supports coroutines. We expect to deprecate and remove the  <code>/await</code> switch at some point in the future.</div>
<div></div>
</div>
<div></div>
</div>
</div>
</div>
<div>
<h2 id="stability-improvements">Stability Improvements</h2>
<p>Visual Studio 2019 version 16.11 also includes several important fixes to improve the stability and reliability of coroutines.</p>
<p>The largest change relates to how the optimizer does what is called “promotion”, which is the algorithm to decide which variables get placed on the coroutine frame and which variables remain on the (traditional) stack. Many coroutine bugs can be traced back to an incorrect decision here. Typically this shows up as a crash, or as a variable having an incorrect or random value after a coroutine resumes execution. This promotion algorithm has been rewritten to be more accurate, and the result is less crashes and a much smaller coroutine frame size overall. The old algorithm is still accessible by passing <code>/d2CoroNewPromotion-</code> to cl.exe.</p>
<p>A related fix concerns how exception objects are stored. The lifetime rules for exceptions can get complicated, and they need to be handled specifically when it comes time to decide variable promotion.</p>
<p>A bug was found and fixed related to catch blocks in coroutines. Under certain circumstances (namely, when the only throwing call in a try block was from a user defined awaiter method) the optimizer could erroneously conclude a catch block was dead, and incorrectly remove it. The compiler is now aware that awaiter methods can throw.</p>
<p>Finally, a serious issue was resolved related to how and when destructors are invoked. This relates to how the construction state is tracked in coroutines for certain objects which are conditionally destroyed when leaving a scope. It comes up most when constructing objects when using the conditional (ternary) operator. The bug manifests itself by a destructor for such temporary objects not being invoked, or in certain cases invoked twice. This has also been fixed in 16.11.</p>
<h2 id="feedback">Feedback</h2>
</div>
<p>We urge you to try out C++ coroutines in Visual Studio, either with C++20 or now with <code>/await:strict</code>, to see how asynchronous functions can help make your code more natural. As always, we welcome feedback on our coroutine implementation either in the comments below, or for bug reports and feature requests directly on <a href="https://developercommunity.visualstudio.com/home">Developer Community</a>.</p>
</div>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/">C++20 Coroutine Improvements in Visual Studio 2019 version 16.11</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp20-coroutine-improvements-in-visual-studio-2019-version-16-11/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
	</channel>
</rss>
