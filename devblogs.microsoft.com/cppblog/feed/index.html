<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Tue, 20 Sep 2022 12:21:56 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Microsoft C++ Code Analysis Warnings with Key Events</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/#comments</comments>
		
		<dc:creator><![CDATA[Hwi-sung Im]]></dc:creator>
		<pubDate>Tue, 20 Sep 2022 15:00:33 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[New Feature]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[key events]]></category>
		<category><![CDATA[static analysis]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31106</guid>

					<description><![CDATA[<p>Introduction <br />
To make your C++ coding experience as safe as possible, the Microsoft C++ Code Analysis has added new checks and improved existing ones to help you prevent bugs before they find their way into your products. Some of the checks work harder than others,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/">Microsoft C++ Code Analysis Warnings with Key Events</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 aria-level="1" aria-level="1" id="introduction"><span data-contrast="none">Introduction</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">To make your C++ coding experience as safe as possible, the Microsoft C++ Code Analysis has added new checks and improved existing ones to help you prevent bugs before they find their way into your products. Some of the checks work harder than others, analyzing the code deeper by simulating runtime behavior. As such, they can find defects that are harder to find through syntactic checks alone or through data flow analysis.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">It is natural that developers find it harder to find the root causes for some of these more complex warnings. Imagine a warning where the effect of the bug is detected tens or hundreds of lines below the root cause of the bug, and the code against which the defect is reported looks completely legitimate. How would you be able to quickly find the root cause and fix it?</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">In this blog post, we would like to reintroduce an existing Visual Studio feature that has been there to help with this challenge, and to highlight the big improvements we have made to the feature which will make it easier and more compelling to use.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="challenges-with-code-analysis-warning"><span data-contrast="none">Challenges with Code Analysis Warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">Let’s review the usual challenges we have when a static code analysis check tells us there is a defect in our code. It can be best demonstrated with some example code with a known defect. The following example is intentionally made convoluted enough to demonstrate the challenge of finding the root cause for warnings from a path-sensitive check.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint"> 1   #include &lt;Windows.h&gt; 
 2   
 3   int test(); 
 4   
 5   void t1() 
 6   { 
 7       VARIANT v1; 
 8       VARIANT v2; 
 9       VARIANT v3{}; 
10   
11       VARIANT* pv = &amp;v3; 
12       VARIANT* pvTmp = nullptr; 
13   
14      VariantInit(&amp;v1); 
15   
16       if (test() != 0) 
17           pvTmp = &amp;v1; 
18       else 
19           pvTmp = &amp;v2; 
20    
21       switch (test()) 
22       { 
23       case 1: 
24       case 2: 
25           pv = pvTmp; 
26           break; 
27       default: 
28           pv = &amp;v3; 
29           break; 
30       } 
31   
32       VariantClear(pv); // Warning C33001 here 
33   }</pre>
<p><span data-contrast="auto">Running code analysis on this code will give a few warnings. One of them will be this:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint">test.cpp(32) : warning C33001: VARIANT 'pv' was cleared when it was uninitialized (expression 'pv').: Lines: 5, 7, 8, 9, 11, 12, 14, 16, 19, 21, 25, 26, 32</pre>
<p><span data-contrast="auto">In summary, clearing a <code>VARIANT</code> object that was not properly initialized can result in many random problems, including crashes, memory errors, etc. More information about this specific check can be found at </span><a href="https://docs.microsoft.com/bs-latn-ba/cpp/code-quality/c33001?view=msvc-160"><span data-contrast="none">c33001 | Microsoft Docs</span></a><span data-contrast="auto">. But for this discussion, let’s focus on the root cause of the defect – why does the check say we are clearing a <code>VARIANT</code> object that is not initialized?</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">The line of code to which the warning points us is completely legitimate: we must clear the <code>VARIANT</code> object before we are done with it. Then what is the problem? It must be that somewhere along the code flow that reaches line 32, the <code>VARIANT</code> object that <code>pv</code> points to has not been initialized.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Let’s try to find out where the root cause is. First, we will need to find out which <code>VARIANT</code> object <code>pv</code> points to. Then follow the code flow to see why that object has never been initialized. To figure those out, we will need to trace back the code flow from where the defect is reported. Because it is likely dependent on the path that the check analyzed, we will use the line numbers provided in the warning. That seems doable. However, that doesn’t seem to be the most efficient way. Imagine a similar bug is in an excessively big function. A similar warning may come with tens or hundreds of lines of code to trace back. Many of us would feel offended by such a warning, rather than helped.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">This blog post is not about finding root cause by tracking back source code manually like this. So, before going any further along this path, let’s see if there is any help available.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="code-analysis-warning-with-key-events"><span data-contrast="none">Code Analysis Warning with Key Events</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">It may not be well known, but selected warnings from some of MSVC&#8217;s C++ static analysis checks that have been there for long time always had additional information that helps with tracing back your code to identify the root causes. This additional information is called “Key Events.” A Key Event is associated with a step in the analysis code flow. It explains what has happened in that specific step. During analysis, these checks add Key Event candidates to the steps where important or interesting events occur, e.g., when a new buffer is created, etc. As a check finds a defect, it collects all relevant Key Events along the code flow that led to the defect and adds them to the warning. Some common events are also added as Key Events &#8211; e.g., when a relevant variable is initialized or updated, when code flow branches, etc.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Here is an example of a warning with Key Events from one of those older checks as they are presented in the Error List. You could get these by clicking on the expansion triangle icon in the left-most column of the warning:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>&nbsp;</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents.png"><img class="wp-image-31110 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents.png" alt="Image of C6001 warning with Key Events" width="841" height="213" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents.png 1157w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents-300x76.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents-1024x259.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents-768x194.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<p><span data-contrast="auto">As you can see, these Key Events add rich information to the warning, making it very easy to follow the code and understand what is going on along the code flow of the analysis.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="improvements-to-key-events"><span data-contrast="none">Improvements to Key Events</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We believe in the value of Key Events for our customers. So, we decided to remove the hinderances in making it available for more checks. We also made it a lot easier to use.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">To solve the first problem, we added equivalent support to our newer engine, allowing many newer checks to add Key Events to their warnings with little effort. This was done earlier, and new checks have been adding Key Events to their warnings. As of the release of Visual Studio 2022 version 17.4 Preview 2 we have augmented many checks with Key Events, including warnings for:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:1,&quot;335559684&quot;:-2,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769226&quot;:&quot;Symbol&quot;,&quot;469769242&quot;:[8226],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Enum misuse as buffer index: C33010 and C33011</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:1,&quot;335559684&quot;:-2,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769226&quot;:&quot;Symbol&quot;,&quot;469769242&quot;:[8226],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="auto">VARIANT object misuse: C33001 ~ C33005</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:1,&quot;335559684&quot;:-2,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769226&quot;:&quot;Symbol&quot;,&quot;469769242&quot;:[8226],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Concurrency problems: C26100 ~ C26167</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ul>
<p><span data-contrast="auto">We will add Key Events to even more warnings in the upcoming Visual Studio releases.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559685&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="2" aria-level="2" id="improved-key-event-presentation-in-visual-studio"><span data-contrast="none">Improved Key Event presentation in Visual Studio</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">Visual Studio 2022 version 17.4 Preview 2 comes with big improvements in presentation of the Key Events.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Key Events used to be presented inside the Error List window as shown earlier. Usually, real estate of Error List is very limited to present a warning with a large number of Key Events. Also, it was hard to interact with the Key Events in the list, due to missing features and bugs. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">First, we redesigned the way Visual Studio presents the Key Events for MSVC C++ static analysis warnings. Key Events will now be presented outside of Error List window, in their own window as follows:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p aria-level="2"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2.png"><img class="size-full wp-image-31116 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2.png" alt="Image Visual Studio built in Key Events window 2" width="1682" height="1227" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2.png 1682w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-300x219.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-1024x747.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-768x560.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-1536x1120.png 1536w" sizes="(max-width: 1682px) 100vw, 1682px" /></a></p>
<p><span style="font-size: 1rem;" data-contrast="auto">You can open this window by selecting the warning with double clicking or pressing enter key, or clicking the small window icon on the left-most column of the warning entry in the Error List. This window is like any other tabbed window &#8211; it can be docked, floated, resized, or added to the tabbed windows. Selecting a Key Event in this window highlights the corresponding source line. Keyboard navigation among the Key Events is improved in this window, and source code highlighting follows the selected Key Event.</span><span style="font-size: 1rem;" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-contrast="auto">This will make it a lot easier to review the Key Events and navigate through them along with the corresponding source code, often greatly reducing the time to find the root cause of the defect. For the example code and the warning, now it is a lot easier to tell <code>pv</code> is pointing to <code>pvTmp</code>, and <code>pvTmp</code> is pointing to <code>v2</code>, which was never initialized in the code flow.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<h1 aria-level="2" aria-level="2" id="presentation-of-key-events-through-sarif-viewer-extension"><span data-contrast="none">Presentation of Key Events through SARIF Viewer Extension</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We have teamed up with the developers of the SARIF Viewer Extension for Visual Studio. Some of you may have tried its older versions before. If you haven’t tried it before, now is a good time to get the latest release and give it a try, as we believe it will greatly enhance your productivity with the improvements we made to the extension.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h2 aria-level="3" aria-level="3" id="visualization-of-key-events-in-sarif-explorer-window"><span data-contrast="none">Visualization of Key Events in SARIF Explorer window</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">Through close collaboration among related teams, we greatly improved the functionality of the SARIF Viewer Extension for Visual Studio. When installed and enabled this extension can now display Key Events in its SARIF Explorer window without requiring you to find and open the SARIF file. You just need to select the warning that has the small window icon on the left-most column by <span style="font-size: 1rem;" data-contrast="auto">double clicking or pressing the enter key, or clicking the small window icon</span>. Visual Studio will let SARIF Viewer Extension display the Key Events, instead of its own pop-up window:</span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio.png"><img class="size-full wp-image-31117 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio.png" alt="Image Key Events presentation in SARIF Explorer window of SARIF Viewere Extension for Visual Studio" width="2447" height="1381" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio.png 2447w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-300x169.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-1024x578.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-768x433.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-1536x867.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-2048x1156.png 2048w" sizes="(max-width: 2447px) 100vw, 2447px" /></a></span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">If you select a Key Event in the SARIF Explorer window, the corresponding source code in the Text Editor window will be highlighted with slightly darker color. If you select source code that is highlighted in the Text Editor window, the corresponding Key Event will be highlighted in the SARIF Explorer window.</span></p>
<h2 aria-level="3" aria-level="3" id="source-code-adornment-with-key-events"><span data-contrast="none">Source code adornment with Key Events </span></h2>
<p><span data-contrast="auto">There is even greater news. The SARIF Viewer Extension for VS now displays Key Events right next to the source code they belong to. This will make it a lot easier to find the root cause by allowing review of the source code along with detailed explanation on what the check discovered or assumed at each of the steps of the analysis path that leads to the defect. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Here is an example:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> <a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio.png"><img class="size-full wp-image-31118 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio.png" alt="Image Key Events presentation in Text Editor window by SARIF Viewere Extension for Visual Studio" width="2441" height="1380" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio.png 2441w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-300x170.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-1024x579.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-768x434.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-1536x868.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-2048x1158.png 2048w" sizes="(max-width: 2441px) 100vw, 2441px" /></a></span></p>
<p>&nbsp;</p>
<h1 aria-level="1" aria-level="1" id="setting-up-environment"><span data-contrast="none">Setting up environment</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">To get the essential help from Key Events, you don’t need to do anything. Visual Studio comes with full features to present and let you interact with Key Events. Just install or upgrade your Visual Studio to VS 2022 17.4 Preview 2 or later. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-contrast="auto">To enjoy the new Key Events feature to its full extent in your day-to-day work, also install or upgrade your SARIF Viewer Extension to the latest version. Go to “Extensions &gt; Manage Extensions,” and search for “Microsoft SARIF Viewer 2022”. As of this writing, version 3.0.98.16906 is available. Any version newer than that should work:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog.png"><img class="wp-image-31119 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog.png" alt="Image Microsoft SARIF Viewer Extension in Manage Extensions dialog" width="952" height="255" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog.png 1373w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog-300x80.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog-1024x274.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog-768x206.png 768w" sizes="(max-width: 952px) 100vw, 952px" /></a> </span></p>
<p><span data-contrast="auto">To enable or disable “text adornment” with Key Events, please go to “Tools &gt; Options… &gt; SARIF Viewer” and select/unselect “Enable Key Event text adornments in the editor” option. It is enabled by default:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog.png"><img class="wp-image-31120 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog.png" alt="Image SARIF Viewer Key Event Text Adornment option in Options Dialog" width="920" height="479" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog.png 1473w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog-300x156.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog-1024x533.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog-768x400.png 768w" sizes="(max-width: 920px) 100vw, 920px" /></a> </span></p>
<h1 aria-level="1" aria-level="1" id="conclusion"><span data-contrast="none">Conclusion</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">This is not the final destination for the Key Events feature. Instead, it is only a new starting point for greater improvements. For example, we are working on making the Key Events more relevant to the defect, e.g., by eliminating older assignments that do not contribute to the defect. We are also looking into better navigation support among relevant Key Events. As some of you may already be hoping, we’d love to bring the SARIF Viewer Extension experience into Visual Studio, without requiring installation of the extension.</span></p>
<h1 aria-level="1" aria-level="1" id="send-us-your-feedback"><span data-contrast="none">Send us your feedback</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We are very much interested in your feedback to continue to improve this experience. The comments below are open. Feedback can also be shared through the </span><a href="https://developercommunity.visualstudio.com/spaces/8/index.html"><span data-contrast="none">Developer Community</span></a><span data-contrast="auto">. You can also reach us on Twitter (</span><a href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span data-contrast="auto">), or via email at </span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/">Microsoft C++ Code Analysis Warnings with Key Events</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Xiang Fan]]></dc:creator>
		<pubDate>Fri, 16 Sep 2022 15:10:12 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31056</guid>

					<description><![CDATA[<p>We are working hard on improving the diagnostics experience in MSVC and Visual Studio. We began this work in Visual Studio 2022 version 17.3 and while not everything is ready yet, we would like to share the early progress.</p>
<p>Motivation &#38;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/">The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are working hard on improving the diagnostics experience in MSVC and Visual Studio. We began this work in Visual Studio 2022 version 17.3 and while not everything is ready yet, we would like to share the early progress.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png"><img class="alignnone wp-image-31064 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png" alt="In-box viewer" width="640" height="571" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-300x268.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-768x685.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1536x1370.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png 1876w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h3 id="motivation-principles">Motivation &amp; Principles</h3>
<p>New C++ features like concepts and ranges present the opportunity for more expressive code and better-defined APIs. However, to make the most of them, better diagnostics are required from tooling so that constraint failures can be pinpointed and resolved.</p>
<p>We are aware that there is a lot of room for improvement, as noted by many of you on <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a>, and we are now actively investing in this area.</p>
<p>Our developer advocate <a href="https://twitter.com/TartanLlama">Sy Brand</a> submitted a <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2429r0.pdf">paper</a> to WG21 which discusses the key principles of compiler diagnostics, and how the state of the art in C++ compilers can be improved. We are using this document as guidance in the design of our work.</p>
<p>As a first step, we are working on the compiler to make sure it gathers all the available information and can output it in a tool-friendly way for human consumption later. We are also adding new diagnostic visualization capabilities to Visual Studio to make it easier to navigate and understand large errors.</p>
<h3 id="compiler-changes">Compiler changes</h3>
<ol>
<li>The last message for template instantiation contexts now displays the text column which the error occurred at.</li>
<li>The compiler now lists all candidates for a function call and explains why each candidate fails.</li>
<li>The error message for unsatisfied associated constraints is expanded to detail which underlying constraints were not satisfied.</li>
</ol>
<h4 id="source-code">Source code</h4>
<pre class="lang:c++ decode:true">#include &lt;concepts&gt;

struct functor
{
    template &lt;std::integral T&gt;
    void operator()(T);
    void operator()(int*);
    void operator()(long*);
};

template&lt;typename T&gt;
void test(T t)
{
    functor f;
    f(t);
}

int main()
{
    test(1.0);
}</pre>
<h4 id="compiler-output-in-17-2">Compiler output in 17.2</h4>
<pre>example.cpp(15,2): error C2664: 'void functor::operator ()(long *)': cannot convert argument 1 from 'T' to 'long *'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(8,7): note: see declaration of 'functor::operator ()'
        void operator()(long *);
             ^
example.cpp(20): note: see reference to function template instantiation 'void test&lt;double&gt;(T)' being compiled
        with
        [
            T=double
        ]
        test(1.0);</pre>
<h4 id="compiler-output-in-17-4">Compiler output in 17.4</h4>
<pre>example.cpp(15,2): error C2665: 'functor::operator ()': no overloaded function could convert all the argument types
        f(t);
        ^
example.cpp(7,7): note: could be 'void functor::operator ()(int *)'
        void operator()(int *);
             ^
example.cpp(15,2): note: 'void functor::operator ()(int *)': cannot convert argument 1 from 'T' to 'int *'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(8,7): note: or       'void functor::operator ()(long *)'
        void operator()(long *);
             ^
example.cpp(15,2): note: 'void functor::operator ()(long *)': cannot convert argument 1 from 'T' to 'long *'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(6,7): note: or       'void functor::operator ()(T)'
        void operator()(T);
             ^
example.cpp(15,2): note: the associated constraints are not satisfied
        f(t);
        ^
example.cpp(5,12): note: the concept 'std::integral&lt;double&gt;' evaluated to false
        template &lt;std::integral T&gt;
                  ^
concepts(81,20): note: the constraint was not satisfied
concept integral = is_integral_v&lt;_Ty&gt;;
                   ^
example.cpp(15,2): note: while trying to match the argument list '(T)'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(20,10): note: see reference to function template instantiation 'void test&lt;double&gt;(T)' being compiled
        with
        [
            T=double
        ]
        test(1.0);
                ^</pre>
<h3 id="ide-changes">IDE changes</h3>
<h4 id="ide-experience-in-17-4-in-box-viewer">IDE experience in 17.4 (in-box viewer)</h4>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png"><img class="alignnone wp-image-31064 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png" alt="In-box viewer" width="640" height="571" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-300x268.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-768x685.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1536x1370.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png 1876w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h4 id="ide-experience-in-17-4-sarif-viewer-extension">IDE experience in 17.4 (SARIF viewer extension)</h4>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5.png"><img class="alignnone wp-image-31065 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-1024x868.png" alt="SARIF viewer Extension" width="640" height="543" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-1024x868.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-300x254.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-768x651.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-1536x1302.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5.png 1905w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>The compiler changes often generate more text, and it sometimes makes understanding them harder. We are experimenting with a new compiler option to output the diagnostics into the Static Analysis Results Interchange Format (SARIF). The output will be loaded by Visual Studio to visualize the hierarchy of the messages so that it is easier to navigate.</p>
<p>Currently, clicking an error which is associated with SARIF output in the Visual Studio error list will bring up a pop up with collapsible diagnostic information. We are also working on a <a href="https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer">SARIF Viewer extension</a> to provide a richer experience.</p>
<h3 id="technical-details">Technical details</h3>
<p>Here are the three areas the compiler focuses on right now.</p>
<h4 id="general-infrastructure-source-location">General infrastructure (source location)</h4>
<p>The column information in error messages was added in Visual Studio 2017. However, it is sometimes missing or incorrect.</p>
<ul>
<li>Missing column information is often because the compiler does not always propagate the column information between functions.</li>
<li>Incorrect column information is sometimes produced because the compiler does not maintain the necessary information in nested contexts (e.g., instantiating a template specialization) and its value is incorrectly modified.</li>
</ul>
<p>We are continuing to audit the APIs which manipulate the source location to make sure they propagate and maintain the column information.</p>
<p>There are still cases where the column information is incorrect in the first place (which is common in the compiler generated functions), so if you hit any of these, please let us know!</p>
<h4 id="overload-resolution">Overload resolution</h4>
<p>The error messages for overload resolution vary depending on whether the function is a global function or a member function, whether it is an operator or not, and is sensitive to the number of available candidates. This causes inconsistencies like:</p>
<ul>
<li>The compiler often only lists the last candidate it tried.</li>
<li>The compiler sometimes lists all candidates, but without explaining why each candidate fails.</li>
<li>The compiler often ignores template candidates.</li>
</ul>
<p>We now align the behavior in these scenarios to be more consistent: we always list all candidates including the template and explain why each candidate fails.</p>
<h4 id="concept-unsatisfied-associated-constraints">Concept (unsatisfied associated constraints)</h4>
<p>Previously, the compiler only emitted one general purpose message for unsatisfied associated constraints.</p>
<p>Now, the compiler will emit all the associated constraints which contribute to a given failure. Some of them will have an explanation while others will not.</p>
<p>We are still working on the latter because most of our semantics analysis logic does not propagate the reasons back to the caller yet – the constraint validation logic only knows that something failed.</p>
<h3 id="call-for-action">Call for action</h3>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc" target="_blank" rel="noopener">Twitter @visualc</a>.</p>
<p class="">If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019" target="_blank" rel="noopener">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/" target="_blank" rel="noopener">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/">The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Dev Containers for C++ in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/#respond</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Wed, 14 Sep 2022 17:25:38 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30999</guid>

					<description><![CDATA[<p>We are happy to share with you that we have added Dev Container support In Visual Studio 2022 17.4 for C++ projects using CMake Presets.<br />
Containers are a great way to package up everything for running an application. Through a Dockerfile all prerequisites are captured so that there is a consistent runtime environment anywhere the container is deployed and run Dev Containers expand this concept to capture everything necessary for developing and building an application in the container.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/">Dev Containers for C++ in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to share with you that we have added Dev Container support In Visual Studio 2022 17.4 for C++ projects using CMake Presets.</p>
<p>Containers are a great way to package up everything for running an application. Through a Dockerfile all prerequisites are captured so that there is a consistent runtime environment anywhere the container is deployed and run Dev Containers expand this concept to capture everything necessary for developing and building an application in the container. We have been observing for some time that containers are becoming more popular in the C++ community for providing reproducible build environments.</p>
<p>Visual Studio Code has had support for Dev Containers for some time now. Beginning in Visual Studio 2022 17.4 you can now use Dev Containers for your C++ projects as well.</p>
<h1 id="trying-dev-container-support">Trying Dev Container support</h1>
<p>You will need to have Docker Desktop installed on Windows to use this capability. This is part of the Linux and embedded development with C++ workload., so make sure that is selected in your installation.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png"><img class="alignnone size-full wp-image-30992" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png" alt="The Linux and embedded development workload option in Visual Studio" width="520" height="134" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png 520w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001-300x77.png 300w" sizes="(max-width: 520px) 100vw, 520px" /></a></p>
<p>We have enabled this capability for projects that use CMake Presets. You can clone this sample to get started.</p>
<pre>git clone git@github.com:robotdad/visualstudio-devcontainer-cpp.git</pre>
<p>This project is the same as File New CMake Project in Visual Studio with one difference. There is an additional folder .devcontainer that contains the Dockerfile and devcontainer.json which together define the Dev Container to start.</p>
<p>On opening this folder in Visual Studio you will be prompted to reopen the folder in a container.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1.png"><img class="alignnone size-full wp-image-31001" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1.png" alt="Visual Studio notification that the folder contains a Dev Container with options to reopen in a container, manage settings, or learn more" width="744" height="40" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1.png 744w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1-300x16.png 300w" sizes="(max-width: 744px) 100vw, 744px" /></a></p>
<p>On first use when the container is started the backing image is downloaded. You can see progress of the startup in the new Dev Containers output window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1.png"><img class="alignnone size-full wp-image-31002" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1.png" alt="Visual Studio output window showing information for Dev Containers" width="765" height="368" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1.png 765w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1-300x144.png 300w" sizes="(max-width: 765px) 100vw, 765px" /></a></p>
<p>When startup is finished CMake cache generation starts, when it is done you can edit and debug as normal.</p>
<p>You can switch between your Dev Container and other options using the Target System drop down in the tool bar.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1.png"><img class="alignnone size-full wp-image-31003" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1.png" alt="Visual Studio debug options showing Dev Container as an available machine target" width="707" height="102" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1.png 707w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1-300x43.png 300w" sizes="(max-width: 707px) 100vw, 707px" /></a></p>
<h1 id="options">Options</h1>
<p>Dev Containers have a few options under Tools Options. Most importantly you can control whether or not you want to be prompted to reopen in a container. You can also set a remote host to be the location to run containers, the remote host must be running docker services.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1.png"><img class="alignnone size-full wp-image-31004" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1.png" alt="Visual Studio tools options menu showing Dev Containers selected under Cross Platform" width="845" height="572" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1.png 845w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1-300x203.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1-768x520.png 768w" sizes="(max-width: 845px) 100vw, 845px" /></a></p>
<h1 id="notes">Notes</h1>
<p>The feature uses Linux containers. We are not supporting Windows containers with this mechanism, as such this is not relevant for traditional Windows C++ development using MSVC. The is intended for cross platform development.</p>
<p>A backend service for Visual Studio Code runs within a Dev Container, this is not the case for Visual Studio. Visual Studio manages the lifecycle of Dev Containers it uses as you work, but it treats them as remote targets in a similar way to other Linux or WSL targets. The devcontainer.json configuration file may contain some VS Code specific information, like needed extensions, which are not relevant to Visual Studio. Those are ignored by Visual Studio so it is expected that there will be common Dev Container definitions used with either environment.</p>
<p>Do not open the same folder in Visual Studio and VS Code at the same time. This will result in them connecting to the same container which will result in conflicts between CMake running in two contexts against the same folder.</p>
<h1 id="send-us-your-feedback">Send us your feedback</h1>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your C++ development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/">Dev Containers for C++ in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg Environment Activation in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/#respond</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Wed, 14 Sep 2022 17:23:45 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[embedded]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30990</guid>

					<description><![CDATA[<p>In Visual Studio 2022 17.4 vcpkg environments will now automatically activate. A vcpkg environment is described by a manifest that captures the artifacts necessary for building your application (learn more about vcpkg artifacts). Today the vcpkg artifact experience is focused on embedded developers,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/">vcpkg Environment Activation in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In Visual Studio 2022 17.4 vcpkg environments will now automatically activate. A vcpkg environment is described by a manifest that captures the artifacts necessary for building your application (<a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">learn more about vcpkg artifacts</a>). Today the vcpkg artifact experience is focused on embedded developers, but we will be expanding this in time to all C++ development scenarios.</p>
<h1 id="try-vcpkg-environment-activation">Try vcpkg environment activation</h1>
<p>This is part of the Linux and embedded development with C++ workload., so make sure that is selected in your installation.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png"><img class="alignnone size-full wp-image-30992" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png" alt="The Linux and embedded development workload option in Visual Studio" width="520" height="134" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png 520w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001-300x77.png 300w" sizes="(max-width: 520px) 100vw, 520px" /></a></p>
<p>Today you need to install vcpkg directly, it is not installed with Visual Studio yet. To do so run this command.</p>
<pre>iex (iwr -useb "https://aka.ms/vcpkg-init.ps1")</pre>
<p>For a project to try with this you can use any of the projects described in our <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Development announcement</a>. Originally this required you to activate the vcpkg environment from the command line, then launch VS from that prompt. Now all you need to do is open the project and VS will handle the activation.</p>
<p>To try it clone this repository.</p>
<pre>git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Now open the subfolder getting-started\MXChip\AZ3166 in Visual Studio. You will see the following notification that vcpkg environment activation has started. This may take some time on first use when the artifacts are initially downloaded.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003.png"><img class="alignnone size-full wp-image-30993" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003.png" alt="Background task notification that vcpkg activation has started" width="363" height="170" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003.png 363w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-300x140.png 300w" sizes="(max-width: 363px) 100vw, 363px" /></a></p>
<p>When activation is finished there will be a notification.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005.png"><img class="alignnone size-full wp-image-30994" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005.png" alt="Background task notification that vcpkg activation has completed" width="383" height="202" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005.png 383w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-300x158.png 300w" sizes="(max-width: 383px) 100vw, 383px" /></a></p>
<p>If you missed it you can check the notification area by selecting it.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007.png"><img class="alignnone size-full wp-image-30995" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007.png" alt="Completed background task information that vcpkg activation has completed" width="600" height="118" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007.png 600w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-300x59.png 300w" sizes="(max-width: 600px) 100vw, 600px" /></a></p>
<p>You can also check the current or complete status of the activation in the vcpkg output window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009.png"><img class="alignnone size-full wp-image-30996" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009.png" alt="Output windows showing vcpkg information" width="1122" height="289" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009.png 1122w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-300x77.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1024x264.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-768x198.png 768w" sizes="(max-width: 1122px) 100vw, 1122px" /></a></p>
<p>This sample is a CMake project, so when vcpkg activation is complete CMake cache generation will start and then your project will be ready for use.</p>
<h1 id="managing-the-vcpkg-environment">Managing the vcpkg environment</h1>
<p>Visual Studio integrates the vcpkg environment as part of the Solution explorer.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011.png"><img class="alignnone size-full wp-image-30997" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011.png" alt="Solution explorer menu entries for vcpkg, edit, reactivate, and deactivate" width="350" height="158" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011.png 350w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011-300x135.png 300w" sizes="(max-width: 350px) 100vw, 350px" /></a></p>
<p>The opens the vcpkg-configuration.json file which captures the vcpkg environment. Reactivate will activate the vcpkg environment again picking up any changes made to the configuration. removes the vcpkg environment from the current configuration leaving you with a standard Visual Studio environment. If your project depends on compilers or other tools provided by the vcpkg configuration it likely will no longer build and IntelliSense may not work.</p>
<h1 id="send-us-your-feedback">Send us your feedback</h1>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your C++ development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/">vcpkg Environment Activation in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Integrating C++ header units into Office using MSVC (1/n)</title>
		<link>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/</link>
					<comments>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Mon, 12 Sep 2022 21:12:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[C++ language]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[modernization]]></category>
		<category><![CDATA[modules]]></category>
		<category><![CDATA[Office]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31007</guid>

					<description><![CDATA[<p>.cameron {<br />
    color: #4472c4;<br />
  }</p>
<p>C++20 has had a lot to offer and one feature in particular requires the most thought of all when integrating into our projects: C++ modules (or C++ header units in this particular case).  In this blog we will show a real world case of integrating a new C++20 feature into a large codebase that we might all be familiar with.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/">Integrating C++ header units into Office using MSVC (1/n)</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<style>
  .cameron {
    color: #4472c4;
  }
</style>
<p>C++20 has had a lot to offer and one feature in particular requires the most thought of all when integrating into our projects: C++ modules (or <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">C++ header units</a> in this particular case).  In this blog we will show a real world case of integrating a new C++20 feature into a large codebase that we might all be familiar with.  Just a few notes:</p>
<ul>
<li>This blog is authored in a style of two perspectives:</li>
<ul>
<li>Zachary Henkel&#8217;s perspective will be in black text.</li>
<li>Cameron DaCamara&#8217;s perspective will be in <span class="cameron">accent text</span>.</li>
</ul>
<li>This blog is the first in a series detailing experiences in integrating header units into the Office codebase.</li>
<li>The first blog here is very early results so do not expect to see very fine-grained numbers.</li>
</ul>
<p>Without further delay, let us jump right in!</p>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#problem-description">Problem description: Why header units?</a></li>
<li><a href="#baby-steps">Baby steps to start the work: Basic projects to target and early obstacles</a></li>
<li><a href="#larger-steps">Larger steps: How does Office package up header units for build?</a></li>
<li><a href="#together">Putting it all together: Smoke tests and early numbers</a></li>
<li><a href="#next-steps">Looking ahead: Build more headers and measure</a></li>
</ul>
<p></p>
<h2><span id="problem-description">How MSVC enables header units in a multi-platform codebase</span></h2>
<p>C++20 header units are a way to receive many of the benefits of modules, while still working with a codebase that was designed for classic header inclusion.  The benefits of header units looked appealing to Office, but we weren&#8217;t willing to extensively add platform #ifdefs for the sake of consuming them.  Fortunately, the C++ standard anticipated this scenario!  The flag MSVC <a href="https://docs.microsoft.com/en-us/cpp/build/reference/translateinclude?view=msvc-170"><code>/translateInclude</code></a> will automatically translate a textual inclusion to a header unit import when it encounters a #include specified in a command line mapping to the compiler.  This allows Office to build and consume header units without any code changes at all!</p>
<p><span class="cameron">It is worth noting that the <code>/translateInclude</code> feature is a standard-supported feature, <a href="https://eel.is/c%2B%2Bdraft/cpp.include#7"><code>[cpp.include]/7</code></a>. Include translation allows the implementation to replace <code>#include</code> with <code>import</code>.  It is essential for gradual codebase migration that there be a bridge such as include translation to enter the world of modules.  More importantly, a header unit can do something that a <a href="https://docs.microsoft.com/en-us/cpp/build/creating-precompiled-header-files?view=msvc-170">PCH</a> cannot: it can be moved around from project to project and reused!  So not only does the integration of header units require no source-level changes, but the build throughput potential for multiple projects is far beyond what PCH can offer.  One more point to header units compared to PCH: they&#8217;re small, really small compared to PCH.  In our measurements, a header unit can often times be 10x smaller than an equivalent PCH in content.</span></p>
<h3 id="selecting-header-unit-candidates">Selecting header unit candidates</h3>
<p>Once Office knew we wanted to use header units, the challenge became finding a good set of candidate headers.  Our low-level shared code components, that we&#8217;ve termed liblets, have properties that make them attractive header unit blocks.  All a liblet&#8217;s headers exposed as dependencies need to be self-contained and this property is enforced by existing tools!  Secondly, liblets clearly express their dependencies.  This allows us to build an acyclic graph of dependencies and build up sets of header units.</p>
<h2><span id="baby-steps">Baby Steps</span></h2>
<p>The first step Office took was simply to determine if we could build a header unit!  This <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">Microsoft docs</a> page has the full steps but summarized here are the key points:</p>
<ul>
<li>Turn on module support.  Ideally Office would be compiling all code as C++20 and header unit support would be available automatically.  Unfortunately, due to the size of the Office codebase, we&#8217;re not ready to make the switch.  Luckily Office already compiles with the compiler flag <a href="https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170"><code>/permissive-</code></a>.  By running the compiler in standards conformance mode Office is able to fall back on the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/experimental-module?view=msvc-170"><code>-experimental:module</code></a> flag for header unit support until the C++20 migration is complete.  It&#8217;s important to note that this <em>doesn&#8217;t do anything</em> other than enable the feature, it won&#8217;t force any code to compile as header units without additional flags.</li>
<li>Determine where in the build tree we will create the IFC artifacts and pass that location to the compiler with <a href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-alphabetically?view=msvc-170"><code>/ifcOutput</code></a></li>
<li>We enabled some additional compiler flags for the purposes of testing, more on this later.</li>
</ul>
<p>Right out of the gate Office hit a snag.  Our headers weren&#8217;t as self-contained as we had assumed.  Our tools that operate on headers in isolation rely on common textual includes being provided by the precompiled header!  Until the work to break our precompiled header dependency is complete, we&#8217;re force-including (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/fi-name-forced-include-file?view=msvc-170"><code>/FI</code></a>) the precompiled header into each header being compiled as a header unit.</p>
<p><span class="cameron">From this perspective, it is important that the compiler should make traditional PCH technology work along with the new modules technology (which is the same machinery the compiler uses to export and import header units).</span></p>
<p><span class="cameron">The first compiler bug on deck was the fact that the front-end has a rather&#8230; interesting approach to PCH.  The problem observed was that <em>sometimes</em> the compiler would error with &#8220;<code>error C7612: could not find header unit for 'X'</code>&#8220;.  The most curious thing was that the command line had the reference to header unit &#8216;X&#8217; clear as day.  It was not until I debugged the front-end with PCH turned on where the PCH interacted with certain identifiers that I discovered the culprit.  When the compiler starts, it allocates a table where hashed identifiers go, and when the compiler sees <a href="https://docs.microsoft.com/en-us/cpp/build/reference/headerunit?view=msvc-170"><code>/headerUnit:quote X=X.ifc</code></a> it will create hashed identifiers for the components of the name for fast comparison purposes.  The problem is that this processing happened too early because in the presence of a PCH the compiler will memmap the PCH file and <a href="https://en.wikipedia.org/wiki/Bit_blit">blit</a> the memory directly into existing compiler heap locations&#8230; exactly where we just inserted our identifiers from processing the <code>/headerUnit</code> arguments, which means we also get bogus identifiers when trying to find the matching header unit name to IFC combo.  One hefty comment and code rearranging later, our first bug was fixed!</span></p>
<p>The preprocessor presented another set of challenges. The set of preprocessor macros must be consistent between header unit creation and consumption. Inconsistent conditional compilation is forbidden in header units.  Eliminating cases, such as the following, will be an ongoing concern for Office as header unit usage increases.</p>
<pre>#if defined(Assert)
#define ASSUME( condition ) Assert( condition )
#else
#define ASSUME ( condition ) __noop()
#endif</pre>
<p>The experiment to create as many header units as possible helped uncover many outstanding bugs with code that was never instantiated by the compiler.  </p>
<p>One such example, this does not return on all code paths:</p>
<pre>inline HRESULT sink(std::unique_ptr&lt;Widget&gt; widget)
{
#if DEBUG
  if (!widget) return E_POINTER;
#endif
  m_widget = std::move(widget);
}</pre>
<p><span class="cameron">Let&#8217;s talk about inline functions.  Consider:</span></p>
<pre>void undef(); 
inline void f() {
  undef();
}
int main() { }</pre>
<p><span class="cameron">You might be surprised to find that every major compiler vendor will accept the above C++ code and link the program successfully!  It turns out that the standard wording here <a href="https://eel.is/c%2B%2Bdraft/dcl.inline#5"><code>[dcl.inline]/5</code></a> is quite special, and it allows for a unique optimization which allows a compiler front-end to tell the back-end that the definition of a specific function is never needed because said function is never referenced, so this bespoke definition can be discarded altogether, which further implies <code>undef</code> is also never referenced leading to a well-formed program.</span></p>
<p><span class="cameron">There has been a long-standing issue in the compiler where it was forced to emit every inline function definition into the associated .obj if the current translation unit was a module interface unit or a header unit.  While this will still lead to correct program semantics, it has two major drawbacks:</code></span></p>
<ol class="cameron">
<li>The compiler cannot enable the aforementioned optimization with inline functions, and</li>
<li>This compiler behavior means that <a href="https://docs.microsoft.com/en-us/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">LTCG</a> is required for inlining of functions declared <code>inline</code> and defined in the imported translation unit.</li>
</ol>
<p><span class="cameron">It turns out that Office relied on &#8216;1&#8217;, a lot.  So, we just fixed the bug.  During the Office header unit integration, the compiler provided a switch to enable the behavior of emitting every inline function definition into the IFC which would be loaded on-demand if it was used on the import side.</span></p>
<p>Office has been on a long journey to ensure all our code is standards compliant via the MSVC <code>/Zc</code> flags and <code>/permissive-</code>.  The header unit pilot acted as a forcing function to accelerate our efforts to enable the standards conformant preprocessor (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/zc-preprocessor?view=msvc-170"><code>/Zc:preprocessor</code></a>) globally.</p>
<p><span class="cameron">Anybody familiar with the quirks of the traditional preprocessor in MSVC will understand that its behavior is something of an eldritch horror.  Adding to that, the traditional preprocessor has virtually no data model besides walking blobs of text to create a new stream of text for the compiler&#8217;s tokenizer.  The standard states that preprocessing should begin with a series of <a href="https://eel.is/c%2B%2Bdraft/lex.phases#1.3">pp-tokens</a> and end up with a series of lexical tokens which are then parsed.   The new preprocessor (<code>/Zc:preprocessor</code>) allows the compiler to store these pp-tokens into the IFC in a principled way.  These pp-tokens are needed as they compose the definition of <a href="https://eel.is/c%2B%2Bdraft/cpp.replace#general-2">object-like and function-like</a> macros and is the reason why <code>/Zc:preprocessor</code> is <a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-exportheader?view=msvc-170#remarks">required for header unit compilation</a>.</span></p>
<h2><span id="larger-steps">Larger Steps?</span></h2>
<p>Once Office could create header units it was time to consume them!  Again, the <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">Microsoft docs</a> page contains the full details but the key steps for Office were:</p>
<ul>
<li>Use the <code>/translateInclude</code> flag to avoid rewriting <code>#include</code> to <code>import</code>.</li>
<li>Pass the header unit mapping <code>/headerUnit liblet/header.h=&lt;ifc path&gt;</code>.</li>
<li>Decide what to do with the .obj file created as part of a header unit.</li>
</ul>
<p>In Office we bundle all header unit mappings per-liblet into a single <a href="https://docs.microsoft.com/en-us/cpp/build/reference/at-specify-a-compiler-response-file?view=msvc-170">response file</a>.  We&#8217;ve found this to strike the right balance of dependency tracking despite potentially over specifying the number of header units being consumed.</p>
<p>Header unit consumption started revealing heterogeneous build flags throughout the product.  Big pain points include static vs dynamic CRT (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=msvc-170"><code>/MT</code> vs <code>/MD</code></a>), unsigned char (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/j-default-char-type-is-unsigned?view=msvc-170"><code>/J</code></a>) and <code>/DUNICODE</code>.  It is possible to create a distinct header unit flavor for each combination, but so far, we&#8217;ve stuck to a single flavor with the most common options.</p>
<p>The obj file from a header unit is packaged into the pre-existing lib files to make consuming header units easy.</p>
<h2><span id="together">Putting it together</span></h2>
<p>The most recent milestone hit in the pilot is to successfully compile and link three of Office&#8217;s shared code dlls.  While building the dlls Office successfully compiled ninety distinct header units from pre-existing shared code headers.  To aid integration header units are enabled for all of a project&#8217;s publicly shared headers at once.  This means that even though each header unit that&#8217;s been created will be used <em>somewhere</em> in Office, there isn&#8217;t any guarantee it is consumed while building these specific dlls.  To build the dll we tested 2/5 of the generated header units were consumed, as validated by the report generated by the new <a href="https://docs.microsoft.com/en-us/cpp/build/reference/sourcedependencies?view=msvc-170"><code>/sourceDependencies</code></a> flag.  We anticipate these numbers to increase significantly with some upcoming work to replace the compiler&#8217;s brittle legacy ODR validation logic.</p>
<p><span class="cameron">The module machinery in the compiler has historically tried to use source locations to perform ODR matching (<a href="https://eel.is/c%2B%2Bdraft/basic.def.odr">One Definition Rule</a>).  The problem, of course, is that the header units can be moved around and locations change from machine-to-machine (even project-to-project) so the strategy of trying to perform an ODR match based on source location can be quite fragile, as mentioned above.  After working with Office it was abundantly clear that the compiler needs to adjust its strategy and perform more of a structural comparison when matching for ODR&mdash;a change which is still ongoing and targeting a future release.  Please note that ODR checking for named modules do not have any of the problems above as they provide better ODR guarantees vs being reliant on source location.</span></p>
<h2><span id="next-steps">Next steps</span></h2>
<p>We are just as anxious to get build throughput metrics internally as we expect all of you to be. Once we have a broad set of header units being generated and consumed, we plan to do gather extensive build timing data.  We want to see the effect building and consuming header units has on the build speed of both clean builds and incremental builds and we want to measure the effects both with and without our existing precompiled headers.  Additionally, we need to determine if there is a high enough throughput gain to justify creating additional header unit flavors for currently incompatible compiler flags. Do we have enough projects that require the static CRT or build without Unicode support to spend the compilation time generating header units in those configurations?</p>
<p>Finally, we want to add support for consuming header units outside of Office&#8217;s shared code.  We have a shared code architecture that makes it easy to create header units and track the downstream projects that depend on them.  We need to extend the build system support that has already been created to date so that Office&#8217;s client apps can also see the benefits of header units.  If you&#8217;d like to learn more about how Office architects its shared code, please catch the CppCon 2022 talk <a href="https://cppcon.digital-medium.co.uk/session/2022/how-microsoft-uses-c-to-deliver-office/">&#8220;How Microsoft Uses C++ to Deliver Office: Huge Size, Small Components&#8221;</a> once it&#8217;s available online.</p>
<p><span class="cameron">Office is nearly 100 million lines of native code and the compiler is seeing a lot of new code, which is both a blessing and a curse as it can halt development until a compiler fix is created but ultimately makes a product which is not only more robust for Office but for every customer using MSVC!</span></p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/all-header-units.png" alt="BUILD!" /></p>
<h4 id="closing">Closing</h4>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow Cameron DaCamara on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/">Integrating C++ header units into Office using MSVC (1/n)</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Team at CppCon 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 12 Sep 2022 13:00:27 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31039</guid>

					<description><![CDATA[<p>The Microsoft C++ team has an exciting lineup of sessions at CppCon 2022. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/">Microsoft C++ Team at CppCon 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><img class="size-full wp-image-24953 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png" alt="Microsoft @ CppCon" width="760" height="466" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png 760w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp-300x184.png 300w" sizes="(max-width: 760px) 100vw, 760px" /></p>
<p>The Microsoft C++ team has an exciting lineup of sessions at <a href="https://cppcon.org/">CppCon 2022</a>. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks, products, or anything else! You can also join the <a href="https://aka.ms/cppcon/discord">#visual_studio channel on the CppCon Discord</a> to talk to us (note: to join, head to <a href="https://discord.com/channels/864799911358627861/864825142386622474">#directory</a> channel first, and check the checkbox next to &#8220;Visual Studio&#8221; box).</p>
<p>We’re also running a survey on the C++ ecosystem. If you have a moment, <a href="https://aka.ms/cppcon" target="_blank" rel="noopener noreferrer">please take our survey</a>, it&#8217;s quick.</p>
<p>Here’s the lineup:</p>
<h1 id="monday-september-12th">Monday, September 12th</h1>
<p><strong>09:00 – 10:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/whats-new-in-c23/">What’s New in C++23</a> – Sy Brand (online)</p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/the-imperatives-must-go/">The Imperatives Must Go</a> – Victor Ciura (online)</p>
<p><strong>14:00 – 15:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/c-dependencies-dont-have-to-be-painful/">C++ Dependencies Don’t Have To Be Painful: Why You Should Use a Package Manager</a> – Augustin Popa</p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/how-microsoft-uses-c-to-deliver-office/">How Microsoft Uses C++ to Deliver Office</a> – Zachary Henkel</p>
<h1 id="tuesday-september-13th">Tuesday, September 13th</h1>
<p><strong>09:00 – 10:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/high-performance-load-time-implementation-selection/">High-performance Load-time Implementation Selection</a> – Joe Bialek and Pranav Kant</p>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/c-mythbusters/">C++ MythBusters</a> – Victor Ciura (online)</p>
<h1 id="wednesday-september-14th">Wednesday, September 14th</h1>
<p><strong>16:45 – 17:45 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/memory-safe-c/">-memory-safe C++</a> – Jim Radigan</p>
<h1 id="thursday-september-15th">Thursday, September 15th</h1>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/whats-new-for-you-in-visual-studio-code/">What’s New in Visual Studio Code</a> – Marian Luparu and Sinem Akinci (online)</p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/overcoming-embedded-development-tooling-challenges/">Overcoming Embedded Development Tooling Challenges</a> – Marc Goodner (online)</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/reproducible-developer-environments/">Reproducible Developer Environments</a> – Michael Price</p>
<h1 id="friday-september-16th">Friday, September 16th</h1>
<p><strong>07:45 – 08:45 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/github-features-every-c-developer-should-know/">GitHub Features Every C++ Developer Should Know</a> – Michael Price</p>
<p><strong>09:00 – 10:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/whats-new-in-visual-studio-2022/">What&#8217;s New in Visual Studio 2022</a> – Sy Brand and Marian Luparu (online)</p>
<p><strong>16:15 – 18:15 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/c-complexity/">C++ Simplicity, Safety, and Toolability</a> – Herb Sutter</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/">Microsoft C++ Team at CppCon 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Importing ST projects into Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Thu, 01 Sep 2022 18:50:15 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30966</guid>

					<description><![CDATA[<p>In the world of Arm microcontrollers there are many silicon vendors, one of the largest is STMicroelectronics. ST has a large catalog of available devices with many capabilities as well as supporting development boards for evaluating them. They also produce STM32CubeIDE,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/">Importing ST projects into Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In the world of Arm microcontrollers there are many silicon vendors, one of the largest is <a href="https://www.st.com/">STMicroelectronics</a>. ST has a large catalog of available devices with many capabilities as well as supporting development boards for evaluating them. They also produce <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a>, a custom IDE to use when targeting their devices, and <a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html">STM32CubeMX</a>, a configuration tool used in configuring properties of their devices and generating projects.</p>
<p>If you are a developer already using ST’s products I’m not telling you anything new. You may not be aware though of the work we have been doing to <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">enable embedded developers in Visual Studio Code</a>. This embedded experience relies on the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifacts capabilities</a> to help acquire toolchains and configure the dev environment. To make it easier for developers using ST devices to try Visual Studio Code we have been working with ST to enable importing STM32CubeIDE projects.</p>
<p>We accomplish this by generating a CMake project from the ST project. ST provides many sample projects across their portfolio. We’ve validated builds across ST’s sample projects with this mechanism, over 3,000 of them. At present we have a 94% pass rate which we are continuing to improve. This gives us confidence that our approach will be successful for importing your own ST projects. Our embedded tools extension also enables device flashing and debugging through the importer, though we have only validated this on the hardware we have.</p>
<p>This post is going to go over how this project importer functionality works in conjunction with vcpkg and ST’s tools.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode.png"><img class="alignnone size-full wp-image-30967" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode.png" alt="A STM32 project in VSCode" width="1430" height="951" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode.png 1430w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode-300x200.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode-1024x681.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode-768x511.png 768w" sizes="(max-width: 1430px) 100vw, 1430px" /></a></p>
<h4 id="using-st-projects-in-visual-studio-code">Using ST projects in Visual Studio Code</h4>
<p>This post assumes some familiarity with ST devices, development tools, and embedded development generally. If you need some background, we recommend the following articles on getting started with STM32 from <a href="https://shawnhymel.com/">Shawn Hymel</a>.</p>
<ul>
<li><a href="https://www.digikey.com/en/maker/projects/getting-started-with-stm32-introduction-to-stm32cubeide/6a6c60a670c447abb90fd0fd78008697">Introduction to STM32CubeIDE</a></li>
<li><a href="https://www.digikey.com/en/maker/projects/getting-started-with-stm32-introduction-to-freertos/ad275395687e4d85935351e16ec575b1">Introduction to FreeRTOS </a></li>
</ul>
<p>We rely on vcpkg for managing dependencies like CMake and Ninja, which includes acquiring them and making them available for use in your development environment. You can learn more about how we vcpkg in our <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Visual Studio Code embedded development overview</a>. You can install it in a single shell command for your platform.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre>iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>You will need the Embedded Tools extension version 0.3.0 or greater installed in Visual Studio Code to use the ST project importer.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3.png"><img class="alignnone size-full wp-image-30968" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3.png" alt="Embedded Tools extension page from VS Code" width="624" height="171" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3-300x82.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>Today our importer requires that you have the <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a> software installed in the default location for your platform. We have been testing this capability with STM32CubeIDE 1.9.0 and STM32CubeMX 6.5.0. If you have multiple instances installed side by side we do not have the ability to control which is selected.</p>
<p>It is also necessary to acquire the board support package for your device in STM32CubeIDE. This is so that we can use the compilers and supporting applications provided by ST from within Visual Studio Code.</p>
<p>There will be a lighter weight package available from ST in the future. We plan to enable acquisition of the dependencies here via vcpkg as well.</p>
<p>With our prerequisites installed, from within Visual Studio Code in the command pallet (&lt;Ctrl&gt;+&lt;Shift&gt;+&lt;P&gt;) run “Create project from ST project”.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj.png"><img class="alignnone size-full wp-image-30969" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj.png" alt="Create ST project in VS Code command pallate" width="1456" height="189" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj.png 1456w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj-300x39.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj-1024x133.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj-768x100.png 768w" sizes="(max-width: 1456px) 100vw, 1456px" /></a></p>
<p>Navigate to where your ST .cproject is and select it. You can then select either the debug or release configuration. Now you can select Build to compile your firmware with CMake. To debug select the Debug view, then select the launch button. This will run the STM32 programmer to flash the firmware onto the device and connect using GDB. From here all of our embedded development views (<a href="https://docs.microsoft.com/cpp/embedded/serial-monitor?view=msvc-170&amp;tabs=visual-studio">serial</a>, <a href="https://docs.microsoft.com/cpp/embedded/rtos-view?view=msvc-170&amp;tabs=visual-studio">RTOS</a>, and <a href="https://docs.microsoft.com/cpp/embedded/peripheral-view?view=msvc-170&amp;tabs=visual-studio">peripherals</a>) are available.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode.png"><img class="alignnone size-full wp-image-30970" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode.png" alt="STM32 FreeRTOS project debugging in VS Code" width="1430" height="815" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode.png 1430w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode-300x171.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode-1024x584.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode-768x438.png 768w" sizes="(max-width: 1430px) 100vw, 1430px" /></a></p>
<p>If your project has an .ioc file you can open the context menu and open STM32CubeMX for your project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode.png"><img class="alignnone wp-image-30971" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode.png" alt="VS Code context menu for CubeMX .ioc file" width="655" height="366" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode.png 1106w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode-300x168.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode-1024x572.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode-768x429.png 768w" sizes="(max-width: 655px) 100vw, 655px" /></a></p>
<p>If you make changes to your project in STM32CubeMX they will be recognized and the CMake cache will regenerate.</p>
<p>After you close Visual Studio Code for your next session with your project you will need to launch Visual Studio Code from a vcpkg activated prompt. To do so in your shell navigate to the project folder containing vcpkg-configuration.json, run vcpkg activate, then code .</p>
<p>In a future release this will no longer be necessary, activation will happen automatically.</p>
<h4 id="understanding-cmake-interaction">Understanding CMake interaction</h4>
<p>You can see the simple CMakeLists.txt that is generated in the root of the project where the .cproject is located. This has a dependency on generated CMake files under the cmake directory. There are paths in these files that are set to the discovered location of the ST compilers on your machine. If you intend to move to CMake from the ST project format we advise that you adjust these files to your needs, particularly for use in a team where the paths may vary.</p>
<p>The other thing to be aware of is that sometimes in the STM32CubeIDE samples, the project may be in a subdirectory of the source code. If you do not see your project files in the file view this may be why. Select the CMake targets view and you should see everything that CMake has used to generate the build.</p>
<p>Following from the above point we recommend that when generating projects using STM32CubeMX you leave the default selected in the Project Manager for “Generate Under Root”. This will keep your .cproject in the root of the folder with the generated source files. This is how STM32CubeIDE generates projects by default as well.</p>
<p>If you open the project again in STM32CubeIDE you will need to exclude the build directory used by CMake from your project. Right click the build directory and select Resource Configurations &gt; Exclude from Build.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig.png"><img class="alignnone size-full wp-image-30973" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig.png" alt="STM32IDE context menu for resource configuration" width="354" height="361" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig.png 354w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig-294x300.png 294w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig-24x24.png 24w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig-48x48.png 48w" sizes="(max-width: 354px) 100vw, 354px" /></a></p>
<p>Then select both Debug and Release in the Exclude from build dialog.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions.png"><img class="alignnone wp-image-30974" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions.png" alt="STM32 IDE build exclusions dialog" width="498" height="325" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions.png 732w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions-300x196.png 300w" sizes="(max-width: 498px) 100vw, 498px" /></a></p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio Code for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/">Importing ST projects into Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg August 2022 Release is Now Available: CMake Version Update, Updated FAQ, Cross-compilation Fix for Apple Silicon</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Tue, 23 Aug 2022 16:23:27 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30936</guid>

					<description><![CDATA[<p>The August 2022 release of the vcpkg package manager is available. This blog post summarizes changes from July 25th, 2022 to August 14th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>8 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/">vcpkg August 2022 Release is Now Available: CMake Version Update, Updated FAQ, Cross-compilation Fix for Apple Silicon</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.08.15">August 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from July 25<sup>th</sup>, 2022 to August 14<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>8 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>192 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,975 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are over <strong>10,106 port versions</strong>.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.08.15">August release of the main vcpkg repo</a> includes <strong>204 commits</strong>.</li>
<li><strong>69 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.7k forks</strong> and <strong>16.5k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<p>This is a minor update and there was no tool update this month, so most of the changes are to the open-source ports registry or minor changes. See the full <a href="https://github.com/microsoft/vcpkg/compare/2022.07.25...2022.08.15">commit changelog</a> for details. We call out several of the more interesting changes below.</p>
<p>&nbsp;</p>
<h4 id="vcpkg-now-uses-cmake-v3-24">vcpkg now uses CMake v3.24</h4>
<p>Updated the version of CMake used by vcpkg to 3.24. Note: this doesn’t restrict what version of CMake a vcpkg user can use for their own projects, and vcpkg can be asked to use a version of CMake already installed on the user’s machine, as long as it is not an older version than 3.24.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/25365">Microsoft/vcpkg#25365</a> (thank you @<a href="https://github.com/Neumann-A">Neumann-A</a>!)</p>
<p>&nbsp;</p>
<h4 id="improved-cross-compilation-for-apple-silicon">Improved cross-compilation for Apple silicon</h4>
<p>A community PR improves correctness when cross-compiling from x86_64 to arm64 on macOS (and vice-versa). It also takes into account Rosetta’s capability to run x86_64 binaries on arm64 macOS systems.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/26240">Microsoft/vcpkg#26240</a> (thanks @<a href="https://github.com/ekilmer">ekilmer</a>!)</p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation changes</h4>
<p>The following documentation changes were made this release:</p>
<ul>
<li>Extensive changes to the FAQ page as it was out of date, taking account of new vcpkg features and tool targeting capabilities.</li>
<li>Updated triplets documentation to include the variable VCPKG_FIXUP_ELF_RPATH (thanks @Osyotr!)</li>
</ul>
<p>PRs: <a href="https://github.com/microsoft/vcpkg/pull/25400">Microsoft/vcpkg#25400</a>, <a href="https://github.com/microsoft/vcpkg/pull/26040">Microsoft/vcpkg#26040</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,775</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,828</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,741</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,755</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>939</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,364</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>891</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,697</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,765</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>Neumann-A (27 commits)</li>
<li>Thomas1664 (8 commits)</li>
<li>Osyotr (6 commits)</li>
<li>autoantwort (5 commits)</li>
<li>ekilmer (3 commits)</li>
<li>dg0yt (3 commits)</li>
<li>cenit (2 commits)</li>
<li>myd7349 (1 commit)</li>
<li>coryan (1 commit)</li>
<li>AenBleidd (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.08.15">full August release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/">vcpkg August 2022 Release is Now Available: CMake Version Update, Updated FAQ, Cross-compilation Fix for Apple Silicon</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Updates to Visual Studio Build Tools license for C and C++ Open-Source projects</title>
		<link>https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/</link>
					<comments>https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/#comments</comments>
		
		<dc:creator><![CDATA[Marian Luparu]]></dc:creator>
		<pubDate>Thu, 18 Aug 2022 18:40:37 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30919</guid>

					<description><![CDATA[<p>Visual Studio Build Tools (VSBT) can now be used for compiling open-source C++ dependencies from source without requiring a Visual Studio license, even when you are working for an enterprise on a commercial or closed-source project.<br />
This change expands user rights to the Build Tools and does not limit the existing Visual Studio Community license provisions around Open-Source development.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/">Updates to Visual Studio Build Tools license for C and C++ Open-Source projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio Build Tools</a> (VSBT) can now be used for compiling open-source C++ dependencies from source without requiring a Visual Studio license, even when you are working for an enterprise on a commercial or closed-source project.</p>
<p>This change expands user rights to the Build Tools and does not limit the existing Visual Studio Community license provisions around Open-Source development. If you already are a developer contributing to OSS projects, you can continue to use Visual Studio and Visual Studio Build Tools together for free, just like before.</p>
<h3 id="new-license-benefits">New License Benefits</h3>
<p>If you are an enterprise developer or developing any closed-source projects, this change now allows you to use Visual Studio Build Tools to compile and build any C++ 3rd party open-source dependencies, without needing a paid Visual Studio license, when you’re not using Visual Studio for active C++ development.</p>
<p>For example, if your Node.js application depends on npm native modules like sqllite3, bufferutil, etc., in order to successfully install these npm packages on Windows, <a href="https://github.com/Microsoft/nodejs-guidelines/blob/master/windows-environment.md#compiling-native-addon-modules">you will need to use Visual Studio Build Tools</a>. Previously, if the application you were developing was not OSS, installing VSBT was permitted only if you had a valid Visual Studio license (e.g., Visual Studio Community or higher). With this new license option, if you do not need the full functionality of Visual Studio for your active development of your project, you have the flexibility to install Visual Studio Build Tools for free.</p>
<p>As noted above, if you and your team need to compile and develop proprietary C++ code with Visual Studio, a Visual Studio license will still be required.</p>
<p>You can review the latest Visual Studio Build Tools license here: <a href="https://visualstudio.microsoft.com/license-terms/vs2022-ga-diagnosticbuildtools/">License Terms | Microsoft Diagnostic Build Tools for Visual Studio 2022 &#8211; Visual Studio</a> (for full list of licenses check out the <a href="https://visualstudio.microsoft.com/license-terms/">Visual Studio Licenses &amp; EULA Directory</a>)</p>
<h3 id="background">Background</h3>
<p>The C++ OSS ecosystem is a vibrant one and you need to look no further than the growing popularity of <a href="https://vcpkg.io/">vcpkg, the multi-platform C++ dependency manager from Microsoft</a>, to see how it is becoming a fundamental building block for an increasing number of projects. We are thrilled to see the adoption of many of these C++ open-source libraries in the Python or node.JS communities as well. We hope these licensing changes will allow for further adoption of these C++ libraries in enterprise environments, where building from source:</p>
<ul>
<li>removes friction in securing the supply chain,</li>
<li>creates a smooth migration path to the latest MSVC versions,</li>
<li>presents opportunities for further runtime performance optimizations, and</li>
<li>potentially allows for more active OSS contributions to these libraries</li>
</ul>
<h3 id="whats-next">What&#8217;s Next</h3>
<p>We are actively working to further simplify the acquisition of the MSVC toolchain and all its dependencies, to make it as easy as possible to <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">bootstrap a C++ environment on Windows</a> for C++ developers as well as for other language communities that chose to depend on MSVC toolchain. Stay tuned for more news on our blog.</p>
<p>For questions or feedback on these licensing changes, please reach out to us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or on Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/">Updates to Visual Studio Build Tools license for C and C++ Open-Source projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>proxy: Runtime Polymorphism Made Easier Than Ever</title>
		<link>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/</link>
					<comments>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/#comments</comments>
		
		<dc:creator><![CDATA[Mingxin Wang]]></dc:creator>
		<pubDate>Mon, 15 Aug 2022 15:00:41 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Experimental]]></category>
		<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30853</guid>

					<description><![CDATA[<p>proxy is a single-header cross-platform library that facilitates runtime polymorphism.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/">proxy: Runtime Polymorphism Made Easier Than Ever</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><code>proxy</code> is an open-source, cross-platform, single-header C++ library, making runtime polymorphism easier to implement and faster, empowered by our breakthrough innovation of Object-oriented Programming (OOP) theory in recent years. Consider three questions:</p>
<ol>
<li>Do you want to facilitate architecture design and matainance by writing non-intrusive polymorphic code in C++ as easily as in Rust or Golang?</li>
<li>Do you want to facilitate lifetime management of polymorphic objects as easily as in languages with runtime Garbage Collection (GC, like Java or C#), <em>without</em> compromising performance?</li>
<li>Have you tried other polymorphic programming libraries in C++ but found them deficient?</li>
</ol>
<p>If so, this library is for you. You can find the implementation at <a href="https://github.com/microsoft/proxy">our GitHub repo</a>, integrate with your project using <a href="https://github.com/microsoft/vcpkg">vcpkg</a> (search for <code>proxy</code>), or learn more about the theory and technical specifications from <a href="https://wg21.link/p0957">P0957</a>.</p>
<h2 id="overview">Overview</h2>
<p>In C++ today, there are certain architecture and performance limitations in existing mechanisms of polymorphism, specifically, virtual functions (based on inheritance) and various polymorphic wrappers (with value semantics) in the standard. As a result, <code>proxy</code> can largely replace the existing &#8220;virtual mechanism&#8221; to implement your vision in runtime polymorphism, while having no intrusion on existing code, with even better performance.</p>
<p>All the facilities of the library are defined in namespace <code>pro</code>. The 3 major class templates are <code>dispatch</code>, <code>facade</code> and <code>proxy</code>. Here is a demo showing how to use this library to implement runtime polymorphism in a different way from the traditional inheritance-based approach:</p>
<pre><code class="language-cpp">// Abstraction
struct Draw : pro::dispatch&lt;void(std::ostream&amp;)&gt; {
  template &lt;class T&gt;
  void operator()(const T&amp; self, std::ostream&amp; out) { self.Draw(out); }
};
struct Area : pro::dispatch&lt;double()&gt; {
  template &lt;class T&gt;
  double operator()(const T&amp; self) { return self.Area(); }
};
struct DrawableFacade : pro::facade&lt;Draw, Area&gt; {};

// Implementation (No base class)
class Rectangle {
 public:
  void Draw(std::ostream&amp; out) const
      { out &lt;&lt; "{Rectangle: width = " &lt;&lt; width_ &lt;&lt; ", height = " &lt;&lt; height_ &lt;&lt; "}"; }
  void SetWidth(double width) { width_ = width; }
  void SetHeight(double height) { height_ = height; }
  double Area() const { return width_ * height_; }

 private:
  double width_;
  double height_;
};

// Client - Consumer
std::string PrintDrawableToString(pro::proxy&lt;DrawableFacade&gt; p) {
  std::stringstream result;
  result &lt;&lt; "shape = ";
  p.invoke&lt;Draw&gt;(result);  // Polymorphic call
  result &lt;&lt; ", area = " &lt;&lt; p.invoke&lt;Area&gt;();  // Polymorphic call
  return std::move(result).str();
}

// Client - Producer
pro::proxy&lt;DrawableFacade&gt; CreateRectangleAsDrawable(int width, int height) {
  Rectangle rect;
  rect.SetWidth(width);
  rect.SetHeight(height);
  return pro::make_proxy&lt;DrawableFacade&gt;(rect);  // No heap allocation is expected
}</code></pre>
<h2 id="configure-your-project">Configure your project</h2>
<p>To get started, set the language level of your compiler to at least C++20 and get the header file (<a href="https://github.com/microsoft/proxy/blob/main/proxy.h">proxy.h</a>). You can also install the library via <a href="https://github.com/microsoft/vcpkg/">vcpkg</a>, which is a C++ library management software invented by Microsoft, by searching for &#8220;proxy&#8221;.</p>
<p>To integrate with CMake, 3 steps are required:</p>
<ol>
<li>Set up the vcpkg manifest by adding &#8220;proxy&#8221; as a dependency in your <code>vcpkg.json</code> file:
<pre><code class="language-json">{
"name": "&lt;project_name&gt;",
"version": "0.1.0",
"dependencies": [
{
  "name": "proxy"
}
]
}</code></pre>
</li>
<li>Use <code>find_package</code> and <code>target_link_libraries</code> commands to reference to the library <code>proxy</code> in your <code>CMakeLists.txt</code> file:
<pre><code class="language-cmake">find_package(proxy CONFIG REQUIRED)
target_link_libraries(&lt;target_name&gt; PRIVATE msft_proxy)</code></pre>
</li>
<li>Run CMake with vcpkg toolchain file:
<pre><code class="language-cmake">cmake &lt;source_dir&gt; -B &lt;build_dir&gt; -DCMAKE_TOOLCHAIN_FILE=&lt;vcpkg_dir&gt;/scripts/buildsystems/vcpkg.cmake</code></pre>
</li>
</ol>
<h2 id="what-makes-the-proxy-so-charming">What makes the &#8220;proxy&#8221; so charming</h2>
<p>As a polymorphic programming library, <code>proxy</code> has various highlights, including:</p>
<ol>
<li>being <em>non-intrusive</em></li>
<li>allowing lifetime management <em>per object</em>, complementary with smart pointers</li>
<li>high-quality code generation</li>
<li>supporting flexible composition of abstractions</li>
<li>optimized syntax for Customization Point Objects (CPO) and modules</li>
<li>supporting general-purpose static reflection</li>
<li>supporting expert performance tuning</li>
<li>high-quality diagnostics.</li>
</ol>
<p>In this section, we will briefly introduce each of the highlights listed above with concrete examples.</p>
<h3 id="highlight-1-being-non-intrusive">Highlight 1: Being non-intrusive</h3>
<p>Designing polymorphic types with inheritance usually requires careful architecting. If the design is not thought through enough early on, the components may become overly complex as more and more functionality is added, or extensibility may be insufficient if polymorphic types are coupled too closely. On the other hand, some libraries (including the standard library) may not have proper polymorphic semantics even if they, by definition, satisfy same specific constraints. In such scenarios, users have no alternative but to design and maintain extra middleware themselves to add polymorphism support to existing implementations.</p>
<p>For example, some programming languages provide base types for containers, which makes it easy for library authors to design APIs without binding to a specific data structure at runtime. However, this is not feasible in C++ because most of the standard containers are not required to have a common base type. I do not think this is a design defect of C++, on the contrary, I think it is reasonable not to overdesign for runtime abstraction before knowing the concrete requirements both for the simplicity of the semantics and for runtime performance. With <code>proxy</code>, because it is non-intrusive, if we want to abstract a mapping data structure from indices to strings for localization, we may define the following facade:</p>
<pre><code class="language-cpp">struct at : pro::dispatch&lt;std::string(int)&gt; {
  template &lt;class T&gt;
  auto operator()(T&amp; self, int key) { return self.at(key); }
};
struct ResourceDictionaryFacade : pro::facade&lt;at&gt; {};</code></pre>
<p>It could proxy any potential mapping data structure, including but not limited to <code>std::map&lt;int, std::string&gt;</code>, <code>std::unordered_map&lt;int, std::string&gt;</code>, <code>std::vector&lt;std::string&gt;</code>, etc.</p>
<pre><code class="language-cpp">// Library
void DoSomethingWithResourceDictionary(pro::proxy&lt;ResourceDictionaryFacade&gt; p) {
  try {
    std::cout &lt;&lt; p.invoke(1) &lt;&lt; std::endl;
  } catch (const std::out_of_range&amp; e) {
    std::cout &lt;&lt; "No such element: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}

// Client
std::map&lt;int, std::string&gt; var1{{1, "Hello"}};
std::vector&lt;std::string&gt; var2{"I", "love", "Proxy", "!"};
DoSomethingWithResourceDictionary(&amp;var1);  // Prints "Hello"
DoSomethingWithResourceDictionary(&amp;var2);  // Prints "love"
DoSomethingWithResourceDictionary(std::make_shared&lt;std::unordered_map&lt;int, std::string&gt;&gt;());  // Prints "No such element: {implementation-defined error message}"</code></pre>
<p>Overall, inheritance-based polymorphism has certain limitations in usability. As <a href="https://www.youtube.com/watch?v=QGcVXgEVMJg">Sean Parent commented on NDC 2017</a>: <em>The requirements of a polymorphic type, by definition, comes from its use, and there are no polymorphic types, only polymorphic use of similar types. Inheritance is the base class of evil</em>.</p>
<h3 id="highlight-2-evolutionary-lifetime-management">Highlight 2: Evolutionary lifetime management</h3>
<p>It is such a pain to manage lifetime of objects in large systems written in C++. Because C++ does not have built-in GC support due to performance considerations, users need to beware of lifetime management of every single object. Although we have smart pointers since C++11 (i.e., <code>std::unique_ptr</code> and <code>std::shared_ptr</code>), and various 3rd-party fancy pointers like <code>boost::interprocess::offset_ptr</code>, they are not always sufficient for polymorphic use with inheritance. By using the <code>proxy</code> complementary with smart pointers, clients could care less about lifetime management as if there is runtime GC, but without compromising performance.</p>
<p>Before using any polymorphic object, the first step is always to create it. In other programming languages like Java or C#, we can <code>new</code> an object at any time and runtime GC will take care of lifetime management when it becomes unreachable, at the cost of performance. But how should we implement it in C++? Consider the <code>drawable</code> example in the &#8220;Overview&#8221; section: given there are 3 <code>drawable</code> types in a system: <code>Rectangle</code>, <code>Circle</code>, and <code>Point</code>. Specifically,</p>
<ul>
<li><code>Rectangle</code>s have width, height, transparency, and area</li>
<li><code>Circle</code>s have radius, transparency, and area</li>
<li><code>Point</code>s do not have any property; its area is always zero</li>
</ul>
<p>A library function <code>MakeDrawableFromCommand</code> shall be defined as a factory function responsible for creating a <code>drawable</code> instance by parsing the command line.</p>
<p>Here is how we usually define the types with inheritance:</p>
<pre><code class="language-cpp">// Abstraction
class IDrawable {
 public:
  virtual void Draw(std::ostream&amp; out) const = 0;
  virtual double Area() const = 0;
  // Don't forget the virtual destructor, otherwise `delete`ing a pointer of `IDrawable` may result in memory leak!
  virtual ~IDrawable() {}  
};

// Implementation
class Rectangle : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  void SetWidth(double width);
  void SetHeight(double height);
  void SetTransparency(double);
  double Area() const override;
};
class Circle : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  void SetRadius(double radius);
  void SetTransparency(double transparency);
  double Area() const override;
};
class Point : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  constexpr double Area() const override { return 0; }
};</code></pre>
<p>If we use <code>std::string</code> to represent the command line, the parameter type of <code>MakeDrawableFromCommand</code> could be <code>const std::string&amp;</code>, where there should not be much debate. But what should the return type be? <code>IDrawable*</code>? <code>std::unique_ptr&lt;IDrawable&gt;</code>? Or <code>std::shared_ptr&lt;IDrawable&gt;</code>? Specifically,</p>
<ul>
<li>If we use <code>IDrawable*</code>, the semantics of the return type is ambiguous because it is a raw pointer type and does not indicate the lifetime of the object. For instance, it could be allocated via <code>operator new</code>, from a memory pool or even a global object. Clients always need to learn the hidden contract from the author (or even need to learn the implementation details if the author and documentation are not available for consulting) and properly disposing of the object when the related business has finished via <code>operator delete</code> or some other way corresponding to how it was allocated.</li>
<li>If we use <code>std::unique_ptr&lt;IDrawable&gt;</code>, it means every single object is allocated individually from the heap, even if the value is potentially immutable or reusable (&#8220;flyweight&#8221;), which is potentially bad for performance.</li>
<li>If we use <code>std::shared_ptr&lt;IDrawable&gt;</code>, the performance could become better for flyweight objects due to the relatively low cost of copying, but the ownership of the object becomes ambiguous (a.k.a. &#8220;ownership hell&#8221;), and the thread-safety guarantee of copy-construction and destruction of <code>std::shared_ptr</code> may also add to runtime overhead. On the other hand, if we prefer <code>std::shared_ptr</code> across the whole system, every polymorphic type is encouraged to inherit <code>std::enable_shared_from_this</code>, which may significantly affect the design and maintenance of a large system.</li>
</ul>
<p>For <code>proxy</code>, with the definition from the &#8220;Overview&#8221; section, we can simply define the return type as <code>pro::proxy&lt;DrawableFacade&gt;</code> without further concern. In the implementation, <code>pro::proxy&lt;DrawableFacade&gt;</code> could be instantiated from all kinds of pointers with potentially different lifetime management strategy. For example, <code>Rectangle</code>s may be created every time when requested from a memory pool, while the value of <code>Point</code>s could be cached throughout the lifetime of the program:</p>
<pre><code class="language-cpp">pro::proxy&lt;DrawableFacade&gt; MakeDrawableFromCommand(const std::string&amp; s) {
  std::vector&lt;std::string&gt; parsed = ParseCommand(s);
  if (!parsed.empty()) {
    if (parsed[0u] == "Rectangle") {
      if (parsed.size() == 3u) {
        static std::pmr::unsynchronized_pool_resource rectangle_memory_pool;
        std::pmr::polymorphic_allocator&lt;&gt; alloc{&amp;rectangle_memory_pool};
        auto deleter = [alloc](Rectangle* ptr) mutable
            { alloc.delete_object&lt;Rectangle&gt;(ptr); };
        Rectangle* instance = alloc.new_object&lt;Rectangle&gt;();
        std::unique_ptr&lt;Rectangle, decltype(deleter)&gt; p{instance, deleter};  // Allocated from a memory pool
        p-&gt;SetWidth(std::stod(parsed[1u]));
        p-&gt;SetHeight(std::stod(parsed[2u]));
        return p;  // Implicit conversion happens
      }
    } else if (parsed[0u] == "Circle") {
      if (parsed.size() == 2u) {
        Circle circle;
        circle.SetRadius(std::stod(parsed[1u]));
        return pro::make_proxy&lt;DrawableFacade&gt;(circle);  // SBO may apply
      }
    } else if (parsed[0u] == "Point") {
      if (parsed.size() == 1u) {
        static Point instance;  // Global singleton
        return &amp;instance;
      }
    }
  }
  throw std::runtime_error{"Invalid command"};
}</code></pre>
<p>The full implementation of the example above could be found in our <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_integration_tests.cpp#L87-L116">integration tests</a>. In this example, there are 3 <code>return</code> statements in different branches and the return types are also different. Lifetime management with inheritance-based polymorphism is error-prone and inflexible, while <code>proxy</code> allows easy customization of any lifetime management strategy, including but not limited to raw pointers and various smart pointers with potentially pooled memory management.</p>
<p>Specifically, Small Buffer Optimization (SBO, a.k.a., SOO, Small Object Optimization) is a common technique to avoid unnecessary memory allocation (see the second <code>return</code> statement). However, for inheritance-based polymorphism, there are few facilities in the standard that support SBO; for other standard polymorphic wrappers, implementations may support SBO, but there is no standard way to configure it so far. For example, if the size of <code>std::any</code> is <code>n</code>, it is theoretically impossible to store the concrete value whose size is larger than <code>n</code> without external storage.</p>
<p><strong>The top secret making <code>proxy</code> both easy-to-use and fast is that it allows lifetime management <em>per object</em></strong>, which had not been addressed in traditional OOP theory (inheritance-based polymorphism) ever before.</p>
<p>If you have tried other polymorphic programming libraries in C++ before, you may or may not find this highlight of lifetime management unique to <code>proxy</code>. Some of these libraries claim to support various lifetime management model, but do not allow <em>per-object</em> customization like <code>proxy</code> does.</p>
<p>Take <a href="https://github.com/ldionne/dyno"><code>dyno</code></a> as an example. <code>dyno</code> is another non-intrusive polymorphic programming library in C++. Given an &#8220;interface&#8221; type <code>I</code>, <code>dyno</code> does not allow <code>dyno::poly&lt;I&gt;</code> to have a different lifetime management model. By default, <code>dyno::poly&lt;I&gt;</code> always allocates from the heap by the time this blog was written (see <a href="https://github.com/ldionne/dyno/blob/b05a51eeaa4ddd7deb9e3100984bf20cfbf94eab/include/dyno/poly.hpp#L64">typename Storage = dyno::remote_storage</a>). For example, if we want to take advantage of SBO, it is needed to override the <code>Storage</code> type, i.e., <code>dyno::poly&lt;I, dyno::sbo_storage&lt;...&gt;&gt;</code>, which is a different type from <code>dyno::poly&lt;I&gt;</code>. Therefore, <code>dyno::poly&lt;I&gt;</code> could not be used to implement features like <code>MakeDrawableFromCommand</code> above, where the optimal lifetime management model of each branch may differ. Whereas <code>proxy</code> does not have a second template parameter. Given a facade type <code>F</code>, <code>pro::proxy&lt;F&gt;</code> is compatible with <em>any</em> lifetime management model within the constraints of the facade.</p>
<h3 id="highlight-3-high-quality-code-generation">Highlight 3: High-quality code generation</h3>
<p>Not only does <code>proxy</code> allow efficient lifetime management per object, but also it could generate high quality code for every indirect call. Specifically,</p>
<ol>
<li>Invocations from <code>proxy</code> could be properly inlined, except for the virtual dispatch on the client side, similar to the inheritance-based mechanism.</li>
<li>Because <code>proxy</code> is based on pointer semantics, the &#8220;dereference&#8221; operation may happen inside the virtual dispatch, which always generates different instructions from the inheritance-based mechanism.</li>
<li>As tested, with &#8220;clang 13.0.0 (x86-64)&#8221; and &#8221; clang 13.0.0 (RISC-V RV64)&#8221;, <code>proxy</code> generates one more instruction than the inheritance-based mechanism, while the situation is reversed with &#8220;gcc 11.2 (ARM64)&#8221;. This may infer that <code>proxy</code> could have similar runtime performance in invocation with the inheritance-based mechanism at least on the 3 processor architectures (x86-64, ARM64, RISC-V RV64).</li>
</ol>
<p>More details of code generation analysis could be found in <a href="https://wg21.link/p0957">P0957</a>.</p>
<h3 id="highlight-4-composition-of-abstractions">Highlight 4: Composition of abstractions</h3>
<p>To support reuse of declaration of expression sets, like inheritance of virtual base classes, the <code>facade</code> allows combination of different dispatches with <code>std::tuple</code>, while duplication is allowed. For example,</p>
<pre><code class="language-cpp">struct D1;
struct D2;
struct D3;
struct FA : pro::facade&lt;D1, D2, D3&gt; {};
struct FB : pro::facade&lt;D1, std::tuple&lt;D3, D2&gt;&gt; {};
struct FC : pro::facade&lt;std::tuple&lt;D1, D2, D3&gt;, D1, std::tuple&lt;D2, D3&gt;&gt; {};</code></pre>
<p>In the sample code above, given <code>D1</code>, <code>D2</code> and <code>D3</code> are well-formed dispatch types, <code>FA</code>, <code>FB</code> and <code>FC</code> are equivalent. This allows &#8220;diamond inheritance&#8221; of abstraction without</p>
<ul>
<li>syntax ambiguity</li>
<li>coding techniques like &#8220;virtual inheritance&#8221;</li>
<li>extra binary size</li>
<li>runtime overhead</li>
</ul>
<h3 id="highlight-5-syntax-for-cpos-and-modules">Highlight 5: Syntax for CPOs and modules</h3>
<p>Along with the standardization of Customization Point Objects (CPO) and improved syntax for Non-Type Template Parameters (NTTP), there are two recommended ways to define a &#8220;dispatch&#8221; type:</p>
<p>The first way is to manually overload <code>operator()</code> as demonstrated before. This is useful when a dispatch is intended to be defined in a header file shared with multiple translation units, e.g., in <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_invocation_tests.cpp#L25-L33">tests/proxy_invocation_tests.cpp</a>:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct ForEach : pro::dispatch&lt;void(pro::proxy&lt;CallableFacade&lt;void(T&amp;)&gt;&gt;)&gt; {
 template &lt;class U&gt;
 void operator()(U&amp; self, pro::proxy&lt;CallableFacade&lt;void(T&amp;)&gt;&gt;&amp;&amp; func) {
  for (auto&amp; value : self) {
   func.invoke(value);
  }
 }
};</code></pre>
<p>The second way is to specify a <code>constexpr</code> callable object as the second template parameter. It provides easier syntax if a corresponding CPO is defined before, or the &#8220;dispatch&#8221; is intended to be defined in a module with lambda expressions, e.g. in <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_invocation_tests.cpp#L23">tests/proxy_invocation_tests.cpp</a>:</p>
<pre><code class="language-cpp">struct GetSize : pro::dispatch&lt;std::size_t(), std::ranges::size&gt; {};</code></pre>
<h3 id="highlight-6-static-reflection">Highlight 6: Static reflection</h3>
<p>Reflection is an essential requirement in type erasure, and <code>proxy</code> welcomes general-purpose static (compile-time) reflection other than <code>std::type_info</code>.</p>
<p>In other languages like C# or Java, users are allowed to acquire detailed metadata of a type-erased type at runtime with simple APIs, but this is not true for <code>std::function</code>, <code>std::any</code> or inheritance-based polymorphism in C++. Although these reflection facilities add certain runtime overhead to these languages, they do help users write simple code in certain scenarios. In C++, as the reflection TS keeps evolving, there will be more static reflection facilities in the standard with more specific type information deduced at compile-time than <code>std::type_info</code>. It becomes possible for general-purpose reflection to become zero-overhead in C++ polymorphism.</p>
<p>As a result, we decided to make <code>proxy</code> support general-purpose static reflection. It&#8217;s off by default, and theoretically won&#8217;t impact runtime performance other than the target binary size if turned on. Here is an example to reflect the given types to <code>MyReflectionInfo</code>:</p>
<pre><code class="language-cpp">class MyReflectionInfo {
 public:
  template &lt;class P&gt;
  constexpr explicit MyReflectionInfo(std::in_place_type_t&lt;P&gt;) : type_(typeid(P)) {}
  const char* GetName() const noexcept { return type_.name(); }

 private:
  const std::type_info&amp; type_;
};

struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  using reflection_type = MyReflectionInfo;
};</code></pre>
<p>Users may call <code>MyReflectionInfo::GetName()</code> to get the implementation-defined name of a type at runtime:</p>
<pre><code class="language-cpp">pro::proxy&lt;MyFacade&gt; p;
puts(p.reflect().GetName());  // Prints typeid(THE_UNDERLYING_POINTER_TYPE).name()</code></pre>
<h3 id="highlight-7-performance-tuning">Highlight 7: Performance tuning</h3>
<p>To allow implementation balance between extensibility and performance, a set of constraints to a pointer is introduced, including maximum size, maximum alignment, minimum copyability, minimum relocatability and minimum destructibility. The term &#8220;relocatability&#8221; was introduced in <a href="https://wg21.link/p1144">P1144</a>, &#8220;equivalent to a move and a destroy&#8221;. This blog uses the term &#8220;relocatability&#8221; but does not depend on the technical specifications of <a href="https://wg21.link/p1144">P1144</a>.</p>
<p>While the size and alignment could be described with <code>std::size_t</code>, the constraint level of copyability, relocatability and destructibility are described with enum <code>pro::constraint_level</code>, which includes <code>none</code>, <code>nontrivial</code>, <code>nothrow</code> and <code>trivial</code>, matching the standard wording. The defaults are listed below:</p>
<table>
<thead>
<tr>
<th><strong>Constraints</strong></th>
<th><strong>Defaults</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Maximum size</td>
<td>The size of two pointers</td>
</tr>
<tr>
<td>Maximum alignment</td>
<td>The alignment of a pointer</td>
</tr>
<tr>
<td>Minimum copyability</td>
<td>None</td>
</tr>
<tr>
<td>Minimum relocatability</td>
<td>Nothrow</td>
</tr>
<tr>
<td>Minimum destructibility</td>
<td>Nothrow</td>
</tr>
</tbody>
</table>
<p>We can assume the default maximum size and maximum alignment greater than or equal to the implementation of raw pointers, <code>std::unique_ptr</code> with default deleters, <code>std::unique_ptr</code> with any one-pointer-size of deleters and <code>std::shared_ptr</code> of any type.</p>
<p>Note that the default minimum copyability is &#8220;None&#8221;, which means <code>proxy</code> could be instantiated from a non-copyable type like <code>std::unique_ptr</code>. However, if we never want to instantiate a <code>proxy</code> with non-copyable types (including <code>std::unique_ptr</code>) and want the <code>proxy</code> to be copyable, it is allowed to customize it in a facade definition:</p>
<pre><code class="language-cpp">// Abstraction
struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  static constexpr auto minimum_copyability = pro::constraint_level::nontrivial;
};

// Client
pro::proxy&lt;MyFacade&gt; p0 = /* Omitted */;
auto p1 = p0;  // Calls the constructor of the underlying pointer type</code></pre>
<p>In some cases where we clearly know we always instantiate a <code>proxy</code> with a raw pointer, and want to optimize the performance to the limit, it is allowed to add even more constraints in a facade definition, at the cost of reducing the scope of feasible pointer types:</p>
<pre><code class="language-cpp">// Abstraction
struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  static constexpr auto minimum_copyability = pro::constraint_level::trivial;
  static constexpr auto minimum_relocatability = pro::constraint_level::trivial;
  static constexpr auto minimum_destructibility = pro::constraint_level::trivial;
  static constexpr auto maximum_size = sizeof(void*);
  static constexpr auto maximum_alignment = alignof(void*);
};

// Client
static_assert(std::is_trivially_copy_constructible_v&lt;pro::proxy&lt;MyFacade&gt;&gt;);
static_assert(std::is_trivially_destructible_v&lt;pro::proxy&lt;MyFacade&gt;&gt;);</code></pre>
<p><strong>IMPORTANT NOTICE</strong>: clang will fail to compile if the <strong>minimum_destructibility</strong> is set to <strong>constraint_level::trivial</strong> in a facade definition. The root cause of this failure is that the implementation requires the language feature defined in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0848r3.html">P0848R3: Conditionally Trivial Special Member Functions</a>, but it has not been implemented in clang, according to its <a href="https://clang.llvm.org/cxx_status.html">documentation</a>, at the time this blog was written.</p>
<h3 id="highlight-8-diagnostics">Highlight 8: Diagnostics</h3>
<p>The design of <code>proxy</code> is SFINAE-friendly, thanks to the Concepts feature since C++20. If it is used incorrectly, compile error messages could be generated accurately at the spot. For example, if we call the constructor of <code>proxy</code> with a pointer, whose type does not meet the facade definition:</p>
<pre><code class="language-cpp">pro::proxy&lt;MyFacade&gt; p;
p.invoke&lt;nullptr_t&gt;();  // nullptr_t is not a valid dispatch type</code></pre>
<p>Here is the error message gcc 11.2 will report:</p>
<pre><code class="language-text">&lt;source&gt;:550:22: error: no matching function for call to 'pro::proxy&lt;MyFacade&gt;::invoke&lt;nullptr_t&gt;()'
  550 |   p.invoke&lt;nullptr_t&gt;();
      |   ~~~~~~~~~~~~~~~~~~~^~
&lt;source&gt;:445:18: note: candidate: 'template&lt;class D, class ... Args&gt; decltype(auto) pro::proxy&lt;F&gt;::invoke(Args&amp;&amp; ...) requires (pro::details::dependent_traits&lt;pro::details::facade_traits&lt;F&gt;, D&gt;::dependent_t&lt;pro::details::facade_traits&lt;F&gt;, D&gt;::applicable) &amp;&amp; (pro::details::BasicTraits::has_dispatch&lt;D&gt;) &amp;&amp; (is_convertible_v&lt;std::tuple&lt;_Args2 ...&gt;, typename D::argument_types&gt;) [with D = D; Args = {Args ...}; F = MyFacade]'
  445 |   decltype(auto) invoke(Args&amp;&amp;... args)
      |                  ^~~~~~
&lt;source&gt;:445:18: note:   template argument deduction/substitution failed:
&lt;source&gt;:445:18: note: constraints not satisfied</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>We hope this has helped clarify how to take advantage of the library &#8220;proxy&#8221; to write polymorphic code easier. If you have any questions, comments, or issues with the library, you can comment below, file issues in <a href="https://github.com/microsoft/proxy">our GitHub repo</a>, or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/">proxy: Runtime Polymorphism Made Easier Than Ever</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
	</channel>
</rss>
