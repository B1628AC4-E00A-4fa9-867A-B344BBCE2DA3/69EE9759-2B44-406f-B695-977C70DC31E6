<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Mon, 24 Oct 2022 16:03:13 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Improving Copy and Move Elision</title>
		<link>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/#comments</comments>
		
		<dc:creator><![CDATA[Bran Hagger]]></dc:creator>
		<pubDate>Mon, 24 Oct 2022 16:00:31 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31231</guid>

					<description><![CDATA[<p>With Visual Studio 2022 version 17.4 Preview 3, we&#8217;ve significantly increased the number of situations where we do copy or move elision and given users more control over whether these transformations are enabled.<br />
What are copy and move elision?<br />
When a return keyword in a C++ function is followed by an expression of non-primitive type,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>With Visual Studio 2022 version 17.4 Preview 3, we&#8217;ve significantly increased the number of situations where we do copy or move elision and given users more control over whether these transformations are enabled.</p>
<h2 id="what-are-copy-and-move-elision">What are copy and move elision?</h2>
<p>When a <code>return</code> keyword in a C++ function is followed by an expression of non-primitive type, the execution of that return statement copies the result of the expression into the return slot of the calling function. To do this, the copy or move constructor of the non-primitive type is called. Then, as part of exiting the function, destructors for function-local variables are called, likely including any variables named in the expression following the <code>return</code> keyword.</p>
<p>The C++ specification allows the compiler to construct the returned object directly in the return slot of the calling function, eliding the copy or move constructor executed as part of the return. Unlike most other optimizations, this transformation is allowed to have an observable effect on the program&#8217;s output &#8211; namely, the copy or move constructor and associated destructor are called one less time.</p>
<h2 id="mandatory-copy-move-elision-in-visual-studio">Mandatory copy/move elision in Visual Studio</h2>
<p>The C++ standard <em>requires</em> copy or move elision when the returned value is initialized as part of the <code>return</code> statement (such as when a function with return type <code>Foo</code> returns <code>return Foo()</code>). The Microsoft Visual C++ compiler always performs copy and move elision for return statements where it is required to do so, regardless of the flags passed to the compiler. This behavior is unchanged.</p>
<h2 id="changes-to-optional-copy-move-elision-in-visual-studio-17-4-preview-3">Changes to optional copy/move elision in Visual Studio 17.4 Preview 3</h2>
<p>When the returned value is a named variable, the compiler <em>may</em> elide the copy or move but is not required to do so. The standard still requires a copy or move constructor to be defined for the named return variable, even if the compiler elides the constructor in all cases. Prior to Visual Studio 2022 version 17.4 Preview 3, when optimizations were disabled (such as with the <code>/Od</code> compiler flag or for functions marked with <code>#pragma optimize("", off)</code>) the compiler would only perform mandatory copy and move elision. With the <code>/O2</code> flag, the compiler would perform optional copy or move elision for optimized functions with simple control flow.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, we are giving developers the option for consistency with the new <code>/Zc:nrvo</code> compiler flag. The <code>/Zc:nrvo</code> flag will be passed by default when code is compiled with the <code>/O2</code> flag, the <code>/permissive-</code> flag, or when compiling for <code>/std:c++20</code> or later. When this flag is passed, copy and move elision will be performed wherever possible. We would like to turn <code>/Zc:nrvo</code> on by default in a future release.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, optional copy/move elision can also be explicitly disabled with the <code>/Zc:nrvo-</code> flag. It is impossible to disable mandatory copy/move elision.</p>
<p>In Visual Studio 2022 version 17.4 Preview 3, we are also increasing the number of places where we do copy/move elision when optional copy/move elision is enabled with the <code>/Zc:nrvo</code>, <code>/O2</code>, <code>/permissive-</code>, or <code>/std:c++20</code> or later flags.</p>
<table>
<thead>
<tr>
<th></th>
<th>Earlier versions of Visual Studio</th>
<th>Visual Studio 17.4 Preview 3 and later</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mandatory copy/move elision</td>
<td>Always occurs.</td>
<td>Always occurs.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in function without loops or exception handling</td>
<td>Occurs under <code>/O2</code> unless the function has multiple returned symbols with overlapping lifetimes or the type&#8217;s copy or move constructor has default arguments.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in a loop</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in functions with exception handling</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable when the copy or move constructor has additional default arguments</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for throw of a named variable</td>
<td>Never occurs.</td>
<td>Never occurs.</td>
</tr>
</tbody>
</table>
<h2 id="examples-of-optional-copy-move-elision">Examples of optional copy/move elision</h2>
<p>The simplest example of optional copy or move elision is a function such as:</p>
<pre><code class="language-C++">Foo SimpleReturn() {
    Foo result;
    return result;
}</code></pre>
<p>Earlier versions of the MSVC compiler already elided the copy or move of <code>result</code> into the return slot in this case if the <code>/O2</code> flag was passed. In Visual Studio 2022 version 17.4 Preview 3, the copy or move is also elided if the <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed, and retained if the <code>/Zc:nrvo-</code> flag is passed.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, we now perform copy/move elision in the following additional cases if the <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed to the compiler and the <code>/Zc:nrvo-</code> flag is not:</p>
<h3 id="return-inside-a-loop">Return inside a loop</h3>
<pre><code class="language-C++">Foo ReturnInALoop(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        Foo result;
        if (i == (iterations / 2)) {
            return result;
        }
    }
}</code></pre>
<p>The <code>result</code> object will be properly constructed at the start of each iteration of the loop and destructed at the end of each iteration. On the iteration where <code>result</code> is returned, its destructor will not be called on exit from the function. The function&#8217;s caller will destroy the returned object when it falls out of scope in that function.</p>
<h3 id="return-with-exception-handling">Return with exception-handling</h3>
<pre><code class="language-C++">Foo ReturnInTryCatch() {
    try {
        Foo result;
        return result;
    } catch (...) {}
}</code></pre>
<p>The copy or move of the <code>result</code> object will now be elided if the <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed and the <code>/Zc:nrvo-</code> flag is not. We also now properly handle more complex cases such as:</p>
<pre><code class="language-C++">int n;

void throwFirstThreeIterations() {
    ++n;
    if (n &lt;= 3) throw n;
}

Foo ComplexTryCatch()
{
Label1:
    Foo result;

    try {
        throwFirstThreeIterations();
        return result;
    }
    catch(...) {
        goto Label1;    
    }
}</code></pre>
<p>The <code>result</code> object will be constructed in the return slot for the caller function and no copy/move constructor or destructor will be called for it on a successful return. When an exception is thrown, whether or not the <code>result</code> object is destructed is determined by which exception-handling flags are passed to the compiler. By default, no stack-unwinding will occur and therefore no destructors will be called. However, if stack-unwinding exception handling is enabled with the <code>/EHs</code>, <code>/EHa</code>, or <code>/EHr</code> flags, <code>goto Label1</code> will cause <code>result</code>&#8216;s destructor to be called because it jumps to before <code>result</code> is initialized. Either way, when the expression <code>Foo result</code> is reached again, the object will be constructed again in the return slot.</p>
<h3 id="copy-constructors-with-default-arguments">Copy constructors with default arguments</h3>
<p>We now properly detect that a copy or move constructor with default arguments is still a copy or move constructor, and therefore can be elided in the cases above. A copy constructor with default parameters will look something like the following:</p>
<pre><code class="language-C++">struct StructWithCopyConstructorDefaultParam {
   int X;

   StructWithCopyConstructorDefaultParam(int x) : X(x) {}
   StructWithCopyConstructorDefaultParam(StructWithCopyConstructorDefaultParam const&amp; original, int defaultParam = 0) :
      X(original.X + defaultParam) {
      printf("Copy constructor called.\n");
   }
};
</code></pre>
<h2 id="limitations-on-nrvo">Limitations on NRVO</h2>
<p>Although the MSVC compiler now performs copy and move elision in many more situations, it is not always possible to perform copy/move elision. To see why this is true, consider the following function:</p>
<pre><code class="language-C++">Foo WhichShouldIReturn(bool condition) {
    Foo resultA;
    if (condition) {
        Foo resultB;
        return resultB;
    }
    return resultA;
}</code></pre>
<p>Copy elision constructs the object to be returned in the return slot, but which object should be constructed in the return slot in this case? For the copy of <code>resultA</code> to be elided at <code>return resultA</code>, it must be constructed in the return slot. However, if <code>condition</code> is true, <code>resultB</code> will need to be constructed in the return slot before <code>resultA</code> is destroyed. There is no way to perform copy elision for both paths.</p>
<p>We currently choose to avoid doing optional copy/move elision on all paths in a function if copy/move elision is impossible on any path. However, changes to inlining decisions, dead code elimination, and other optimizations can change whether copy or move elision is possible. For this reason, it is never safe to write code that depends on certain behavior for copy/move elision of named variables unless all optional copy/move elision is disabled with <code>/Zc:nrvo-</code>.</p>
<p>As long as stack-unwinding exception handling is enabled or no exceptions are thrown, it is still safe to assume that every constructer call has a matching destructor call.</p>
<h2 id="feedback">Feedback</h2>
<p>We encourage you to try out this update in the latest Visual Studio 2022 version 17.4 Preview. Please let us know what you think or any issues you encounter. We can be reached via the comments below, via twitter (<a href="https://twitter.com/visualc">@visualC</a>) or via <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 06 Oct 2022 18:02:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31188</guid>

					<description><![CDATA[<p>The September 2022 release of the vcpkg package manager is available. This blog post summarizes changes from August 15th, 2022 to September 27th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
&#160;<br />
vcpkg now has over 2,000 unique libraries in its open-source registry<br />
With this release,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">September 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from August 15<sup>th</sup>, 2022 to September 27<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>&nbsp;</p>
<h3 id="vcpkg-now-has-over-2000-unique-libraries-in-its-open-source-registry">vcpkg now has over 2,000 unique libraries in its open-source registry</h3>
<p>With this release, and the 6<sup>th</sup> anniversary of the launch of vcpkg, we are proud to hit a new milestone:<strong> over 2,000 unique open-source libraries</strong> are available in the vcpkg catalog! vcpkg continues to maintain the largest catalog of any C/C++ package manager with over 10,000 unique library versions with built-in support for many popular architectures, operating systems, and compilers, including x64, x86, arm, arm64, WebAssembly, Linux, macOS, Windows, iOS, Android, FreeBSD, UWP, MSVC, Clang, gcc, mingw, as well as static and shared (dynamic) libraries and more! And of course, since vcpkg is configured to build all these libraries from source, you can make further customizations as needed for your unique workflow.</p>
<p>From the beginning, we have invested extensively in building a large ecosystem of libraries supporting as many development workflows as possible, and we will continue to honor that commitment. While the C++ ecosystem is incredibly diverse, we will rise to the challenge and try to make as many developers as possible more productive. Managing libraries is well understood as a top C++ pain point in annual ISO C++ surveys, but we hope that will change over the next several years.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>48 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>419 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>2,022 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are over <strong>10,839 port versions</strong>.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">September release of the main vcpkg repo</a> includes <strong>249 commits</strong>.</li>
<li><strong>95 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.8k forks</strong> and <strong>16.8k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<p>While last month was relatively quiet, this month’s update includes several vcpkg tool changes. See the full tool <a href="https://github.com/microsoft/vcpkg-tool/compare/2022-07-21...2022-09-20">commit changelog</a> for details. Notable changes are summarized below.</p>
<p>&nbsp;</p>
<h4 id="optional-name-and-version-fields-in-vcpkg-json">Optional name and version fields in vcpkg.json</h4>
<p><code>vcpkg.json</code> is the manifest file for specifying library dependencies, versions, optional features and other metadata required for acquiring ports. Previously, two fields were always mandatory for this file:</p>
<ul>
<li><code>name</code>: specifies a name for the project this manifest resides in.</li>
<li><code>version</code>: specifies a version for the project this manifest resides in.</li>
</ul>
<p>These fields are only really useful if your project is a library or other port that you want to package with vcpkg. However, we required the same schema for all projects consuming vcpkg ports (even if they themselves are not a port), which may be confusing for users. From now on, these fields are optional for projects that are only consuming ports, but not producing one. If you’re packaging a library for use in vcpkg however, you absolutely still need to specify these fields as they are critical for consumers to be able to consume your library via vcpkg.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/605">Microsoft/vcpkg-tool#605</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-artifacts-improvements">vcpkg artifacts improvements</h4>
<p>We are continuing to improve our preview experience for vcpkg artifacts, which enable acquisition of developer tools like compilers and debuggers from vcpkg. These are some changes in this release, especially for multiple registry scenarios:</p>
<ul>
<li>The <code>--registry</code>switch has been removed as registries are required to have a name.</li>
<li>Commands which take as input registry names or IDs now combine the set of registry names from the global set and the local project.</li>
<li>Console output now always displays registries using the following rules:
<ul>
<li>If the registry URI is in the project, the name of the project is used.</li>
<li>If the registry URI is not in the project, and the name of the registry in the global configuration does not conflict with the project, the global configuration’s name is used.</li>
<li>Otherwise, the URI enclosed in []s is used. This is a signal to vcpkg users that they will need to provide an appropriate registry name if they want something different.</li>
</ul>
</li>
<li>The command x-regenerate I now requires a local file path.</li>
<li>Several places that used to break when handling relative paths now tolerate the situation correctly, including x-regenerate.</li>
<li>If an artifact declares a dependency from a particular registry, and that registry’s name is not declared in the artifact itself, resolution fails. Vcpkg will no longer try to find the name in the project/global configuration.</li>
<li>Commands that need activation like add and remove no longer try to activate the project automatically.</li>
<li>Artifacts are now installed and enumerated in topological sorted order.</li>
<li>There is no longer a built-in registry named “default”.</li>
<li>Except for index.yaml, all remaining YAML files have been replaced with JSON. This may invalidate existing installed artifacts. This change was necessary in order to make the artifacts experience more consistent with our existing experience for managing ports.</li>
<li>Output messages have been cleaned up, including the removal of several newlines.</li>
<li>Bug fix: the console output no longer gets confused around registry names and no longer displays names using a “[URL]” format when it is unnecessary to do so.</li>
</ul>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/690">Microsoft/vcpkg-tool#690</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/693">Microsoft/vcpkg-tool#693</a></p>
<p>&nbsp;</p>
<h4 id="cleaned-up-console-output-when-not-connected-to-a-console">Cleaned up console output when not connected to a console</h4>
<p>We fixed some console output bugs when vcpkg is not connected to a console/TTY. Specifically:</p>
<ul>
<li>VT codes when showing tables should now be displayed correctly.</li>
<li>Progress bars are no longer displayed as the extra output may be undesirable in CI systems and also was not displaying correctly at times.</li>
</ul>
<p><strong>Before (non-TTY): </strong></p>
<p><img width="1489" height="191" class="wp-image-31202" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4.png" alt="Graphical user interface Description automatically generated with low confidence" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4.png 1489w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-300x38.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-1024x131.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-768x99.png 768w" sizes="(max-width: 1489px) 100vw, 1489px" /></p>
<p><strong>After (non-TTY): </strong></p>
<p><img width="1393" height="661" class="wp-image-31203" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2.png" alt="Text Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2.png 1393w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-300x142.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-1024x486.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-768x364.png 768w" sizes="(max-width: 1393px) 100vw, 1393px" /></p>
<p><strong>In TTY: </strong></p>
<p><img width="1630" height="412" class="wp-image-31204" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5.png" alt="Graphical user interface Description automatically generated with low confidence" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-300x76.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-1024x259.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-768x194.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-1536x388.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/702">Microsoft/vcpkg-tool#702</a></p>
<p>&nbsp;</p>
<h4 id="added-schemata-for-vcpkg-json-vcpkg-configuration-json-and-artifacts">Added schemata for vcpkg.json, vcpkg-configuration.json, and artifacts</h4>
<p>We added official schemas for our manifest files to make it easier to validate that files are authored correctly. In the future, we will also be using this experience to validate manifest files opened in Visual Studio and Visual Studio Code and notify users if errors are present using the IntelliSense experience.</p>
<p>You can try it yourself for the vcpkg.json and vcpkg-configuration.json manifests by</p>
<p>adding the following to the appropriate .json file:</p>
<p><code>"$schema": https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/vcpkg.schema.json</code></p>
<p><img width="1018" height="677" class="wp-image-31205" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2.png 1018w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2-300x200.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2-768x511.png 768w" sizes="(max-width: 1018px) 100vw, 1018px" /></p>
<p>To try it out on JSON files describing artifacts,</p>
<p>add the following to the file:</p>
<p><code>"$schema": https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/artifact.schema.json</code></p>
<p><img width="1050" height="562" class="wp-image-31206" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2.png 1050w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-300x161.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-1024x548.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-768x411.png 768w" sizes="(max-width: 1050px) 100vw, 1050px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/650">Microsoft/vcpkg-tool#650</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,823</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,879</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,784</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,795</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>956</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,444</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>910</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,738</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,810</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>Thomas1664 (21 commits)</li>
<li>dg0yt (16 commits)</li>
<li>Neumann-A (14 commits)</li>
<li>wrobelda (5 commits)</li>
<li>autoantwort (4 commits)</li>
<li>m-kuhn (4 commits)</li>
<li>coryan (4 commits)</li>
<li>RT222 (2 commits)</li>
<li>eao197 (2 commits)</li>
<li>chausner (2 commits)</li>
<li>Osyotr (2 commits)</li>
<li>daschuer (1 commit)</li>
<li>ekilmer (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>myd7349 (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>past-due (1 commit)</li>
<li>DragonJoker (1 commit)</li>
<li>xvitaly (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">full September release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue </a><span style="color: #00a9e0;">tracker </span>or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<h3 id="interested-in-vcpkg-but-not-sure-where-to-start">Interested in vcpkg but not sure where to start?</h3>
<p>Is your company experiencing challenges managing C/C++ libraries? Perhaps you&#8217;re curious if a package manager is the right choice to you? Please reach out to vcpkg@microsoft.com and we&#8217;d be happy to help!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</title>
		<link>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/</link>
					<comments>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Mon, 03 Oct 2022 21:59:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31177</guid>

					<description><![CDATA[<p>One of the new features for C++ developers in Visual Studio 2022 version 17.3 is NuGet PackageReference support for C++/CLI MSBuild projects that target .NET Core and .NET 5 or higher. More specifically, this impacts CLR Class Library (.NET) and CLR Empty Project (.NET) project templates.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/">Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>One of the new features for C++ developers in Visual Studio 2022 version 17.3 is <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files">NuGet PackageReference</a> support for <strong>C++/CLI MSBuild projects that target .NET Core and .NET 5 or higher</strong>. More specifically, this impacts <em>CLR Class Library (.NET)</em> and <em>CLR Empty Project (.NET)</em> project templates. This functionality allows you to manage NuGet packages while bringing the <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/migrate-packages-config-to-package-reference">benefits of PackageReference</a> support to your dependencies. This feature is on by default for new projects. To enable this feature for your existing projects, add the following property to your project file:</p>
<p><code>&lt;PropertyGroup Label="Globals"&gt;</code></p>
<p><code>&lt;EnableManagedPackageReferenceSupport&gt;true&lt;/EnableManagedPackageReferenceSupport&gt; &lt;/PropertyGroup&gt;</code></p>
<p>In most cases, you will want to enable this for the whole codebase. You can do this by setting the property in a <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2022">Directory.Build.props file</a> instead.</p>
<p>When this property is set to <strong>true</strong>, NuGet will recognize on project load that the project is participating in the PackageReference experience and begin restoring packages just as it would for a .NET project.</p>
<p><strong>Note:</strong> in order to modify this setting in any way, it is required to unload the project file, make the change, then reload it for the change to take effect. This setting cannot be changed for an actively loaded project.</p>
<p>&nbsp;</p>
<h3 id="is-packagereference-support-limited-to-managed-c-cli-projects">Is PackageReference support limited to managed C++/CLI projects?</h3>
<p>In short, yes. It is important to support NuGet PackageReference for projects that touch .NET code since NuGet is the recommended dependency management solution for .NET. Furthermore, the C++ team will continue supporting C++/CLI projects as an interop story between C++ and .NET.</p>
<p>For native C++ projects, we recommend using vcpkg for both C++ open-source and closed source libraries. With compilation from source, binary caching, custom registries, version conflict resolution, and more, we believe this will provide the best experience for managing C/C++ dependencies. vcpkg can also target a large variety of platforms and architectures natively and works with any C++ build system.</p>
<p>With that said, we would love to hear your feedback on language interop scenarios with C++: <a href="https://developercommunity.visualstudio.com/report?space=8&amp;ftype=idea&amp;entry=suggestion">please file suggestion tickets</a> on Developer Community.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback</h3>
<p>We would love to hear from you! <a id="post-31177-_Hlk110857813"></a><a href="https://visualstudio.microsoft.com/">Download Visual Studio 2022</a>, give it a try, and file bugs or feature requests on <a href="https://developercommunity.visualstudio.com/home">Visual Studio Developer Community</a>. For new issues within NuGet, please report a <a href="https://github.com/NuGet/Home/issues/new/choose">GitHub Issue</a>. For general NuGet experience issues, let us know via the <a href="https://learn.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022">Report a Problem</a> option in Visual Studio found under the <em>Help &gt; Report A Problem </em>menu.</p>
<p>Feel free to leave comments in this blog post with your thoughts or reach out to us at <a href="mailto:visualc@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/">Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Using system package manager dependencies with vcpkg</title>
		<link>https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/</link>
					<comments>https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Shaw]]></dc:creator>
		<pubDate>Wed, 28 Sep 2022 21:55:20 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31151</guid>

					<description><![CDATA[<p>According to C++ 2022 developer survey, the top 3 ways to manage C++ libraries were having the library source code as part of the build, compiling the library separately from instructions, and acquiring the library from a system package manager. Language package managers,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/">Using system package manager dependencies with vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>According to C++ 2022 developer survey, the top 3 ways to manage C++ libraries were having the library source code as part of the build, compiling the library separately from instructions, and acquiring the library from a system package manager. Language package managers, such as vcpkg, simplify library management by offering the ease of use of a system package manager with the power, flexibility, and portability of building from source.</p>
<p>vcpkg brings several advantages to C++ library management. First, vcpkg supports a wide range of customizations for each library. vcpkg installs libraries with a specific version. For additional configuration, each library supports various features and flags. Second, the vcpkg catalog supports over 1900 libraries. Third, vcpkg brings finer control: once a library and feature set are selected, that library&#8217;s configuration will be consistent on any platform.</p>
<p>However, there are certain scenarios where using a system package manager is the better choice. You can deploy ABI compatible security and bug fixes without deploying the entire application. Multiple applications can use the same shared library, which reduces deployment size. And sometimes, company policy requires using a particular system package dependency. </p>
<p>In the first example, we will show what it will look like if we strictly use dependencies from vcpkg. In the second example, we will replace some dependencies with system package manager ones.</p>
<p>This blogpost is for advanced users of vcpkg. To get started with vcpkg instead, see <a href="https://github.com/microsoft/vcpkg">https://github.com/microsoft/vcpkg</a>.</p>
<h3 id="building-an-application-with-dependencies-from-the-vcpkg-catalog">Building an application with dependencies from the vcpkg catalog</h3>
<p>In this example, we are using Ubuntu 22.04 and the x64-linux triplet. First, create three files in an empty project directory: vcpkg.json, main.cpp, and CMakeLists.txt.</p>
<pre class="prettyprint">
//vcpkg.json
{
    "name": "test-project", 
    "version": "1.0.0",
    "dependencies": [
        "azure-core-cpp"
        "curl"
    ]
}</pre>
<pre class="prettyprint">
//main.cpp
#include &#60;curl/curl.h&#62;
#include &#60;azure/core/internal/strings.hpp&#62;
#include &#60;iostream&#62;

using namespace std;
using Azure::Core::_internal::StringExtensions;

int main() {
    cout &#60;&#60; curl_version() &#60;&#60; endl;
    cout &#60;&#60; StringExtensions::LocaleInvariantCaseInsensitiveEqual("aA", "aa") &#60;&#60; endl;
}</pre>
<pre class="prettyprint">
# CMakeLists.txt
cmake_minimum_required(VERSION 3.22)
project(test-project)
add_executable(main main.cpp)
find_package(CURL REQUIRED)
find_package(azure-core-cpp CONFIG REQUIRED)
target_link_libraries(main PUBLIC Azure::azure-core CURL::libcurl)</pre>
<p>Configuring the project:</p>
<pre class="prettyprint">cmake &#60;path to project&#62; -DCMAKE_TOOLCHAIN_FILE=&#60;path to vcpkg&#62;/scripts/buildsystems/vcpkg.cmake

... [build output]
Detecting compiler hash for triplet x64-linux...
The following packages will be built and installed:
azure-core-cpp[core,curl,http]:x64-linux -&#62; 1.7.1
curl[core,non-http,openssl,ssl]:x64-linux -&#62; 7.84.0#1
* openssl[core]:x64-linux -&#62; 3.0.5#4
* vcpkg-cmake[core]:x64-linux -&#62; 2022-07-18
* vcpkg-cmake-config[core]:x64-linux -&#62; 2022-02-06#1
* zlib[core]:x64-linux -&#62; 1.2.12#1
Additional packages (*) will be modified to complete this operation.
...</pre>
<p>Building and running main:</p>
<pre class="prettyprint">cmake --build . &#38;&#38; ./main

[ 50%] Building CXX object CMakeFiles/main.dir/main.cpp.o
[100%] Linking CXX executable main
[100%] Built target main
libcurl/7.82.0-DEV OpenSSL/3.0.2 zlib/1.2.12
1</pre>
<p>We can use ldd to list the shared libraries:</p>
<pre class="prettyprint">ldd main

linux-vdso.so.1 (0x00007ffc32bf1000)
libstdc++.so.6 =&#62; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f816357a000)
libm.so.6 =&#62; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f8163493000)
libgcc_s.so.1 =&#62; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f8163473000)
libc.so.6 =&#62; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f816324b000)
/lib64/ld-linux-x86-64.so.2 (0x00007f8163cf0000)</pre>
<h3 id="using-curl-and-openssl-from-the-system-package-manager">Using curl and OpenSSL from the system package manager</h3>
<p>You can use <a href="https://github.com/microsoft/vcpkg/blob/master/docs/specifications/ports-overlay.md" rel="noopener" target="_blank">port overlays</a> to configure vcpkg to use the system package manager dependencies. We will build the previous example and use curl and OpenSSL from the system package manager.</p>
<p>Install the developer dependencies for curl with an OpenSSL backend and OpenSSL:</p>
<pre class="prettyprint">sudo apt-get install libcurl4-openssl-dev libssl-dev</pre>
<p>Create the port overlay directory and file structure:</p>
<pre class="prettyprint">mkdir -p &#60;path to project&#62;/overlays/curl &#60;path to project&#62;/overlays/openssl</pre>
<pre class="prettyprint">//&#60;path to project&#62;/overlays/curl/vcpkg.json
{
    "name": "curl",
    "version": "1.0.0",
    "port-version": 0,
    "features": {
        "ssl": {
            "description": ""
        }
    }
}</pre>
<pre class="prettyprint"># &#60;path to project&#62;/overlays/curl/portfile.cmake
set(VCPKG_POLICY_EMPTY_PACKAGE enabled)</pre>
<pre class="prettyprint">//&#60;path to project&#62;/overlays/openssl/vcpkg.json
{
    "name": "openssl",
    "version": "3.0.5"
}</pre>
<pre class="prettyprint"># &#60;path to project&#62;/overlays/openssl/portfile.cmake
set(VCPKG_POLICY_EMPTY_PACKAGE enabled)</pre>
<p>Building with CMake (we’re using the same project in the previous example):</p>
<pre class="prettyprint">cmake &#60;path to project&#62; -DVCPKG_OVERLAY_PORTS=&#60;path to project&#62;/overlays -DCMAKE_TOOLCHAIN_FILE=&#60;path to vcpkg&#62;/scripts/buildsystems/vcpkg.cmake

-- Running vcpkg install
Detecting compiler hash for triplet x64-linux...
The following packages will be built and installed:
azure-core-cpp[core,curl,http]:x64-linux -&#62; 1.7.1
curl[core,non-http,openssl,ssl]:x64-linux -&#62; 7.84.0#1 -- &#60;path to project&#62;/overlays/curl
* openssl[core]:x64-linux -&#62; 3.0.5#4 -- &#60;path to project&#62;/overlays/openssl
* vcpkg-cmake[core]:x64-linux -&#62; 2022-07-18
* vcpkg-cmake-config[core]:x64-linux -&#62; 2022-02-06#1
Additional packages (*) will be modified to complete this operation.
...</pre>
<p>Building and running main:</p>
<pre class="prettyprint">cmake --build .
.\main

libcurl/7.81.0 OpenSSL/3.0.2 zlib/1.2.11 brotli/1.0.9 zstd/1.4.8 libidn2/2.3.2 libpsl/0.21.0 (+libidn2/2.3.2) libssh/0.9.6/openssl/zlib nghttp2/1.43.0 librtmp/2.3 OpenLDAP/2.5.11
1</pre>
<p>Checking whether we’ve linked the correct shared libraries (libssl and libcurl):</p>
<pre class="prettyprint">ldd main

libcurl.so.4 =&#62; /lib/x86_64-linux-gnu/libcurl.so.4 (0x00007f632c1c0000)
libssl.so.3 =&#62; /lib/x86_64-linux-gnu/libssl.so.3 (0x00007f632c11c000)
libcrypto.so.3 =&#62; /lib/x86_64-linux-gnu/libcrypto.so.3 (0x00007f632bcda000)
libstdc++.so.6 =&#62; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f632baae000)
libm.so.6 =&#62; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f632b9c7000)
... (25+ more dependencies)</pre>
<p>You will notice curl and openssl from the system package manager have more dependencies than the curl and openssl from the vcpkg catalog. In the above example, we only added port overlays for the dependencies that we use. If you were to build a more complex application that would depend on other dependencies, you would need to add additional overlays.</p>
<p>Both the vcpkg and the system packager catalogs can contain the same library, and we need to make sure the application only links one copy of each library. Linking two different versions of the same library could lead to ODR violations.
In the example, curl from the system package manager pulls in OpenSSL as a dependency. We overlayed the OpenSSL dependency in vcpkg to prevent vcpkg from also acquiring OpenSSL from its catalog.</p>
<h4 id="how-did-cmake-find-curl"> How did CMake find curl?</h4>
<p>When find_package(CURL) is called, CMake searches for the CURL libraries in the vcpkg_installed directory. If the CURL libraries are not found on the CMake paths, it defaults to the FindCurl module which finds the system dependency.</p>
<h3 id="learn-more"> Learn More </h3>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/" rel="noopener" target="_blank">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues" rel="noopener" target="_blank">issue tracker</a> or join a more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions" rel="noopener" target="_blank">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap" rel="noopener" target="_blank">roadmap</a> page.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/">Using system package manager dependencies with vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>A Visual Studio Debugger Extension for the Raspberry Pi Camera</title>
		<link>https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/</link>
					<comments>https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/#comments</comments>
		
		<dc:creator><![CDATA[Paul Maybee]]></dc:creator>
		<pubDate>Wed, 21 Sep 2022 15:04:55 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30885</guid>

					<description><![CDATA[<p>While developing a sample application for a Raspberry Pi with a camera using the RaspiCam library, it occurred to me that it would be convenient and fun to be able to see the current camera input while debugging the application.  The Visual Studio debugger supports type-specific custom visualizers and end-user extensions that implement UI for these visualizers.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/">A Visual Studio Debugger Extension for the Raspberry Pi Camera</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>While developing a sample application for a Raspberry Pi with a camera using the <a href="https://github.com/rmsalinas/raspicam">RaspiCam</a> library, it occurred to me that it would be convenient and fun to be able to see the current camera input while debugging the application.  The Visual Studio debugger supports type-specific custom visualizers and end-user extensions that implement UI for these visualizers. I decided to make one for the RaspiCam camera types that would display the current image from the camera. The image below is the end result, showing Visual Studio debugging a program running on the Raspberry Pi and displaying the content of a Raspberry Pi camera object in a pop-up debugger visualizer.</p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/08/Picture1.png" alt="Picture of rasperry pi displaying camera" /></p>
<h5 id="build-a-raspicam-application">Build a RaspiCam Application</h5>
<p><span class="TextRun SCXW83782341 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentStart CommentHighlightPipeRest CommentHighlightRest SCXW83782341 BCX8">I needed a sample Raspberry Pi camera application.</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> I downloaded the <a href="https://gnutoolchains.com/raspberry/">Raspberry Pi SDK</a></span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> and a CM</span><span class="NormalTextRun SpellingErrorV2Themed CommentHighlightRest SCXW83782341 BCX8">ake</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> toolchain to my windows machine</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">. I downloaded </span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">the <a href="https://github.com/rmsalinas/raspicam">Raspiam cd camera library</a> </span></span><span class="TextRun SCXW83782341 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">and <a href="https://github.com/opencv/opencv">OpenCV</a></span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">. I used the Raspberry Pi toolchain to build </span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">both these repositories. I then created a new CM</span><span class="NormalTextRun SpellingErrorV2Themed CommentHighlightRest SCXW83782341 BCX8">ake</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> project in Visual Studio, wrote a simple camera application and linked to these two libraries. My </span><span class="NormalTextRun SpellingErrorV2Themed CommentHighlightRest SCXW83782341 BCX8">CMakePresets.json</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> file contains this configuration</span><span class="NormalTextRun CommentHighlightPipeRest SCXW83782341 BCX8">:</span></span><span class="EOP SCXW83782341 BCX8" data-ccp-props="{}"> </span></p>
<pre class="prettyprint">  "configurePresets": [
    {
      "name": "raspberrypi-Debug",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/out/build/${presetName}",
      "installDir": "${sourceDir}/out/install/${presetName}",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "C:/temp/raspberry/toolchain-rpi.cmake",
        "OpenCV_DIR": "D:\\opencv-4.5.5\\opencv-4.5.5\\out\\install\\RaspberryPi-Debug\\lib\\cmake\\opencv4",
        "raspicam_DIR": "D:\\raspicam\\out\\install\\raspberrypi-Debug\\lib\\cmake"
      },
      "environment": {
        "RASPBIAN_ROOTFS": "c:/temp/raspberry/arm-linux-gnueabihf/sysroot",
        "PATH": "c:/temp/raspberry/bin;$env{Path}"
      }
    }
  ],
  "buildPresets": [
   {
      "name": "cross-build",
      "environment": {
        "PATH": "c:/temp/raspberry/bin;$penv{PATH}"
      },
      "configurePreset": "raspberrypi-Debug"
    }
  ]
</pre>
<p>My Raspberry Pi application uses the OpenCV library and the <code>RaspiCam_Still_Cv</code> camera type for capturing and manipulating the camera image.</p>
<pre>    raspicam::RaspiCam_Still_Cv Camera;
    cv::Mat image;

    Camera.open();
    Camera.grab();
    Camera.retrieve(image);
    cv::imwrite("raspicam_cv_image.jpg", image);</pre>
<p>I wanted to debug this application on the Pi so I added the launch configuration below. This instructs the debugger to first deploy the application to my RaspberryPi device in directory ~/camera. I copied all the shared OpenCV and RaspiCam libraries I needed to this directory too.</p>
<pre>    {
      "type": "cppgdb",
      "name": "DebugOnPi",
      "project": "CMakeLists.txt",
      "projectTarget": "simpletest_raspicam",
      "debuggerConfiguration": "gdb",
      "MIMode": "gdb",
      "args": [],
      "env": {},
      "deployDirectory": "~/camera",
      "remoteMachineName": "<em>&lt;your-connection-name-here&gt;</em>",
      "preDebugCommand": "export LD_LIBRARY_PATH=~/camera"
    }</pre>
<p>I could now debug on the Raspberry Pi.</p>
<h5 id="add-visualizers-to-the-linux-debugger">Add Visualizers to the Linux Debugger</h5>
<p>Although the Visual Studio Windows debugger supports UI visualizers, it turned out that the Visual Studio Linux debugger did not have this feature implemented.  Since the Raspberry Pi runs Raspian, a Debian Linux variant, the first thing I had to do was fix that. The Linux debugger is an open source project called <a href="https://github.com/Microsoft/MIEngine">MIEngine</a>. The MIEngine runs as a Visual Studio debugger “engine” that controls a gdb process running remotely on a Linux host. The MIEngine already supported custom variable visualization using <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2022">natvis</a> files (example below). However, it did not support the <code>UIVizualizer</code> tag in natvis files which is necessary to open a new visualization window containing, for example, a camera image. The work described here is now part of the MIEngine and in Visual Studio. The completed PR with the changes is <a href="https://github.com/microsoft/MIEngine/pull/1281">here</a>. Remember it’s open source, so you too can contribute in this way!</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010"&gt;
     &lt;UIVisualizer ServiceId="{0A73397B-D550-4BFE-94C9-C0E5122DC06F}" Id="1"
             MenuName="Raspberry Still Camera (OpenCV) Visualizer"/&gt;

      &lt;Type Name="raspicam::RaspiCam_Still_Cv"&gt;
         &lt;UIVisualizer ServiceId="{0A73397B-D550-4BFE-94C9-C0E5122DC06F}" Id="1" /&gt;
      &lt;/Type&gt;            
&lt;/AutoVisualizer&gt;</pre>
<p>There were two changes I needed to make to the MIEngine: First was to recognize and process the <code>UIVisualizer</code> element in natvis files and second was to automatically load natvis files for registered Visual Studio extensions.</p>
<ul>
<li>Recognizing the element was simple. The MIEngine already parsed natvis files, it was just ignoring the <code>UIVisualizer</code> element. I simply changed the natvis lookup code to return not just the visualized string value for an expression, but also a list of any <code>UIVisualizers</code> that were present for the expression type. The MIEngine returns an expression value to the Visual Studio debugger as an <code><a href="https://github.com/microsoft/MIEngine/blob/main/src/MIDebugEngine/AD7.Impl/AD7Property.cs">AD7Property</a></code>. I updated the <code>AD7Property</code> class to also return the list of <code>UIVisualizers</code> found.</li>
<li>The MIEngine makes requests of Visual Studio via its <code><a href="https://github.com/microsoft/MIEngine/tree/main/src/DebugEngineHost">DebugEngineHost</a></code>. In order to support visualization, I needed to call into Visual Studio from the <code>DebugEngineHost</code> and ask it for an <code>IVsExtensionManagerPrivate</code> service reference. I then called into the resulting service asking for a list of all resources tagged as “<code>NativeCrossPlatformVisualizer</code>”. It returned a list of file names for resources that have this tag. These are given to the MIEngine natvis processor for parsing.</li>
</ul>
<p>Finally, there was an additional feature that was missing from the MIEngine. It didn’t have a convenient way for a caller holding an <code>AD7Property</code> object to determine the execution context (that is, stack frame) where the expression that generated that property was evaluated. So, I extended the <code>AD7Property</code> class to implement a new interface <code><a href="https://github.com/microsoft/MIEngine/blob/main/src/DebugEngineHost.Stub/Shared/Microsoft.VisualStudio.Debugger.Interop.MI.cs">IDebugMIEngineProperty</a></code> that contains a method for returning the properties <code>IDebugExpressionContext2</code>. Now all the parts are in place for developing a <code>UIVisualizer</code> for Linux applications.</p>
<h5 id="create-a-visualizer-vsix-project">Create a Visualizer VSIX Project</h5>
<p>The <code>UIVisualizer</code> for a data type is identified in natvis by a GUID <em>ServiceId</em> and an integer <em>Id</em>. These are the values the debugger will use to find and open the associated visualizer. The <em>ServiceId</em> identifies a type that implements <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.debugger.interop.ivscppdebuguivisualizer?view=visualstudiosdk-2022"><code>VsCppDebugUIVisualizer</code></a>. The Id identified which of its visualizers to open – in the case that more than one visualizer is supported by the service. I needed to author a service for my camera picture viewer as a visual studio extension.</p>
<p>To start, I created a VSIX (Visual Studio extension project) called PictureViewer (you need to have the “Visual Studio extension development” workload installed). Then I defined an interface for my visualizer tagged with my viewer’s <em>ServiceId</em> and attributed the VSIX Package object with this interface. I now had to define the relationship between the <code>UIVisualizer</code> element in the natvis file with this VSIX package.</p>
<pre>[Guid("0A73397B-D550-4BFE-94C9-C0E5122DC06F")]
public interface IPictureViewerService
{
}
…
[PackageRegistration(UseManagedResourcesOnly = true, AllowsBackgroundLoading = true)]
[ProvideService(typeof(IPictureViewerService), ServiceName = "PictureViewerService", IsAsyncQueryable = true)]
[Guid(PictureViewerPackage.PackageGuidString)]
public sealed class PictureViewerPackage : AsyncPackage
{
…
}</pre>
<p>I then added a new <code>PictureViewerService</code> that implements both <code>IPictureViewerService</code> and <code>IVsCppDebugUIVisualizer</code>. The only method it implements is <code>IVsCppDebugUIVisualizer.DisplayValue</code>.</p>
<pre>int DisplayValue(uint ownerHwnd, uint visualizerId, IDebugProperty3 debugProperty)

</pre>
<p>This is the API called by the debugger to display a value using a custom <code>UIVisualizer</code>. The already evaluated expression value is passed to the visualizer in the <code>debugProperty</code> object.</p>
<p>I implemented my UI in class <code>PictureViewerViewModel</code>. The UI in this example is very simple, just an Image and a Button in a pop-up window. When the service activates the UI the view model object fires off a task to load the image from the application being debugged and then invokes <code><a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.window.showdialog?view=netframework-4.7.2">ShowDialog</a></code>. The XAML snippet below defines the content of the dialog.</p>
<pre>&lt;Grid Margin="4"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="*" /&gt;
        &lt;RowDefinition Height="Auto" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Image Width="{Binding Image.Width}" Height="{Binding Image.Height}"
        Source="{Binding Image}"/&gt;
    &lt;Button Grid.Row="1" Margin="4,0" x:Uid="LoadNext_Button"
            Content="Next"
            Command="{Binding ClickCommand, Mode=OneTime}" /&gt;
&lt;/Grid&gt;

</pre>
<p>The view model is where the work is done to populate the UI from the camera content. In this case I was interested in retrieving JPEG content from the camera and using it to create a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.imaging.bitmapimage?view=netframework-4.7.2">BitmapImage</a>. To get an image from a camera object the debugger must perform the same operations that the application would have to do to do the same thing. Or more accurately, the debugger must instruct the debuggee to do these steps using expression evaluation. The code below uses Visual Studio debugger APIs to evaluate a string expression given an <code>IDebugMIEngineProperty</code> <em>context</em>. It returns both a string with the debugger’s result of the evaluation and a memory context object that can be used to read the raw bytes of that result.</p>
<pre>private DEBUG_PROPERTY_INFO EvalExpression(string expr, out IDebugMemoryContext2 ppMemory)
{

   if (context.ParseText(expr, enum_PARSEFLAGS.PARSE_EXPRESSION, 10, out IDebugExpression2 ppExpr, out string error, out uint errorCode) != VSConstants.S_OK)
   {
      throw new ApplicationException($"Failed to parse expression '{expr}'.");
   }

   if (ppExpr.EvaluateSync(0, 0, null, out IDebugProperty2 prop) != VSConstants.S_OK)
   {
      throw new ApplicationException($"Failed to evaluate expression '{expr}'.");
   }

   DEBUG_PROPERTY_INFO[] value = new DEBUG_PROPERTY_INFO[1]; ;
   if (prop.GetPropertyInfo(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE, 10, 0, null, 0, value) != VSConstants.S_OK)
   {
      throw new ApplicationException($"Failed to get expression value for '{expr}'.");
   }

   if (prop.GetMemoryContext(out ppMemory) != VSConstants.S_OK)
   {
      ppMemory = null;
   }

   return value[0];
}

</pre>
<p>Now I needed to implement the right sequence of expression evaluations. I based the sequence on the sample C++ code below that retrieves an in-memory jpg image from a camera object.</p>
<pre>raspicam::RaspiCam_Still_Cv Camera;
...
cv::Mat image;
Camera.grab();
Camera.retrieve(image);

vector&lt;uchar&gt; jpgImage;
vector&lt;int&gt; jpgParams;
cv::InputArray ia = cv::_InputArray(image);
string jpg = ".jpg";

cv::imencode(jpg, ia, jpgImage, jpgParams);

</pre>
<p>Since I have registered the visualizer for the camera type, the debugProperty object that is passed into the visualizer will contain the results of evaluating a <code>RaspiCam_Still_Cv</code> object. It can be cast to an <code>IDebugMIEngineProperty</code> and used to get a context for evaluating expressions. The final result is that the debuggee application creates an in-memory object containing a JPEG image. The debugger then reads the bytes from the debuggee memory and creates the BitmapImage.</p>
<p>The first thing you might notice is that this sequence of evaluations involves creating several objects: <em>image</em>, <em>jpgImage</em>, <em>jpgParams</em>, <em>ia</em>, and <em>jpg</em>. These objects do not exist on the debuggee so they must be created. To create an object via expression evaluation, the debugger must first malloc the memory for the object and then invoke the object’s constructor. I do this in <code>MakeHeapObject</code> below:</p>
<pre>private string MakeHeapObject(string type, string constructor, string cparams = "")
{
   var address = this.EvalExpression($"malloc(sizeof({type}))");
   if (!address.bstrValue.StartsWith("0x"))
   {
      throw new ApplicationException(address.bstrValue);
   }

   var init = this.EvalExpression(
                $"(({type} *){address.bstrValue})-&gt;{constructor}({cparams})");
   return address.bstrValue;
}</pre>
<p>For example, to make an object of type “<code>vector&lt;int&gt;</code>,” the visualizer calls:</p>
<pre>this.MakeHeapObject("std::vector&lt;int, std::allocator&lt;int&gt; &gt;", "vector")

</pre>
<p>A string containing the new object’s address in the debuggee is returned, for example “<code>0xf7003421</code>”. <span class="NormalTextRun SCXW228642498 BCX9">The object is similarly </span><span class="NormalTextRun SCXW228642498 BCX9">deleted</span><span class="NormalTextRun SCXW228642498 BCX9"> in </span><code><span class="NormalTextRun SpellingErrorV2Themed SCXW228642498 BCX9">FreeHeapObject</span></code><span class="NormalTextRun SCXW228642498 BCX9"> when it is no longe</span><span class="NormalTextRun SCXW228642498 BCX9">r</span><span class="NormalTextRun SCXW228642498 BCX9"> needed. Notice that </span><span class="NormalTextRun SCXW228642498 BCX9">it is possible to introduce new interactions that would not have occurred whenever running code in the </span><span class="NormalTextRun SpellingErrorV2Themed SCXW228642498 BCX9">debuggee</span><span class="NormalTextRun SCXW228642498 BCX9">. It may not be</span><span class="NormalTextRun SCXW228642498 BCX9"> safe </span><span class="NormalTextRun SCXW228642498 BCX9">to create and destroy </span><span class="NormalTextRun SCXW228642498 BCX9">objects that</span> <span class="NormalTextRun SCXW228642498 BCX9">affect</span> <span class="NormalTextRun SCXW228642498 BCX9">shared resources.</span></p>
<p>Now all the pieces are in place for evaluating the sequence of expressions necessary to get the jpg image into a debuggee in-memory byte array. Once this is done the <code>IDebugMemoryContext2</code> is used to read the bytes from debuggee memory into a buffer in Visual Studio. The Bitmap image is created from a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream?view=netframework-4.7.2">MemoryStream</a> built on that buffer.</p>
<p>The VSIX project also needs to contain the .natvis file containing the type-to-Visualizer mapping (see top of this section). The VSIX manifest points to the file and tags it as a “<code>NativeCrossPlatformVisualizer</code>” asset.</p>
<pre>  &lt;Asset Type="NativeCrossPlatformVisualizer" Path="raspicam.natvis"/&gt;</pre>
<p>All the details can be found in <a href="https://github.com/microsoft/VisualStudioMIEnginePictureViewer">this git repository</a>, including the sample CMake application (above) to test with.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/">A Visual Studio Debugger Extension for the Raspberry Pi Camera</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Code Analysis Warnings with Key Events</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/#comments</comments>
		
		<dc:creator><![CDATA[Hwi-sung Im]]></dc:creator>
		<pubDate>Tue, 20 Sep 2022 15:00:33 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[New Feature]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[key events]]></category>
		<category><![CDATA[static analysis]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31106</guid>

					<description><![CDATA[<p>Introduction <br />
To make your C++ coding experience as safe as possible, the Microsoft C++ Code Analysis has added new checks and improved existing ones to help you prevent bugs before they find their way into your products. Some of the checks work harder than others,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/">Microsoft C++ Code Analysis Warnings with Key Events</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 aria-level="1" aria-level="1" id="introduction"><span data-contrast="none">Introduction</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">To make your C++ coding experience as safe as possible, the Microsoft C++ Code Analysis has added new checks and improved existing ones to help you prevent bugs before they find their way into your products. Some of the checks work harder than others, analyzing the code deeper by simulating runtime behavior. As such, they can find defects that are harder to find through syntactic checks alone or through data flow analysis.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">It is natural that developers find it harder to find the root causes for some of these more complex warnings. Imagine a warning where the effect of the bug is detected tens or hundreds of lines below the root cause of the bug, and the code against which the defect is reported looks completely legitimate. How would you be able to quickly find the root cause and fix it?</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">In this blog post, we would like to reintroduce an existing Visual Studio feature that has been there to help with this challenge, and to highlight the big improvements we have made to the feature which will make it easier and more compelling to use.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="challenges-with-code-analysis-warning"><span data-contrast="none">Challenges with Code Analysis Warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">Let’s review the usual challenges we have when a static code analysis check tells us there is a defect in our code. It can be best demonstrated with some example code with a known defect. The following example is intentionally made convoluted enough to demonstrate the challenge of finding the root cause for warnings from a path-sensitive check.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint"> 1   #include &lt;Windows.h&gt; 
 2   
 3   int test(); 
 4   
 5   void t1() 
 6   { 
 7       VARIANT v1; 
 8       VARIANT v2; 
 9       VARIANT v3{}; 
10   
11       VARIANT* pv = &amp;v3; 
12       VARIANT* pvTmp = nullptr; 
13   
14      VariantInit(&amp;v1); 
15   
16       if (test() != 0) 
17           pvTmp = &amp;v1; 
18       else 
19           pvTmp = &amp;v2; 
20    
21       switch (test()) 
22       { 
23       case 1: 
24       case 2: 
25           pv = pvTmp; 
26           break; 
27       default: 
28           pv = &amp;v3; 
29           break; 
30       } 
31   
32       VariantClear(pv); // Warning C33001 here 
33   }</pre>
<p><span data-contrast="auto">Running code analysis on this code will give a few warnings. One of them will be this:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint">test.cpp(32) : warning C33001: VARIANT 'pv' was cleared when it was uninitialized (expression 'pv').: Lines: 5, 7, 8, 9, 11, 12, 14, 16, 19, 21, 25, 26, 32</pre>
<p><span data-contrast="auto">In summary, clearing a <code>VARIANT</code> object that was not properly initialized can result in many random problems, including crashes, memory errors, etc. More information about this specific check can be found at </span><a href="https://docs.microsoft.com/bs-latn-ba/cpp/code-quality/c33001?view=msvc-160"><span data-contrast="none">c33001 | Microsoft Docs</span></a><span data-contrast="auto">. But for this discussion, let’s focus on the root cause of the defect – why does the check say we are clearing a <code>VARIANT</code> object that is not initialized?</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">The line of code to which the warning points us is completely legitimate: we must clear the <code>VARIANT</code> object before we are done with it. Then what is the problem? It must be that somewhere along the code flow that reaches line 32, the <code>VARIANT</code> object that <code>pv</code> points to has not been initialized.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Let’s try to find out where the root cause is. First, we will need to find out which <code>VARIANT</code> object <code>pv</code> points to. Then follow the code flow to see why that object has never been initialized. To figure those out, we will need to trace back the code flow from where the defect is reported. Because it is likely dependent on the path that the check analyzed, we will use the line numbers provided in the warning. That seems doable. However, that doesn’t seem to be the most efficient way. Imagine a similar bug is in an excessively big function. A similar warning may come with tens or hundreds of lines of code to trace back. Many of us would feel offended by such a warning, rather than helped.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">This blog post is not about finding root cause by tracking back source code manually like this. So, before going any further along this path, let’s see if there is any help available.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="code-analysis-warning-with-key-events"><span data-contrast="none">Code Analysis Warning with Key Events</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">It may not be well known, but selected warnings from some of MSVC&#8217;s C++ static analysis checks that have been there for long time always had additional information that helps with tracing back your code to identify the root causes. This additional information is called “Key Events.” A Key Event is associated with a step in the analysis code flow. It explains what has happened in that specific step. During analysis, these checks add Key Event candidates to the steps where important or interesting events occur, e.g., when a new buffer is created, etc. As a check finds a defect, it collects all relevant Key Events along the code flow that led to the defect and adds them to the warning. Some common events are also added as Key Events &#8211; e.g., when a relevant variable is initialized or updated, when code flow branches, etc.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Here is an example of a warning with Key Events from one of those older checks as they are presented in the Error List. You could get these by clicking on the expansion triangle icon in the left-most column of the warning:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>&nbsp;</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents.png"><img class="wp-image-31110 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents.png" alt="Image of C6001 warning with Key Events" width="841" height="213" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents.png 1157w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents-300x76.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents-1024x259.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/C6001_KeyEvents-768x194.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<p><span data-contrast="auto">As you can see, these Key Events add rich information to the warning, making it very easy to follow the code and understand what is going on along the code flow of the analysis.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="improvements-to-key-events"><span data-contrast="none">Improvements to Key Events</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We believe in the value of Key Events for our customers. So, we decided to remove the hinderances in making it available for more checks. We also made it a lot easier to use.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">To solve the first problem, we added equivalent support to our newer engine, allowing many newer checks to add Key Events to their warnings with little effort. This was done earlier, and new checks have been adding Key Events to their warnings. As of the release of Visual Studio 2022 version 17.4 Preview 2 we have augmented many checks with Key Events, including warnings for:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:1,&quot;335559684&quot;:-2,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769226&quot;:&quot;Symbol&quot;,&quot;469769242&quot;:[8226],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Enum misuse as buffer index: C33010 and C33011</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:1,&quot;335559684&quot;:-2,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769226&quot;:&quot;Symbol&quot;,&quot;469769242&quot;:[8226],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="auto">VARIANT object misuse: C33001 ~ C33005</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:1,&quot;335559684&quot;:-2,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769226&quot;:&quot;Symbol&quot;,&quot;469769242&quot;:[8226],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Concurrency problems: C26100 ~ C26167</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ul>
<p><span data-contrast="auto">We will add Key Events to even more warnings in the upcoming Visual Studio releases.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559685&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="2" aria-level="2" id="improved-key-event-presentation-in-visual-studio"><span data-contrast="none">Improved Key Event presentation in Visual Studio</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">Visual Studio 2022 version 17.4 Preview 2 comes with big improvements in presentation of the Key Events.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Key Events used to be presented inside the Error List window as shown earlier. Usually, real estate of Error List is very limited to present a warning with a large number of Key Events. Also, it was hard to interact with the Key Events in the list, due to missing features and bugs. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">First, we redesigned the way Visual Studio presents the Key Events for MSVC C++ static analysis warnings. Key Events will now be presented outside of Error List window, in their own window as follows:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p aria-level="2"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2.png"><img class="size-full wp-image-31116 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2.png" alt="Image Visual Studio built in Key Events window 2" width="1682" height="1227" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2.png 1682w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-300x219.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-1024x747.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-768x560.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Visual-Studio-built-in-Key-Events-window-2-1536x1120.png 1536w" sizes="(max-width: 1682px) 100vw, 1682px" /></a></p>
<p><span style="font-size: 1rem;" data-contrast="auto">You can open this window by selecting the warning with double clicking or pressing enter key, or clicking the small window icon on the left-most column of the warning entry in the Error List. This window is like any other tabbed window &#8211; it can be docked, floated, resized, or added to the tabbed windows. Selecting a Key Event in this window highlights the corresponding source line. Keyboard navigation among the Key Events is improved in this window, and source code highlighting follows the selected Key Event.</span><span style="font-size: 1rem;" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-contrast="auto">This will make it a lot easier to review the Key Events and navigate through them along with the corresponding source code, often greatly reducing the time to find the root cause of the defect. For the example code and the warning, now it is a lot easier to tell <code>pv</code> is pointing to <code>pvTmp</code>, and <code>pvTmp</code> is pointing to <code>v2</code>, which was never initialized in the code flow.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<h1 aria-level="2" aria-level="2" id="presentation-of-key-events-through-sarif-viewer-extension"><span data-contrast="none">Presentation of Key Events through SARIF Viewer Extension</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We have teamed up with the developers of the SARIF Viewer Extension for Visual Studio. Some of you may have tried its older versions before. If you haven’t tried it before, now is a good time to get the latest release and give it a try, as we believe it will greatly enhance your productivity with the improvements we made to the extension.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h2 aria-level="3" aria-level="3" id="visualization-of-key-events-in-sarif-explorer-window"><span data-contrast="none">Visualization of Key Events in SARIF Explorer window</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">Through close collaboration among related teams, we greatly improved the functionality of the SARIF Viewer Extension for Visual Studio. When installed and enabled this extension can now display Key Events in its SARIF Explorer window without requiring you to find and open the SARIF file. You just need to select the warning that has the small window icon on the left-most column by <span style="font-size: 1rem;" data-contrast="auto">double clicking or pressing the enter key, or clicking the small window icon</span>. Visual Studio will let SARIF Viewer Extension display the Key Events, instead of its own pop-up window:</span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio.png"><img class="size-full wp-image-31117 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio.png" alt="Image Key Events presentation in SARIF Explorer window of SARIF Viewere Extension for Visual Studio" width="2447" height="1381" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio.png 2447w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-300x169.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-1024x578.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-768x433.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-1536x867.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-SARIF-Explorer-window-of-SARIF-Viewere-Extension-for-Visual-Studio-2048x1156.png 2048w" sizes="(max-width: 2447px) 100vw, 2447px" /></a></span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">If you select a Key Event in the SARIF Explorer window, the corresponding source code in the Text Editor window will be highlighted with slightly darker color. If you select source code that is highlighted in the Text Editor window, the corresponding Key Event will be highlighted in the SARIF Explorer window.</span></p>
<h2 aria-level="3" aria-level="3" id="source-code-adornment-with-key-events"><span data-contrast="none">Source code adornment with Key Events </span></h2>
<p><span data-contrast="auto">There is even greater news. The SARIF Viewer Extension for VS now displays Key Events right next to the source code they belong to. This will make it a lot easier to find the root cause by allowing review of the source code along with detailed explanation on what the check discovered or assumed at each of the steps of the analysis path that leads to the defect. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Here is an example:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> <a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio.png"><img class="size-full wp-image-31118 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio.png" alt="Image Key Events presentation in Text Editor window by SARIF Viewere Extension for Visual Studio" width="2441" height="1380" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio.png 2441w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-300x170.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-1024x579.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-768x434.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-1536x868.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Key-Events-presentation-in-Text-Editor-window-by-SARIF-Viewere-Extension-for-Visual-Studio-2048x1158.png 2048w" sizes="(max-width: 2441px) 100vw, 2441px" /></a></span></p>
<p>&nbsp;</p>
<h1 aria-level="1" aria-level="1" id="setting-up-environment"><span data-contrast="none">Setting up environment</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">To get the essential help from Key Events, you don’t need to do anything. Visual Studio comes with full features to present and let you interact with Key Events. Just install or upgrade your Visual Studio to VS 2022 17.4 Preview 2 or later. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-contrast="auto">To enjoy the new Key Events feature to its full extent in your day-to-day work, also install or upgrade your SARIF Viewer Extension to the latest version. Go to “Extensions &gt; Manage Extensions,” and search for “Microsoft SARIF Viewer 2022”. As of this writing, version 3.0.98.16906 is available. Any version newer than that should work:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog.png"><img class="wp-image-31119 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog.png" alt="Image Microsoft SARIF Viewer Extension in Manage Extensions dialog" width="952" height="255" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog.png 1373w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog-300x80.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog-1024x274.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Microsoft-SARIF-Viewer-Extension-in-Manage-Extensions-dialog-768x206.png 768w" sizes="(max-width: 952px) 100vw, 952px" /></a> </span></p>
<p><span data-contrast="auto">To enable or disable “text adornment” with Key Events, please go to “Tools &gt; Options… &gt; SARIF Viewer” and select/unselect “Enable Key Event text adornments in the editor” option. It is enabled by default:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:257}"><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog.png"><img class="wp-image-31120 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog.png" alt="Image SARIF Viewer Key Event Text Adornment option in Options Dialog" width="920" height="479" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog.png 1473w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog-300x156.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog-1024x533.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/SARIF-Viewer-Key-Event-Text-Adornment-option-in-Options-Dialog-768x400.png 768w" sizes="(max-width: 920px) 100vw, 920px" /></a> </span></p>
<h1 aria-level="1" aria-level="1" id="conclusion"><span data-contrast="none">Conclusion</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">This is not the final destination for the Key Events feature. Instead, it is only a new starting point for greater improvements. For example, we are working on making the Key Events more relevant to the defect, e.g., by eliminating older assignments that do not contribute to the defect. We are also looking into better navigation support among relevant Key Events. As some of you may already be hoping, we’d love to bring the SARIF Viewer Extension experience into Visual Studio, without requiring installation of the extension.</span></p>
<h1 aria-level="1" aria-level="1" id="send-us-your-feedback"><span data-contrast="none">Send us your feedback</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We are very much interested in your feedback to continue to improve this experience. The comments below are open. Feedback can also be shared through the </span><a href="https://developercommunity.visualstudio.com/spaces/8/index.html"><span data-contrast="none">Developer Community</span></a><span data-contrast="auto">. You can also reach us on Twitter (</span><a href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span data-contrast="auto">), or via email at </span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/">Microsoft C++ Code Analysis Warnings with Key Events</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Xiang Fan]]></dc:creator>
		<pubDate>Fri, 16 Sep 2022 15:10:12 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31056</guid>

					<description><![CDATA[<p>We are working hard on improving the diagnostics experience in MSVC and Visual Studio. We began this work in Visual Studio 2022 version 17.3 and while not everything is ready yet, we would like to share the early progress.</p>
<p>Motivation &#38;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/">The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are working hard on improving the diagnostics experience in MSVC and Visual Studio. We began this work in Visual Studio 2022 version 17.3 and while not everything is ready yet, we would like to share the early progress.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png"><img class="alignnone wp-image-31064 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png" alt="In-box viewer" width="640" height="571" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-300x268.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-768x685.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1536x1370.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png 1876w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h3 id="motivation-principles">Motivation &amp; Principles</h3>
<p>New C++ features like concepts and ranges present the opportunity for more expressive code and better-defined APIs. However, to make the most of them, better diagnostics are required from tooling so that constraint failures can be pinpointed and resolved.</p>
<p>We are aware that there is a lot of room for improvement, as noted by many of you on <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a>, and we are now actively investing in this area.</p>
<p>Our developer advocate <a href="https://twitter.com/TartanLlama">Sy Brand</a> submitted a <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2429r0.pdf">paper</a> to WG21 which discusses the key principles of compiler diagnostics, and how the state of the art in C++ compilers can be improved. We are using this document as guidance in the design of our work.</p>
<p>As a first step, we are working on the compiler to make sure it gathers all the available information and can output it in a tool-friendly way for human consumption later. We are also adding new diagnostic visualization capabilities to Visual Studio to make it easier to navigate and understand large errors.</p>
<h3 id="compiler-changes">Compiler changes</h3>
<ol>
<li>The last message for template instantiation contexts now displays the text column which the error occurred at.</li>
<li>The compiler now lists all candidates for a function call and explains why each candidate fails.</li>
<li>The error message for unsatisfied associated constraints is expanded to detail which underlying constraints were not satisfied.</li>
</ol>
<h4 id="source-code">Source code</h4>
<pre class="lang:c++ decode:true">#include &lt;concepts&gt;

struct functor
{
    template &lt;std::integral T&gt;
    void operator()(T);
    void operator()(int*);
    void operator()(long*);
};

template&lt;typename T&gt;
void test(T t)
{
    functor f;
    f(t);
}

int main()
{
    test(1.0);
}</pre>
<h4 id="compiler-output-in-17-2">Compiler output in 17.2</h4>
<pre>example.cpp(15,2): error C2664: 'void functor::operator ()(long *)': cannot convert argument 1 from 'T' to 'long *'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(8,7): note: see declaration of 'functor::operator ()'
        void operator()(long *);
             ^
example.cpp(20): note: see reference to function template instantiation 'void test&lt;double&gt;(T)' being compiled
        with
        [
            T=double
        ]
        test(1.0);</pre>
<h4 id="compiler-output-in-17-4">Compiler output in 17.4</h4>
<pre>example.cpp(15,2): error C2665: 'functor::operator ()': no overloaded function could convert all the argument types
        f(t);
        ^
example.cpp(7,7): note: could be 'void functor::operator ()(int *)'
        void operator()(int *);
             ^
example.cpp(15,2): note: 'void functor::operator ()(int *)': cannot convert argument 1 from 'T' to 'int *'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(8,7): note: or       'void functor::operator ()(long *)'
        void operator()(long *);
             ^
example.cpp(15,2): note: 'void functor::operator ()(long *)': cannot convert argument 1 from 'T' to 'long *'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(6,7): note: or       'void functor::operator ()(T)'
        void operator()(T);
             ^
example.cpp(15,2): note: the associated constraints are not satisfied
        f(t);
        ^
example.cpp(5,12): note: the concept 'std::integral&lt;double&gt;' evaluated to false
        template &lt;std::integral T&gt;
                  ^
concepts(81,20): note: the constraint was not satisfied
concept integral = is_integral_v&lt;_Ty&gt;;
                   ^
example.cpp(15,2): note: while trying to match the argument list '(T)'
        with
        [
            T=double
        ]
        f(t);
        ^
example.cpp(20,10): note: see reference to function template instantiation 'void test&lt;double&gt;(T)' being compiled
        with
        [
            T=double
        ]
        test(1.0);
                ^</pre>
<h3 id="ide-changes">IDE changes</h3>
<h4 id="ide-experience-in-17-4-in-box-viewer">IDE experience in 17.4 (in-box viewer)</h4>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png"><img class="alignnone wp-image-31064 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png" alt="In-box viewer" width="640" height="571" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1024x913.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-300x268.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-768x685.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3-1536x1370.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture3.png 1876w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h4 id="ide-experience-in-17-4-sarif-viewer-extension">IDE experience in 17.4 (SARIF viewer extension)</h4>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5.png"><img class="alignnone wp-image-31065 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-1024x868.png" alt="SARIF viewer Extension" width="640" height="543" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-1024x868.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-300x254.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-768x651.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5-1536x1302.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/Picture5.png 1905w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>The compiler changes often generate more text, and it sometimes makes understanding them harder. We are experimenting with a new compiler option to output the diagnostics into the Static Analysis Results Interchange Format (SARIF). The output will be loaded by Visual Studio to visualize the hierarchy of the messages so that it is easier to navigate.</p>
<p>Currently, clicking an error which is associated with SARIF output in the Visual Studio error list will bring up a pop up with collapsible diagnostic information. We are also working on a <a href="https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer">SARIF Viewer extension</a> to provide a richer experience.</p>
<h3 id="technical-details">Technical details</h3>
<p>Here are the three areas the compiler focuses on right now.</p>
<h4 id="general-infrastructure-source-location">General infrastructure (source location)</h4>
<p>The column information in error messages was added in Visual Studio 2017. However, it is sometimes missing or incorrect.</p>
<ul>
<li>Missing column information is often because the compiler does not always propagate the column information between functions.</li>
<li>Incorrect column information is sometimes produced because the compiler does not maintain the necessary information in nested contexts (e.g., instantiating a template specialization) and its value is incorrectly modified.</li>
</ul>
<p>We are continuing to audit the APIs which manipulate the source location to make sure they propagate and maintain the column information.</p>
<p>There are still cases where the column information is incorrect in the first place (which is common in the compiler generated functions), so if you hit any of these, please let us know!</p>
<h4 id="overload-resolution">Overload resolution</h4>
<p>The error messages for overload resolution vary depending on whether the function is a global function or a member function, whether it is an operator or not, and is sensitive to the number of available candidates. This causes inconsistencies like:</p>
<ul>
<li>The compiler often only lists the last candidate it tried.</li>
<li>The compiler sometimes lists all candidates, but without explaining why each candidate fails.</li>
<li>The compiler often ignores template candidates.</li>
</ul>
<p>We now align the behavior in these scenarios to be more consistent: we always list all candidates including the template and explain why each candidate fails.</p>
<h4 id="concept-unsatisfied-associated-constraints">Concept (unsatisfied associated constraints)</h4>
<p>Previously, the compiler only emitted one general purpose message for unsatisfied associated constraints.</p>
<p>Now, the compiler will emit all the associated constraints which contribute to a given failure. Some of them will have an explanation while others will not.</p>
<p>We are still working on the latter because most of our semantics analysis logic does not propagate the reasons back to the caller yet – the constraint validation logic only knows that something failed.</p>
<h3 id="call-for-action">Call for action</h3>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc" target="_blank" rel="noopener">Twitter @visualc</a>.</p>
<p class="">If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019" target="_blank" rel="noopener">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/" target="_blank" rel="noopener">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/">The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Dev Containers for C++ in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Wed, 14 Sep 2022 17:25:38 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30999</guid>

					<description><![CDATA[<p>We are happy to share with you that we have added Dev Container support In Visual Studio 2022 17.4 for C++ projects using CMake Presets.<br />
Containers are a great way to package up everything for running an application. Through a Dockerfile all prerequisites are captured so that there is a consistent runtime environment anywhere the container is deployed and run Dev Containers expand this concept to capture everything necessary for developing and building an application in the container.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/">Dev Containers for C++ in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to share with you that we have added Dev Container support In Visual Studio 2022 17.4 for C++ projects using CMake Presets.</p>
<p>Containers are a great way to package up everything for running an application. Through a Dockerfile all prerequisites are captured so that there is a consistent runtime environment anywhere the container is deployed and run Dev Containers expand this concept to capture everything necessary for developing and building an application in the container. We have been observing for some time that containers are becoming more popular in the C++ community for providing reproducible build environments.</p>
<p>Visual Studio Code has had support for Dev Containers for some time now. Beginning in Visual Studio 2022 17.4 you can now use Dev Containers for your C++ projects as well.</p>
<h1 id="trying-dev-container-support">Trying Dev Container support</h1>
<p>You will need to have Docker Desktop installed on Windows to use this capability. This is part of the Linux and embedded development with C++ workload., so make sure that is selected in your installation.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png"><img class="alignnone size-full wp-image-30992" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png" alt="The Linux and embedded development workload option in Visual Studio" width="520" height="134" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png 520w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001-300x77.png 300w" sizes="(max-width: 520px) 100vw, 520px" /></a></p>
<p>We have enabled this capability for projects that use CMake Presets. You can clone this sample to get started.</p>
<pre>git clone git@github.com:robotdad/visualstudio-devcontainer-cpp.git</pre>
<p>This project is the same as File New CMake Project in Visual Studio with one difference. There is an additional folder .devcontainer that contains the Dockerfile and devcontainer.json which together define the Dev Container to start.</p>
<p>On opening this folder in Visual Studio you will be prompted to reopen the folder in a container.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1.png"><img class="alignnone size-full wp-image-31001" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1.png" alt="Visual Studio notification that the folder contains a Dev Container with options to reopen in a container, manage settings, or learn more" width="744" height="40" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1.png 744w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-1-300x16.png 300w" sizes="(max-width: 744px) 100vw, 744px" /></a></p>
<p>On first use when the container is started the backing image is downloaded. You can see progress of the startup in the new Dev Containers output window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1.png"><img class="alignnone size-full wp-image-31002" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1.png" alt="Visual Studio output window showing information for Dev Containers" width="765" height="368" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1.png 765w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-1-300x144.png 300w" sizes="(max-width: 765px) 100vw, 765px" /></a></p>
<p>When startup is finished CMake cache generation starts, when it is done you can edit and debug as normal.</p>
<p>You can switch between your Dev Container and other options using the Target System drop down in the tool bar.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1.png"><img class="alignnone size-full wp-image-31003" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1.png" alt="Visual Studio debug options showing Dev Container as an available machine target" width="707" height="102" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1.png 707w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-1-300x43.png 300w" sizes="(max-width: 707px) 100vw, 707px" /></a></p>
<h1 id="options">Options</h1>
<p>Dev Containers have a few options under Tools Options. Most importantly you can control whether or not you want to be prompted to reopen in a container. You can also set a remote host to be the location to run containers, the remote host must be running docker services.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1.png"><img class="alignnone size-full wp-image-31004" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1.png" alt="Visual Studio tools options menu showing Dev Containers selected under Cross Platform" width="845" height="572" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1.png 845w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1-300x203.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1-768x520.png 768w" sizes="(max-width: 845px) 100vw, 845px" /></a></p>
<h1 id="notes">Notes</h1>
<p>The feature uses Linux containers. We are not supporting Windows containers with this mechanism, as such this is not relevant for traditional Windows C++ development using MSVC. The is intended for cross platform development.</p>
<p>A backend service for Visual Studio Code runs within a Dev Container, this is not the case for Visual Studio. Visual Studio manages the lifecycle of Dev Containers it uses as you work, but it treats them as remote targets in a similar way to other Linux or WSL targets. The devcontainer.json configuration file may contain some VS Code specific information, like needed extensions, which are not relevant to Visual Studio. Those are ignored by Visual Studio so it is expected that there will be common Dev Container definitions used with either environment.</p>
<p>Do not open the same folder in Visual Studio and VS Code at the same time. This will result in them connecting to the same container which will result in conflicts between CMake running in two contexts against the same folder.</p>
<h1 id="send-us-your-feedback">Send us your feedback</h1>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your C++ development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/">Dev Containers for C++ in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg Environment Activation in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/#respond</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Wed, 14 Sep 2022 17:23:45 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[embedded]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30990</guid>

					<description><![CDATA[<p>In Visual Studio 2022 17.4 vcpkg environments will now automatically activate. A vcpkg environment is described by a manifest that captures the artifacts necessary for building your application (learn more about vcpkg artifacts). Today the vcpkg artifact experience is focused on embedded developers,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/">vcpkg Environment Activation in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In Visual Studio 2022 17.4 vcpkg environments will now automatically activate. A vcpkg environment is described by a manifest that captures the artifacts necessary for building your application (<a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">learn more about vcpkg artifacts</a>). Today the vcpkg artifact experience is focused on embedded developers, but we will be expanding this in time to all C++ development scenarios.</p>
<h1 id="try-vcpkg-environment-activation">Try vcpkg environment activation</h1>
<p>This is part of the Linux and embedded development with C++ workload., so make sure that is selected in your installation.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png"><img class="alignnone size-full wp-image-30992" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png" alt="The Linux and embedded development workload option in Visual Studio" width="520" height="134" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001.png 520w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image001-300x77.png 300w" sizes="(max-width: 520px) 100vw, 520px" /></a></p>
<p>Today you need to install vcpkg directly, it is not installed with Visual Studio yet. To do so run this command.</p>
<pre>iex (iwr -useb "https://aka.ms/vcpkg-init.ps1")</pre>
<p>For a project to try with this you can use any of the projects described in our <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Development announcement</a>. Originally this required you to activate the vcpkg environment from the command line, then launch VS from that prompt. Now all you need to do is open the project and VS will handle the activation.</p>
<p>To try it clone this repository.</p>
<pre>git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Now open the subfolder getting-started\MXChip\AZ3166 in Visual Studio. You will see the following notification that vcpkg environment activation has started. This may take some time on first use when the artifacts are initially downloaded.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003.png"><img class="alignnone size-full wp-image-30993" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003.png" alt="Background task notification that vcpkg activation has started" width="363" height="170" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003.png 363w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image003-300x140.png 300w" sizes="(max-width: 363px) 100vw, 363px" /></a></p>
<p>When activation is finished there will be a notification.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005.png"><img class="alignnone size-full wp-image-30994" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005.png" alt="Background task notification that vcpkg activation has completed" width="383" height="202" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005.png 383w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image005-300x158.png 300w" sizes="(max-width: 383px) 100vw, 383px" /></a></p>
<p>If you missed it you can check the notification area by selecting it.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007.png"><img class="alignnone size-full wp-image-30995" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007.png" alt="Completed background task information that vcpkg activation has completed" width="600" height="118" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007.png 600w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image007-300x59.png 300w" sizes="(max-width: 600px) 100vw, 600px" /></a></p>
<p>You can also check the current or complete status of the activation in the vcpkg output window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009.png"><img class="alignnone size-full wp-image-30996" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009.png" alt="Output windows showing vcpkg information" width="1122" height="289" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009.png 1122w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-300x77.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-1024x264.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image009-768x198.png 768w" sizes="(max-width: 1122px) 100vw, 1122px" /></a></p>
<p>This sample is a CMake project, so when vcpkg activation is complete CMake cache generation will start and then your project will be ready for use.</p>
<h1 id="managing-the-vcpkg-environment">Managing the vcpkg environment</h1>
<p>Visual Studio integrates the vcpkg environment as part of the Solution explorer.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011.png"><img class="alignnone size-full wp-image-30997" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011.png" alt="Solution explorer menu entries for vcpkg, edit, reactivate, and deactivate" width="350" height="158" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011.png 350w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/image011-300x135.png 300w" sizes="(max-width: 350px) 100vw, 350px" /></a></p>
<p>The opens the vcpkg-configuration.json file which captures the vcpkg environment. Reactivate will activate the vcpkg environment again picking up any changes made to the configuration. removes the vcpkg environment from the current configuration leaving you with a standard Visual Studio environment. If your project depends on compilers or other tools provided by the vcpkg configuration it likely will no longer build and IntelliSense may not work.</p>
<h1 id="send-us-your-feedback">Send us your feedback</h1>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your C++ development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/">vcpkg Environment Activation in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Integrating C++ header units into Office using MSVC (1/n)</title>
		<link>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/</link>
					<comments>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Mon, 12 Sep 2022 21:12:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[C++ language]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[modernization]]></category>
		<category><![CDATA[modules]]></category>
		<category><![CDATA[Office]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31007</guid>

					<description><![CDATA[<p>.cameron {<br />
    color: #4472c4;<br />
  }</p>
<p>C++20 has had a lot to offer and one feature in particular requires the most thought of all when integrating into our projects: C++ modules (or C++ header units in this particular case).  In this blog we will show a real world case of integrating a new C++20 feature into a large codebase that we might all be familiar with.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/">Integrating C++ header units into Office using MSVC (1/n)</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<style>
  .cameron {
    color: #4472c4;
  }
</style>
<p>C++20 has had a lot to offer and one feature in particular requires the most thought of all when integrating into our projects: C++ modules (or <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">C++ header units</a> in this particular case).  In this blog we will show a real world case of integrating a new C++20 feature into a large codebase that we might all be familiar with.  Just a few notes:</p>
<ul>
<li>This blog is authored in a style of two perspectives:</li>
<ul>
<li>Zachary Henkel&#8217;s perspective will be in black text.</li>
<li>Cameron DaCamara&#8217;s perspective will be in <span class="cameron">accent text</span>.</li>
</ul>
<li>This blog is the first in a series detailing experiences in integrating header units into the Office codebase.</li>
<li>The first blog here is very early results so do not expect to see very fine-grained numbers.</li>
</ul>
<p>Without further delay, let us jump right in!</p>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#problem-description">Problem description: Why header units?</a></li>
<li><a href="#baby-steps">Baby steps to start the work: Basic projects to target and early obstacles</a></li>
<li><a href="#larger-steps">Larger steps: How does Office package up header units for build?</a></li>
<li><a href="#together">Putting it all together: Smoke tests and early numbers</a></li>
<li><a href="#next-steps">Looking ahead: Build more headers and measure</a></li>
</ul>
<p></p>
<h2><span id="problem-description">How MSVC enables header units in a multi-platform codebase</span></h2>
<p>C++20 header units are a way to receive many of the benefits of modules, while still working with a codebase that was designed for classic header inclusion.  The benefits of header units looked appealing to Office, but we weren&#8217;t willing to extensively add platform #ifdefs for the sake of consuming them.  Fortunately, the C++ standard anticipated this scenario!  The flag MSVC <a href="https://docs.microsoft.com/en-us/cpp/build/reference/translateinclude?view=msvc-170"><code>/translateInclude</code></a> will automatically translate a textual inclusion to a header unit import when it encounters a #include specified in a command line mapping to the compiler.  This allows Office to build and consume header units without any code changes at all!</p>
<p><span class="cameron">It is worth noting that the <code>/translateInclude</code> feature is a standard-supported feature, <a href="https://eel.is/c%2B%2Bdraft/cpp.include#7"><code>[cpp.include]/7</code></a>. Include translation allows the implementation to replace <code>#include</code> with <code>import</code>.  It is essential for gradual codebase migration that there be a bridge such as include translation to enter the world of modules.  More importantly, a header unit can do something that a <a href="https://docs.microsoft.com/en-us/cpp/build/creating-precompiled-header-files?view=msvc-170">PCH</a> cannot: it can be moved around from project to project and reused!  So not only does the integration of header units require no source-level changes, but the build throughput potential for multiple projects is far beyond what PCH can offer.  One more point to header units compared to PCH: they&#8217;re small, really small compared to PCH.  In our measurements, a header unit can often times be 10x smaller than an equivalent PCH in content.</span></p>
<h3 id="selecting-header-unit-candidates">Selecting header unit candidates</h3>
<p>Once Office knew we wanted to use header units, the challenge became finding a good set of candidate headers.  Our low-level shared code components, that we&#8217;ve termed liblets, have properties that make them attractive header unit blocks.  All a liblet&#8217;s headers exposed as dependencies need to be self-contained and this property is enforced by existing tools!  Secondly, liblets clearly express their dependencies.  This allows us to build an acyclic graph of dependencies and build up sets of header units.</p>
<h2><span id="baby-steps">Baby Steps</span></h2>
<p>The first step Office took was simply to determine if we could build a header unit!  This <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">Microsoft docs</a> page has the full steps but summarized here are the key points:</p>
<ul>
<li>Turn on module support.  Ideally Office would be compiling all code as C++20 and header unit support would be available automatically.  Unfortunately, due to the size of the Office codebase, we&#8217;re not ready to make the switch.  Luckily Office already compiles with the compiler flag <a href="https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170"><code>/permissive-</code></a>.  By running the compiler in standards conformance mode Office is able to fall back on the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/experimental-module?view=msvc-170"><code>-experimental:module</code></a> flag for header unit support until the C++20 migration is complete.  It&#8217;s important to note that this <em>doesn&#8217;t do anything</em> other than enable the feature, it won&#8217;t force any code to compile as header units without additional flags.</li>
<li>Determine where in the build tree we will create the IFC artifacts and pass that location to the compiler with <a href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-alphabetically?view=msvc-170"><code>/ifcOutput</code></a></li>
<li>We enabled some additional compiler flags for the purposes of testing, more on this later.</li>
</ul>
<p>Right out of the gate Office hit a snag.  Our headers weren&#8217;t as self-contained as we had assumed.  Our tools that operate on headers in isolation rely on common textual includes being provided by the precompiled header!  Until the work to break our precompiled header dependency is complete, we&#8217;re force-including (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/fi-name-forced-include-file?view=msvc-170"><code>/FI</code></a>) the precompiled header into each header being compiled as a header unit.</p>
<p><span class="cameron">From this perspective, it is important that the compiler should make traditional PCH technology work along with the new modules technology (which is the same machinery the compiler uses to export and import header units).</span></p>
<p><span class="cameron">The first compiler bug on deck was the fact that the front-end has a rather&#8230; interesting approach to PCH.  The problem observed was that <em>sometimes</em> the compiler would error with &#8220;<code>error C7612: could not find header unit for 'X'</code>&#8220;.  The most curious thing was that the command line had the reference to header unit &#8216;X&#8217; clear as day.  It was not until I debugged the front-end with PCH turned on where the PCH interacted with certain identifiers that I discovered the culprit.  When the compiler starts, it allocates a table where hashed identifiers go, and when the compiler sees <a href="https://docs.microsoft.com/en-us/cpp/build/reference/headerunit?view=msvc-170"><code>/headerUnit:quote X=X.ifc</code></a> it will create hashed identifiers for the components of the name for fast comparison purposes.  The problem is that this processing happened too early because in the presence of a PCH the compiler will memmap the PCH file and <a href="https://en.wikipedia.org/wiki/Bit_blit">blit</a> the memory directly into existing compiler heap locations&#8230; exactly where we just inserted our identifiers from processing the <code>/headerUnit</code> arguments, which means we also get bogus identifiers when trying to find the matching header unit name to IFC combo.  One hefty comment and code rearranging later, our first bug was fixed!</span></p>
<p>The preprocessor presented another set of challenges. The set of preprocessor macros must be consistent between header unit creation and consumption. Inconsistent conditional compilation is forbidden in header units.  Eliminating cases, such as the following, will be an ongoing concern for Office as header unit usage increases.</p>
<pre>#if defined(Assert)
#define ASSUME( condition ) Assert( condition )
#else
#define ASSUME ( condition ) __noop()
#endif</pre>
<p>The experiment to create as many header units as possible helped uncover many outstanding bugs with code that was never instantiated by the compiler.  </p>
<p>One such example, this does not return on all code paths:</p>
<pre>inline HRESULT sink(std::unique_ptr&lt;Widget&gt; widget)
{
#if DEBUG
  if (!widget) return E_POINTER;
#endif
  m_widget = std::move(widget);
}</pre>
<p><span class="cameron">Let&#8217;s talk about inline functions.  Consider:</span></p>
<pre>void undef(); 
inline void f() {
  undef();
}
int main() { }</pre>
<p><span class="cameron">You might be surprised to find that every major compiler vendor will accept the above C++ code and link the program successfully!  It turns out that the standard wording here <a href="https://eel.is/c%2B%2Bdraft/dcl.inline#5"><code>[dcl.inline]/5</code></a> is quite special, and it allows for a unique optimization which allows a compiler front-end to tell the back-end that the definition of a specific function is never needed because said function is never referenced, so this bespoke definition can be discarded altogether, which further implies <code>undef</code> is also never referenced leading to a well-formed program.</span></p>
<p><span class="cameron">There has been a long-standing issue in the compiler where it was forced to emit every inline function definition into the associated .obj if the current translation unit was a module interface unit or a header unit.  While this will still lead to correct program semantics, it has two major drawbacks:</code></span></p>
<ol class="cameron">
<li>The compiler cannot enable the aforementioned optimization with inline functions, and</li>
<li>This compiler behavior means that <a href="https://docs.microsoft.com/en-us/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">LTCG</a> is required for inlining of functions declared <code>inline</code> and defined in the imported translation unit.</li>
</ol>
<p><span class="cameron">It turns out that Office relied on &#8216;1&#8217;, a lot.  So, we just fixed the bug.  During the Office header unit integration, the compiler provided a switch to enable the behavior of emitting every inline function definition into the IFC which would be loaded on-demand if it was used on the import side.</span></p>
<p>Office has been on a long journey to ensure all our code is standards compliant via the MSVC <code>/Zc</code> flags and <code>/permissive-</code>.  The header unit pilot acted as a forcing function to accelerate our efforts to enable the standards conformant preprocessor (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/zc-preprocessor?view=msvc-170"><code>/Zc:preprocessor</code></a>) globally.</p>
<p><span class="cameron">Anybody familiar with the quirks of the traditional preprocessor in MSVC will understand that its behavior is something of an eldritch horror.  Adding to that, the traditional preprocessor has virtually no data model besides walking blobs of text to create a new stream of text for the compiler&#8217;s tokenizer.  The standard states that preprocessing should begin with a series of <a href="https://eel.is/c%2B%2Bdraft/lex.phases#1.3">pp-tokens</a> and end up with a series of lexical tokens which are then parsed.   The new preprocessor (<code>/Zc:preprocessor</code>) allows the compiler to store these pp-tokens into the IFC in a principled way.  These pp-tokens are needed as they compose the definition of <a href="https://eel.is/c%2B%2Bdraft/cpp.replace#general-2">object-like and function-like</a> macros and is the reason why <code>/Zc:preprocessor</code> is <a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-exportheader?view=msvc-170#remarks">required for header unit compilation</a>.</span></p>
<h2><span id="larger-steps">Larger Steps?</span></h2>
<p>Once Office could create header units it was time to consume them!  Again, the <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">Microsoft docs</a> page contains the full details but the key steps for Office were:</p>
<ul>
<li>Use the <code>/translateInclude</code> flag to avoid rewriting <code>#include</code> to <code>import</code>.</li>
<li>Pass the header unit mapping <code>/headerUnit liblet/header.h=&lt;ifc path&gt;</code>.</li>
<li>Decide what to do with the .obj file created as part of a header unit.</li>
</ul>
<p>In Office we bundle all header unit mappings per-liblet into a single <a href="https://docs.microsoft.com/en-us/cpp/build/reference/at-specify-a-compiler-response-file?view=msvc-170">response file</a>.  We&#8217;ve found this to strike the right balance of dependency tracking despite potentially over specifying the number of header units being consumed.</p>
<p>Header unit consumption started revealing heterogeneous build flags throughout the product.  Big pain points include static vs dynamic CRT (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=msvc-170"><code>/MT</code> vs <code>/MD</code></a>), unsigned char (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/j-default-char-type-is-unsigned?view=msvc-170"><code>/J</code></a>) and <code>/DUNICODE</code>.  It is possible to create a distinct header unit flavor for each combination, but so far, we&#8217;ve stuck to a single flavor with the most common options.</p>
<p>The obj file from a header unit is packaged into the pre-existing lib files to make consuming header units easy.</p>
<h2><span id="together">Putting it together</span></h2>
<p>The most recent milestone hit in the pilot is to successfully compile and link three of Office&#8217;s shared code dlls.  While building the dlls Office successfully compiled ninety distinct header units from pre-existing shared code headers.  To aid integration header units are enabled for all of a project&#8217;s publicly shared headers at once.  This means that even though each header unit that&#8217;s been created will be used <em>somewhere</em> in Office, there isn&#8217;t any guarantee it is consumed while building these specific dlls.  To build the dll we tested 2/5 of the generated header units were consumed, as validated by the report generated by the new <a href="https://docs.microsoft.com/en-us/cpp/build/reference/sourcedependencies?view=msvc-170"><code>/sourceDependencies</code></a> flag.  We anticipate these numbers to increase significantly with some upcoming work to replace the compiler&#8217;s brittle legacy ODR validation logic.</p>
<p><span class="cameron">The module machinery in the compiler has historically tried to use source locations to perform ODR matching (<a href="https://eel.is/c%2B%2Bdraft/basic.def.odr">One Definition Rule</a>).  The problem, of course, is that the header units can be moved around and locations change from machine-to-machine (even project-to-project) so the strategy of trying to perform an ODR match based on source location can be quite fragile, as mentioned above.  After working with Office it was abundantly clear that the compiler needs to adjust its strategy and perform more of a structural comparison when matching for ODR&mdash;a change which is still ongoing and targeting a future release.  Please note that ODR checking for named modules do not have any of the problems above as they provide better ODR guarantees vs being reliant on source location.</span></p>
<h2><span id="next-steps">Next steps</span></h2>
<p>We are just as anxious to get build throughput metrics internally as we expect all of you to be. Once we have a broad set of header units being generated and consumed, we plan to do gather extensive build timing data.  We want to see the effect building and consuming header units has on the build speed of both clean builds and incremental builds and we want to measure the effects both with and without our existing precompiled headers.  Additionally, we need to determine if there is a high enough throughput gain to justify creating additional header unit flavors for currently incompatible compiler flags. Do we have enough projects that require the static CRT or build without Unicode support to spend the compilation time generating header units in those configurations?</p>
<p>Finally, we want to add support for consuming header units outside of Office&#8217;s shared code.  We have a shared code architecture that makes it easy to create header units and track the downstream projects that depend on them.  We need to extend the build system support that has already been created to date so that Office&#8217;s client apps can also see the benefits of header units.  If you&#8217;d like to learn more about how Office architects its shared code, please catch the CppCon 2022 talk <a href="https://cppcon.digital-medium.co.uk/session/2022/how-microsoft-uses-c-to-deliver-office/">&#8220;How Microsoft Uses C++ to Deliver Office: Huge Size, Small Components&#8221;</a> once it&#8217;s available online.</p>
<p><span class="cameron">Office is nearly 100 million lines of native code and the compiler is seeing a lot of new code, which is both a blessing and a curse as it can halt development until a compiler fix is created but ultimately makes a product which is not only more robust for Office but for every customer using MSVC!</span></p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/all-header-units.png" alt="BUILD!" /></p>
<h4 id="closing">Closing</h4>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow Cameron DaCamara on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/">Integrating C++ header units into Office using MSVC (1/n)</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
	</channel>
</rss>
