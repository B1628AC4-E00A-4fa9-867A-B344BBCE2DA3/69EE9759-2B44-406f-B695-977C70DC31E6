<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Mon, 06 Dec 2021 18:09:22 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Embedded Software Development in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 16:29:06 +0000</pubDate>
				<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29828</guid>

					<description><![CDATA[<p>We are happy to announce that we have added new embedded development capabilities to Visual Studio 2022 Preview. Used in conjunction with the new vcpkg artifact capabilities you can quickly bootstrap an embedded development machine and get started.<br />
In this post we will walk you through Visual Studio installation of the embedded workload,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Software Development in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that we have added new embedded development capabilities to <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2022 Preview</a>. Used in conjunction with the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifact capabilities</a> you can quickly bootstrap an embedded development machine and get started.</p>
<p>In this post we will walk you through Visual Studio installation of the embedded workload, how to acquire embedded tool dependencies with vcpkg, then demonstrate edit, build, deploy, and debugging directly in Visual Studio with new peripheral register and RTOS object views. We will demonstrate all of this with an Azure RTOS ThreadX project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png"><img class="alignnone wp-image-29829 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png" alt="VS embedded development screenshot" width="1712" height="1122" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png 1712w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-300x197.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-1024x671.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-768x503.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-1536x1007.png 1536w" sizes="(max-width: 1712px) 100vw, 1712px" /></a></p>
<p>Azure RTOS ThreadX is a widely used Real Time Operating System (RTOS) used on billions of microcontrollers (MCUs) in products around the world. We have dedicated pages for Visual Studio usage in the getting started guides for the <a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/VS.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/blob/master/NXP/MIMXRT1060-EVK/VS.md">NXP 1060</a>, and <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L4S5I-IOT01A/VS.md">STMicro STM32L4_L4+</a> boards. The techniques used for interacting with these boards should be applicable to other targets by changing configuration information.</p>
<h4 id="installation">Installation</h4>
<p>To get started install the latest preview release of Visual Studio 2022 and select the Linux and embedded development with C++ workload. The components you need are selected by default.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png"><img class="alignnone size-full wp-image-29830" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png" alt="Installation screen for embedded workload" width="910" height="460" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png 910w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded-300x152.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded-768x388.png 768w" sizes="(max-width: 910px) 100vw, 910px" /></a></p>
<p>One of the challenges in embedded development is getting the tools necessary installed and configured. It is not uncommon to have different compilers used for different projects, custom debug tools, etc. This is where the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts">artifact capabilities in vcpkg</a> can help us. Today we’ll demonstrate using vcpkg from a PowerShell prompt to activate our embedded development environment. In a future release this will be integrated into Visual Studio for a more seamless experience.</p>
<p>From a PowerShell prompt, clone the Azure RTOS getting started repo. This sample will serve as our example project for the remainder of this post.</p>
<pre class="prettyprint">git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Navigate to the subfolder for the board you are using, here I’m using the Azure IoT DevKit.</p>
<pre class="prettyprint">cd .\getting-started\MXChip\AZ3166\</pre>
<p>If you haven’t already, install vcpkg.</p>
<pre class="prettyprint">iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>In the project folder, there is a file vcpkg_configuration.json. This manifest file was created with vcpkg and has recorded the tools you need to build and debug this project. See <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts">the vcpkg artifacts post</a> for details on how to create your own manifest. Running the vcpkg activate command will use this file to determine if I have those tools, install them if I do not, then activate them in my environment for use.</p>
<pre class="prettyprint">vcpkg activate</pre>
<p>So, in three commands we have cloned our embedded project, installed vcpkg, acquired and activated the necessary tools for building the project.</p>
<h4 id="using-visual-studio-for-embedded-development">Using Visual Studio for embedded development</h4>
<p>In the previous section we used vcpkg to acquire the tools for our embedded project. Today vcpkg is not integrated in Visual Studio. So, at present we need to launch Visual Studio from the environment we activated at the command line so those tools are available for its use as well.</p>
<pre class="prettyprint">Start-Process devenv .</pre>
<p>Note that if you have more than one version of Visual Studio installed this may not launch the current preview, in that case you will need to use the full path to your preview installation, for example</p>
<pre class="prettyprint">C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\IDE\devenv</pre>
<p>Now that we have the project open in Visual Studio it is ready to go as any other CMake project. <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">Visual Studio can run the CMake build using the preconfigured CMakePresets file</a> with the compilers vcpkg acquired.</p>
<p>All the editing power of Visual Studio is now available for use with the embedded project. With this Azure RTOS project we’ll cover code navigation, IntelliSense, build, deploy, debugging. We will also cover new diagnostic capabilities around peripheral registers and RTOS object views.</p>
<h5 id="code-navigation-and-intellisense">Code Navigation and IntelliSense</h5>
<p>Use Ctrl + T to open Go to All and type button, select the button_a_callback function to navigate to it. Note on hover that this function expands to TIM3-&gt;CCR1 which is a peripheral register on the board which we’ll inspect while we are debugging.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png"><img class="alignnone size-full wp-image-29831" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png" alt="IntelliSense function expansion screenshot" width="763" height="471" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png 763w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd-300x185.png 300w" sizes="(max-width: 763px) 100vw, 763px" /></a></p>
<h5 id="build-deploy-and-debug-on-hardware">Build, Deploy, and Debug on hardware</h5>
<p>Set a breakpoint on RGB_LED_SET_R().</p>
<p>To see how the launch is controlled select view all files in the solution explorer and open <a href="https://docs.microsoft.com/cpp/build/launch-vs-schema-reference-cpp?view=msvc-170">.vs\launch.vs.json</a>. You can see the miDebuggerPath set to use arm-none-eabi-gdb while the debugServerPath is set to invoke openocd with the configuration script in debugServerArgs. The information for describing peripheral registers is provided by the MCU manufacturer in an SVD file that we point to with svdPath. This project is configured to break on entry with the property stopAtConnect.</p>
<p>Now, with your board plugged into the PC (and <a href="https://www.st.com/en/development-tools/stsw-link009.html">ST-LINK drivers</a> installed), set the debug target to Launch and F5 will work using openocd acquired by vcpkg to flash and debug the attached board. Execution stops at the entry function, so here we see the assembly code for that. We can also view the disassembly by going to the menu Debug &gt; Windows &gt; Disassembly.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png"><img class="alignnone size-full wp-image-29832" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png" alt="Assembly source and disassembly screenshot" width="936" height="164" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly-300x53.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly-768x135.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>Press continue to let execution continue.</p>
<h5 id="peripheral-registers">Peripheral Registers</h5>
<p>Now press the A button on the board. This has triggered our breakpoint. We can now go to the menu Debug &gt; Windows &gt; Embedded Registers. This opens the peripheral register view using the information from our SVD file specified in the launch configuration. We can now scroll through this list to find the register we are interested in, here TIM3-&gt;CCR1 which will update when we step over the RGB_LED_SET_R function.</p>
<p>On break</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png"><img class="alignnone size-full wp-image-29833" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png" alt="Register on break screenshot" width="936" height="349" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak-300x112.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak-768x286.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>After stepping</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png"><img class="alignnone size-full wp-image-29834" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png" alt="Register after stepping" width="936" height="395" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep-300x127.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep-768x324.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<h5 id="rtos-object-views">RTOS Object Views</h5>
<p>The application in the getting started project has several threads, but you won’t see them with the existing threads window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png"><img class="alignnone size-full wp-image-29839" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png" alt="Threads window screenshot" width="1348" height="223" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png 1348w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-300x50.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-1024x169.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-768x127.png 768w" sizes="(max-width: 1348px) 100vw, 1348px" /></a></p>
<p>Why not? A good explanation can be found in this <a href="https://azure.microsoft.com/resources/real-time-operating-system">white paper on Real Time Operating Systems</a>.</p>
<p>&#8220;A Real-Time Operating System is system software that provides services and manages processor resources for applications. These resources include processor cycles, memory, peripherals, and interrupts. The main purpose of a Real-Time Operating System is to allocate processing time among various duties the embedded software must perform. This typically involves a division of the software into pieces, commonly called “tasks” or “threads,” and creating a run-time environment that provides each thread with its own virtual microprocessor (“Multithreading”). Basically, a virtual microprocessor consists of a virtual set of microprocessor resources, e.g., register set, program counter, stack memory area, and a stack pointer. Only while executing does a thread use the physical microprocessor resources, but each thread retains its own copy of the contents of these resources as if they were its own private resources (the thread”s “context”).&#8221;</p>
<p>So for embedded development ideally you would have views that could show you information about these RTOS objects. To see the new available RTOS objects views, go to the menu Debug &gt; Windows &gt; RTOS Objects. Here you will see options for the objects that ThreadX provides, here we’ll select Threads.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png"><img class="alignnone size-full wp-image-29840" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png" alt="Debug RTOS menu options" width="325" height="297" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png 325w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu-300x274.png 300w" sizes="(max-width: 325px) 100vw, 325px" /></a></p>
<p>The threads view shows at a glance much of the information you would commonly need during embedded development, thread ids and names, how many times they have run, where the stack starts, ends, and its size as well as the maximum stack usage.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png"><img class="alignnone size-full wp-image-29842" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png" alt="RTOS threads window" width="1440" height="177" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png 1440w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-300x37.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-1024x126.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-768x94.png 768w" sizes="(max-width: 1440px) 100vw, 1440px" /></a></p>
<p>There are other views for additional ThreadX objects like block and byte pools, events, mutexes, queues, and timers. We also have RTOS object views for FreeRTOS though the available objects there differ based on what it supports.</p>
<h5 id="hardware-breakpoint-limits">Hardware breakpoint limits</h5>
<p>One last debugging capability to call out is that embedded hardware targets commonly have a limited set of hardware breakpoints available. Setting too many can corrupt the debugger state. As such we have added hardwareBreakpoints to launch.vs.json. For this board that is set to what it supports which is 6. If we set more than that we will see the breakpoint is not set and we get a warning that it won’t be hit. This prevents corrupting the connection to the board and allows us the opportunity to unset some other breakpoints and continue debugging uninterrupted.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png"><img class="alignnone size-full wp-image-29843" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png" alt="hardware breakpoint exceeded warning" width="667" height="124" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png 667w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning-300x56.png 300w" sizes="(max-width: 667px) 100vw, 667px" /></a></p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>If you are on Linux or Mac and looking for similar capabilities, yes, we will be bringing embedded development capabilities to VS Code soon as well. We have provided VS Code getting started guides for Azure RTOS the same boards as VS (<a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/vscode.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/tree/master/NXP/MIMXRT1060-EVK">NXP 1060</a>, and <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L475E-IOT01A/VS.md">STMicro STM32L4_L4+</a>), though today the capabilities are limited to acquisition with vcpkg, edit, build, deploy, and debug. Similar embedded specific views will be coming in a future extension.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Software Development in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Bootstrap your dev environment with vcpkg artifacts</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 16:27:55 +0000</pubDate>
				<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29826</guid>

					<description><![CDATA[<p>We are happy to announce a new experience for acquiring artifacts using vcpkg. We define an artifact as a set of packages required for a working development environment. Examples of relevant packages include compilers, linkers, debuggers, build systems, and platform SDKs.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">Bootstrap your dev environment with vcpkg artifacts</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce a new experience for acquiring artifacts using vcpkg. We define an artifact as a set of packages required for a working development environment. Examples of relevant packages include compilers, linkers, debuggers, build systems, and platform SDKs. With this important change, vcpkg can not only download and build your libraries from source, it can also bootstrap the rest of your environment, acquiring pre-built binary dependencies for your projects.</p>
<p>The experience is in preview and currently focused on embedded developers. We will expand the scope in the future to include any developers targeting Linux, macOS, or Windows.</p>
<p>This post focuses on using vcpkg artifacts at the command line. Check out the <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Development in Visual Studio blogpost</a> for how the capabilities are used there.</p>
<p>Here we are going to show how to acquire vcpkg, then activate artifacts for building an embedded project. Following that we’ll cover specific vcpkg capabilities for finding and using artifacts, then how to create a manifest and add artifacts to it. We will also cover how you can use artifacts of your own that are not part of the default artifact registry.</p>
<h4 id="using-vcpkg-artifacts">Using vcpkg artifacts</h4>
<p>We’ll look at some embedded development scenarios to understand the new artifact capabilities in vcpkg. Embedded development is particularly known for being difficult to get a new developer machine started. Projects often have specific compiler requirements, special debug tools needed, etc. What we will show here is how through using vcpkg with a manifest you can capture these requirements and easily restore an environment for an embedded project. You do not need a device to follow along as we will not show any device interactivity. These steps except where noted are consistent cross platform.</p>
<h5 id="acquire-vcpkg">Acquire vcpkg</h5>
<p>We have also added a new way to acquire vcpkg in a single step without a git clone of the repo. Depending on your platform use one of the following commands to get vcpkg.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre class="prettyprint">iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>CMD Shell</p>
<pre class="prettyprint">-LO https://aka.ms/vcpkg-init.cmd &amp;&amp; .\vcpkg-init.cmd</pre>
<h5 id="clone-the-example-project">Clone the example project</h5>
<p>The example project is the Azure RTOS getting started repo, so start by cloning that with this command.</p>
<pre class="prettyprint">git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>This repo has many projects within is, each for a specific board. Use the Azure IoT DevKit by switching to that directory.</p>
<pre class="prettyprint">cd .\getting-started\MXChip\AZ3166\</pre>
<h5 id="vcpkg-activate">vcpkg activate</h5>
<p>In the project folder, there is a file vcpkg-configuration.json. This manifest file has recorded the tools you need to build and debug this project. Running the vcpkg activate command will use this file to determine if those tools have been acquired before, acquire them not, then activate them in your environment for use.</p>
<pre class="prettyprint">vcpkg activate</pre>
<p>This is a new vcpkg command that works with artifacts. As this is the first time you are using vcpkg for artifacts it acquires the new vcpkg-ce component on demand. The ce in this component name stands for configure environment. This name was chosen as vcpkg will modify your current environment to use the artifacts in the manifest with your C++ projects.</p>
<p>To demonstrate that build the project. To do so generate the CMake configuration, then build the project using the preset provided by CMakePresets.json in the project with the following two commands.</p>
<pre class="prettyprint">cmake --preset arm-gcc-cortex-m4
cmake --build --preset arm-gcc-cortex-m4</pre>
<p>So, in just a few commands you have installed vcpkg, cloned an embedded project, acquired and activated the necessary tools for building the project, and successfully compiled it.</p>
<h5 id="finding-artifacts">Finding artifacts</h5>
<p>There is a vcpkg search command already that finds ports of libraries in the vcpkg registry. We needed a way to distinguish between the existing vcpkg port concept and the new artifacts concept in areas where the commands could mean either. As such we have introduced a new find command that can be used as find port name, or find artifact name. The existing search command is still present with its existing behavior that only returns ports.</p>
<p>Try finding an artifact, like CMake, with the following command.</p>
<pre class="prettyprint">vcpkg find artifact cmake</pre>
<p>This will output anything that matches the short name used, currently the below.</p>
<pre class="prettyprint">vcpkg-ce ('configure environment') is experimental and may change at any time.
 Artifact                       Version  Summary
 microsoft:tools/kitware/cmake  3.20.1   Kitware's cmake tool
</pre>
<h5 id="using-artifacts">Using artifacts</h5>
<p>Now that you have found an artifact you want to use, you can with the vcpkg use command. Try this command to use CMake.</p>
<pre class="prettyprint">vcpkg use cmake 
vcpkg-ce ('configure environment') is experimental and may change at any time.
 Artifact                           Version    Status     Dependency  Summary

 microsoft:tools/kitware/cmake      3.20.1     installed              Kitware's cmake tool

Activating individual artifacts
</pre>
<p>Yes, you can activate more than one artifact at a time. The following command activates gcc, cmake, and ninja, a complete C++ build system in one command. Note this is the Arm GCC compiler as that is the only one presently in the registry.</p>
<pre class="prettyprint">vcpkg use gcc cmake ninja</pre>
<h5 id="creating-your-own-manifest">Creating your own manifest</h5>
<p>The manifest, vcpkg-configuration.json, in the example above was also created with vcpkg. To create a manifest with tools needed for your own use vcpkg new. Make sure to run the subsequent commands in a new directory that is not a subfolder of an existing project.</p>
<pre class="prettyprint">vcpkg new</pre>
<h5 id="adding-artifacts-to-your-manifest">Adding artifacts to your manifest</h5>
<p>Now that we have a manifest and found artifacts we want to use with our project it is simple to add them. Note that the add command requires us to specify an artifact as it can also be used to add ports to a manifest.</p>
<pre class="prettyprint">vcpkg add artifact cmake

vcpkg-ce ('configure environment') is experimental and may change at any time.

 Artifact                       Version  Status     Dependency  Summary

 microsoft:tools/kitware/cmake  3.20.1   installed  *           Kitware's cmake tool

Project c:\source\newprj activated</pre>
<p>Now you can check in vcpkg-configuration.json with your source. Anyone else who uses your project can install vcpkg with a single command, then activate the artifacts in your manifest and reproduce the same results locally.</p>
<h4 id="subsequent-use-of-vcpkg">Subsequent use of vcpkg</h4>
<p>In the above examples vcpkg was available on the command line after installation. There is a quick way to get it back in new instances of your favorite terminal.</p>
<p>Linux/macOS</p>
<pre class="prettyprint">. ~/.vcpkg/vcpkg-init.sh</pre>
<p>PowerShell</p>
<pre class="prettyprint">. ~/.vcpkg/vcpkg-init.ps1</pre>
<p>CMD Shell</p>
<pre class="prettyprint">%USERPROFILE%\.vcpkg\vcpkg-init.cmd</pre>
<h4 id="removing-vcpkg">Removing vcpkg</h4>
<p>That was fun, how do you remove vcpkg installed from your system using the instructions above? Simply delete the .vcpkg folder in your home directory. No other changes have been made to your system through installing or using it.</p>
<h4 id="using-your-own-registry">Using your own registry</h4>
<p>The current artifacts in the default registry are limited to the embedded scenarios we have been developing the tool around which focus on Azure RTOS. In the future this set will expand to desktop development scenarios. The default registry can be found here: <a href="https://github.com/microsoft/vcpkg-ce-catalog">https://github.com/microsoft/vcpkg-ce-catalog</a>. Note that we are not taking pull requests of artifact additions to the default registries at this time.</p>
<p>We fully expect people to have their own artifacts they would like to use, or to provide for others to use.</p>
<p>As an example, what if you want to use a newer Arm compiler? Our example uses the one set by the example Azure RTOS project so that is the only one we put into the registry. In the steps below I will show how I added a new Arm compiler to my own registry. You can follow the same steps, modified for the artifact you need, to create your own registry of artifacts for use with vcpkg.</p>
<p>To create a new Arm gcc artifact metadata file I looked at the existing artifact metadata for the gcc compiler in the vcpkg-ce-catalog repo, <a href="https://github.com/microsoft/vcpkg-ce-catalog/blob/main/compilers/arm/gcc/gcc-2020.10.0.yaml">compilers/arm/gcc/ gcc-2020.10.0.yaml</a>.</p>
<p>On my local machine I copied that file into a folder, myregistry, under the same path for consistency. I then went to Arm’s website to find the latest compilers they provide. I then renamed the metadata file to match, gcc-2021.10.0.yaml. I updated the fields in the file for the version, the artifact urls under install &gt; unzip, and added the sha256 information. Note that Arm only provides md5 sums for their artifacts, this meant I had to download the artifacts manually first to generate my own sha256 sums to use. You can find this file in my personal GitHub repository here, <a href="https://github.com/robotdad/myregistry/blob/main/compilers/arm/gcc/gcc-2021.10.0.yaml">gcc-2021.10.0.yaml</a>.</p>
<p>Now, to test this I created a test folder and created a manifest with vcpkg new. I then opened this manifest and added a registry section pointing to my local folder with the artifact metadata.</p>
<pre class="prettyprint">{
    "registries": [
      {
        "name": "myregistry",
        "location": "c:/source/myregistry",
        "kind": "artifact"
      }
    ]
}</pre>
<p>Note that I specified the full path, alias like ~ are not supported.  Now, to find this entry I specified the name as part of the search query.</p>
<pre class="prettyprint">vcpkg find artifact myregistry:gcc

vcpkg-ce ('configure environment') is experimental and may change at any time.
Artifact                 Version    Summary
myregistry:compilers/arm/gcc  2021.10.0  GCC compiler for ARM CPUs.</pre>
<p>Once verified I added it to the manifest in the same way.</p>
<pre class="prettyprint">vcpkg add artifact local:gcc

vcpkg-ce ('configure environment') is experimental and may change at any time.
Artifact                      Version    Status     Dependency Summary
myregistry:compilers/arm/gcc  2021.10.0  installed  *          GCC compiler for ARM CPUs.

Project c:\source\test activated
</pre>
<p>Now my manifest looks like this:</p>
<pre class="prettyprint">{
  "registries": [
    {
      "name": "myregistry",
      "location": "c:/source/myregistry",
      "kind": "artifact"
    }
  ],
  "requires": {
    "myregistry:compilers/arm/gcc": "* 2021.10.0"
  }
}</pre>
<p>I wouldn’t want to share a manifest with others where a local path was used for a registry. Network paths are supported which works if I am only sharing internally. Note I had to escape the path in the location field.</p>
<pre class="prettyprint">"location": "\\\\myshare\\folder\\myregistry",</pre>
<p>I wanted to share my registry on GitHub to support this post which requires a couple of extra steps. The first extra step is to generate an index file. To do so I ran the following experimental command (this is likely to change in the future).</p>
<pre class="prettyprint">vcpkg z-ce regenerate c:/source/myregistry</pre>
<p>This generated an index.yaml for all of the artifact metadata files in the specified location.</p>
<p>To use a registry published in a GitHub repo I needed to specify the endpoint that provides an archive of the repository. This allows vcpkg to acquire all the artifact metadata in a single request. For a GitHub repo this is available at the path /archive/refs/heads/main.zip under the repository. For this example, I published my registry in my personal GitHub account here, <a href="https://github.com/robotdad/myregistry">https://github.com/robotdad/myregistry</a>, the location for that is specified as below in the manifest.</p>
<pre class="prettyprint">"location": "https://github.com/robotdad/myregistry/archive/refs/heads/main.zip",</pre>
<h4 id="give-us-your-feedback">Give us your feedback!</h4>
<p>We are very interested in hearing your thoughts on the new artifact capabilities in vcpkg. We have a separate repo for the component that provides those, <a href="https://github.com/microsoft/vcpkg-ce">vcpkg-ce</a>, where you can file any issues you encounter. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. As capabilities around artifacts in vcpkg evolve, your thoughts are critical to us for creating an excellent developer experience.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">Bootstrap your dev environment with vcpkg artifacts</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</title>
		<link>https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/</link>
					<comments>https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/#respond</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 15:20:01 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++ extension]]></category>
		<category><![CDATA[compilation database]]></category>
		<category><![CDATA[compile commands]]></category>
		<category><![CDATA[compile_commands.json]]></category>
		<category><![CDATA[CPP]]></category>
		<category><![CDATA[make]]></category>
		<category><![CDATA[makefile]]></category>
		<category><![CDATA[makefile tools]]></category>
		<category><![CDATA[problem matcher]]></category>
		<category><![CDATA[vs code]]></category>
		<category><![CDATA[VSCode]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29854</guid>

					<description><![CDATA[<p>The December 2021 update of the Makefile Tools extension for Visual Studio Code is here, bringing you support for problem matchers (to easily view errors and warnings in the editor), the ability to generate a compile_commands.json file for your project, and a bunch of other enhancements and bug fixes!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/">Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The December 2021 update of <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">the Makefile Tools extension for Visual Studio Code</a> is here, bringing you <a href="https://github.com/microsoft/vscode-makefile-tools/issues/7">support for problem matchers</a> (to easily view errors and warnings in the editor), the ability to <a href="https://github.com/microsoft/vscode-makefile-tools/issues/104">generate a compile_commands.json file</a> for your project, and a bunch of other enhancements and bug fixes! To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-makefile-tools/releases/tag/v0.3.0">release notes on GitHub.</a></p>
<h1 id="problem-matchers">Problem matchers</h1>
<p>If you’ve used the C++ extension for VS Code, you’re probably familiar with the <strong>Problems</strong> panel, where you can navigate through a list of compiler errors and warnings found in your project. VS Code uses a <a href="https://code.visualstudio.com/Docs/editor/tasks#_processing-task-output-with-problem-matchers">problem matcher</a> to display the errors and warnings in the Problems panel.</p>
<p>For example, if you’re missing a semi-colon in your source file, you’ll see the compiler error in the <strong>Problems</strong> panel. Selecting the problem brings you to the line of code generating the error or warning. To fix the problem, click on the lightbulb and choose from a list of Quick Actions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png"><img class="alignnone size-full wp-image-29856" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png" alt="A screenshot of the Problems Pane in VS Code, showing errors and warnings found by GCC and make in the project" width="3036" height="2054" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png 3036w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-300x203.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-1024x693.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-768x520.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-1536x1039.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-2048x1386.png 2048w" sizes="(max-width: 3036px) 100vw, 3036px" /></a></p>
<p>Now, let’s say you don’t have any compiler errors, but make displays a bunch of warnings when you build your project. Until now, there wasn’t a way to see those warnings in the Problems panel. With this latest release of the Makefile Tools extension, you’ll see all of make’s errors and warnings in the Problems panel after you build your program.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png"><img class="alignnone size-full wp-image-29857" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png" alt="A screenshot showing make's warnings in the Problems Pane in VS Code after building a project with Makefile Tools." width="3036" height="2062" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png 3036w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-300x204.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-1024x695.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-768x522.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-1536x1043.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-2048x1391.png 2048w" sizes="(max-width: 3036px) 100vw, 3036px" /></a></p>
<p>To enable make errors and warnings in the Problems panel, add <strong>&#8220;problemMatchers&#8221;: [&#8220;$gcc&#8221;]</strong> to your makefile configuration in settings.json, like this:</p>
<pre class="prettyprint">"makefile.configurations": [

        {

            "name": "MyConfiguration",

            "problemMatchers": [

                "$gcc"

            ],

            "makeArgs": ["any", "other", "args", "you", "want"]

        },

]</pre>
<p>If you’re on Windows using MSVC, set the problemMatcher to <strong>&#8220;$msCompile&#8221;</strong> instead of <strong>&#8220;$gcc&#8221;</strong>. Contributions from the community to support additional problem matchers are welcome! Problem matchers are defined in the extension’s <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/package.json#L198">package.json</a> file.</p>
<h1 id="generate-compile_commands-json">Generate compile_commands.json</h1>
<p>As a C++ developer, you might find yourself wanting a compilation database, which is a file that stores compilation instructions for the source files in your project. Compilation databases are used by many <a href="https://clang.llvm.org/docs/ClangTools.html">Clang tools</a> and editors/IDEs. A common compilation database format is compile_commands.json, which contains command objects, one for each translation unit in the project. Each command object specifies the translation unit’s main file, the compile command, and the working directory where the compile command is run.</p>
<p>With this latest release of the Makefile Tools extension, you can generate a compile_commands.json file for your project. All you have to do is specify the path to the target compile_commands.json file in settings.json, like this:</p>
<pre class="prettyprint">"makefile.compileCommandsPath": ".vscode/compile_commands.json"</pre>
<p>Then configure your project to generate compile_commands.json at the specified location.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png"><img class="alignnone size-full wp-image-29855" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png" alt="A screenshot of the contents of a compile_commands.json file generated by the Makefile Tools extension" width="3088" height="1888" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png 3088w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-300x183.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-1024x626.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-768x470.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-1536x939.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-2048x1252.png 2048w" sizes="(max-width: 3088px) 100vw, 3088px" /></a></p>
<p>Thank you <a href="https://github.com/rapgenic">rapgenic</a> for the request and for contributing to this feature!</p>
<h1 id="give-it-a-try">Give it a try</h1>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Download the Makefile Tools extension for Visual Studio Code</a> today, give it a try, and let us know what you think. Check out <a href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/">this blog post</a> to learn how to get started with Makefile Tools.</p>
<p>If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-makefile-tools/issues">Issues section of our GitHub repository</a>. Be sure to check out the <a href="https://github.com/microsoft/vscode-makefile-tools/tree/main/docs">Makefile Tools documentation</a> for troubleshooting tips and a list of tested repositories and their configuration instructions.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:makefiletools@microsoft.com">makefiletools@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/">Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>C++ build throughput investigation and tune up</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/#comments</comments>
		
		<dc:creator><![CDATA[olgaark]]></dc:creator>
		<pubDate>Fri, 19 Nov 2021 09:41:12 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29790</guid>

					<description><![CDATA[<p>Building C++ code is a complex process, launching many build tools in parallel and often running for a long time. It is always desirable to make it faster, but also a challenge to understand what the most effective way would be to achieve this.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">C++ build throughput investigation and tune up</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Building C++ code is a complex process, launching many build tools in parallel and often running for a long time. It is always desirable to make it faster, but also a challenge to understand what the most effective way would be to achieve this.</p>
<p>We’d like to share some techniques we use to get a “bigger” picture of the build, as well as tools that can help to see what is taking time in a particular part of the build. We’ll also talk about MSBuild project options which can improve build parallelism without overwhelming the system, as well as other (not immediately obvious) options which might affect build throughput.</p>
<p>This blog is more like a list of what is currently available, full of instructions and details. Some of the suggestions should be useful for any C++ build, but most of the measurements and tuning options are for MSBuild based projects (vcxproj).</p>
<p>As any performance improvement starts with the measurement, here we are – measure your build.</p>
<p>Note that the total build time can vary quite noticeably between several identical builds on the same machine – the system is adjusting to the active processes. So, if you compare builds before and after making some options changes, it is more reliable to run the build several times and get the average. It is also helpful to measure not only the total build time but get more detailed information, so if you get a surprising result, you can figure out why it happened. For MSBuild we recommend running it on the command line and collecting a <a href="http://www.msbuildlog.com/">binary log</a>.</p>
<h2 id="measure-your-build-time-using-msbuild-performance-summary">Measure your build time using MSBuild Performance Summary</h2>
<p>If your build is MSBuild based, the first thing to do when investigating build performance is to see which projects and which tasks/targets inside the projects are taking most of the build time. The performance summary data is also very useful for comparing builds using different options.</p>
<p>To get a performance summary for your full build, you can do the following: open a Developer (or MSBuild) Command Prompt and run the build of your solution with the following options (replace Configuration and Platform values with the ones your solution actually has):</p>
<pre class="prettyprint">msbuild /m /t:clean /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln 
msbuild  /m /fl  -flp:PerformanceSummary;v=q;LogFile=Perf.log /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln
</pre>
<p>The “quet” or “minimal” verbosity setting (<code>-flp:PerformanceSummary;v=q</code>) is recommended as console logging itself takes noticeable time. But you can set the verbosity to other levels if you want more build info in the Perf.log. You can also add <code>/detailedSummary</code> to see msbuild.exe <a href="https://devblogs.microsoft.com/visualstudio/msbuild-4-detailed-build-summary/#gimme-some-numbers">nodes utilization</a>).</p>
<p>The same information can be extracted from a binary log. We recommend creating binary logs when investigating your builds. To create a binary log, run:</p>
<pre><code class="language-txt">msbuild /m /t:clean /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln 
msbuild /m /bl:build.binlog /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln</code></pre>
<p>To extract the perf info into Perf.log, run:</p>
<pre><code class="language-txt">msbuild -noconlog -flp:PerformanceSummary -flp:v=q  build.binlog
ren msbuild.log Perf.log</code></pre>
<p>You can also enable “Build Timings” for VC projects in the IDE by setting “Tools/Options/Projects and Solutions/VC++ Project Settings/Build Timings” = “Yes”. This will create the Perf Summary for each project, but not for the whole solution build. Thus, using the command line is better to see the “whole picture”.</p>
<p>In the Perf.log you’ll find times (in ms) it took to build the whole solution, each project (in the time increasing order) and commutative time of all targets and tasks (also in the time increasing order). Note that project build time and some targets (like ResolveProjectReferences target) include the wait for referenced projects to be built. You can use the Timeline tab of the binlog viewer to see if other projects were built as a part of a particular project build.</p>
<p>For a solution containing mostly C++ projects, cl and link would usually be the tasks taking most of the time:</p>
<pre><code class="language-txt">Project Performance Summary:
…
    1100252 ms  d:testMySolution.sln          1 calls  solution build time (msbuild /m)

Task Performance Summary:
…
     22495731 ms  Link    250 calls 
    152500624 ms  CL      250 calls </code></pre>
<p>The task time is the sum of all times the task was executing for all projects and thus it can be bigger than the total build time. For CL and Link tasks their time is very close to the cl.exe and link.exe time.</p>
<h2 id="use-build-insights-to-see-the-build-timeline-for-cl-exe-and-link-exe">Use Build Insights to see the build timeline for cl.exe and link.exe</h2>
<p>Most of the C++ builds time is usually spent in the compiler. To visualize what is going on during the build, see the processes running in parallel and pivot on the parts that take most of the time, you can use the <a href="https://devblogs.microsoft.com/cppblog/introducing-c-build-insights/">Build Insights</a> tool.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/word-image.gif"><img class="alignnone wp-image-25179 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/word-image.gif" alt="" width="881" height="680" /></a></p>
<h2 id="change-options-to-improve-c-build-throughput">Change options to improve C++ build throughput</h2>
<p>There are many parameters which can affect build throughput and different codebases can benefit from different sets of options. Here we&#8217;ll talk about antivirus and project settings which are easy to change and which can potentially greatly improve your build throughput.</p>
<h3 id="1-check-your-antivirus-settings">1. Check your antivirus settings</h3>
<p>C++ builds produce a lot of intermediate files and we often see the file system as a bottleneck there. With your antivirus scanning all build outputs, the problem is greatly amplified.</p>
<p>Windows Defender Antivirus automatically excludes most of the common build tools when they are found in the default install locations. But if you install Visual Studio in a custom location or use many additional build tools, your build throughput might be affected.</p>
<p>To see if Windows Defender scans are impacting your build, you can use <a href="https://techcommunity.microsoft.com/t5/microsoft-defender-for-endpoint/announcing-performance-analyzer-for-microsoft-defender-antivirus/ba-p/2713911">Performance Analyzer for Microsoft Defender Antivirus</a>. The tool collects minimal data so you can run it for a good chunk of your build (10-20 min is usually enough) if not the whole build. We recommend closing all application unrelated to the build before collecting the data to avoid seeing unrelated to build processes in the report.</p>
<p>To collect the data and see the affected build processes:</p>
<ul>
<li>Open a Windows PowerShell and run:
<pre><code class="language-txt">New-MpPerformanceRecording -RecordTo MyBuild.etl</code></pre>
</li>
<li>Rebuild your code in the IDE or on the command line</li>
<li>After the build is finished (or after 10-20 min) go back to the PowerShell and stop the recording by hitting any key</li>
<li>In PowerShell run
<pre><code class="language-txt">Get-MpPerformanceReport -TopProcesses:20 MyBuild.etl</code></pre>
<p>This will give you the list of the affected processes, similar to the following one:</p>
<pre><code class="language-txt">TopProcesses
============

Count TotalDuration MinDuration AverageDuration MaxDuration MedianDuration ProcessPath
----- ------------- ----------- --------------- ----------- -------------- -----------
8193  62272.1020ms    0.1790ms        7.6006ms  119.5682ms       6.8465ms   D:Visual Studio 17VCToolsMSVC14.30.30528binHostx64x86cl.exe
1068  14587.9547ms    3.2531ms       13.6591ms 927.2716ms       6.0416ms    D:Visual Studio 17VCToolsMSVC14.30.30528binHostx64x86link.exe
…</code></pre>
<p>You can add the build tools from the trusted locations to the excluded files or directories list in the <a href="https://docs.microsoft.com/microsoft-365/security/defender-endpoint/configure-extension-file-exclusions-microsoft-defender-antivirus?view=o365-worldwide#exclusion-lists">Windows Defender settings.</a></li>
</ul>
<h3 id="2-redefine-tmp-directory">2. Redefine TMP directory.</h3>
<p>During compilation, cl.exe creates a tmp file per each source in the TMP folder. When many cl.exe processes are running in parallel and simultaneously creating a lot of files in the same folder it creates a lot of stress for the file system.</p>
<p>Using different TMP folders for different projects (and preferably not on the system drive) often makes the build faster, especially on powerful machines with many CPUs where disk I/O and file system are more often a bottleneck.</p>
<p>We are planning to address this problem in the future VS releases, but meanwhile you can redefine the TMP environment variable to be different for different projects. See the proposed <code>Directory.Build.props</code> sample at the end of the blog.</p>
<h3 id="3-tune-build-options-for-better-parallelism">3. Tune build options for better parallelism.</h3>
<p>Many C++ build operations support parallel execution. A general assumption is that the build should be faster when more build operations are running in parallel. This is true, but only to a point when the build is not overwhelming the system capacity to distribute machine resources between processes and threads.</p>
<p>Most of the build tools are heavy users of CPU, memory, and the file system. Depending on the number of source files, their size, and content, any of these components can be a bottleneck preventing the build from being faster when more tools are running in parallel. When a resource limit is hit, running more build operations in parallel will make the build slower, rather than faster, sometimes significantly. For instance, the <code>msbuild /m</code> + <code>cl /MP</code> resource overuse problem has been known for quite some time, but recently became more frequent as more and more computers have 32+ logical CPUs.
The problem of optimal build parallelism is quite complex as it is hard to predict up front the resource usage of a particular build operation and pretty much impossible to predict actual resource availability for the whole time of that build operation. But some heuristics can be used, at least for the number of running processes and threads.</p>
<h4 id="msbuild-resource-manager"><em>MSBuild Resource Manager</em></h4>
<p>In VS 2019 16.10, MSBuild introduced <a href="https://github.com/dotnet/msbuild/blob/main/documentation/specs/resource-management.md">cross-process resource management</a>, which allows build parts (tasks) of different projects communicating their anticipated CPU usage and limiting this usage if resources are already reserved by other build parts. All C++ build tasks that launch several processes (like cl.exe or custom build tools) or the ones that are known to use many threads (like link.exe) participate in this communication.</p>
<p>In VS 2022 17.0 VC project’s build uses the MSBuild Resource Manager by default. The MSBuild Resource Manager support is also available VS 2019 16.11, but off by default. To activate it the following property should be defined as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample):</p>
<p><code>set UseMSBuildResourceManager=true</code></p>
<p>If you don’t use <code>/MP</code> for your build currently, turn it on and give it a try. To affect all projects, define the following property as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample):</p>
<p><code>set CL_MP = true</code></p>
<p>By default, the MSBuild Resource Manager will allow maximum 2*(number of CPU cores) to be used simultaneously by all project’s tasks. The 2x cores (instead of just 1x) limit is partially dictated by the current MSBuild scheduler architecture, but also seems to allow better build throughput on average. Most of the time the build will use less than 2xCPUs and when it does, the system usually tolerates 2x CPU oversubscription quite well unless bottlenecks other than the CPU are hit by the build (see Many Cores Machines section).</p>
<p>There are also a couple of “knobs” to try if the default behavior is not good enough.
In addition to setting the maximum number of projects allowed to be built in parallel (<code>msbuild /m:nProjects</code>), you can set the following environment variables (cannot be MSBuild properties) to modify the behavior:</p>
<ul>
<li><code>MSBUILDCORELIMIT=N</code> where N is the max number of cores to be given to one project. By default it’s the number of logical CPUs on the machine</li>
<li><code>MSBUILDNODECOREALLOCATIONWEIGHT= [0 – 100]</code>
0% means that MSBuild nodes don’t consider using CPUs and 100% means that each MSBuild node would be considered using 1 CPU. In C++ builds, MSBuild processes CPU usage is small comparing to the compiler CPU usage, so 0 should be OK. But for mixed C# and C++ solutions it probably should be set to something between 50 and 100.</li>
</ul>
<p>If for some reason building with the MSBuild Resource Manager is slower for your build and you don’t want to experiment with other options, you can disable it by setting <code>UseMSBuildResourceManager</code> as false.</p>
<h4 id="multitooltask-mtt"><em>MultiToolTask (MTT)</em></h4>
<p>Other options which can be used to limit the number of cl.exe processes running in parallel are described in <a href="https://devblogs.microsoft.com/cppblog/improved-parallelism-in-msbuild/">Improve Parallelism in MSBuild</a>.</p>
<p>To activate MTT mode set the following properties as environment variables or as MSBuild properties for all projects (see also the <code>Directory.Build.props</code> sample below):</p>
<pre><code class="language-txt">set UseMultiToolTask=true
set EnforceProcessCountAcrossBuilds=true</code></pre>
<p>This will make the build launch a separate cl.exe process for each C/C++ source and limit the number of simultaneously running cl processes (across all project builds) to <code>CL_MPCOUNT</code>, which is by default set to the number of logical processors.</p>
<p>MultiToolTask mode can be also used together with the MSBuild Resource Manager. This might be beneficial for some builds as instead of asking the MSBuild Resource Manager for available resources only once before launching the top-level <code>cl.exe /MP</code>, the build will ask it before launching cl.exe for each source file.</p>
<p>Note, that for projects with many small and simple C/C++ files (i.e., when individual file compilation is not taking a long time), launching a separate cl.exe processes for each file would bring a noticeable overhead. So, this option is recommended to use when most of the source files are relatively large and complex.</p>
<p>In VS 2022, the new experimental &#8220;ClServer&#8221; mode has been added to address the process creation overhead in MTT mode by using server-client model similar to <code>cl.exe /MP</code>. The server would spawn worker cl.exe processes, then dispatch work via IPC. The server resides in MSBuild process so is in-sync with the resource manager while scheduling work dynamically—allocating more workers or freeing resources to scaling down to deal with &#8220;long pole&#8221; compiles.</p>
<p>To enable this mode the following property should be defined as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample below):</p>
<p><code>set EnableClServerMode=true</code></p>
<h4 id="increase-build-parallelism-for-native-c-projects-experimental"><em>Increase build parallelism for native C++ projects (experimental)</em></h4>
<p>This option is experimental and works only for command line builds currently (not supported for the IDE build).</p>
<p>By default, if project B is referencing project A, the build of project B will not start until project A’s build is finished.
This makes sense for managed projects where assemblies must exist before they can be used as references in the compilation.</p>
<p>But native C++ code compilation usually does not use any build outputs from the referenced projects, only the linker does.
Even with C++20 modules, where compilation does use the build outputs (modules) from the referenced projects, it only needs to wait for the referenced project compilation step to finish but does not need to wait for the link to be complete.</p>
<p>To allow the compilation step of the referencing projects to start as soon as the compilation step of the referenced projects is finished:</p>
<p><code>set BuildPassReferences=true</code></p>
<p>To allow parallel compilation of all native sources in spite of project references (implies <code>BuildPassReferences=true</code>): (Note that this mode won&#8217;t work if the code is using C++ 20 modules built as a part of the solution)</p>
<p><code>set AllowParallelCompileInReferencedProjects=true</code></p>
<p>As these options would allow more build parts running simultaneously, make sure to enable the MSBuild Resource Manager and/or MultiToolTask with <code>EnforceProcessCountAcrossBuilds</code>.</p>
<p>The command line should look like:</p>
<p><code>msbuild /p:Configuration=Debug;Platform= x64 /t:BuildGenerateSources;BuildCompile;BuildLink solution.sln</code></p>
<p>How it works:</p>
<p>By default, MSBuild starts project build execution after all projects it references finish building.
Each VC project build consists of BuildGenerateSources, BuildCompile and BuildLink targets executed one after another. They are historically called “build passes”.</p>
<p>The default build timeline for two projects where ProjectB is referencing ProjectA looks like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/Build.png" alt="Regular build" /></p>
<p>When <code>BuildPassReferences</code> is set to true, a project B’s <code>BuildGenerateSources</code> target will be executed as soon as project A’s <code>BuildGenerateSources</code> target finish building. The project B’s <code>BuildCompile</code> target will wait for project B’s <code>BuildGenerateSources</code> target to finish executing, as well as project A’s <code>BuildCompile</code> targets. Similarly, a project B’s <code>BuildLink</code> target will wait for project B’s <code>BuildCompile</code> target and project A’s <code>BuildLink</code> target.</p>
<p>So, with <code>BuildPassReferences = true</code>, the build timeline would look like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/BuildPasses.png" alt="Build with pass references" /></p>
<p>When <code>AllowParallelCompileInReferencedProjects</code> is true, the build will allow even the same targets of the referencing and referenced projects to run in parallel. This will only work if a target does not use outputs from the same target of the referenced project. Note, that .lib and .implib are created as a part of <code>BuildCompile</code> so they are always available for <code>BuildLink</code>.</p>
<p>The project B’s <code>BuildGenerateSources</code> target can be executed at the same time as project A&#8217;s <code>BuildGenerateSources</code> target.
The project B’s <code>BuildCompile</code> target will wait for project B’s and project A&#8217;s <code>BuildGenerateSources</code> targets to finish executing.
The project B’s <code>BuildLink</code> target will wait for project B’s and project A&#8217;s <code>BuildCompile</code> targets.</p>
<p>So, with <code>AllowParallelCompileInReferencedProjects=true</code> the timeline would look like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/ParallelCompile.png" alt="Build with parallel compilation" /></p>
<h3 id="4-tune-sources-includes-and-precompiled-headers-pch">4. Tune sources, includes and precompiled headers (PCH)</h3>
<p>To see which sources are taking most of the compiler time, use <a href="https://devblogs.microsoft.com/cppblog/introducing-c-build-insights/">Build Insights</a>. This tool will help you to see if adding a particular include to the pch would save a lot of compilation time. It will also allow you to view the build timeline.</p>
<p>Check the following blog post for adjusting PCH files:
<a href="https://devblogs.microsoft.com/cppblog/precompiled-header-pch-issues-and-recommendations/">Precompiled Header (PCH) issues and recommendations</a></p>
<p>If your files are well isolated, you can also try using Unity(Jumbo) builds:
<a href="https://devblogs.microsoft.com/cppblog/support-for-unity-jumbo-files-in-visual-studio-2017-15-8-experimental/">Support for Unity (Jumbo) Files in Visual Studio 2017 15.8 (Experimental)</a></p>
<h3 id="5-special-considerations-for-machines-with-64-cpus">5. Special considerations for machines with 64+ CPUs</h3>
<p>The following recommendations are based on the build time measurements performed on a 192 cores Windows Server machine.</p>
<ul>
<li>If you are running Windows Server 2016 on such a machine, it is highly recommended to upgrade it to WS2019. WS2016 was not optimized for launching many (64+) instances of the same exe, which resulted in poor performance of 64+ cl.exe running together.</li>
<li>When using Windows Server 2019, make sure that antivirus check is not affecting your build and TMP directory is redefined (i.e. follow recommendations #1 and #2 of this blog, see the chart below).</li>
<li>The build is likely to hit file system and disk I/O bottleneck when running a lot of build tools in parallel. If you’ve adjusted your build options for the best parallelism (#3), but still see low CPU utilization during build, it is likely that build is hitting a bottleneck other than CPU. Try limiting the number of projects running in parallel, as well as setting <code>MSBUILDCORELIMIT</code> to a lower number &#8211; this might actually improve your build throughput.</li>
</ul>
<p>In one of our tests, we’ve built a generated solution containing 250 projects, 250 cpp files each, with no project references. The C++ code was also generated and, admittedly, quite simple, containing one class per file, up to 30 methods each.</p>
<p>The following chart shows build times of this solution with different system and TMP options.
Each bar corresponds to the <code>msbuild /m:[nProjects]</code> build time, no other options were set. As the test projects did not have any project references, that was enough to achieve best parallelism.
Each series contains build times when number of projects built in parallel (and thus max number of cl.exe instances running together) was 10, 20, 30, 40, 60, 80, 100, 120, 140, 160, and 180.</p>
<p>The system/TMP setting for each series are:</p>
<ol>
<li>WS2016 Default settings</li>
<li>WS2019 Default settings, custom VS install location (Defender on, no exclusions, default TMP folder <code>c:users[username]AppDataLocalTemp</code>)</li>
<li>WS2019* Build tools are excluded from the Defender scan. Default TMP folder, not excluded from Defender scan.</li>
<li>WS2019** Build tools and default TMP folder are excluded from the Defender scan</li>
<li>WS2019*** Build tools are excluded from the Defender scan, TMP is set to project specific location, different for each project.</li>
</ol>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/Chart.png" alt="Build time (ms)" /></p>
<p>Note that in all series, build time did not improve much (and even got worse) when building more projects in parallel after some point. For this particular solution, building just ~40 projects in parallel showed the best results.</p>
<p>We’ve also tested other generated solutions with different number of projects, longer code, project references, etc. We also used different build options, especially the ones we recommend using in section#3.
The trends were quite similar, though the optimal number of parallel processes might differ.</p>
<p>The “real” code compilation usually takes much longer than the compilation of our small and simple generated files, so File System bottleneck might be not so pronounced there. But changing the antivirus and TMP settings improved the build times there as well, though not as much.</p>
<h2 id="directory-build-props-sample-to-set-options-for-all-projects">Directory.Build.props sample to set options for all projects</h2>
<p>Create<code> Directory.Build.props</code> in the root directory to affect all projects under this root.
This is a sample content of<code> Directory.Build.props</code> you can use to try different build settings.</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project&gt;
  &lt;PropertyGroup&gt;
    &lt;!-- To enable project specific directory for temporary files. --&gt;
    &lt;UseProjectTMPDirectory&gt;true&lt;/UseProjectTMPDirectory&gt;

    &lt;!-- To enable MSBuild Resource Manager in VS 2019 16.11 (on by default in VS 2022) --&gt;
    &lt;UseMSBuildResourceManager&gt;true&lt;/UseMSBuildResourceManager&gt;

    &lt;!-- Uncomment to enable MultiToolTask (MTT) mode. --&gt;
    &lt;!--&lt;UseMultiToolTask&gt;true&lt;/UseMultiToolTask&gt;
      &lt;EnforceProcessCountAcrossBuilds&gt;true&lt;/EnforceProcessCountAcrossBuilds&gt;--&gt;

    &lt;!-- Uncomment to enable experimental MTT ClServer mode, available in VS 2022. --&gt;
    &lt;!--&lt;EnableClServerMode&gt;true&lt;/EnableClServerMode&gt;--&gt;

    &lt;!-- Uncomment and change the value to control the maximum number of cl.exe processes running in parallel. 
         If using MTT without MSBuild Resource Manager, 10-20% oversubscription is often beneficial. --&gt;
    &lt;!--&lt;CL_MPCount&gt;20&lt;/CL_MPCount&gt;--&gt;

    &lt;!--Uncomment to allow executing more build operations in parallel--&gt;
    &lt;!--&lt;BuildPassReferences&gt;true&lt;/BuildPassReferences&gt; --&gt;
    &lt;!--&lt;AllowParallelCompileInReferencedProjects&gt;true&lt;/AllowParallelCompileInReferencedProjects&gt; --&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemDefinitionGroup&gt;
    &lt;!--  Enable parallel compilation (cl.exe /MP) --&gt;
    &lt;ClCompile&gt;
      &lt;MultiProcessorCompilation&gt;true&lt;/MultiProcessorCompilation&gt;
    &lt;/ClCompile&gt;
    &lt;!--  Enable parallel execution of a custom build tool--&gt;
    &lt;CustomBuild&gt;
      &lt;BuildInParallel&gt;true&lt;/BuildInParallel&gt;
    &lt;/CustomBuild&gt;
  &lt;/ItemDefinitionGroup&gt;

  &lt;!-- Define project specific directory for temporary files --&gt;
  &lt;Target Name="SetProjectTMPDirectory"
          Condition="'$(UseProjectTMPDirectory)' == 'true'"
          AfterTargets="SetBuildDefaultEnvironmentVariables"&gt;
    &lt;MakeDir Directories="$(IntDir)TMP"/&gt;
    &lt;SetEnv Name   ="TMP"
            Value  ="$(IntDir)TMP"
            Prefix ="false"&gt;
    &lt;/SetEnv&gt;
  &lt;/Target&gt;
&lt;/Project&gt;</code></pre>
<h2 id="send-us-feedback">Send Us Feedback</h2>
<p>Build is a complex process, and its performance depends on many factors and circumstances. Building different codebases on different hardware would benefit from different build settings. We hope you can try some of the options described in the blog and see if they improve your build time.</p>
<p>If you try any suggestions, please let us know, we love to hear from you! You can leave your comments below or email us at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">C++ build throughput investigation and tune up</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>What’s new for C++ cross-platform developers in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/#comments</comments>
		
		<dc:creator><![CDATA[Erika Sweet]]></dc:creator>
		<pubDate>Thu, 18 Nov 2021 15:33:43 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29778</guid>

					<description><![CDATA[<p>Visual Studio 2022 is available now! Check out the video below to learn what’s new for C++ developers who are building for more than just Windows, or who are developing with an eye to open source. This video covers: </p>
<p>Building with Visual Studio’s CMake Presets integration  <br />
Managing dependencies with a vcpkg manifest file and binary caching  <br />
Editing CMake scripts with CMake in-editor documentation and language services for CMake <br />
Building and debugging a Linux GUI application on WSL 2 with Visual Studio’s native support for WSL 2  <br />
Reproducing local builds with CMake Presets and GitHub Actions <br />
Debugging a remote process with LLDB </p>
<p>Contact us<br />
Have questions or comments about Visual Studio 2022?</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/">What’s new for C++ cross-platform developers in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">Visual Studio 2022 is </span><a href="https://visualstudio.microsoft.com/downloads/"><span data-contrast="none">available now</span></a><span data-contrast="auto">! Check out the video below to learn what’s new for C++ developers who are building for more than just Windows, or who are developing with an eye to open source. This video covers:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Building with Visual Studio’s <a href="https://aka.ms/cmakepresetsvs">CMake Presets integration</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="auto">Managing dependencies with a <a href="https://vcpkg.io/en/index.html">vcpkg manifest file and binary caching</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Editing CMake scripts with <a href="https://devblogs.microsoft.com/cppblog/in-editor-documentation-for-cmake-in-visual-studio/">CMake in-editor documentation</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170#language-services-for-cmake">language services for CMake</a></span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Building and debugging a Linux GUI application on WSL 2 with <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-build-debug-wsl2?view=msvc-170">Visual Studio’s native support for WSL 2</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto"><a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-170#run-cmake-from-the-command-line-or-a-ci-pipeline">Reproducing local builds with CMake Presets</a> and GitHub Actions</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><a href="http://aka.ms/lldb"><span data-contrast="auto">Debugging a remote process with LLDB</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></a></li>
</ul>
<p><center>
<iframe src="//www.youtube.com/embed/yImev317_Ns" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></center></p>
<h3 id="contact-us">Contact us</h3>
<p><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">Have</span><span class="NormalTextRun SCXW106660144 BCX8"> </span><span class="NormalTextRun SCXW106660144 BCX8">questions or comments about</span><span class="NormalTextRun SCXW106660144 BCX8"> Visual Studio 2022? Want to </span><span class="NormalTextRun SCXW106660144 BCX8">share feedback with our team? </span><span class="NormalTextRun SCXW106660144 BCX8">You can contact us </span><span class="NormalTextRun SCXW106660144 BCX8">at </span></span><a class="Hyperlink SCXW106660144 BCX8" href="mailto:visualcpp@microsoft.com" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">visualcpp@microsoft.com</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> </span><span class="NormalTextRun SCXW106660144 BCX8">or</span><span class="NormalTextRun SCXW106660144 BCX8"> on Twitter (</span></span><a class="Hyperlink SCXW106660144 BCX8" href="https://twitter.com/visualc" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">@VisualC</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">). The best way to file a bug or suggest a feature is with the </span></span><strong><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">Send Feedback</span></span></strong><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> button in the upper right-hand corner of the IDE. See </span></span><a class="Hyperlink SCXW106660144 BCX8" href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">How to report a problem with Visual Studio or Visual Studio Installer</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> for more information. </span></span><span class="EOP SCXW106660144 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/">What’s new for C++ cross-platform developers in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Code Analysis with GitHub Actions</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Winsor]]></dc:creator>
		<pubDate>Tue, 26 Oct 2021 11:23:10 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29701</guid>

					<description><![CDATA[<p>We previously talked about GitHub Code Scanning capabilities which enabled developers to incorporate security checks into their CI/CD environment and developer workflow. CodeQL is the default analysis engine behind Code Scanning. Today we are introducing support for MSVC Code Analysis which will provide a great companion to CodeQL for C++ GitHub repos with Windows workflows.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">Microsoft C++ Code Analysis with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We previously talked about <a href="https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/">GitHub Code Scanning capabilities</a> which enabled developers to incorporate security checks into their CI/CD environment and developer workflow. <a href="https://codeql.github.com/">CodeQL</a> is the default analysis engine behind Code Scanning. Today we are introducing support for MSVC Code Analysis which will provide a great companion to CodeQL for C++ GitHub repos with Windows workflows.</p>
<p>This <a href="https://github.com/marketplace/actions/microsoft-c-code-analysis-action">Action</a> will take the variety of Code Quality and Security warnings available in Visual Studio today and process them as alerts, displaying them in the <a href="https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/managing-code-scanning-alerts-for-your-repository">Security view of a GitHub repository</a>. The code scanning alerts produced will power the <a href="https://github.com/features/security/code">existing features</a> available through GitHub. These include highlighting the source code of contributors’ PRs with any warnings they may have introduced or allowing repository owners to view and manage the backlog of alerts under the Security tab.</p>
<p><img class="alignnone" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/CodeScanning.png" alt="Analysis results annotated in Pull Request UI" width="933" height="557" /></p>
<p>Alongside the support for analysis alerts inside of GitHub, the results can also be published as workflow artifacts, allowing contributors to download and view them locally in the IDE. This is enabled by our <a href="https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/">support for SARIF</a>, which is a standardized file format for analysis tooling. This format can be viewed inside of Visual Studio Code using the <a href="https://marketplace.visualstudio.com/items?itemName=MS-SarifVSCode.sarif-viewer">SARIF Viewer extension</a>. This will provide additional information highlighted on the source code, allowing the developer to easily resolve any problems found.</p>
<p>The repository will need to support CMake to ensure information about how the project is built can be extracted. We chose CMake because it provides a good abstraction for the varied nature of C++ projects and due to its wide adoption in the open-source community. It also provides an easy path for teams not currently building with the Microsoft Compiler to get analysis setup and see the features it has to offer.</p>
<h2 id="setup-github-action">Setup GitHub Action</h2>
<p>To get started using this experience you can find an entry for Microsoft C++ Code Analysis on the Security (tab) -&gt; Setup up code scanning page if C++ is detected in your repository.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/WorkflowSetup.gif"><img class="alignnone wp-image-29704 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/WorkflowSetup.gif" alt="Setting up Code Scanning workflow (GIF)" width="1002" height="592" /></a></p>
<p>Once you have the template installed you can customize it to adapt to the specific needs of your repository. You can configure options such as ignoring a set of targets used for testing or changing the Ruleset file. The Ruleset file allows you to customize which warnings will be run beyond the default behavior. You can select a predefined ruleset available in a Visual Studio install (inside the ‘Team ToolsStatic Analysis ToolsRule Sets’ directory) or reference a customized file checked-in to the source. For the best results create a custom ruleset that adds/removes warnings from official rulesets in VS. This will ensure you receive updated checks as more are developed. Refer to the <a href="https://docs.microsoft.com/cpp/code-quality/using-rule-sets-to-specify-the-cpp-rules-to-run?view=msvc-160">documentation on rulesets</a> for more information.</p>
<h3 id="example-ruleset">Example Ruleset</h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;RuleSet Name="Example" Description="Enable Warnings" ToolsVersion="10.0"&gt; 
  &lt;!-- Default rules available in Visual Studio --&gt;
  &lt;Include Path="NativeRecommendedRules.ruleset" Action="Default" /&gt; 
  &lt;Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis"     
         RuleNamespace="Microsoft.Rules.Native"&gt; 
    &lt;Rule Id="C26440" Action="None" /&gt; &lt;!-- Exclude: Declare noexcept --&gt;
    &lt;Rule Id="C26492" Action="None" /&gt; &lt;!-- Include: No const_cast&lt;&gt; --&gt; 
  &lt;/Rules&gt; 
&lt;/RuleSet&gt; </code></pre>
<h2 id="feedback">Feedback</h2>
<p>The action is published under a pre-release status as it is tested on additional GitHub repositories and more features are added. We would love to hear feedback from you on how we can improve the Action to make it compatible with your GitHub projects. If you have a need for Native MSBuild support, please express your interest on the following <a href="https://developercommunity.visualstudio.com/t/Add-Native-MSBuild-support-for-GitHub-Ac/1563225">feature request ticket</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">Microsoft C++ Code Analysis with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Mon, 25 Oct 2021 13:53:40 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[gamedev]]></category>
		<category><![CDATA[Intellisense]]></category>
		<category><![CDATA[unreal engine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29655</guid>

					<description><![CDATA[<p>With Visual Studio, we want to build the best tools to empower game developers. We joined forces with Epic Games to bring faster semantic highlighting and IntelliSense ready to Visual Studio 2022 for Unreal Engine developers. In this blog post, we will detail how we worked with the Unreal Engine team to significantly speed up the time it takes IntelliSense to start when a new file is opened in the editor by an order of 18x.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>With Visual Studio, we want to build the best tools to empower game developers. We joined forces with Epic Games to bring faster semantic highlighting and IntelliSense ready to Visual Studio 2022 for Unreal Engine developers. In this blog post, we will detail how we worked with the Unreal Engine team to significantly speed up the time it takes IntelliSense to start when a new file is opened in the editor by an order of <strong>18x</strong>.</p>
<p><strong><em>&#8220;We&#8217;ve always struggled with Intellisense performance in the Unreal Engine solution, but these changes are a night-and-day improvement. Faster feedback and less waiting help devs stay focused on making amazing games.&#8221;</em></strong> – Ben Marsh, Lead Programmer at Epic Games</p>
<p><strong>The changes are available for Unreal Engine 4.27.1 projects using the latest Visual Studio 2022 Preview. The changes will be available for Unreal Engine 5 at a later date.</strong></p>
<h1 id=""><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHOld30s.gif"><img class="aligncenter size-full wp-image-29684" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHOld30s.gif" alt="Image UnrealPCHOld30s" width="1200" height="675" /></a></h1>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHNew15s.gif"><img class="aligncenter size-full wp-image-29685" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHNew15s.gif" alt="Image UnrealPCHNew15s" width="1200" height="675" /></a></p>
<h2 id="testing-methodology">Testing Methodology</h2>
<p>We tested using an Unreal Engine 4.27.1 sample project on a desktop with Intel Core i7-9700 @ 3Ghz, 64GB RAM, and an SSD. The tests took place on Visual Studio 2019 16.11.5 and Visual Studio 2022 Preview 6. The results were averaged over 4 runs.</p>
<h2 id="results">Results</h2>
<p>When opening a file on Visual Studio 2019, it took <strong>11.0</strong> seconds for IntelliSense to be ready and semantic code colorization to show up. Opening a different file took the same amount of time to get to the same state. Closing and reopening the same file took <strong>1.0</strong> seconds for the ready state.</p>
<p>In comparison, Visual Studio 2022 took <strong>7.2</strong> seconds for the first file to be ready and <strong>0.4</strong> seconds for any subsequent files.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png"><img class="aligncenter size-full wp-image-29671" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png" alt="Image UnrealPCH" width="2273" height="1393" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png 2273w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-300x184.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-1024x628.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-768x471.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-1536x941.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-2048x1255.png 2048w" sizes="(max-width: 2273px) 100vw, 2273px" /></a></p>
<h2 id="analysis">Analysis</h2>
<p>Prior to the change, each translation unit, the C++ and header files in your project, started from scratch with no state reuse between them. Reopening the same file took 1 second; however, because PCHs were not shared between files, opening any file for the first time took the same amount of time for semantic highlighting to show up and IntelliSense to be ready.</p>
<p>In Unreal Engine 4.27.1 projects using Visual Studio 2022, the generated project files are updated to configure IntelliSense to share compilation state across translation units. As a result, the semantic code colorization and IntelliSense completion will be available drastically quicker (<strong>0.4 seconds</strong>) when switching files in Visual Studio.</p>
<p>In addition, C++ IntelliSense improvements in VS2022 were able to bring down ready time by a factor of <strong>1.5x</strong> from 11 seconds to 7.4 seconds. This change will benefit all C++ developers using IntelliSense, not only Unreal Engine developers.</p>
<h2 id="applying-the-change-to-your-project">Applying The Change to Your Project</h2>
<p>Currently, you will need to manually make an update in the Unreal Engine Editor to apply the changes.</p>
<ol>
<li>Click Edit -&gt; Editor Preferences -&gt; Source Code</li>
<li>Change Source Code Editor to “Visual Studio 2022”</li>
<li>Click File -&gt; Refresh Visual Studio 2022 Project</li>
<li>Click File -&gt; Open Visual Studio 2022 to open the project in Visual Studio</li>
</ol>
<p><em>If you use GenerateProjectFiles.bat when working with Unreal Engine source code, use “GenerateProjectFiles.bat -2022” to generate project files with changes.</em></p>
<h2 id="feedback-wanted">Feedback Wanted!</h2>
<p>We received feedback about various ways of making the game developer experiences even better in Visual Studio. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like the one detailed in this blogpost.</p>
<p>How will these productivity enhancements impact you as a game developer? What other enhancements do you wish to see in Visual Studio? Talk to us in the comments below, on Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h2 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h2>
<p><strong><a href="https://visualstudio.microsoft.com/launch/">Visual Studio 2022</a> is now available! </strong></p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>15</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Team at CppCon 2021</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 25 Oct 2021 11:45:06 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29688</guid>

					<description><![CDATA[<p>The Microsoft C++ team has an exciting lineup of sessions at CppCon 2021. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/">Microsoft C++ Team at CppCon 2021</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><img class="size-full wp-image-24953 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png" alt="Microsoft @ CppCon" width="760" height="466" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png 760w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp-300x184.png 300w" sizes="(max-width: 760px) 100vw, 760px" /></p>
<p>The Microsoft C++ team has an exciting lineup of sessions at <a href="https://cppcon.org/">CppCon 2021</a>. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks, products, or anything else! You can also join the <a href="https://aka.ms/cppcon/discord">#visual_studio channel on the CppCon Discord</a> to talk to us.</p>
<p>We’re also running a survey on the C++ ecosystem. If you have a moment, <a href="https://aka.ms/cppcon" target="_blank" rel="noopener noreferrer">please take our survey</a>, it&#8217;s quick.</p>
<p>Here’s the lineup:</p>
<h1 id="monday-october-25th">Monday, October 25<sup>th</sup></h1>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv1r/implementing-c-modules-lessons-learned-lessons-abandoned">Implementing C++ Modules: Lessons Learned, Lessons Abandoned</a> by Gabriel Dos Reis and Cameron DaCamara</p>
<h1 id="tuesday-october-26th">Tuesday, October 26<sup>th</sup></h1>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a id="37d29d70768539d44c325dcb13429b97" class="name" href="https://cppcon2021.sched.com/event/nv4b/documentation-in-the-era-of-concepts-and-ranges">Documentation in the Era of Concepts and Ranges</a> by Sy Brand and Christopher Di Bella (Google)</p>
<p><a href="https://cppcon2021.sched.com/event/o66J/extending-and-simplifying-c-thoughts-on-pattern-matching-using-is-and-as">Extending and Simplifying C++: Thoughts on Pattern Matching using <code>is</code> and <code>as</code></a> by Herb Sutter</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv4x/static-analysis-and-program-safety-in-c-making-it-real">Static Analysis and Program Safety in C++: Making it Real</a> by Sunny Chatterjee</p>
<p><strong>16:45 – 17:45 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv55/in-memory-and-persistent-representations-of-c">In-memory and Persistent Representations of C++</a> (on-site edition) by Gabriel Dos Reis</p>
<h1 id="wednesday-october-27th">Wednesday, October 27<sup>th</sup></h1>
<p><strong>12:30 – 13:30 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv55/in-memory-and-persistent-representations-of-c">In-memory and Persistent Representations of C++</a> (online edition) by Gabriel Dos Reis</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvBW/whats-new-in-visual-studio-64-bit-ide-c20-wsl-2-and-more">What&#8217;s New in Visual Studio: 64-bit IDE, C++20, WSL 2, and more</a> by Sy Brand and Marian Luparu</p>
<h1 id="thursday-october-28th">Thursday, October 28<sup>th</sup></h1>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvCA/c20s-dyachronodyagg-calendars-and-time-zones-in-msvc">C++20’s &lt;chrono&gt; Calendars and Time Zones in MSVC</a> by Miya Natsuhara</p>
<p><strong>14:00 – 15:00 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvCL/an-editor-can-do-that-debugging-assembly-language-and-gpu-kernels-in-visual-studio-code">An Editor Can Do That? Debugging Assembly Language and GPU Kernels in Visual Studio Code</a> by Julia Reid</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nvCV/why-does-stdformat-do-that">Why does std::format do that?</a> by Charlie Barto</p>
<p><strong>16:45 – 17:45 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv7V/finding-bugs-using-path-sensitive-static-analysis">Finding Bugs Using Path-Sensitive Static Analysis</a> (in-person edition) by Gabor Horvath</p>
<h1 id="friday-october-29th">Friday, October 29<sup>th</sup></h1>
<p><strong>12:00 – 13:00 (MDT):</strong></p>
<p><a href="https://cppcon2021.sched.com/event/nv7V/finding-bugs-using-path-sensitive-static-analysis">Finding Bugs Using Path-Sensitive Static Analysis</a> (online edition) by Gabor Horvath</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/">Microsoft C++ Team at CppCon 2021</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-cpp-team-at-cppcon-2021/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>A Race Condition in .NET Finalization and its Mitigation for C++/CLI</title>
		<link>https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/</link>
					<comments>https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/#comments</comments>
		
		<dc:creator><![CDATA[Tanveer Gani]]></dc:creator>
		<pubDate>Fri, 15 Oct 2021 15:00:12 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28733</guid>

					<description><![CDATA[<p>Abstract<br />
There is a dormant race condition in .NET which affects even single threaded code when finalizers are executed. The cause is primarily the fact that finalizers are called on a separate thread by .NET and may access objects which have already been garbage collected due to aggressive lifetime determination by the .NET JIT compiler in newer versions of the .NET runtime.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/">A Race Condition in .NET Finalization and its Mitigation for C++/CLI</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h2 id="abstract">Abstract</h2>
<blockquote><p>There is a dormant race condition in <code>.NET</code> which affects even single threaded code when finalizers are executed. The cause is primarily the fact that finalizers are called on a separate thread by <code>.NET</code> and may access objects which have already been garbage collected due to aggressive lifetime determination by the <code>.NET</code> JIT compiler in newer versions of the <code>.NET</code> runtime.
A solution for this problem, in the form of automatic generation of calls to <code>System::GC::KeepAlive</code>, has been implemented in the Microsoft C++ compiler and is available in version 16.10 and later.</p></blockquote>
<h2 id="introduction">Introduction</h2>
<p>C++/CLI is primarily meant to be an interop language bridging the native
and <code>.NET</code> worlds efficiently. Consequently, a frequently occuring code
pattern is wrapping of native pointers in managed classes. E.g.</p>
<pre><code class="language-cpp">class NativeClass { ... };
ref class ManagedClass {
    ...
private:
    NativeClass* ptr;
};</code></pre>
<p>Often, the managed wrapper class will <code>new</code> an instance of
<code>NativeClass</code>, which controls and accesses a system resource (e.g. a
file), uses the resources and to make sure that the resource is properly
released back, delegates this task to the finalizer. Elaborating the
above example, we could have code like:</p>
<pre><code class="language-cpp"> 1  using Byte = System::Byte;
 2  using String = System::String^;
 3  using Char = System::Char;
 4
 5  class File {
 6      FILE*   fp;
 7  public:
 8      explicit File(const Char* path, const Char* mode)
 9      {
10          fp = _wfopen(path, mode);
11      }
12      void Read() { ... }
13      void Write(const void*, size_t) { ... }
14      void Seek() { ... }
15      void Close()
16      {
17          if (fp) {
18              fclose(fp); fp = nullptr;
19          }
20      }
21      ~File() { Close(); }
22  };

26   ref class DataOnDisk
27   {
28   public:
29       DataOnDisk(String path, String mode)
30       {
31           cli::pin_ptr&lt;const Char&gt; path_ptr = PtrToStringChars(path);
32           cli::pin_ptr&lt;const Char&gt; mode_ptr = PtrToStringChars(mode);
33           ptr = new File(path_ptr, mode_ptr);
34       }
35       ~DataOnDisk() { this-&gt;!DataOnDisk(); }
36       !DataOnDisk()
37       {
38           if (ptr) {
39               delete ptr; ptr = nullptr;
40           }
41       }
42       void Close() { this-&gt;!DataOnDisk(); }
43       void WriteData(array&lt;Byte&gt;^ data) { ... }
44   private:
45       File*           ptr;  // Pointer to native implementation class.
46   };</code></pre>
<p>In the above code, class <code>File</code> controls the actual file via the native
C++ interface, while <code>DataOnDisk</code> uses the native class to read/write
structured data to file (details have been omitted for clarity). While
<code>Close</code> can be called explicitly when there is no more use for the file,
the finalizer is meant to do this when the <code>DataOnDisk</code> object is
collected.</p>
<p>As we shall see in the following section, while the above code appears
correct, there is a hidden race condition that can cause program errors.</p>
<h2 id="race-condition">Race Condition</h2>
<p>Let us define the member <code>WriteData</code> from the above code</p>
<pre><code class="language-cpp">49  void DataOnDisk::WriteData(array&lt;Byte&gt;^ buffer)
50  {
51      pin_ptr&lt;Byte&gt; buffer_ptr = &amp;buffer[0];
52      this-&gt;ptr-&gt;Write(buffer_ptr, buffer-&gt;Length);
53  } </code></pre>
<p>This function itself might be called in this context:</p>
<pre><code class="language-cpp">55  void test_write()
56  {
57      DataOnDisk^ dd = gcnew DataOnDisk(...);
58      array&lt;Byte&gt;^ buf = make_test_data();
59      dd-&gt;WriteData(buf);
60  } </code></pre>
<p>So far, nothing catches the eye or looks remotely dangerous. Starting
from <code>test_write</code>, let us examine what happens in detail.</p>
<ol>
<li>A <code>DataOnDisk</code> object is created (line 57), some test data is
created and <code>WriteData</code> is called to write this data to file (line
59).</li>
<li>The <code>WriteData</code> carefully pins the buffer array object (line 51)
before taking the address of an element and calling the <code>Write</code>
member function of the underlying native <code>File</code> object. The pinning
is important because we don&#8217;t want <code>.NET</code> to move the buffer bytes
while the write is happening.</li>
<li>However, since the <code>.NET</code> garbage collector knows nothing about
native types, the <code>ptr</code> field of <code>DataOnDisk</code> is just a bit pattern
with no other meaning attached. The <code>.NET</code> JIT compiler has analyzed
the code and determined that the last use of the <code>dd</code> object is to
access <code>ptr</code> (line 52), before its value is passed as the implicit
object parameter of <code>File::Write</code>. Following this reasoning by the
JIT compiler, once the value of <code>ptr</code> is fetched from the object,
<em>the object <code>dd</code> is no longer needed</em> and becomes eligible for
garbage collection.The fact that <code>ptr</code> points to a live native
object is opaque to <code>.NET</code> because it does not track native
pointers.</li>
<li>From here onward, things can go wrong. The object <code>dd</code> is scheduled
for collection and as part of the process, the finalizer is run,
typically on a second thread. Now, we have potentially two things
happening at the same time without any ordering between them, a
classic race condition: the <code>Write</code> member function is executing and
the finalizer <code>!DataOnDisk</code> is executing as well, the latter will
<code>delete</code> the file object referenced by <code>ptr</code> <em>while <code>File::Write</code> is
possibly still running</em>, which can then result in a crash or other
incorrect behavior.</li>
</ol>
<h2 id="wait-wha">Wait &#8212; Wha&#8230;?</h2>
<p>Several questions immediately come to mind:</p>
<ul>
<li><em>Is this a new bug?</em> Yes &#8212; and no. The issue has potentially been
around since <code>.NET</code> 2.0.</li>
<li><em>What changed?</em> The <code>.NET</code> JIT compiler started being aggressive
with lifetime determination in <code>.NET</code> 4.8. From the perspective of
managed code, it is doing the right thing.</li>
<li><em>But, this affects a core C++/CLI native interop scenario. What can
be done?</em> Read on.</li>
</ul>
<h2 id="solutions">Solutions</h2>
<p>It is easy to see that when the call to <code>Write</code> happens (line 52), if
<code>this</code> is kept alive, the race condition disappears since <code>dd</code> will no
longer be collected before the call to <code>Write</code> returns. This could be
done in several different ways:</p>
<ul>
<li><em>Treat the change in the behavior of the JIT compiler as a bug and
revert back to old behavior.</em> Doing this requires a system update
for <code>.NET</code> and potentially disables optimizations. Freezing the
<code>.NET</code> framework at version 4.7 is also an option but not one that
will work in the longer term, especially since the same JIT behavior
can happen in <code>.NET</code> <code>Core</code> as well.</li>
<li><em>Manually insert <code>System::GC::KeepAlive(this)</code> calls where needed</em>.
This works but is error prone and requires examining the user source
and changing it, so this is not a viable solution for large source
bases.</li>
<li><em>Have the compiler inject <code>System::GC::KeepAlive(this)</code> calls, when
needed</em>. This is the solution we have implemented in the Microsoft
C++ compiler.</li>
</ul>
<h2 id="details">Details</h2>
<p>We could brute-force a solution by issuing a call to <code>KeepAlive</code> every
time we see a call to native function, but for performance reasons we
want to be more clever. We want to issue such calls where there is a
possibility of a race condition but nowhere else. The following is the
algorithm that the Microsoft C++ compiler follows to determine if an
implicit <code>KeepAlive</code> call is to be issued at a point in the code where:</p>
<ul>
<li>We are at a return statement or implicit return from a member
function of a managed class;</li>
<li>The managed class has a member of type &#8216;reference or pointer to
unmanaged type&#8217;, including members in its direct or indirect base
classes, or embedded in members of class-types occuring anywhere in
the class hierarchy;</li>
<li>A call to a function <code>FUNC</code> is found in the current (managed member)
function, which satisfies one or more of these conditions:</p>
<ol>
<li><code>FUNC</code> doesn&#8217;t have a <code>__clrcall</code> calling convention, or</li>
<li><code>FUNC</code> doesn&#8217;t take <code>this</code> either as an implicit or explicit
argument, or</li>
<li>A reference to <code>this</code> doesn&#8217;t follow the call to <code>FUNC</code></li>
</ol>
</li>
</ul>
<p>In essence, we are looking for indicators that show <code>this</code> is in no
danger of getting garbage collected during the call to <code>FUNC</code>. Hence, if
the above conditions are satisfied, we insert a
<code>System::GC::KeepAlive(this)</code> call immediately following the call to
<code>FUNC</code>. Even though a call to <code>KeepAlive</code> looks very much like a
function call in the generated MSIL, the JIT compiler treats it as a
directive to consider the current object alive at that point.</p>
<h2 id="how-to-get-the-fix">How to get the fix</h2>
<p>The above Microsoft C++ compiler behavior is <strong>on by default</strong> in Visual
Studio <strong>version 16.10</strong> and up but in in cases where unforeseen
problems occur due to the new implicit emission of <code>KeepAlive</code> calls,
the Microsoft C++ compiler provides two escape hatches:</p>
<ul>
<li>the driver switch <code>/clr:implicitKeepAlive-</code>, which turns off all
such calls in the translation unit. This switch is not available in
project system settings but must be added explicitly to the
command-line option list
(<code>Property Pages &gt; Command Line &gt; Additional Options</code>).</li>
<li><code>#pragma implicit_keepalive</code>, which provides fine-grained control
over the emission of such calls at the function level.</li>
</ul>
<h2 id="a-final-nit">A Final Nit</h2>
<p>The astute reader will have noted that there is still a possible race
condition at line 39. To see why, imagine that both the finalizer thread
and user code call the finalizer at the same time. The possibility of a
double-delete in this case is obvious. Fixing this requires a critical
section but is beyond the scope of this article and left to the reader
as an exercise.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/">A Race Condition in .NET Finalization and its Mitigation for C++/CLI</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/a-race-condition-in-net-finalization-and-its-mitigation-for-cpp-cli/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</title>
		<link>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Fri, 08 Oct 2021 18:50:59 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29173</guid>

					<description><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/">Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">C++ Developer Community</a> page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the detailed overview of a new experimental <a href="https://docs.microsoft.com/cpp/build/reference/analyze-code-analysis">code analysis</a> check that can detect null pointer dereference errors, along with a comparison to an existing check that has the same purpose.</p>
<h2 id="overview">Overview</h2>
<p>Internally, we have multiple analysis engines. This is opaque from the users’ point of view; warnings are surfaced identically regardless of the engine we used to implement them. One of our code analysis tools, has a number of checks to catch null pointer dereference errors. These include <a href="https://aka.ms/cpp/warnings/C6011">C6011</a>, <a href="https://aka.ms/cpp/warnings/C6387">C6387</a>, and <a href="https://aka.ms/cpp/warnings/C28196">C28196</a>. While these warnings have historically been successful and prevented many errors, they do not work well with some aspects of modern C++. Moreover, the data flow framework they are written in has its limitations. EspXEngine was created to solve most of these problems. We already ship many analyses that are based on EspXEngine’s powerful path-sensitive data flow analysis including <a href="https://devblogs.microsoft.com/cppblog/concurrency-code-analysis-in-visual-studio-2019/">Concurrency Check</a> and <a href="https://devblogs.microsoft.com/cppblog/new-code-analysis-checks-in-visual-studio-2019-use-after-move-and-coroutine/">Use After Move Check</a>. The success of these checks convinced us to port null pointer analysis to EspXEngine. We are excited to make the new version available to try which introduces many improvements compared to the old one. The rest of the blog post is an in-depth overview of some of the improvements and gives some hints how to use power-user features like annotations.</p>
<h2 id="path-sensitive-analysis">Path-sensitive analysis</h2>
<p>Both analysis engines are capable of path-sensitive analysis. Let’s consider the example below to understand what this means:</p>
<pre><code class="language-c++">void path_sensitive(int *p, bool cond) { 
    int state = 0; 

    // branch 1  
    if (p != nullptr) { 
        state = 1; 
    } 

    // branch 2 
    if (cond) { 
        state = 2; 
        p = nullptr; 
    } 

    // branch 3 
    if (state == 1) { 
        *p = 42; // Null dereference? 
    } 
} </code></pre>
<p>The code above has multiple branches. Some of those branches are correlated, but flow-sensitive analyses will not reason about these correlations. For instance, a flow-sensitive analysis might conclude that the code is unsafe due to a potential null-dereference, since <code>p</code> is set to <code>nullptr</code> in branch 2, and then dereferenced in branch 3. However, this would be a false positive because branch 3 <strong>cannot</strong> be reached if branch 2 has been taken. Path-sensitive analyses, on the other hand, do reason about these types of reachability conditions, and would therefore conclude that the code above is safe. As a result, path-sensitive analyses are more precise. But, this precision comes at the cost of analysis time and memory. Both engines have identical behavior on this code snippet.</p>
<h2 id="local-analysis">Local analysis</h2>
<p>Both engines are doing intraprocedural analysis. They cannot see across function boundaries and rely on types, type extensions, models and contracts to bridge the gap.</p>
<pre><code class="language-c++">void local_analysis(int *p, int *q, bool cond) { 
    if (p == nullptr) 
        return; 
    q = nullptr; 
    std::swap(p, q); 
    *p = 42; // Null dereference 
} </code></pre>
<p>The code above has a bug. The pointer <code>p</code> is <code>nullptr</code> due to the call to swap. This bug is not found by the current check. However, EspXEngine models some common APIs. As a result, it can figure out the bug and report a warning to the user.</p>
<p>Unfortunately, when we call our own APIs, EspXEngine will not know the semantics of the called function. In those cases, we can use types or <a href="https://docs.microsoft.com/cpp/code-quality/understanding-sal?view=msvc-160">SAL annotations</a> to describe the pre- and postconditions of our functions:</p>
<pre><code class="language-c++">_Notnull_ int *get_my_ptr(); 
gsl::not_null&lt;int *&gt; get_my_ptr2(); 
void local_analysis(int *p) { 
    _Analysis_assume_(p != nullptr); 
    *p = 42; 
} </code></pre>
<p>In the code above, we use the <code>_Notnull_</code> and <code>_Analysis_assume_</code> SAL annotations to describe the constraints on the values of some pointers. This is supported by both engines. A more modern approach is to use rich types to express these contracts. This is only supported in EspXEngine. Moreover, it will flag code where a null pointer is stored into a <a href="https://github.com/microsoft/GSL"><code>gsl::not_null</code></a> pointer:</p>
<pre><code class="language-c++">void assign_to_gsl_notnull() { 
    int* p = nullptr; 
    auto q = gsl::make_not_null(p); // C26822 warning 
} </code></pre>
<p>While types are great to encode our expectations, SAL has the power to express a wider range of contracts. Consider the example below:</p>
<pre><code class="language-c++">void postcondition_conditional(bool b, _When_(b == true, _Outptr_) int** p)  { 
    if (b == true) 
        *p = nullptr; // C26824 warning 
} </code></pre>
<p>This function has a complex postcondition. Whenever the first argument is true, the value at location <code>*p</code> must be not-<code>null</code> when the function exists. These contracts are understood by both engines (although the support in EspXEngine is more sophisticated) and many Windows APIs are annotated to describe their behavior. We would love to use a standard language facility, but the contracts proposal was not accepted for C++20 and we need a solution that work both for C and C++ APIs.</p>
<h2 id="some-problems-with-our-existing-null-pointer-checks">Some problems with our existing null pointer checks</h2>
<p>I wanted to showcase some examples where the null pointer check based on EspXEngine has better behavior than the current one. First of all, there are some low easy to catch null pointer dereferences that are not found by the current checks:</p>
<pre><code class="language-c++">void nullptr_constant_dereference() { 
    *(int*)nullptr = 5; // Previously, it was not found. 
} </code></pre>
<p>There are also cases where they were noisier:</p>
<pre><code class="language-c++">struct Node { 
    int number; 
    Node* next; 
}; 

void add_number(Node*&amp; head, Node*&amp; tail, int data) { 
    if (head != nullptr) { 
        tail-&gt;next = (Node*)malloc(sizeof(Node)); 
        tail = tail-&gt;next; 
    } else { 
        head = (Node*)malloc(sizeof(Node)); 
        tail = head; 
    } 
    tail-&gt;number = data; // C6011 warning 
    tail-&gt;next = nullptr; 
} </code></pre>
<p>In the code above the current version will give a null pointer dereference warning on the line with the comment. Technically, this warning could be a true positive when <code>malloc</code> fails and returns a <code>nullptr</code>. This is a scenario that is irrelevant for many applications. EspXEngine has both low and high confidence warnings and will only emit a low confidence warning in this case. Most users are probably only interested in the high confidence warnings that are expected to have less noise and turn the low confidence warnings off.</p>
<p>Moreover, we decided to make EspXEngine stricter detecting various undefined behavior:</p>
<pre><code class="language-c++">void method_null_dereference(Foo* p, Foo* q) { 
    if (p || q) 
        return; 

    p-&gt;method();            // C26822 warning 
    q-&gt;static_method(42);   // OK, not UB.  
} </code></pre>
<p>In the code above, contrary to EspXEngine, the current warning will not warn when we call a method on a null pointer. Strictly speaking, this code has undefined behavior, but many implementations will work fine when <code>method</code> does not dereference the <code>this</code> pointer.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The upcoming Visual Studio 2022 17.0 Preview 4 will feature new, experimental checks to find null pointer dereference errors. These checks are intended to be better versions of the current ones with improved precision and additional features. These new checks are doing in-depth analysis and are expected to increase the analysis time. They are off by default and can be enabled by using the <code>CppCoreCheckExperimentalRules</code> ruleset.</p>
<h2 id="try-it-out-and-let-us-know-what-you-think">Try it out and let us know what you think:</h2>
<p>The work that we do is heavily influenced by feedback we receive on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check. Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/">Improved Null Pointer Dereference Detection in Visual Studio 2022 version 17.0 Preview 4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improved-null-pointer-dereference-detection-in-visual-studio-2022-version-17-0-preview-4/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
	</channel>
</rss>
