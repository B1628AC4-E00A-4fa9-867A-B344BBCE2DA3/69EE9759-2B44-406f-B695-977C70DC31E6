<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Tue, 12 Jul 2022 18:07:10 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Integrated Terminal in Visual Studio: New SSH integration for Linux targeting</title>
		<link>https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/</link>
					<comments>https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/#comments</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 12 Jul 2022 18:07:10 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30770</guid>

					<description><![CDATA[<p>In the latest version of Visual Studio, users are now able to leverage the integrated terminal to access their remote targets when developing for remote machines from Windows. This updated terminal includes an interactive SSH shell. It can be accessed by going to View-&#62;Terminal in Visual Studio. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/">Integrated Terminal in Visual Studio: New SSH integration for Linux targeting</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW224106047 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW224106047 BCX8">In the </span></span><a class="Hyperlink SCXW224106047 BCX8" href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW224106047 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW224106047 BCX8" data-ccp-charstyle="Hyperlink">latest version of Visual Studio</span></span></a><span class="TextRun SCXW224106047 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW224106047 BCX8">, users are </span><span class="NormalTextRun SCXW224106047 BCX8">now </span><span class="NormalTextRun SCXW224106047 BCX8">able</span><span class="NormalTextRun SCXW224106047 BCX8"> to </span><span class="NormalTextRun SCXW224106047 BCX8">leve</span><span class="NormalTextRun SCXW224106047 BCX8">rage</span><span class="NormalTextRun SCXW224106047 BCX8"> the integrated terminal to access their remote targets</span><span class="NormalTextRun SCXW224106047 BCX8"> when developing for </span><span class="NormalTextRun SCXW224106047 BCX8">remote machines from Windows</span><span class="NormalTextRun SCXW224106047 BCX8">. This </span><span class="NormalTextRun SCXW224106047 BCX8">updated terminal</span><span class="NormalTextRun SCXW224106047 BCX8"> includes an interactive SSH shell.</span> <span class="NormalTextRun SCXW224106047 BCX8">I</span><span class="NormalTextRun SCXW224106047 BCX8">t</span><span class="NormalTextRun SCXW224106047 BCX8"> can be accessed by going to View-&gt;Terminal in Visual Studio</span><span class="NormalTextRun CommentStart SCXW224106047 BCX8">.</span></span><span class="EOP SCXW224106047 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950.png"><img class="alignnone size-full wp-image-30775" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950.png" alt="New SSH Integrated Terminal in Visual Studio" width="1023" height="574" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950.png 1023w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950-300x168.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-093950-768x431.png 768w" sizes="(max-width: 1023px) 100vw, 1023px" /></a></p>
<p><span class="TextRun SCXW167861519 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW167861519 BCX8">Now, </span><span class="NormalTextRun CommentStart SCXW167861519 BCX8">instead of </span><span class="NormalTextRun SCXW167861519 BCX8">starting an SSH session inside of </span><span class="NormalTextRun SpellingErrorV2Themed SCXW167861519 BCX8">PowerShell</span><span class="NormalTextRun SCXW167861519 BCX8"> or WSL and </span><span class="NormalTextRun SCXW167861519 BCX8">having to re-authenticate</span><span class="NormalTextRun SCXW167861519 BCX8">,</span><span class="NormalTextRun SCXW167861519 BCX8"> you can select one of your existing connections with one click</span><span class="NormalTextRun SCXW167861519 BCX8">. The </span><span class="NormalTextRun SCXW167861519 BCX8">integrated terminal pulls from the stored connections </span><span class="NormalTextRun SCXW167861519 BCX8">established</span><span class="NormalTextRun SCXW167861519 BCX8"> in your Connection Manager</span><span class="NormalTextRun SCXW167861519 BCX8">. You only </span><span class="NormalTextRun AdvancedProofingIssueV2Themed SCXW167861519 BCX8">have to</span><span class="NormalTextRun SCXW167861519 BCX8"> authenticate once when you add a stored connection</span><span class="NormalTextRun SCXW167861519 BCX8"> and </span><span class="NormalTextRun CommentStart SCXW167861519 BCX8">the</span><span class="NormalTextRun SCXW167861519 BCX8">n this authentication information will remain stored in Visual Studio</span><span class="NormalTextRun SCXW167861519 BCX8">,</span><span class="NormalTextRun SCXW167861519 BCX8"> allowing for</span><span class="NormalTextRun SCXW167861519 BCX8"> less downtime spent managing SSH</span><span class="NormalTextRun SCXW167861519 BCX8"> connections that have timed out</span><span class="NormalTextRun SCXW167861519 BCX8">.</span><span class="NormalTextRun SCXW167861519 BCX8"> </span></span><span class="EOP SCXW167861519 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401.png"><img class="alignnone size-full wp-image-30776" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401.png" alt="Connection Manager in Visual Studio" width="753" height="490" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401.png 753w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094401-300x195.png 300w" sizes="(max-width: 753px) 100vw, 753px" /></a></p>
<p><span class="TextRun SCXW3747466 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW3747466 BCX8">In the upper left corner</span><span class="NormalTextRun SCXW3747466 BCX8"> of the integrated terminal</span><span class="NormalTextRun SCXW3747466 BCX8">, </span><span class="NormalTextRun SCXW3747466 BCX8">you can click on the SSH</span><span class="NormalTextRun SCXW3747466 BCX8"> connection selected and see </span><span class="NormalTextRun SCXW3747466 BCX8">the profile </span><span class="NormalTextRun CommentStart SCXW3747466 BCX8">dropdown</span><span class="NormalTextRun SCXW3747466 BCX8"> entrie</span><span class="NormalTextRun SCXW3747466 BCX8">s </span><span class="NormalTextRun SCXW3747466 BCX8">available that show connections </span><span class="NormalTextRun SCXW3747466 BCX8">enumerated</span><span class="NormalTextRun SCXW3747466 BCX8"> from your Connection Manager.</span></span><span class="EOP SCXW3747466 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626.png"><img class="alignnone size-full wp-image-30778" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626.png" alt="SSH dropdown in Integrated Terminal" width="1029" height="562" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626.png 1029w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626-300x164.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626-1024x559.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/Screenshot-2022-07-12-094626-768x419.png 768w" sizes="(max-width: 1029px) 100vw, 1029px" /></a></p>
<p><span data-contrast="auto">When you click on a connection from the dropdown, the terminal will spawn a new terminal instance that will remain docked next to your current terminal instance in the tabs below. </span><span data-ccp-props="{}"> </span></p>
<p><span data-contrast="auto">Additionally, the new integrated terminal now supports manipulating files, running background tasks, configuring your remote system, and testing your deployed code all from inside of VS instead of having to use an external SSH client. This terminal also supports color and command sequences, so for example, copy, paste, and find shortcuts will work, as well as interactive programs like vim.</span><span data-ccp-props="{}"> </span></p>
<h4 id="send-us-your-feedback">Send us your feedback!</h4>
<p><span class="TextRun SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW169529413 BCX8">Download the latest version of Visual Studio and give the latest integrated terminal a try. </span><span class="NormalTextRun CommentStart SCXW169529413 BCX8">Let us know </span><span class="NormalTextRun SCXW169529413 BCX8">your thoughts,</span><span class="NormalTextRun SCXW169529413 BCX8"> and whether there is anything </span><span class="NormalTextRun SCXW169529413 BCX8">you’d</span><span class="NormalTextRun SCXW169529413 BCX8"> like to see. </span></span><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8"> </span></span><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8">We are </span><span class="NormalTextRun SCXW169529413 BCX8">very interested</span><span class="NormalTextRun SCXW169529413 BCX8"> in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (</span></span><a class="Hyperlink SCXW169529413 BCX8" href="https://twitter.com/visualc" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8" data-ccp-charstyle="Hyperlink">@VisualC</span></span></a><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8">), or via email at </span></span><a class="Hyperlink SCXW169529413 BCX8" href="mailto:visualcpp@microsoft.com" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8" data-ccp-charstyle="Hyperlink">visualcpp@microsoft.com</span></span></a><span class="TextRun Highlight SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8">.</span><span class="NormalTextRun SCXW169529413 BCX8"> To open a bug, please see </span></span><a class="Hyperlink SCXW169529413 BCX8" href="https://developercommunity.visualstudio.com/report?space=8&amp;entry=problem" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW169529413 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW169529413 BCX8" data-ccp-charstyle="Hyperlink">Visual Studio Feedback</span></span></a><span class="EOP SCXW169529413 BCX8" data-ccp-props="{}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/">Integrated Terminal in Visual Studio: New SSH integration for Linux targeting</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/integrated-terminal-in-visual-studio-new-ssh-integration-for-linux-targeting/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>VS2022 Performance Enhancements: Faster C++ Development</title>
		<link>https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Mon, 11 Jul 2022 16:04:16 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[game]]></category>
		<category><![CDATA[Game Development]]></category>
		<category><![CDATA[perf]]></category>
		<category><![CDATA[search]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30753</guid>

					<description><![CDATA[<p>Introduction<br />
Building on top of our performance wins in earlier releases of VS2022, we are excited to announce additional improvements in Visual Studio 2022 17.3! Whether you are a game developer, work with large codebases, or have a small C++ project,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/">VS2022 Performance Enhancements: Faster C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p>Building on top of our <a href="https://aka.ms/VS2022CppPerf1">performance wins</a> in earlier releases of VS2022, we are excited to announce additional improvements in Visual Studio 2022 17.3! Whether you are a game developer, work with large codebases, or have a small C++ project, your C++ development experience in Visual Studio 17.3 will feel even faster!</p>
<p>In this blog, I will share the incredible speed improvements you will experience when VS indexes your codebase and colorizes your C++ code for the first time. In addition, learn about the new Go to All experience that will show results as you type.</p>
<h1 id="testing-methodology">Testing Methodology</h1>
<p>Measuring indexing and time to colorization, we used an Unreal Engine 5 blank C++ project on a desktop with an Intel Core i7-9700 CPU @ 3Ghz, 64GB RAM, and an SSD. For indexing improvements, we benchmarked using both UE5 and the more than 300,000 file Chromium repo. The tests took place on Visual Studio 2019 16.11 and Visual Studio 2022 17.2 and 17.3. For both scenarios, we used system logs to track the duration of the operations.</p>
<h1 id="results">Results</h1>
<h2 id="population-indexing-improvements">Population (Indexing) Improvements</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium.png"><img class="aligncenter size-full wp-image-30755" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium.png" alt="Image indexchromium" width="2003" height="1376" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium.png 2003w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-300x206.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-1024x703.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-768x528.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexchromium-1536x1055.png 1536w" sizes="(max-width: 2003px) 100vw, 2003px" /></a></p>
<p>In Visual Studio 2019 16.11, it takes roughly 26 minutes for the Chromium repo to fully index. In Visual Studio 2022 17.3, waiting for indexing to finish will only take a bit over 6 minutes, a 4.17X speed up. When indexing a large solution like the Chromium repo for the first time, you will save up to 20 minutes with the latest version of Visual Studio.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5.png"><img class="aligncenter size-full wp-image-30756" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5.png" alt="Image indexue5" width="1836" height="1146" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5.png 1836w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-1024x639.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-768x479.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/indexue5-1536x959.png 1536w" sizes="(max-width: 1836px) 100vw, 1836px" /></a></p>
<p>When getting to code in a new Unreal Engine 5 solution, you will see a huge improvement in the latest version of VS2022 versus VS2019. In VS2019 16.11, fully indexing a brand-new C++ UE5 solution took 144 seconds. When using VS2022 17.3, fully indexing the same UE5 solution is now 2X faster at 72 seconds. Whether you are creating a new UE5 project or cloning from an existing repo, your code will index much faster in 17.3.</p>
<h2 id="time-to-colorization">Time to Colorization</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5.png"><img class="aligncenter size-full wp-image-30754" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5.png" alt="Image colorue5" width="2001" height="1222" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5.png 2001w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-300x183.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-1024x625.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-768x469.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/colorue5-1536x938.png 1536w" sizes="(max-width: 2001px) 100vw, 2001px" /></a></p>
<p>Building on top of the improvements in VS2022 17.2, time to colorization is even faster in Visual Studio 2022 17.3. Compared to VS2019 16.11, you will see your UE5 code colorize from a cold start in 7.6 seconds, a 4.3X improvement.</p>
<h2 id="go-to-responsiveness">Go To Responsiveness</h2>
<p>In Visual Studio 2022 17.3, your Go to All experience will feel faster! Previously, results appeared after you stopped typing. In the new experience, results will show as you type. You will now spend less time getting the result you desire.</p>
<p style="text-align: center;"><strong><span style="font-size: 18pt;">Before</span></strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotobefore.gif"><img class="aligncenter size-full wp-image-30766" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotobefore.gif" alt="Image gotobefore" width="454" height="385" /></a></p>
<p style="text-align: center;"><strong><span style="font-size: 18pt;">After</span></strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotoafter.gif"><img class="aligncenter size-full wp-image-30767" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/gotoafter.gif" alt="Image gotoafter" width="454" height="385" /></a></p>
<p>In addition to the new Go to All experience, you can now search and interact with code more efficiently with Contextual Code Previews in our All-In-One Search experience. For more information, please see this <a href="https://devblogs.microsoft.com/visualstudio/sneak-peek-and-edit-your-code-while-you-search/">blog</a>.</p>
<h2 id="git-branch-switching">Git Branch Switching</h2>
<p>In addition to C++ and search improvements, we have also significantly improved the branch switching experience. Please refer to this <a href="https://aka.ms/VS2022-BranchSwitchingPerformance">blog</a> for more information.</p>
<p>&nbsp;</p>
<h1 id="feedback-wanted">Feedback Wanted!</h1>
<p>Your feedback through <a href="https://developercommunity.visualstudio.com/">Developer Community</a>, surveys, and social media channels has made these improvements possible. We thank you for your valuable comments.
These enhancements are a continuation of our focus on improving productivity for game developers. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like ones detailed in this blogpost. If you are a game developer, <a href="http://aka.ms/VSGameDevSurvey">let us know your thoughts in our 2022 Visual Studio Game Developer Survey</a>.</p>
<p>In addition, please continue to help shape the development of Visual Studio by talking to us in the comments below, on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h1 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h1>
<p><a href="https://visualstudio.microsoft.com/downloads/">Download the latest version of Visual Studio 2022</a> to take advantage of these productivity benefits today!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/">VS2022 Performance Enhancements: Faster C++ Development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>C++23&#8217;s Deducing this: what it is, why it is, how to use it</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 27 Jun 2022 10:41:41 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30707</guid>

					<description><![CDATA[<p>Find out how C++23's Deducing this feature can help make your code better.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23&#8217;s Deducing this: what it is, why it is, how to use it</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://wg21.link/p0847">Deducing <code>this</code></a> (P0847) is a C++23 feature which gives a new way of specifying non-static member functions. Usually when we call an object&#8217;s member function, the object is <em>implicitly</em> passed to the member function, despite not being present in the parameter list. P0847 allows us to make this parameter <em>explicit</em>, giving it a name and <code>const</code>/reference qualifiers. For example:</p>
<pre><code class="language-cpp">struct implicit_style {
    void do_something(); //object is implicit
};

struct explicit_style {
    void do_something(this explicit_style&amp; self); //object is explicit
};</code></pre>
<p>The explicit object parameter is distinguished by the keyword <code>this</code> placed before the type specifier, and is only valid for the first parameter of the function.</p>
<p>The reasons for allowing this may not seem immediately obvious, but a bunch of additional features fall out of this almost by magic. These include de-quadruplication of code, recursive lambdas, passing <code>this</code> by value, and a version of the <a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/">CRTP</a> which doesn&#8217;t require the base class to be templated on the derived class.</p>
<p>This post will walk through an overview of the design, then many of the cases you can use this feature for in your own code.</p>
<p>For the rest of this blog post I&#8217;ll refer to the feature as &#8220;explicit object parameters&#8221;, as it makes more sense as a feature name than &#8220;deducing <code>this</code>&#8220;. Explicit object parameters are supported in MSVC as of Visual Studio 2022 version 17.2. A good companion to this post is Ben Deane&#8217;s talk <a href="https://www.youtube.com/watch?v=jXf--bazhJw">Deducing <code>this</code> Patterns</a> from CppCon.</p>
<h2 id="overview">Overview</h2>
<p>The paper which proposed this feature was written by <a href="https://twitter.com/atomgalaxy">Gašper Ažman</a>, <a href="https://twitter.com/ben_deane">Ben Deane</a>, <a href="https://twitter.com/BarryRevzin">Barry Revzin</a>, and <a href="https://twitter.com/TartanLlama">myself</a>, and was guided by the experience of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html#acknowledgements">many experts in the field</a>. Barry and I began writing a version of this paper after we each implemented <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a> and came across the same problem. We would be writing the <code>value</code> function of <code>optional</code> and, like good library developers, we&#8217;d try to make it usable and performant in as many use-cases as we could. So we&#8217;d want <code>value</code> to return a <code>const</code> reference if the object it was called on was <code>const</code>, we&#8217;d want it to return an rvalue if the object it was called on was an rvalue, etc. It ended up looking like this:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // version of value for non-const lvalues
  constexpr T&amp; value() &amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  // version of value for const lvalues
  constexpr T const&amp; value() const&amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  // version of value for non-const rvalues... are you bored yet?
  constexpr T&amp;&amp; value() &amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }

  // you sure are by this point
  constexpr T const&amp;&amp; value() const&amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }
  // ...
};</code></pre>
<p>(If you&#8217;re not familiar with the <code>member_function_name() &amp;</code> syntax, this is called &#8220;ref-qualifiers&#8221; and you can find more info <a href="https://akrzemi1.wordpress.com/2014/06/02/ref-qualifiers/">on Andrzej Krzemieński&#8217;s blog</a>. If you&#8217;re not familiar with rvalue references (<code>T&amp;&amp;</code>) you can read up on move semantics <a href="https://stackoverflow.com/questions/3106110/what-is-move-semantics">on this Stack Overflow question</a>)</p>
<p>Note the near-identical implementations of four versions of the same function, only differentiated on whether they&#8217;re <code>const</code> and whether they move the stored value instead of copying it.</p>
<p>Barry and I would then move on to some other function and have to do the same thing. And again and again, over and over, duplicating code, making mistakes, building maintenance headaches for the future versions of ourselves. &#8220;What if&#8221;, we thought, &#8220;you could just write this?&#8221;</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct optional {
  // One version of value which works for everything
  template &lt;class Self&gt;
  constexpr auto&amp;&amp; value(this Self&amp;&amp; self) {
    if (self.has_value()) {
        return std::forward&lt;Self&gt;(self).m_value;
    }
    throw bad_optional_access();
  }</code></pre>
<p>(If you&#8217;re not familiar with <code>std::forward</code>, you can read about perfect forwarding <a href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c">on Eli Bendersky&#8217;s blog</a>)</p>
<p>This does the same thing as the above four overloads, but in a single function. Instead of writing different versions of <code>value</code> for <code>const optional&amp;</code>, <code>const optional&amp;&amp;</code>, <code>optional&amp;</code>, and <code>optional&amp;&amp;</code>, we write one function template which <em>deduces</em> the <code>const</code>/<code>volatile</code>/reference (cvref for short) qualifiers of the object the it is called on. Making this change for almost every function in the type would cut down our code by a huge amount.</p>
<p>So we wrote a version of what eventually got standardised, soon discovered that Gašper and Ben were working on a different paper for the exact same feature, we joined forces, and here we all are several years later.</p>
<h3 id="design">Design</h3>
<p>The key design principle we followed was that it should <em>do what you expect</em>. To achieve this, we touched as few places in the standard as we possibly could. Notably, we didn&#8217;t touch overload resolution rules or template deduction rules, and name resolution was only changed a little bit (as a treat).</p>
<p>As such, say we have a type like so:</p>
<pre><code class="language-cpp">struct cat {
    template &lt;class Self&gt;
    void lick_paw(this Self&amp;&amp; self);
};</code></pre>
<p>The template parameter <code>Self</code> will be deduced based on all of the same template deduction rules you&#8217;re already familiar with. There&#8217;s no additional magic. You don&#8217;t have to use the names <code>Self</code> and <code>self</code>, but I think they&#8217;re the clearest options, and this follows what several other programming languages do.</p>
<pre><code class="language-cpp">cat marshmallow;
marshmallow.lick_paw();                         //Self = cat&amp;

const cat marshmallow_but_stubborn;
marshmallow_but_stubborn.lick_paw();            //Self = const cat&amp;

std::move(marshmallow).lick_paw();              //Self = cat
std::move(marshmallow_but_stubborn).lick_paw(); //Self = const cat</code></pre>
<p>One name resolution change is that inside such a member function, you are not allowed to explicitly or implicitly refer to <code>this</code>.</p>
<pre><code class="language-cpp">struct cat {
    std::string name;

    void print_name(this const cat&amp; self) {
        std::cout &lt;&lt; name;       //invalid
        std::cout &lt;&lt; this-&gt;name; //also invalid
        std::cout &lt;&lt; self.name;  //all good
    }
};</code></pre>
<h2 id="use-cases">Use Cases</h2>
<p>For the rest of this post, we&#8217;ll look at all the different uses of this feature (at least the ones discovered so far that I know of!) Many of these examples were taken straight from the paper.</p>
<h3 id="de-duplication-quadruplication">De-duplication/quadruplication</h3>
<p>We&#8217;ve already seen how the feature can be applied to a type such as <code>optional</code> to avoid having to write four overloads of the same function.</p>
<p>Note also that this lowers the burden on initial implementation and maintenance of dealing with rvalue member functions. Quite often developers will write only <code>const</code> and non-<code>const</code> overloads for member functions, since in many cases we don&#8217;t really want to write another two whole functions just to deal with rvalues. With deduced qualifiers on <code>this</code>, we get the rvalue versions for free: we just need to write <code>std::forward</code> in the right places to get the runtime performance gains which come with avoiding unnecessary copies:</p>
<pre><code class="language-cpp">class cat {
    toy held_toy_;

public:
    //Before explicit object parameters
    toy&amp; get_held_toy() { return held_toy_; }
    const toy&amp; get_held_toy() const { return held_toy_; }

    //After
    template &lt;class Self&gt;
    auto&amp;&amp; get_held_toy(this Self&amp;&amp; self) {
        return self.held_toy_;
    }

    //After + forwarding
    template &lt;class Self&gt;
    auto&amp;&amp; get_held_toy(this Self&amp;&amp; self) {
        return std::forward&lt;Self&gt;(self).held_toy_;
    }
};</code></pre>
<p>Of course for a simple getter like this, whether or not this change is worth it for your specific use case is up to you. But for more complex functions, or cases where you are dealing with large objects which you want to avoid copying, explicit object parameters make this much easier to handle.</p>
<h3 id="crtp">CRTP</h3>
<p>The Curiously Recurring Template Pattern (CRTP) is a form of compile-time polymorphism which allows you to extend types with common pieces of functionality without paying the runtime costs of virtual functions. This is sometimes referred to as <em>mixins</em> (this isn&#8217;t <em>all</em> the CRTP can be used for, but it is the most common use). For example, we could write a type <code>add_postfix_increment</code> which can be mixed in to another type in order to define postfix increment in terms of prefix increment:</p>
<pre><code class="language-cpp">template &lt;typename Derived&gt;
struct add_postfix_increment {
    Derived operator++(int) {
        auto&amp; self = static_cast&lt;Derived&amp;&gt;(*this);

        Derived tmp(self);
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment&lt;some_type&gt; {
    // Prefix increment, which the postfix one is implemented in terms of
    some_type&amp; operator++();
};</code></pre>
<p>Templating a base class on its derived cast and <code>static_cast</code>ing <code>this</code> inside the function can be a bit arcane, and the problem gets worse when you have multiple levels of CRTP. With explicit object parameters, since we didn&#8217;t change template deduction rules, <em>the type of the explicit object parameter can be deduced to a derived type</em>. More concretely:</p>
<pre><code class="language-cpp">struct base {
    template &lt;class Self&gt;
    void f(this Self&amp;&amp; self);
};

struct derived : base {};

int main() {
    derived my_derived;
    my_derived.f();
}</code></pre>
<p>In the call <code>my_derived.f()</code>, the type of <code>Self</code> inside <code>f</code> is <code>derived&amp;</code>, <em>not</em> <code>base&amp;</code>.</p>
<p>This means that we can define the above CRTP example like so:</p>
<pre><code class="language-cpp">struct add_postfix_increment {
    template &lt;typename Self&gt;
    auto operator++(this Self&amp;&amp; self, int) {
        auto tmp = self;
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment {
    // Prefix increment, which the postfix one is implemented in terms of
    some_type&amp; operator++();
};</code></pre>
<p>Note that now <code>add_postfix_increment</code> is not a template. Instead, we&#8217;ve moved the customisation to the postfix <code>operator++</code>. This means we don&#8217;t need to pass <code>some_type</code> as a template argument anywhere: everything &#8220;just works&#8221;.</p>
<h3 id="forwarding-out-of-lambdas">Forwarding out of lambdas</h3>
<p>Copying captured values out of a closure is simple: we can just pass around the object as usual. Moving captured values out of a closure is also simple: we can just call <code>std::move</code> on it. A problem occurs when we need to perfect-forward a captured value based on whether the closure is an lvalue or rvalue.</p>
<p>One use case I stole from <a href="https://wg21.link/p2445">P2445</a> is for lambdas which can be used in both &#8220;retry&#8221; and &#8220;try or fail&#8221; contexts:</p>
<pre><code class="language-cpp">auto callback = [m=get_message(), &amp;scheduler]() -&gt; bool {
    return scheduler.submit(m);
};
callback(); // retry(callback)
std::move(callback)(); // try-or-fail(rvalue)</code></pre>
<p>The question here is: how do we forward <code>m</code> based on the value category of the closure? Explicit object parameters give us the answer. Since a lambda generates a class with an <code>operator()</code> member function of the given signature, all the machinary I&#8217;ve just explained works for lambdas too.</p>
<pre><code class="language-cpp">auto closure = [](this auto&amp;&amp; self) {
    //can use self inside the lambda
};</code></pre>
<p>This means we can perfect-forward based on the value category of the closure inside the lambda. P2445 gives a <code>std::forward_like</code> helper, which forwards some expression based on the value category of another:</p>
<pre><code class="language-cpp">auto callback = [m=get_message(), &amp;scheduler](this auto &amp;&amp;self) -&gt; bool {
    return scheduler.submit(std::forward_like&lt;decltype(self)&gt;(m));
};</code></pre>
<p>Now our original use case works, and the captured object will be copied or moved depending on how we use the closure.</p>
<h3 id="recursive-lambdas">Recursive lambdas</h3>
<p>Since we now have the ability to name the closure object in a lambda&#8217;s parameter list, this allows us to do recursive lambdas! As above:</p>
<pre><code class="language-cpp">auto closure = [](this auto&amp;&amp; self) {
    self(); //just call ourself until the stack overflows
};</code></pre>
<p>There are more useful uses for this than just overflowing stacks, though. Consider, for example, the ability to do visitation of recursive data structures without having to define additional types or functions? Given the following definition of a binary tree:</p>
<pre><code class="language-cpp">struct Leaf { };
struct Node;
using Tree = std::variant&lt;Leaf, Node*&gt;;
struct Node {
    Tree left;
    Tree right;
};</code></pre>
<p>We can count the number of leaves like so:</p>
<pre><code class="language-cpp">int num_leaves(Tree const&amp; tree) {
    return std::visit(overload( //see below
        [](Leaf const&amp;) { return 1; },                       
        [](this auto const&amp; self, Node* n) -&gt; int {              
            return std::visit(self, n-&gt;left) + std::visit(self, n-&gt;right); 
        }
    ), tree);
}</code></pre>
<p><code>overload</code> here is some facility to create an overload set from multiple lambdas, and is commonly used for <code>variant</code> visitation. See <a href="https://en.cppreference.com/w/cpp/utility/variant/visit">cppreference</a>, for example.</p>
<p>This counts the number of leaves in the tree through recursion. For each function call in the call graph, if the current is a <code>Leaf</code>, it returns <code>1</code>. Otherwise, the overloaded closure calls itself through <code>self</code> and recurses, adding together the leaf counts for the left and right subtrees.</p>
<h3 id="pass-this-by-value">Pass <code>this</code> by value</h3>
<p>Since we can define the qualifiers of the now-explicit object parameter, we can choose to take it by value rather than by reference. For small objects, this can give us better runtime performance. In case you&#8217;re not familiar with how this affects code generation, here&#8217;s an example.</p>
<p>Say we have this code, using regular old implicit object parameters:</p>
<pre><code class="language-cpp">struct just_a_little_guy {
    int how_smol;
    int uwu();
};

int main() {
    just_a_little_guy tiny_tim{42};
    return tiny_tim.uwu();
}</code></pre>
<p>MSVC generates the following assembly:</p>
<pre><code class="language-asm">sub     rsp, 40                           
lea     rcx, QWORD PTR tiny_tim$[rsp]
mov     DWORD PTR tiny_tim$[rsp], 42     
call    int just_a_little_guy::uwu(void)  
add     rsp, 40                            
ret     0</code></pre>
<p>I&#8217;ll walk through this line-by-line.</p>
<ul>
<li><code>sub rsp, 40</code> allocates 40 bytes on the stack. This is 4 bytes to hold the <code>int</code> member of <code>tiny_tim</code>, 32 bytes of <a href="https://stackoverflow.com/questions/30190132/what-is-the-shadow-space-in-x64-assembly"><em>shadow space</em> </a>for <code>uwu</code> to use, and 4 bytes of padding.</li>
<li>The <code>lea</code> instruction loads the address of the <code>tiny_tim</code> variable into the <code>rcx</code> register, which is where <code>uwu</code> is expecting the implicit object parameter (due to the <a href="https://docs.microsoft.com/cpp/build/x64-calling-convention?view=msvc-170">calling conventions</a> used).</li>
<li>The <code>mov</code> stores <code>42</code> into the <code>int</code> member of <code>tiny_tim</code>.</li>
<li>We then call the <code>uwu</code> function.</li>
<li>Finally we de-allocate the space we allocated on the stack before and return.</li>
</ul>
<p>What happens if we instead specify <code>uwu</code> to take its object parameter by value, like this?</p>
<pre><code class="language-cpp">struct just_a_little_guy {
    int how_smol;
    int uwu(this just_a_little_guy);
};</code></pre>
<p>In that case, the following code is generated:</p>
<pre><code class="language-asm">mov     ecx, 42                           
jmp     static int just_a_little_guy::uwu(this just_a_little_guy) </code></pre>
<p>We just move <code>42</code> into the relevant register and jump (<code>jmp</code>) to the <code>uwu</code> function. Since we&#8217;re not passing by-reference we don&#8217;t need to allocate anything on the stack. Since we&#8217;re not allocating on the stack we don&#8217;t need to de-allocate at the end of the function. Since we don&#8217;t need to deallocate at the end of the function we can just jump straight to <code>uwu</code> rather than jumping there and then back into this function when it returns, using <code>call</code>.</p>
<p>These are the kinds of optimisations which can prevent &#8220;death by a thousand cuts&#8221; where you take small performance hits over and over and over, resulting in slower runtimes that are hard to find the root cause of.</p>
<h3 id="sfinae-unfriendly-callables">SFINAE-unfriendly callables</h3>
<p>This issue is a bit more esoteric, but does actually happen in real code (I know because I got a bug report on my extended implementation of <code>std::optional</code> which hit this exact issue in production). Given a member function of <code>optional</code> called <code>transform</code>, which calls the given function on the stored value only if there is one, the problem looks like this:</p>
<pre><code class="language-cpp">struct oh_no {
    void non_const();
};

tl::optional&lt;oh_no&gt; o;
o.transform([](auto&amp;&amp; x) { x.non_const(); }); //does not compile</code></pre>
<p>The error which MSVC gives for this looks like:</p>
<blockquote><p>error C2662: &#8216;void oh_no::non_const(void)&#8217;: cannot convert &#8216;this&#8217; pointer from &#8216;const oh_no&#8217; to &#8216;oh_no &amp;&#8217;</p></blockquote>
<p>So it&#8217;s trying to pass a <code>const oh_no</code> as the implicit object parameter to <code>non_const</code>, which doesn&#8217;t work. But where did that <code>const oh_no</code> come from? The answer is inside the implementation of <code>optional</code> itself. Here is a deliberately stripped-down version:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct optional {
    T t;

    template &lt;class F&gt;
    auto transform(F&amp;&amp; f) -&gt; std::invoke_result_t&lt;F&amp;&amp;, T&amp;&gt;;

    template &lt;class F&gt;
    auto transform(F&amp;&amp; f) const -&gt; std::invoke_result_t&lt;F&amp;&amp;, const T&amp;&amp;&gt;;
};</code></pre>
<p>Those <code>std::invoke_result_t</code>s are there to make <code>transform</code> <a href="https://stackoverflow.com/questions/35033306/what-does-it-mean-when-one-says-something-is-sfinae-friendly">SFINAE-friendly</a>. This basically means that you can check whether a call to <code>transform</code> would compile and, if it wouldn&#8217;t, do something else instead of just aborting the entire compilation. However, there&#8217;s a bit of a hole in the language here.</p>
<p>When doing overload resolution on <code>transform</code>, the compiler has to work out which of those two overloads is the best match given the types of the arguments. In order to do so, it has to instantiate the declarations of both the <code>const</code> and non-<code>const</code> overloads. If you pass an invocable to <code>transform</code> which is not <em>itself</em> SFINAE-friendly, and isn&#8217;t valid for a <code>const</code> qualified implicit object (which is the case with my example) then instantiating the declaration of the <code>const</code> member function will be a hard compiler error. Oof.</p>
<p>Explicit object parameters allow you to solve this problem because the cvref qualifiers are <em>deduced</em> from the expression you call the member function on: if you never call the function on a <code>const optional</code> then the compiler never has to try and instantiate that declaration. Given <code>std::copy_cvref_t</code> from <a href="https://wg21.link/p1450">P1450</a>:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct optional {
    T t;

    template &lt;class Self, class F&gt;
    auto transform(this Self&amp;&amp; self, F&amp;&amp; f) 
    -&gt; std::invoke_result_t&lt;F&amp;&amp;, std::copy_cvref_t&lt;Self, T&gt;&gt;;
};</code></pre>
<p>This allows the above example to compile while still allowing <code>transform</code> to be SFINAE-friendly.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this has helped clarify the function and utility of explicit object parameters. You can try out the feature in <a href="https://visualstudio.microsoft.com/vs/features/cplusplus/">Visual Studio version 17.2</a>. If you have any questions, comments, or issues with the feature, you can comment below, or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23&#8217;s Deducing this: what it is, why it is, how to use it</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg June 2022 Release is Now Available: Force Download vcpkg Dependencies, Documentation Changes, and More</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 22 Jun 2022 01:29:22 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30681</guid>

					<description><![CDATA[<p>The June 2022 release of the vcpkg package manager is available. This includes a hotfix that fixed a regression in the binary caching experience. This blog post summarizes changes from May 11th, 2022 to June 15th, 2022 for the microsoft/vcpkg and microsoft/vcpkg-tool GitHub repos.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/">vcpkg June 2022 Release is Now Available: Force Download vcpkg Dependencies, Documentation Changes, and More</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.06.16.1">June 2022 release of the vcpkg package manager is available</a>. This includes a hotfix that fixed a regression in the binary caching experience. This blog post summarizes changes from May 11<sup>th</sup>, 2022 to June 15<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.04.12">microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/pull/441">microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>In the past month, the <a href="https://isocpp.org/blog/2022/06/results-summary-2022-annual-cpp-developer-survey-lite">ISO C++ 2022 Annual Developer Survey results</a> were released. We want to thank the C++ community for taking the time to provide feedback on vcpkg in the survey. This year, 19% (+4% year over year) of respondents indicated they were using vcpkg. We hope to see more and more of the community adopting package managers in their workflows going forward.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>20 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>292 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,956 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are <strong>10,016 port versions </strong>(new milestone!).</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.06.16.1">June release of the main vcpkg repo</a> includes <strong>247 commits</strong>.</li>
<li><strong>93 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.6k forks</strong> and <strong>15.9k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<h4 id="force-vcpkg-to-download-binary-dependencies-rather-than-use-system-ones">Force vcpkg to download binary dependencies rather than use system ones</h4>
<p>The vcpkg tool depends on several tools to do its work, including ninja and CMake. From the beginning, vcpkg has been able to download copies of these tools automatically does so by default if the tools are not detected on the system at an appropriate version. The downside of this is that in some cases, vcpkg may assume that an incompatible system version of a tool is valid and attempt to use it, only to fail.</p>
<p>In this release, we merged a PR from a community contributor that adds support for an environment variable called VCPKG_FORCE_DOWNLOADED_BINARIES. If this variable is set, vcpkg will ignore any existing system binaries and always download its own copies of the tools it depends on. This results in a more self-contained vcpkg that will reliably run across many machines with different OS flavors and system packages. This behavior is off by default however, so please set this variable if this is a scenario that interests you. Note: this environment variable is effectively the opposite of VCPKG_FORCE_SYSTEM_BINARIES, which always forces the use of system binaries.</p>
<p>PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/138">Microsoft/vcpkg-tool#138</a>, <a href="https://github.com/microsoft/vcpkg/pull/24674">Microsoft/vcpkg#24674</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/536">Microsoft/vcpkg-tool#536</a> (thank you @<a href="https://github.com/christophe-calmejane">christophe-calmejane</a>!)</p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation changes</h4>
<p>We are revamping our documentation based on user feedback. Here is a summary of changes made in this release:</p>
<ul>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/install.md">New documentation article for the vcpkg install command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/integrate.md">New documentation article for the vcpkg integrate command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/search.md">New documentation article for the vcpkg search command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/common-options.md">New documentation article for Common Command Options</a>. This provides a reference for different options available for vcpkg commands run in the command line.</li>
<li>New documentation in <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/config-environment.md">Environment and Configuration</a> on the new environment variable: VCPKG_FORCE_DOWNLOADED_BINARIES.</li>
<li>Split content on <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/cmake-integration.md">CMake</a>, <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/msbuild-integration.md">MSBuild</a>, <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/manual-integration.md">manual integration</a>, and the <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/buildsystems/export-command.md">export command</a> into separate documentation articles.</li>
<li>Added documentation describing criteria for vcpkg releases.</li>
<li>Wording changes, fixed links, and other improvements for several other articles.</li>
</ul>
<p>This is just the start of what will hopefully be a much longer list of changes over the coming months. We will continue to improve our documentation with each release.</p>
<p>PRs: <a href="https://github.com/microsoft/vcpkg/pull/24764">Microsoft/vcpkg#24764</a>, <a href="https://github.com/microsoft/vcpkg/pull/24756">Microsoft/vcpkg#24756</a>, <a href="https://github.com/microsoft/vcpkg/pull/24755">Microsoft/vcpkg#24755</a>, <a href="https://github.com/microsoft/vcpkg/pull/24754">Microsoft/vcpkg#24754</a>, <a href="https://github.com/microsoft/vcpkg/pull/24737">Microsoft/vcpkg#24737</a>, <a href="https://github.com/microsoft/vcpkg/pull/24649">Microsoft/vcpkg#24649</a>, <a href="https://github.com/microsoft/vcpkg/pull/24647">Microsoft/vcpkg#24647</a>, <a href="https://github.com/microsoft/vcpkg/pull/24456">Microsoft/vcpkg#24456</a></p>
<p>&nbsp;</p>
<h4 id="helper-port-for-less-common-build-systems">Helper port for less common build systems</h4>
<p>Through a community contribution by <a href="https://github.com/Neumann-A">Neumann-A</a>, the helper function vcpkg-cmake-get-vars was moved to its own port so it can be independently maintained and versioned. For context, this helper extracts compiler flags and paths to the compiler and linker so the user can build the port. If you are contributing or changing a port that uses a build system that we <a href="https://vcpkg.io/en/docs/maintainers/portfile-functions.html">do not already have a helper for</a>, this new port is for you.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/24636">Microsoft/vcpkg#24636</a> (thanks <a href="https://github.com/Neumann-A">@Neumann-A</a>!)</p>
<p>&nbsp;</p>
<h4 id="fixed-vcpkg-commands-failing-when-a-custom-port-is-installed">Fixed vcpkg commands failing when a custom port is installed</h4>
<p>Power users of vcpkg may be familiar with overlay ports, a feature that makes it possible to override ports with alternate versions. Users modifying the behavior of vcpkg itself may also be accustomed to switching between different branches in their fork of the vcpkg repo. Due to a bug, if you installed an overlay port or branch switched out of a branch with currently installed ports, then attempted to run a vcpkg command again (e.g. install or remove), vcpkg would throw an error, expecting the data about the custom-installed ports to be available despite the fact that it is no longer relevant to the new operation. Thanks to a community contribution, now when you run a command in this context, vcpkg will no longer fail.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/516">Microsoft/vcpkg-tool#516</a> (thanks <a href="https://github.com/Neumann-A">@Neumann-A</a>!)</p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,761</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,810</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,706</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,725</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>928</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,341</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>875</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,671</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,744</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is routinely tested to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>Thomas1664 (13 commits)</li>
<li>Neumann-A (10 commits)</li>
<li>autoantwort (10 commits)</li>
<li>dg0yt (10 commits)</li>
<li>Ryan-rsm-McKenzie (5 commits)</li>
<li>DragonJoker (5 commits)</li>
<li>m-kuhn (3 commits)</li>
<li>Hoikas (3 commits)</li>
<li>RT222 (3 commits)</li>
<li>myd7349 (2 commits)</li>
<li>winsoft666 (2 commits)</li>
<li>hmoffatt (2 commits)</li>
<li>AenBleidd (2 commits)</li>
<li>daschuer (1 commit)</li>
<li>eao197 (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>danielaparker (1 commit)</li>
<li>coryan (1 commit)</li>
<li>longhuan2018 (1 commit)</li>
<li>luncliff (1 commit)</li>
<li>klalumiere (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.06.15">full June release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/">vcpkg June 2022 Release is Now Available: Force Download vcpkg Dependencies, Documentation Changes, and More</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-june-2022-release-is-now-available-force-download-vcpkg-dependencies-documentation-changes-and-more/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What&#8217;s New in CMake for VS Code</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-cmake-for-vs-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-cmake-for-vs-code/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Wed, 15 Jun 2022 15:52:57 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30616</guid>

					<description><![CDATA[<p>The latest version of CMake tools is now available for download in the VS Code Marketplace or using the .vsix file. We have been working hard on improving the CMake experience and are excited to share some new features and improvements for users starting in version 1.11. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-in-cmake-for-vs-code/">What&#8217;s New in CMake for VS Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">The latest version of CMake tools is now <a href="https://github.com/microsoft/vscode-cmake-tools/releases/tag/v1.11.26">available for download</a> in the VS Code Marketplace or using the .vsix file. We have been working hard on improving the CMake experience and are excited to share some new features and improvements for users starting in version 1.11.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="cmake-task-provider-updates"><b><span data-contrast="auto">‘CMake’ task provider updates</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><span data-contrast="auto">We have added more options to the build task and more commands for the “cmake” task type so you don’t have to manually type up shell tasks. Tasks make it easier to automate your workflows. With our new task provider commands, you can easily create workflows that include configuration, build, install, test, clean, and clean rebuild tasks.  </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h5 id="selecting-targets-now-supported"><em>Selecting targets now supported</em></h5>
<p><span class="TextRun SCXW141363534 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW141363534 BCX8">Now, in your build task, users can specify </span><span class="NormalTextRun SCXW141363534 BCX8">multiple </span><span class="NormalTextRun SCXW141363534 BCX8">targets</span></span> <span class="TextRun SCXW141363534 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW141363534 BCX8">and it is included as a parameter in the task template.</span> <span class="NormalTextRun CommentStart SCXW141363534 BCX8">Before, this was a single active target selected in the status bar</span><span class="NormalTextRun SCXW141363534 BCX8">.</span><span class="NormalTextRun SCXW141363534 BCX8"> Now, you can select any target independent of the state of the extension. An example of a build task to target multiple targets (</span><span class="NormalTextRun CommentStart CommentHighlightPipeRest CommentHighlightRest SCXW141363534 BCX8">“main” and “sum</span></span><span class="TrackChangeTextInsertion TrackedChange SCXW141363534 BCX8"><span class="TextRun SCXW141363534 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentHighlightRest SCXW141363534 BCX8">”</span></span></span><span class="TextRun SCXW141363534 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentHighlightPipeRest SCXW141363534 BCX8">) using this feature is seen below. </span></span><span class="EOP SCXW141363534 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130429.png"><img class="alignnone size-full wp-image-30659" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130429.png" alt="Example CMake build task with multiple targets" width="831" height="475" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130429.png 831w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130429-300x171.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130429-768x439.png 768w" sizes="(max-width: 831px) 100vw, 831px" /></a></p>
<h5 id="new-cmake-tasks-supported"><em>New CMake tasks supported</em></h5>
<p><span class="TextRun SCXW197317236 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW197317236 BCX8">To run and configure tasks, press </span><code><span class="NormalTextRun CommentStart CommentHighlightPipeClicked CommentHighlightClicked SCXW197317236 BCX8">Ctrl</span><span class="NormalTextRun CommentHighlightPipeRest CommentHighlightClicked SCXW197317236 BCX8">+Shift+P</span></code><span class="NormalTextRun CommentHighlightPipeClicked SCXW197317236 BCX8"> to pull up the Command Palette</span><span class="NormalTextRun SCXW197317236 BCX8"> and select the </span><span class="NormalTextRun SCXW197317236 BCX8">appropriate option</span><span class="NormalTextRun SCXW197317236 BCX8"> for your tasks. </span></span><span class="EOP SCXW197317236 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130904.png"><img class="alignnone size-full wp-image-30660" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130904.png" alt="Command Palette drop-down with CMake tasks selected" width="895" height="489" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130904.png 895w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130904-300x164.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-130904-768x420.png 768w" sizes="(max-width: 895px) 100vw, 895px" /></a></p>
<p><span class="TextRun SCXW193002484 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW193002484 BCX8">To create a new task, first select “Configure Task” from the dropdown. This will populate the view below in a C++ project. </span></span><span class="EOP SCXW193002484 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-131342.png"><img class="alignnone size-full wp-image-30662" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-131342.png" alt="CMake tasks that the user can select to configure" width="862" height="564" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-131342.png 862w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-131342-300x196.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-131342-768x502.png 768w" sizes="(max-width: 862px) 100vw, 862px" /></a></p>
<p><span class="TextRun SCXW134353995 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW134353995 BCX8">You can select the </span><span class="NormalTextRun SCXW134353995 BCX8">appropriate task</span><span class="NormalTextRun SCXW134353995 BCX8">, which will populate the task template in the </span><span class="NormalTextRun SpellingErrorV2Themed SCXW134353995 BCX8">tasks.json</span><span class="NormalTextRun SCXW134353995 BCX8"> file. </span></span><span class="EOP SCXW134353995 BCX8" data-ccp-props="{}"> <span data-ccp-props="{&quot;201341983&quot;:1,&quot;335559740&quot;:285}"><span class="TextRun SCXW209175148 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW209175148 BCX8">We recommend updating the &#8220;</span><span class="NormalTextRun CommentStart ContextualSpellingAndGrammarErrorV2Themed CommentHighlightPipeRest CommentHighlightRest SCXW209175148 BCX8">detail&#8221;</span> field in the JSON object for your CMake tasks <span class="NormalTextRun CommentHighlightPipeRest SCXW209175148 BCX8">so that you can differentiate the tasks from the drop-down</span></span><span class="TrackChangeTextInsertion TrackedChange SCXW209175148 BCX8"><span class="TextRun SCXW209175148 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW209175148 BCX8">.</span></span></span><span class="EOP SCXW209175148 BCX8" data-ccp-props="{}"> </span></span></span></p>
<p><span class="TextRun SCXW23532722 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW23532722 BCX8">Once the task is created, you can select this task to run using “Run Task</span><span class="NormalTextRun SCXW23532722 BCX8">” from the Command Palette</span><span class="NormalTextRun SCXW23532722 BCX8">,</span><span class="NormalTextRun SCXW23532722 BCX8"> which will run the shell commands for the created task.</span></span><span class="EOP SCXW23532722 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-133234.png"><img class="alignnone wp-image-30665 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-133234.png" alt="Example CMake tasks to select to run" width="937" height="469" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-133234.png 937w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-133234-300x150.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/Screenshot-2022-06-14-133234-768x384.png 768w" sizes="(max-width: 937px) 100vw, 937px" /></a></p>
<h4 id="coming-soon">Coming Soon</h4>
<p><span class="TextRun SCXW82567180 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW82567180 BCX8">We are working to add even more support for the ‘</span><span class="NormalTextRun SpellingErrorV2Themed SCXW82567180 BCX8">CMake</span><span class="NormalTextRun SCXW82567180 BCX8">’ task provider</span><span class="NormalTextRun CommentStart SCXW82567180 BCX8">, including adding </span><span class="NormalTextRun SCXW82567180 BCX8">“</span><span class="NormalTextRun SpellingErrorV2Themed SCXW82567180 BCX8">args</span><span class="NormalTextRun SCXW82567180 BCX8">”</span><span class="NormalTextRun CommentStart SCXW82567180 BCX8"> and </span><span class="NormalTextRun SCXW82567180 BCX8">“</span><span class="NormalTextRun SCXW82567180 BCX8">environment</span><span class="NormalTextRun SCXW82567180 BCX8">”</span><span class="NormalTextRun SCXW82567180 BCX8"> specification for your tasks</span><span class="NormalTextRun SCXW82567180 BCX8">.</span></span><span class="EOP SCXW82567180 BCX8" data-ccp-props="{}"> </span></p>
<h4 id="what-do-you-think">What do you think?</h4>
<p><span class="TextRun SCXW103334939 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW103334939 BCX8">Download the </span><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools"><span class="NormalTextRun SpellingErrorV2Themed CommentHighlightRest SCXW103334939 BCX8">CMake</span><span class="NormalTextRun CommentHighlightRest SCXW103334939 BCX8"> Tools extension</span> </a><span class="NormalTextRun CommentHighlightPipeRest SCXW103334939 BCX8">for Visual Studio Code</span><span class="NormalTextRun SCXW103334939 BCX8"> and let us know what you think. If you run into any issues or have any suggestions, please report them in the </span><a href="https://github.com/microsoft/vscode-cmake-tools/issues"><span class="NormalTextRun CommentStart CommentHighlightPipeRest CommentHighlightRest SCXW103334939 BCX8">Issues section of our GitHub repository</span></a><span class="NormalTextRun CommentHighlightPipeRest SCXW103334939 BCX8">. We would love to hear how you are using CMake tasks. Comment </span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW103334939 BCX8">below</span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW103334939 BCX8">, </span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW103334939 BCX8">or</span><span class="NormalTextRun SCXW103334939 BCX8"> reach us </span><span class="NormalTextRun SCXW103334939 BCX8">via</span><span class="NormalTextRun SCXW103334939 BCX8"> email at </span></span><a class="Hyperlink SCXW103334939 BCX8" href="mailto:visualcpp@microsoft.com" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW103334939 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW103334939 BCX8" data-ccp-charstyle="Hyperlink">visualcpp@microsoft.com</span></span></a><span class="TextRun SCXW103334939 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW103334939 BCX8"> or via </span><span class="NormalTextRun SCXW103334939 BCX8">Twitter at </span><a href="https://twitter.com/visualc"><span class="NormalTextRun CommentStart CommentHighlightPipeRest CommentHighlightRest SCXW103334939 BCX8">@VisualC</span></a><span class="NormalTextRun CommentHighlightPipeRest SCXW103334939 BCX8">.</span></span><span class="EOP SCXW103334939 BCX8" data-ccp-props="{}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-in-cmake-for-vs-code/">What&#8217;s New in CMake for VS Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-cmake-for-vs-code/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Serial and Zephyr support for Visual Studio and VS Code</title>
		<link>https://devblogs.microsoft.com/cppblog/serial-and-zephyr-support/</link>
					<comments>https://devblogs.microsoft.com/cppblog/serial-and-zephyr-support/#respond</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Tue, 07 Jun 2022 18:00:07 +0000</pubDate>
				<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30646</guid>

					<description><![CDATA[<p>We are continuing to improve our embedded development support in Visual Studio and VS Code. We have recently introduced a serial monitor and RTOS support for Zephyr. These capabilities are present in Visual Studio 17.3 Preview 1 as part of the Linux and embedded development workload.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/serial-and-zephyr-support/">Serial and Zephyr support for Visual Studio and VS Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are continuing to improve our embedded development support in <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Visual Studio</a> and <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">VS Code</a>. We have recently introduced a serial monitor and RTOS support for Zephyr. These capabilities are present in Visual Studio 17.3 Preview 1 as part of the Linux and embedded development workload. The Embedded Tools extension for VS Code also includes these capabilities, though the serial monitor is available as a stand-alone extension as well. This post illustrates these new capabilities in Visual Studio and VS Code.</p>
<h4 id="serial-monitor">Serial monitor</h4>
<p>To start the serial monitor in Visual Studio in the Debug &gt; Windows &gt; Serial Monitor.</p>
<p>To start the serial monitor in Visual Studio Code go to the command palate Ctrl + Shift + P  and enter “serial” then select Focus on Serial Monitor View.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vs-serialmonitor.png"><img class="alignnone size-full wp-image-30648" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vs-serialmonitor.png" alt="Visual Studio serial monitor screenshot" width="1753" height="478" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vs-serialmonitor.png 1753w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vs-serialmonitor-300x82.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vs-serialmonitor-1024x279.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vs-serialmonitor-768x209.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vs-serialmonitor-1536x419.png 1536w" sizes="(max-width: 1753px) 100vw, 1753px" /></a></p>
<p>The serial monitor enumerates the available ports in the Port dop down box. You can set the baud rate and line ending mode in their own drop down boxes. Select start monitoring to connect to the selected device.</p>
<p>There are toggle buttons to clear output, prefix time stamps to the output, and select whether the output scrolls or not.</p>
<p>There is a text box at the bottom of the monitor you can use to send message to the connected serial port.</p>
<p>When you are done you can select stop monitoring.</p>
<h4 id="zephyr">Zephyr</h4>
<p>We have added support to our RTOS objects view for Zephyr.</p>
<p>To start the RTOS objects views in Visual Studio, go to the menu Debug &gt; Windows &gt; RTOS Objects. In Visual Studio Code go to the command palate Ctrl + Shift + P  and enter “rtos” then select Focus on RTOS viewer view.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vscode-zephyr.png"><img class="alignnone size-full wp-image-30649" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vscode-zephyr.png" alt="Image vscode zephyr" width="624" height="150" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vscode-zephyr.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/vscode-zephyr-300x72.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>Our extension detects the type of RTOS you are using automatically, there is nothing to set to get the correct view across Azure RTOS, FreeRTOS, or Zephyr.</p>
<p>We do not have a prepared example using vcpkg for project activation, we used the <a href="https://docs.zephyrproject.org/latest/develop/getting_started/index.html">Zephyr projects instructions</a> to configure our environment. Note that there are some Zephyr projects which do not use threads, in those cases our RTOS viewer will not activate as there is nothing for it to display. You also need to ensure that your build includes the necessary debugging symbols, for example:</p>
<p>west build -p auto -b mimxrt1060_evk samples\basic\threads -DCONFIG_DEBUG_THREAD_INFO=y -DCONFIG_INIT_STACKS=y -DCONFIG_THREAD_STACK_INFO=y</p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio or VS Code for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/serial-and-zephyr-support/">Serial and Zephyr support for Visual Studio and VS Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/serial-and-zephyr-support/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC Backend Updates in Visual Studio 2022 version 17.2</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-2/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-2/#comments</comments>
		
		<dc:creator><![CDATA[Chris Pulido]]></dc:creator>
		<pubDate>Tue, 07 Jun 2022 16:00:37 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30628</guid>

					<description><![CDATA[<p>In Visual Studio 2022 version 17.2 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a list of improvements for you to review.</p>
<p>OpenMP: The task directive as defined by OpenMP 3.1 is supported for -openmp:llvm,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-2/">MSVC Backend Updates in Visual Studio 2022 version 17.2</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In <a href="https://visualstudio.microsoft.com/vs/">Visual Studio 2022</a> version 17.2 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a list of improvements for you to review.</p>
<ul>
<li>OpenMP: The <code>task</code> directive as defined by OpenMP 3.1 is supported for <code>-openmp:llvm</code>, including all the clauses. Note that the compiler does not yet support `task` clauses added in later versions of OpenMP. See more details in <a href="https://devblogs.microsoft.com/cppblog/openmp-task-support-for-c-in-visual-studio/">OpenMP Task Support for C++ in Visual Studio</a>.</li>
<li>Implemented Intel intrinsic functions for the AVX512-FP16 instruction set extension. More information about these functions can be found on the <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#avx512techs=AVX512_FP16">Intel Intrinsics Guide</a>.</li>
<li>Implemented Intel intrinsic functions <code>_castf32_u32</code>, <code>_castf64_u64</code>, <code>_castu32_f32</code>, and <code>_castu64_f64</code> to cast between floating point values and integer values without conversion on x64 and x86. More information about these functions can be found on the <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_cast&amp;techs=Other">Intel Intrinsics Guide</a>.</li>
<li>New ARM64 compiler flags: <code>/Zc:arm64-aliased-neon-types-</code> and <code>/Zc:arm64-aliased-neon-types</code>. When you pass <code>/Zc:arm64-aliased-neon-types-</code> to <code>cl.exe</code>, the compiler will treat NEON intrinsic types as distinct types for ARM64 as defined by the <a href="https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst#appendix-support-for-advanced-simd-extensions">Procedure Call Standard for the Arm 64-bit Architecture</a>, which is consistent with Clang and GCC. This flag is opt-in, so ARM64 NEON intrinsic code that compiled with previous versions of MSVC will still compile when you upgrade. <code>/Zc:arm64-aliased-neon-types</code> (without the minus sign at the end) is the default behavior.
<ul>
<li>For example, consider two function declarations, <code>void foo(float32x4_t)</code> and <code>void foo(int32x4_t)</code>. By default, MSVC considers these two the same declaration, and attempting to define them both would lead to a multiple definition error. With <code>/Zc:arm64-aliased-neon-types-</code>, MSVC will treat them as Clang and GCC would.</li>
</ul>
</li>
<li>New ARM64 compiler flags: <code>/arch:armv8.0</code> and <code>/arch:armv8.1</code>. These new flags allow the compiler to generate instructions that were introduced and required by the specified architecture extension. `/arch:armv8.0` is the current default behavior and is the same as if you didn’t specify it. In 17.2, <code>/arch:armv8.1</code> allows the <code>_Interlocked*</code> intrinsic functions to use the appropriate atomic instruction that was introduced with the ARMv8.1 extension, FEAT_LSE.</li>
<li>New and improved optimizations
<ul>
<li>The <a href="https://en.cppreference.com/w/c/numeric/math/log2">C standard library functions <code>log2</code> and <code>log2f</code></a> have been implemented as compiler intrinsic functions on x64 and ARM64. This allows the compiler to perform optimizations with <code>log2</code> and <code>log2f</code> under <code>/fp:fast</code> x64 and ARM64.</li>
<li>Improved auto-vectorizer loop recognition. The auto-vectorizer now recognizes the average pattern and more cases of decrementing induction variables.</li>
<li>More <a href="https://en.wikipedia.org/wiki/Peephole_optimization">peephole optimizations</a> for multiple targets.</li>
<li>Improved load/store pairing on ARM64.</li>
</ul>
</li>
<li>ARM64EC
<ul>
<li>Compiler flags incompatible with the <code>/arm64EC</code> flag are now rejected. This includes all CLR flags, <code>/Gy-</code>, and <code>/Gw-</code>.</li>
<li>Added the <code>/MACHINE:ARM64EC</code> flag to <code>link.exe</code>, and removed it from <code>lib.exe</code>. For <code>lib.exe</code>, you should specify <code>/MACHINE:ARM64X</code>.</li>
<li>When <code>/arm64EC</code> is passed to <code>cl.exe</code> and <code>cl.exe</code> also invokes <code>link.exe</code>, <code>/MACHINE:ARM64EC</code> will be passed by default to <code>link.exe</code>.</li>
</ul>
</li>
</ul>
<p>Do you want to experience the new improvements of the C++ backend? Please <a href="https://visualstudio.microsoft.com/vs/">download the latest Visual Studio 2022</a> and give it a try! Any feedback is welcome. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc">@VisualC</a>)</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-2/">MSVC Backend Updates in Visual Studio 2022 version 17.2</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-2/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg May 2022 Release: artifacts using JSON, COS and SPDX support, and more</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-may-2022-release-is-now-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-may-2022-release-is-now-available/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Tue, 17 May 2022 00:00:51 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30565</guid>

					<description><![CDATA[<p>The May 2022 release of the vcpkg package manager is available. This blog post summarizes changes from March 31st, 2022 to May 10th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>10 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-may-2022-release-is-now-available/">vcpkg May 2022 Release: artifacts using JSON, COS and SPDX support, and more</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.05.10">May 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from March 31<sup>st</sup>, 2022 to May 10<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg/">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>10 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>422 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,936 total libraries</strong> available in the vcpkg public registry.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.05.10">May release of the main vcpkg repo</a> includes <strong>238 commits</strong> by <strong>63 people</strong>.</li>
<li>The main vcpkg repo has <strong>4.5k forks</strong> and <strong>15.7k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<h4 id="vcpkg-artifacts-update">vcpkg Artifacts update</h4>
<p>This is our first significant update to vcpkg artifacts since we introduced them in December. The changes and additions are all on the artifact metadata used in populating catalogs of available artifacts. As such this section is mainly of interest to people working on preparing their own catalogs of artifacts.</p>
<p>The experience is still in preview and retains a focus on embedded developers, but will expand to C++ scenarios targeting Linux, macOS, and Windows soon.</p>
<h5 id="metadata-format-changes">Metadata format changes</h5>
<p>Based on our experiences in expanding the available artifacts in registries we encountered the need to describe more in the registry metadata and realized some of the existing capabilities could be better named.</p>
<p>You will observe all the examples below are in json. When first released, vcpkg artifact catalogs could be created as either yaml or json and our examples were in yaml. Going forward we are normalizing to use json only.</p>
<p>The current “settings” has been renamed “exports” as that is functionally what it is doing. Similarly, the “variables” block has been renamed “environment” as it is setting environment variables.</p>
<p>There are a few additions as well, all to the exports block:</p>
<ul>
<li>contents: categorized files/contents, documentation, etc.</li>
<li>aliases: named commands for use by the consumer or Visual Studio / Visual Studio Code integration</li>
</ul>
<p>We also found the need to be able to support value expansion within demand blocks based on activation.</p>
<p>The examples in the sections below are snippets, see the default <a href="https://github.com/microsoft/vcpkg-ce-catalog">vcpkg artifact registry</a> for complete entries.</p>
<h5 id="settings-to-exports">Settings to exports</h5>
<p>We had a “settings” block that was part of the “demands” block. This block is now named “exports” as it better describes what this block does as it is exporting the configuration into the environment.</p>
<pre class="prettyprint">"demands": {
    "exports": {
        "tools": {
            "cmake": "bin/cmake",
            "cmake_gui": "bin/cmake-gui",
            "ctest": "bin/ctest"
        },
        "paths": {
            "path": "bin"
        }
    }
}</pre>
<h5 id="variables-to-environment">Variables to environment</h5>
<p>There was a variables block used to store the environment variables that are exported from the artifact. “Variables” is not as clear as it could be, as such the name has been changed to “environment” to better convey what this section does. The environment block is part of the exports block.</p>
<pre class="prettyprint">"exports": {
  "environment": {
      "CLFAGS": "-Wall -Wextra -Werror"
  }
}</pre>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/473">Microsoft/vcpkg-tool#473</a></p>
<p>&nbsp;</p>
<h4 id="added-cloud-object-storage-support-for-binary-caching">Added Cloud Object Storage support for binary caching</h4>
<p>Cloud Object Storage (COS) is a distributed storage service from Tencent Cloud accessible via HTTP/HTTPS. A recent community PR enables vcpkg users to use COS for binary caching. <a href="https://vcpkg.io/en/docs/users/binarycaching.html">Binary caching</a> saves copies of library binaries in a shared location that can be accessed by vcpkg for future fast installs, potentially across multiple development environments locally and in CI.</p>
<p>PRs: <a href="https://github.com/microsoft/vcpkg/pull/23538">Microsoft/vcpkg#23538</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/476">Microsoft/vcpkg-tool#476</a> (thank you <a href="https://github.com/day253">@day253</a>!)</p>
<p>&nbsp;</p>
<h4 id="added-software-package-data-exchange-spdx-v2-2-1-support">Added Software Package Data Exchange (SPDX) v2.2.1 support</h4>
<p>Software Package Data Exchange (SPDX) establishes a standard for software bill of materials (SBOM). It allows the expression of components, licenses, copyrights, security references and other metadata relating to software (<a href="https://en.wikipedia.org/wiki/Software_Package_Data_Exchange">Source: Wikipedia</a>). In this release, <em>experimental</em> support was added for the latest SPDX standard to vcpkg which makes it possible to easily track all dependencies that vcpkg installs on your system. This is very important for organizations with security compliance needs, including US-based organizations selling software to the United States government. While vcpkg needs to support SPDX for our own internal compliance needs, this can also be leveraged by vcpkg users shipping their own software. We are still working on this experience, but the prototype is in this tool release.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/296">Microsoft/vcpkg-tool#296</a></p>
<p>&nbsp;</p>
<h4 id="warn-on-classic-mode-build-failure-if-version-constraints-werent-met">Warn on classic mode build failure if version constraints weren’t met</h4>
<p>Tracking has been added for version constraints in vcpkg classic mode. Classic mode is when you specify ports to install in the command line via vcpkg install &lt;PORT&gt;, rather than installing via a manifest. The version constraints are displayed to the user in case of a build failure. While it is by design that classic mode does not force users to rebuild dependencies that are out-of-date, knowing the version constraints is a big help for debugging. This display appears for install commands only.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/494">Microsoft/vcpkg-tool#494</a></p>
<p>&nbsp;</p>
<h4 id="improved-console-output-for-port-operations">Improved console output for port operations</h4>
<p>Cleaned up console output when vcpkg is installing, modifying, or removing ports. New behavior also publishes additional test results to improve diagnostics. We’ve gotten a lot of user feedback that vcpkg is more verbose than people feel is productive – this is just one step toward a more concise vcpkg!</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/437">Microsoft/vcpkg-tool#437</a></p>
<p>&nbsp;</p>
<h4 id="secrets-are-stripped-from-curl-errors-before-printing-them">Secrets are stripped from curl errors before printing them</h4>
<p>For security reasons, secrets listed in curl errors (e.g. x-azblob SAS) are no longer displayed when the errors are printed in vcpkg output in the console window.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/499">Microsoft/vcpkg-tool#499</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,744</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,793</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,689</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,705</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>925</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,327</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>874</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,649</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,724</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is routinely tested to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos between March 31 – May 10, 2022:</p>
<ul>
<li>Thomas1664 (36 commits)</li>
<li>chausner (33 commits)</li>
<li>autoantwort (23 commits)</li>
<li>dg0yt (18 commits)</li>
<li>Neumann-A (11 commits)</li>
<li>RT222 (7 commits)</li>
<li>daschuer (4 commits)</li>
<li>Pospelove (4 commits)</li>
<li>coryan (3 commits)</li>
<li>ZeeWanderer (2 commits)</li>
<li>mathisloge (2 commits)</li>
<li>cenit (2 commits)</li>
<li>AenBleidd (2 commits)</li>
<li>day253 (2 commits)</li>
<li>Ryan-rsm-McKenzie (1 commit)</li>
<li>evpobr (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>luncliff (1 commit)</li>
<li>wrobelda (1 commit)</li>
<li>wravery (1 commit)</li>
<li>horenmar (1 commit)</li>
<li>podsvirov (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.05.10">full May release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-may-2022-release-is-now-available/">vcpkg May 2022 Release: artifacts using JSON, COS and SPDX support, and more</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-may-2022-release-is-now-available/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Pure Virtual C++ 2022 Recordings Available</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-videos-available/</link>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Fri, 13 May 2022 13:56:14 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30554</guid>

					<description><![CDATA[<p>Pure Virtual C++, a free one-day virtual conference for the whole C++ community, ran on 26th April 2022. All sessions are now available to watch online.<br />
Live sessions:</p>
<p>What’s New in C++23 – Sy Brand<br />
Cute C++ Tricks, Part 2 of N: More code you should learn from and never write – Daisy Hollman<br />
Embedded Development with VS and VS Code – Marc Goodner<br />
Everything I learned about static analysis and program safety in C++ – Sunny Chatterjee<br />
Persistent Representation of C++ for Fun and Profit – Gabriel Dos Reis</p>
<p>Pre-conference sessions:</p>
<p>MSVC C++20/23 update – Stephan T.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-videos-available/">Pure Virtual C++ 2022 Recordings Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png"><img class="aligncenter size-large wp-image-27841" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png" alt="Pure Virtual C++ logo" width="640" height="168" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<p>Pure Virtual C++, a free one-day virtual conference for the whole C++ community, ran on 26th April 2022. All sessions are now available to watch online.</p>
<p>Live sessions:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/whats-new-in-cpp23">What’s New in C++23</a> – Sy Brand</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/cute-cpp-tricks-part-2-of-n-more-code-you-should-learn-from-and-never-write">Cute C++ Tricks, Part 2 of N: More code you should learn from and never write</a> – Daisy Hollman</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/embedded-development-with-vs-and-vs-code">Embedded Development with VS and VS Code</a> – Marc Goodner</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/everything-i-learned-about-static-analysis-and-program-safety-in-cpp">Everything I learned about static analysis and program safety in C++</a> – Sunny Chatterjee</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/persistent-representation-of-cpp-for-fun-and-profit">Persistent Representation of C++ for Fun and Profit</a> – Gabriel Dos Reis</li>
</ul>
<p>Pre-conference sessions:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/msvc-cpp-20-23-update/">MSVC C++20/23 update</a> – Stephan T. Lavavej</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/indexed-find-in-files">Indexed Find in Files</a> – Christian Gunderman</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/dependent-breakpoints/">Dependent Breakpoints</a> – Sy Brand</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/stay-calm-and-stress-free-by-using-a-package-manager-an-overview-of-vcpkg/">Stay calm and stress-free by using a package manager: an overview of vcpkg</a> – Augustin Popa</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/targeting-macos-from-visual-studio/">Targeting macOS from Visual Studio</a> – Sinem Akinci</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/data-breakpoints-in-visual-studio-code/">Data Breakpoints in Visual Studio Code</a> – Julia Reid</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/hot-reload-for-cpp/">Hot Reload for C++</a> – David Li</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/productivity-in-visual-studio/">Productivity in Visual Studio</a> – Kyle Reed</li>
<li><a href="https://docs.microsoft.com/en-us/events/pure-virtual-cpp-2022/clang-tidy-in-visual-studio-code/">clang-tidy in Visual Studio Code</a> – Julia Reid</li>
</ul>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2022-videos-available/">Pure Virtual C++ 2022 Recordings Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>MSVC’s STL Completes /std:c++20</title>
		<link>https://devblogs.microsoft.com/cppblog/msvcs-stl-completes-stdc20/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvcs-stl-completes-stdc20/#comments</comments>
		
		<dc:creator><![CDATA[Casey Carter]]></dc:creator>
		<pubDate>Tue, 10 May 2022 18:01:31 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30539</guid>

					<description><![CDATA[<p>We are happy to announce that the final C++20 Standard Library features are now stabilized and available in /std:c++20 mode in both Visual Studio 2022 version 17.2 and Visual Studio 2019 version 16.11.14. This notably includes several proposals approved as Defect Reports (DRs) by the C++ Standard Committee against the C++20 Standard Library that made extensive design changes to &#60;format&#62;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvcs-stl-completes-stdc20/">MSVC’s STL Completes /std:c++20</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that the final C++20 Standard Library features are now stabilized and available in <code>/std:c++20</code> mode in both Visual Studio 2022 version 17.2 and Visual Studio 2019 version 16.11.14. This notably includes <a href="https://github.com/microsoft/STL/projects/9">several proposals approved as Defect Reports (DRs)</a> by the C++ Standard Committee against the C++20 Standard Library that made extensive design changes to <code>&lt;format&gt;</code> and <code>&lt;ranges&gt;</code> as recently as October 2021. <span data-ogsc="rgb(31, 73, 125)">You can now use the complete list of C++20 features in production in a binary compatible way with other supported language version modes.</span></p>
<h2 id="c20-complete-again">C++20 Complete&#8230; Again??!?</h2>
<p>We <a href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">previously announced</a> that MSVC had completed all features in C++20 for Visual Studio version 16.11.0, and that we had added the <code>/std:c++20</code> option to indicate that most C++20 features were stabilized and considered production-ready. We delayed making some library features (<code>&lt;format&gt;</code>, <code>&lt;ranges&gt;</code>, and the portions of <code>&lt;chrono&gt;</code> that use <code>&lt;format&gt;</code>) available under <code>/std:c++20</code> since there were substantial and important changes in the works for those features in the Standard Committee. We didn&#8217;t want to release those features in their current form and later apply changes that would break users of <code>/std:c++20</code>. Those features continued to be available only under <code>/std:c++latest</code> while the Committee finalized the changes and we implemented them.</p>
<h2 id="defect-reports">Defect Reports</h2>
<p>The DRs include both source and <abbr title="Application Binary Interface">ABI</abbr>-breaking changes to features in <code>&lt;format&gt;</code> and <code>&lt;ranges&gt;</code>. The amazing community of contributors that has grown up around the STL since open-sourcing has been implementing the DRs in the Visual Studio 2022 release series under <code>/std:c++latest</code> just as if they were C++23 features. Our plan has been to make the final result available under <code>/std:c++20</code> once all the DRs are done, and then backport that work to Visual Studio 2019 to complete the C++20 story for customers who haven&#8217;t yet moved to Visual Studio 2022. We accomplished the first goal for Visual Studio 2022 17.2 Preview 2.</p>
<p>The backporting work went miraculously well considering that we had to merge a hundred commits from the development branch into the 16.11 release branch and get everything working without regressing that stable release series. We managed to complete the work in time to ship the 16.11 C++20 backport simultaneously with the completion of C++20 support in 17.2.</p>
<h2 id="go-ye-forth-and-code">Go Ye Forth And Code</h2>
<p>We&#8217;re happy to make these last bits of C++20 available to customers who need production stability guarantees. Please let us know about any problems or questions you have with the C++20 support in either Visual Studio 2019 version 16.11.14 or Visual Studio 2022 version 17.2, either via <a href="https://github.com/microsoft/STL/issues">the STL&#8217;s GitHub issue tracker</a>, <a href="https://developercommunity.visualstudio.com/report?space=62&amp;entry=problem">Developer Community</a>, or commenting below.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvcs-stl-completes-stdc20/">MSVC’s STL Completes /std:c++20</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvcs-stl-completes-stdc20/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
	</channel>
</rss>
