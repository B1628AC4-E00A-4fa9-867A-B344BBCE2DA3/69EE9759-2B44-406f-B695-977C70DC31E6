<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Thu, 25 Feb 2021 21:54:35 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Registries: Bring your own libraries to vcpkg</title>
		<link>https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/</link>
					<comments>https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 25 Feb 2021 21:49:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27658</guid>

					<description><![CDATA[<p>Special thanks to Nicole Mazzuca for providing the content of this blog post.<br />
Are you working on a C++ project with library dependencies? Are you tired of maintaining a custom-built package management workflow with duct tape and git submodules? Then you should consider trying out a package manager.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/">Registries: Bring your own libraries to vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><em>Special thanks to Nicole Mazzuca for providing the content of this blog post. </em></p>
<p>Are you working on a C++ project with library dependencies? Are you tired of maintaining a custom-built package management workflow with duct tape and git submodules? Then you should consider trying out a package manager. Perhaps you have been side-eyeing vcpkg for a while, and it looks like the perfect solution for your team, but for one problem: not all your dependencies are open source! Your company has internal libraries that they expect everyone to use too.</p>
<p>&nbsp;</p>
<h3 id="can-vcpkg-work-with-non-open-source-dependencies">Can vcpkg work with non-open-source dependencies?</h3>
<p>Yes! Up until now, your best options included hacking up overlay ports or forking the vcpkg ports tree. But there was room for improvement. Now, we are happy to announce a feature with an experience to manage any libraries you want, whether they are internal-only, open source, your own forks of open source projects, and more. In this blog post, we will delve into <strong>registries</strong>, our new experimental feature. We would love for you to try this feature out, give us feedback, and help us make it the best feature it can be!</p>
<h3 id="getting-started-with-registries">Getting started with registries</h3>
<p>So, we’ve discussed the why of registries; now let’s discuss the how. Let’s say we are developers at North Wind Traders, and our company has a GitHub Enterprise subscription. Of course, depending on your company’s or even your personal situation, you can use whatever solution you’re already using. The goal in this blog post is to set up a git registry, the most common type of registry.</p>
<h4 id="1-create-a-new-registry">1. Create a new registry</h4>
<p>The company’s GitHub organization is at <a href="https://github.com/northwindtraders">https://github.com/northwindtraders</a>, and that can be used to set up the registry. We will create our registry at <a href="https://github.com/northwindtraders/vcpkg-registry">https://github.com/northwindtraders/vcpkg-registry</a>, since that’s as good a name as any, and you can follow along with the branches there.</p>
<p>Once we’ve created this registry, we’ll have to do a few things to actually set it up to contain the packages we want, in this case our internal JSON and Unicode libraries.</p>
<ul>
<li>First, we’ll set up an empty baseline, the minimum requirement for a registry.</li>
<li>Then, we’ll add the files that our library needs to build, and make sure that they work.</li>
<li>Finally, we’ll add the library to the registry, by adding it to the versions database and writing down where to find the library in the git repository.</li>
</ul>
<h4 id="2-create-an-empty-registry-baseline">2. Create an empty registry baseline</h4>
<p>So, let’s start. Clone the (empty) repository, and add a baseline.json file underneath the top level versions directory, containing just the following:</p>
<pre class="prettyprint">{
"default": {}
}</pre>
<h4 id="3-create-a-vcpkg-port-for-your-library">3. Create a vcpkg port for your library</h4>
<p>Now, let’s set up a port entry for the first of our two libraries, the Unicode library <a href="https://github.com/northwindtraders/beicode">beicode</a>. If you have ever written a port, you know how to do this, but for those of us who haven’t, let’s go through it all the same.</p>
<p>We first create a folder for the ports to live; following the standard of the vcpkg central registry, we’ll call the folder ports. Since we use a stable git identifier to specify the directory, we don’t need to put it in a specific place, but it’s good to follow idioms. Inside this ports directory, create beicode’s port directory; inside there, place two empty files, <em>portfile.cmake</em> and <em>vcpkg.json</em>.</p>
<p>At this point, the registry directory should look something like this:</p>
<pre class="prettyprint">ports/
    beicode/
        portfile.cmake
        vcpkg.json
versions/
    baseline.json</pre>
<p>Now, let’s fill out the port. First, since the beicode GitHub repository already has a vcpkg.json manifest, copy that into the <em>vcpkg.json</em> file you created:</p>
<pre class="prettyprint">{
  "name": "beicode",
  "version": "1.0.0",
  "description": "A simple utf-8 based unicode decoding and encoding library",
  "homepage": "https://github.com/northwindtraders/beicode"
}</pre>
<h4 id="4-test-your-new-vcpkg-port-using-overlays">4. Test your new vcpkg port using overlays</h4>
<p>Let’s make sure this works by trying to install the port; we’re not using registries yet, just the pre-existing overlay-ports feature to test stuff out:</p>
<p><code>&gt; vcpkg install beicode --overlay-ports=vcpkg-registry/ports/beicode</code></p>
<p>We should get an error: “<em>The folder /include is empty or not present</em>”. Since we aren’t doing anything just yet, that makes sense. So, let’s fill out our port! Since our port is a simple CMake library, we can create a very simple <em>portfile.cmake</em>:</p>
<pre class="prettyprint">vcpkg_from_github(
  OUT_SOURCE_PATH SOURCE_PATH
  REPO northwindtraders/beicode
  REF 19a1f95c2f56a27ced90227b5e2754a602a08e69
  SHA512 7b2bb7acb2a8ff07bff59cfa27247a7b2cced03828919cd65cc0c8cf1f724f5f1e947ed6992dcdbc913fb470694a52613d1861eaaadbf8903e94eb9cdfe4d000
  HEAD_REF main
)

vcpkg_configure_cmake(
  SOURCE_PATH "${SOURCE_PATH}"
  PREFER_NINJA
)
vcpkg_install_cmake()
vcpkg_fixup_cmake_targets()

file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/include")

file(
  INSTALL "${SOURCE_PATH}/LICENSE"
  DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}"
  RENAME copyright)</pre>
<p>If we run</p>
<p><code>&gt; vcpkg install beicode --overlay-ports=vcpkg-registry/ports/beicode</code></p>
<p>again, we’ll see that it successfully installed! We have written our first port for the registry, and now all that there’s left to do is to add the port to the version set in the registry.</p>
<h4 id="5-specify-each-version-of-your-library-in-the-registry">5. Specify each version of your library in the registry</h4>
<p>Every port’s version data lives in its own file: <em>versions/[first character]-/[portname].json</em>. For example, the version data for <em>fmt</em> would live in <em>versions/f-/fmt.json</em>; the version data for <em>zlib</em> would live in <em>versions/z-/zlib.json</em>. So, for <em>beicode</em>, create <em>versions/b-/beicode.json</em>:</p>
<pre class="prettyprint">{
  "versions": [
    {
      "version": "1.0.0",
      "git-tree": ""
    }
  ]
}</pre>
<p>And add the following to <em>versions/baseline.json</em>:</p>
<pre class="prettyprint">{
  "default": {
    "beicode": { "baseline": "1.0.0", "port-version": 0 }
  }
}</pre>
<p>Finally, let’s figure out what to put in that &#8220;<em>git-tree</em>&#8221; field. Do a git commit of the beicode port tree (but do not push), to make sure git knows about it:</p>
<pre class="prettyprint">&gt; git add ports/beicode
&gt; git commit -m "[beicode] new port"</pre>
<p>Then get the tree identifier for that directory:</p>
<p><code>&gt; git rev-parse HEAD:ports/beicode</code></p>
<p>You should get something like <code>7fb5482270b093d40ab8ac31db89da4f880f01ba</code>; put that in for the &#8220;<em>git-tree</em>&#8221; in <em>beicode.json</em>, and commit the new files:</p>
<pre class="prettyprint">&gt; git add versions
&gt; git commit --amend --no-edit</pre>
<p>And we should be done! The reason we have to do this slightly complex dance is so that we can grab exactly the files of the version we want; other versions will exist in the history of the repository, and thus are always there to be checked out.</p>
<h4 id="6-consume-libraries-from-your-vcpkg-registry-in-a-c-project">6. Consume libraries from your vcpkg registry in a C++ project</h4>
<p>Once we’ve done this, let’s try to consume the library from the new registry in an example codebase. Create a directory outside of the registry and change into that directory. Create a <em>vcpkg.json</em> which depends on beicode:</p>
<pre class="prettyprint">{
"name": "test",
"version": "0",
"dependencies": [
  "fmt",
  "beicode"
]
}</pre>
<p>And a <em>vcpkg-configuration.json</em> that sets up the registry as a git registry:</p>
<pre class="prettyprint">{
  "registries": [
    {
      "kind": "git",
      "repository": "[full path to]/vcpkg-registry",
      "packages": [ "beicode", "beison" ]
    }
  ]
}</pre>
<p>And try a vcpkg install:</p>
<p><code>&gt; vcpkg install --feature-flags=registries,manifests</code></p>
<p>If it works, then you’re ready to push the registry upstream! You can try again with the actual remote registry by replacing the &#8220;<em>repository</em>&#8221; field in your <em>vcpkg-configuration.json</em> file with the actual upstream repository URL.</p>
<p>&nbsp;</p>
<h3 id="how-vcpkg-resolves-libraries-from-registries">How vcpkg resolves libraries from registries</h3>
<p>You’ll notice that beicode and beison are taken from the registry we created; this is because we’ve explicitly said in vcpkg-configuration.json that this is where they’re from. Since we haven’t said where fmt should come from, it just comes from the default registry, which is in this case the registry that ships with vcpkg itself. Registries are never transitive; if you left off beicode from the registry in vcpkg-configuration.json, this would fail to work since beicode doesn’t exist in the default registry, and that’s where vcpkg will look for it. If you wanted to override fmt with your own copy, you could add it to the registry, and then add it to the packages field.</p>
<p>Packaging beison will be much the same, just with a different name. You can try it out for yourself, and then see if your code is any different from <a href="https://github.com/northwindtraders/vcpkg-registry">the upstream</a>.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback!</h3>
<p>Try out vcpkg by visiting our <a href="https://github.com/microsoft/vcpkg/issues">GitHub repo</a>. We welcome your feedback on the tool and the new features <a href="https://github.com/microsoft/vcpkg/issues">in our issue tracker</a> or by reaching out to us at <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a>. We are always looking to improve your experience. To see what’s next for vcpkg, <a href="https://aka.ms/vcpkg/roadmap">check out our roadmap</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/">Registries: Bring your own libraries to vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Take control of your vcpkg dependencies with versioning support</title>
		<link>https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/</link>
					<comments>https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 18 Feb 2021 01:54:07 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27597</guid>

					<description><![CDATA[<p>Special thanks to Victor Romero for putting together the content for this blog post.<br />
We have an exciting new feature to announce in vcpkg: the long-awaited and highly requested package versioning! This feature makes it possible to install specific versions of dependencies and control installed versions over time.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/">Take control of your vcpkg dependencies with versioning support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><em>Special thanks to Victor Romero for putting together the content for this blog post.</em></p>
<p>We have an exciting new feature to announce in vcpkg: the long-awaited and highly requested package versioning! This feature makes it possible to install specific versions of dependencies and control installed versions over time. In order to use this feature, a <strong>vcpkg.json</strong> manifest file must be present in your repo to declare dependencies. Versioning is not currently available for libraries installed via the command line (i.e. <code>vcpkg install library_name</code> commands). The versioning feature is completely optional – you can choose not to specify library versions, and vcpkg will pick the most appropriate set of compatible versions for your dependencies from its baseline catalog. For now, we are considering this feature experimental. Please give us your feedback and let us know how we can improve.</p>
<p>&nbsp;</p>
<h3 id="announcing-package-versioning-support">Announcing package versioning support</h3>
<p>For the past year we have been focusing our efforts on implementing highly requested features in vcpkg that will help our users in a wide variety of scenarios. Two such features are manifests and binary caching, <a href="https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/">which we announced some time ago</a>, and users have been successfully using them in their projects since then. Today, we are announcing support for another anticipated feature: Package versioning. With this feature users will be able to:</p>
<ul>
<li>Declare minimum version constraints on dependencies.</li>
<li>Freeze dependencies at specific versions.</li>
<li>Conveniently upgrade all declared dependencies at once via baselines.</li>
<li>Get reproducible builds independent from the current state of the vcpkg ports registry.</li>
</ul>
<p>&nbsp;</p>
<h3 id="getting-started-with-versions">Getting started with versions</h3>
<p>To enable versioning, you must turn on the “versions” feature flag. There are several ways to do this:</p>
<ul>
<li>Setting the <code>VCPKG_FEATURE_FLAGS</code> environment variable, example in Windows 10:<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag.png"><img class="alignnone size-full wp-image-27599" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag.png" alt="Image versioning feature flag" width="1092" height="307" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag.png 1092w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag-300x84.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag-1024x288.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag-768x216.png 768w" sizes="(max-width: 1092px) 100vw, 1092px" /></a></li>
<li>Setting the <code>VCPKG_FEATURE_FLAGS</code> variable before invoking vcpkg in the command line (example in PowerShell):
<code>$env:VCPKG_FEATURE_FLAGS="versions"</code>
<code>vcpkg install</code></li>
<li>Passing the feature flags in the command line for vcpkg (example in PowerShell):
<code>vcpkg --feature-flags="versions" install</code></li>
</ul>
<p>In the example below, we will be using Visual Studio Code to create a simple CMake project that automatically reads a vcpkg manifest file and installs dependencies. You can do this in Visual Studio as well. For information on how to set up Visual Studio for use with vcpkg with manifests (for MSBuild or CMake), see <a href="https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/">vcpkg: Accelerate your team development environment with binary caching and manifests</a>.</p>
<h4 id="example-1-simple-versioning">Example #1: Simple versioning</h4>
<p>Begin by creating a folder with the following files:</p>
<p><strong>vcpkg.json</strong></p>
<pre class="prettyprint">{
    "name": "versions-test",
    "version": "1.0.0",
    "dependencies": [
        {
            "name": "fmt",
            "version&gt;=": "7.1.3"
        },
        "zlib"
    ],
    "builtin-baseline": "b60f003ccf5fe8613d029f49f835c8929a66eb61"
}</pre>
<p>vcpkg has new version declaration properties when you use manifests. Previously, you could only declare versions for your projects using the “version-string” property. Now that versioning has come around, vcpkg is aware of some new versioning schemes.</p>
<table style="width: 29.7662%;">
<tbody>
<tr>
<td style="width: 30.2663%;"><strong>Version scheme</strong></td>
<td style="width: 80.0773%;"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version</strong></td>
<td style="width: 80.0773%;">Dot-separated numerals: <strong>1.0.0</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version-semver</strong></td>
<td style="width: 80.0773%;">Compliant semantic versions: <strong>1.2.0, 1.2.1-rc</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version-date</strong></td>
<td style="width: 80.0773%;">Dates in YYYY-MM-DD format: <strong>2021-01-01</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version-string</strong></td>
<td style="width: 80.0773%;">Arbitrary strings: <strong>vista, xp</strong></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>The selected versioning scheme has consequences in what vcpkg will allow as a valid version string and the rules for ordering versions. You can read more about versioning schemes in <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/versioning.reference.md#version-schemes">our documentation</a>.</p>
<p>Second, we use the “<code>version&gt;=</code>” property to declare a minimum version constraint on <code>fmt</code>. Notice that we also declare a dependency on <code>zlib</code> without any version constraint.</p>
<p>And lastly, we declare a “<code>builtin-baseline</code>”, the value of which is a commit SHA from the vcpkg repository.</p>
<p>In our example, vcpkg will look inside commit <code>b60f003ccf5fe8613d029f49f835c8929a66eb61</code> and find what the latest versions of <code>fmt</code> and <code>zlib</code> at that point in time were:</p>
<ul>
<li><code>fmt 7.1.3</code></li>
<li><code>zlib 1.2.11#9</code> (the #9 suffix indicates that this is the 9th version of this library build recipe)</li>
</ul>
<p>The set of libraries and versions listed above can be described as the baseline versions for the dependencies used in this project. Baseline versions get added as additional minimum version constraints when resolving package versions.</p>
<p><strong>main.cpp</strong></p>
<pre class="prettyprint">#include &lt;fmt/core.h&gt;
#include &lt;zlib.h&gt;

int main()
{
    fmt::print("fmt version is {}\n"
               "zlib version is {}\n",
               FMT_VERSION, ZLIB_VERSION);
    return 0;
}</pre>
<p><em>[Above] This is a simple single file program to test that dependencies are correctly installed.</em></p>
<p><strong>CMakeLists.txt</strong></p>
<pre class="prettyprint">cmake_minimum_required(VERSION 3.18)

set(VCPKG_FEATURE_FLAGS "versions")
project(versions-test CXX)

add_executable(main main.cpp)

find_package(ZLIB REQUIRED)
find_package(fmt CONFIG REQUIRED)
target_link_libraries(main PRIVATE ZLIB::ZLIB fmt::fmt)</pre>
<p><em>[Above] To use vcpkg manifests with a CMake project, it is necessary to add find_package and target_link_libraries functions to identify your dependencies in CMakeLists.txt. This experience is the same whether a package manager like vcpkg is being used or not. Including these lines makes it possible for dependencies to be included in builds.</em></p>
<p><strong>.vscode/settings.json</strong></p>
<pre class="prettyprint">{
    "cmake.configureSettings": {
        "CMAKE_TOOLCHAIN_FILE": "D:/vcpkg/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x64-windows"
    }
}</pre>
<p><em>[Above] For Visual Studio Code, this is how to point a CMake project to the vcpkg CMake toolchain file. This file must be specified for any CMake project using vcpkg. Other IDEs or editors may have a different experience for pointing to CMake toolchain files.</em></p>
<p>Next, generate the CMake cache using the Visual Studio Code <strong>CMake: Configure</strong> command:</p>
<pre class="prettyprint">[cmakefileapi-driver] Removing d:/versions-test/build/CMakeCache.txt
[proc] Executing command: "C:\Program Files\CMake\bin\cmake.EXE" --no-warn-unused-cli -DCMAKE_TOOLCHAIN_FILE:STRING=D:/vcpkg/scripts/buildsystems/vcpkg.cmake -DVCPKG_TARGET_TRIPLET:STRING=x64-windows -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -Hd:/versions-test -Bd:/versions-test/build -G "Visual Studio 16 2019" -T host=x64 -A x64
[cmake] -- Running vcpkg install
[cmake] Detecting compiler hash for triplet x64-windows...
[cmake] The following packages will be built and installed:
[cmake]     fmt[core]:x64-windows -&gt; 7.1.3 -- D:\vcpkg\buildtrees\versioning\versions\fmt\d99b6a35e1406ba6b6e09d719bebd086f83ed5f3
[cmake]     zlib[core]:x64-windows -&gt; 1.2.11#9 -- D:\vcpkg\buildtrees\versioning\versions\zlib\827111046e37c98153d9d82bb6fa4183b6d728e4</pre>
<p><em>[Above] This is the output produced by the CMake command line when generating the CMake cache. In Visual Studio Code, with the CMake Tools extension installed, the cache can be generated with the &#8220;CMake: Configure&#8221; command.</em></p>
<p>You will know that versioning is working if you notice the “<code>&lt;path-to-vcpkg&gt;/buildtrees/versioning/versions/&lt;portname&gt;/&lt;sha&gt;</code>” pattern in the paths. The port files are being checked out by vcpkg for the declared versions at those locations.</p>
<p>Lastly, run the program:</p>
<pre class="prettyprint">fmt version is 70103  
zlib version is 1.2.11</pre>
<h4 id="example-2-pinning-older-versions">Example #2: Pinning older versions</h4>
<p>Since baselines establish a version floor for all packages and explicit constraints get upgraded when they are lower than the baseline, we need another mechanism to downgrade versions past the baseline.</p>
<p>The mechanism vcpkg provides for that scenario is overrides. When an override is declared on a package, vcpkg will ignore all other version constraints either directly declared in the manifest or from transitive dependencies. In short, overrides will force vcpkg to use the exact version declared, period.</p>
<p>First, change your manifest to add an override on <code>fmt</code> and force vcpkg to use version 6.0.0:</p>
<pre class="prettyprint">{
    "name": "versions-test",
    "version": "1.0.0",
    "dependencies": [
        {
            "name": "fmt",
            "version&gt;=": "7.1.3"
        },
        "zlib"
    ],
    "builtin-baseline": "b60f003ccf5fe8613d029f49f835c8929a66eb61", 
    "overrides": [
        { "name": "fmt", "version": "6.0.0" }
    ]
}</pre>
<p>Next, delete your build folder, generate the CMake cache, and build again:</p>
<pre class="prettyprint">[cmake] -- Running vcpkg install
[cmake] Detecting compiler hash for triplet x64-windows...
[cmake] The following packages will be rebuilt:
[cmake]     fmt[core]:x64-windows -&gt; 6.0.0 -- D:\Work\viromer\versioning\vcpkg\buildtrees\versioning\versions\fmt\d99b6a35e1406ba6b6e09d719bebd086f83ed5f3</pre>
<p>Lastly, run the program:</p>
<pre class="prettyprint">fmt version is 60000  
zlib version is 1.2.11</pre>
<h3 id="how-versioning-works-in-vcpkg">How versioning works in vcpkg</h3>
<p>In the diagram below we depict the chronology of versions released for four different libraries: FMT, zlib, Boost and Azure’s core C++ library.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram.png"><img class="alignnone size-full wp-image-27634" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram.png" alt="Image vcpkg versioning diagram" width="784" height="567" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram.png 784w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram-300x217.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram-768x555.png 768w" sizes="(max-width: 784px) 100vw, 784px" /></a></p>
<p>The vcpkg versioning system is comprised of the following pieces:</p>
<h4 id="baselines">Baselines</h4>
<p>To enable versioning, it is required that you set a baseline to a specific vcpkg commit. By selecting a baseline, you are selecting a snapshot of a certain point in time of the chronology.
Setting the baseline will set a minimum version floor on all your dependencies, the minimum versions being the ones that existed at the selected snapshot. In the picture above, we would have version 7.1.0 for FMT, version 1.2.11 at port revision 9 for zlib, version 1.74.0 for Boost and the September 2020 release for Azure’s Core C++ library.
An advantage of using baselines is that versions that are contemporary are more likely to be compatible. The main vcpkg registry does, after all, build all libraries it contains at the same time to try to ensure compatibility of the whole catalog at every commit.</p>
<h4 id="constraints">Constraints</h4>
<p>In contrast with baselines that set minimum versions for all packages, constraints allow you to specify a minimum version in a package-by-package basis.</p>
<p>Constraints only allow you to upgrade versions further than those at the baseline. As stated above, the baseline sets a minimum version floor for all packages, so if you attempt to add a constraint that is lower than the baseline, the constraint will be upgraded.</p>
<p>An important thing to notice about constraints is that they are transitive where baselines and overrides are not. Dependencies in the graph can express their own constraints and they will be considered by the version resolution algorithm.</p>
<p>But what if you really need to set a version to be lower than the baseline? How can you do it without lowering the baseline? For those cases, you can use overrides.</p>
<h4 id="overrides">Overrides</h4>
<p>An override forces vcpkg to use a specific version while ignoring all other constraint (either explicit or transitive). This allows the user to solve some specific situations like:</p>
<ul>
<li>Downgrading versions lower than the baseline.</li>
<li>Forcing upgraded/downgraded versions on transitive dependencies.</li>
<li>Solving version conflicts between different packages.</li>
</ul>
<p>In the scenario depicted in the diagram, given all that we know about baselines, constraints, and overrides. We can see that version resolution for a project using all four packages would result in:</p>
<ul>
<li>FMT: Version 7.1.2, as specified via constraint.</li>
<li>zlib: Version 1.2.11 at port revision 2, as specified via override.</li>
<li>Boost: Version 1.74, as defaulted by the baseline.</li>
<li>azure-core-pp: Version 2020-09-01, as defaulted by the baseline.</li>
</ul>
<p>&nbsp;</p>
<h3 id="versions-and-custom-ports">Versions and custom ports</h3>
<p>The last thing to discuss is how overlay ports interact with versioning resolution. The answer is: they do not interact at all by design.
Going into more detail, when you provide an overlay for a port, vcpkg will always use the overlay port without caring what version is contained in it. The reasons are two-fold: (1) it is consistent with the existing behavior of overlay ports (completely masking the existing port), and (2) overlay ports do not (and are not expected to) provide enough information to power vcpkg&#8217;s versioning feature.</p>
<p>If you want to have flexible port customization along with versioning features, you should consider making your own custom registry. See our <a href="https://github.com/microsoft/vcpkg/blob/master/docs/specifications/registries-2.md">registries specification for more details</a>.</p>
<p>&nbsp;</p>
<h3 id="further-reading">Further reading</h3>
<p>If you&#8217;re interested in delving deeper into the details of how versioning works we recommended that you read the <a href="https://github.com/microsoft/vcpkg/blob/master/docs/specifications/versioning.md">original versioning specification</a>.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback!</h3>
<p>Try out vcpkg by visiting our <a href="https://github.com/microsoft/vcpkg/issues">GitHub repo</a>. We welcome your feedback on the tool and the new features <a href="https://github.com/microsoft/vcpkg/issues">in our issue tracker</a>. To see what’s next for vcpkg, including support for versioning and registries, <a href="https://aka.ms/vcpkg/roadmap">check out our roadmap</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/">Take control of your vcpkg dependencies with versioning support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>Now announcing: Makefile support in Visual Studio Code!</title>
		<link>https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Wed, 17 Feb 2021 23:42:46 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27606</guid>

					<description><![CDATA[<p>We are excited to announce a brand-new extension for building and debugging Makefile projects in Visual Studio Code: Makefile Tools (preview)! The extension is in pilot stages, but we’ve curated a list of over 70 popular opensource Makefile projects that work with Makefile Tools.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/">Now announcing: Makefile support in Visual Studio Code!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are excited to announce a brand-new extension for building and debugging Makefile projects in Visual Studio Code: <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Makefile Tools (preview)</a>! The extension is in pilot stages, but we’ve curated a <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/repositories.md">list of over 70 popular opensource Makefile projects</a> that work with Makefile Tools. Give it a try and let us know what you think!</p>
<h2 id="installing-the-extension">Installing the extension</h2>
<p>First, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Makefile Tools extension</a> from the VS Code Marketplace.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace.png"><img class="alignnone size-full wp-image-27626" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace.png" alt="Image of Makefile Tools extension in VS Code Marketplace" width="1562" height="370" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace.png 1562w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-300x71.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-1024x243.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-768x182.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-1536x364.png 1536w" sizes="(max-width: 1562px) 100vw, 1562px" /></a></p>
<h2 id="activating-the-extension">Activating the extension</h2>
<p>Once the extension is installed, it will activate when it finds a Makefile in your project’s root folder. If your project’s Makefile is not in the root folder, you can use the <strong>Makefile Path</strong> setting to instruct the extension where to find it. Update <strong>Makefile Path</strong> by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and then selecting <strong>makefile</strong> under <strong>Extensions.</strong></p>
<p><strong><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath.png"><img class="alignnone size-full wp-image-27611" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath.png" alt="Image showing the Makefile Tools extension's Makefile Path property in VS Code settings" width="1238" height="241" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath.png 1238w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath-300x58.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath-1024x199.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath-768x150.png 768w" sizes="(max-width: 1238px) 100vw, 1238px" /></a> </strong></p>
<p>After updating <strong>Makefile Path</strong>, type “makefile” into the Command Palette and run a Makefile Tools command to activate the extension.</p>
<h2 id="configuring-your-project">Configuring your project</h2>
<p>By default, the extension will attempt to use a make program that resides within your $PATH to configure the project. If your make.exe is not in your $PATH, update the <strong>Make Path </strong>setting by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and then selecting <strong>makefile</strong> under <strong>Extensions. </strong>The<strong> Make Path</strong> setting tells the extension where to find your make executable.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath.png"><img class="alignnone size-full wp-image-27612" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath.png" alt="Image showing the Makefile Tools extension's Make Path property in VS Code settings" width="1230" height="213" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath.png 1230w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath-300x52.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath-1024x177.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath-768x133.png 768w" sizes="(max-width: 1230px) 100vw, 1230px" /></a></p>
<p>Once your make path is properly set, accept the prompt to allow Makefile Tools to configure IntelliSense.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense.png"><img class="alignnone size-full wp-image-27623" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense.png" alt="Image showing pop-up notification for allowing the Makefile Tools extension to configure IntelliSense" width="1104" height="269" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense.png 1104w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense-300x73.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense-1024x250.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense-768x187.png 768w" sizes="(max-width: 1104px) 100vw, 1104px" /></a></p>
<p>If you don&#8217;t see that notification, or you accidentally dismissed it, you can grant Makefile Tools permission to configure IntelliSense by running “<strong>C/C++: Change Configuration Provider”</strong> from the Command Palette and selecting <strong>Makefile Tools</strong>.</p>
<p>Now you’re ready to configure your project! If you normally run make from the command line without passing it any additional arguments, you shouldn&#8217;t need to do anything else at this point.</p>
<p>If you regularly pass additional arguments to make, use the Makefile Tools’ <strong>Configurations</strong> setting (<strong>makefile.configurations</strong> in settings.json) to specify those arguments. Makefile.configurations is an array of configuration objects, each with a <strong>name</strong> and <strong>makeArgs</strong> property that holds the arguments to pass to make. To help you out, we’ve <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/repositories.md">documented the correct configurations</a> for over 70 popular open-source repositories. For example, to create a configuration for <a href="https://github.com/littlekernel/lk">littlekernel</a>, where you need to pass “PROJECT=armemu-test” to make, your settings.json would look something like this:</p>
<pre class="prettyprint">"makefile.configurations": [
    {
        "name": "littlekernel",
        "makeArgs": ["PROJECT=armemu-test"]
    }
]</pre>
<p>To choose the configuration for a project, select the Makefile Tools icon in the left explorer menu.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon.png"><img class="alignnone size-full wp-image-27619" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon.png" alt="Image showing the Makefile Tools icon in the explorer menu on the left" width="2871" height="2078" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon.png 2871w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-300x217.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-1024x741.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-768x556.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-1536x1112.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-2048x1482.png 2048w" sizes="(max-width: 2871px) 100vw, 2871px" /></a></p>
<p>Hover over <strong>Configuration</strong> and select the pencil icon to choose a configuration for your project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration.png"><img class="alignnone size-full wp-image-27615" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration.png" alt="Image showing the &quot;edit Configuration&quot; button that appears on hover in the Makefile Tools UI pane" width="836" height="870" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration.png 836w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration-288x300.png 288w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration-768x799.png 768w" sizes="(max-width: 836px) 100vw, 836px" /></a></p>
<p>If you didn’t define any configurations in<strong> makefile.configurations</strong>, the extension will automatically select a default one.</p>
<h2 id="building-targets">Building targets</h2>
<p>After configuring your project, you’re ready to build. Choose a Build target by selecting the pencil icon that appears on hover.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target.png"><img class="alignnone size-full wp-image-27614" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target.png" alt="Image showing the &quot;edit Build target&quot; button that appears on hover in the Makefile Tools UI pane" width="838" height="960" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target.png 838w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target-262x300.png 262w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target-768x880.png 768w" sizes="(max-width: 838px) 100vw, 838px" /></a></p>
<p>Then choose from the list of targets found in your project’s Makefile.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets.png"><img class="alignnone size-full wp-image-27620" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets.png" alt="Image showing a list of build targets found in the project's Makefile, returned by the Makefile Tools extension" width="3240" height="2075" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets.png 3240w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-300x192.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-1024x656.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-768x492.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-1536x984.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-2048x1312.png 2048w" sizes="(max-width: 3240px) 100vw, 3240px" /></a></p>
<p>After setting the Build target, click the Build icon.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target.png"><img class="alignnone size-full wp-image-27613" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target.png" alt="Image showing the Build button in the top right corner of the Makefile Tools UI pane" width="838" height="960" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target.png 838w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target-262x300.png 262w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target-768x880.png 768w" sizes="(max-width: 838px) 100vw, 838px" /></a></p>
<h2 id="debugging-and-running-targets">Debugging and running targets</h2>
<p>To run/debug your program, use the pencil icon to select a Launch target. A configuration for the selected target will be added to the <strong>makefile.launchConfigurations </strong>setting. If you need to pass additional arguments to your targets—things like MIMode, miDebuggerPath, stopAtEntry— add the <strong>binaryArgs</strong> property to the target’s configuration in <strong>makefile.launchConfigurations</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target.png"><img class="alignnone size-full wp-image-27616" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target.png" alt="Image showing the &quot;edit Launch target&quot; button that appears on hover in the Makefile Tools UI pane" width="841" height="952" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target.png 841w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target-265x300.png 265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target-768x869.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<p>Once the Launch target is set, select the Debug icon to start a debugging session.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target.png"><img class="alignnone size-full wp-image-27618" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target.png" alt="Image showing the Debug target button in the top right corner of the Makefile Tools UI pane" width="841" height="952" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target.png 841w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target-265x300.png 265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target-768x869.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<p>To run the program without debugging, select the Run in Terminal button.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal.png"><img class="alignnone size-full wp-image-27621" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal.png" alt="Image showing the Run in Terminal button in top right corner of the Makefile Tools UI pane" width="841" height="952" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal.png 841w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal-265x300.png 265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal-768x869.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<h2 id="makefile-tools-commands">Makefile Tools commands</h2>
<p>You can find all the Makefile Tools commands by opening the Command Palette and typing &#8220;makefile&#8221;. For your convenience, there are commands for building clean and building ALL that you can run without changing the Build target.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands.png"><img class="alignnone size-full wp-image-27617" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands.png" alt="Image showing the Makefile Tools extensions commands in the Command Palette, all beginning with &quot;makefile:&quot;" width="1471" height="856" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands.png 1471w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands-300x175.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands-1024x596.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands-768x447.png 768w" sizes="(max-width: 1471px) 100vw, 1471px" /></a></p>
<h2 id="makefile-tools-settings">Makefile Tools settings</h2>
<p>To find all Makefile Tools settings, go to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and then select <strong>makefile</strong> under <strong>Extensions.</strong> The settings you’ll probably use the most are:</p>
<ul>
<li>configurations (tells the extension which arguments to pass to make when configuring your project)</li>
<li>defaultLaunchConfiguration (global debugger settings)</li>
<li>launchConfigurations (debugger settings for specific launch targets)</li>
<li>makePath (path to your make executable)</li>
<li>makefilePath (path to project’s Makefile)</li>
<li>buildLog (alternative to dry-run)</li>
</ul>
<h2 id="known-limitations">Known limitations</h2>
<p>This is a preview release of Makefile Tools, and although we’ve tested it with over 70 repositories, you may need to do some fiddling to configure your project for the first time. Please feel free to submit a PR to <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/repositories.md">this document</a>, adding your repository and its correct configuration settings, to help anyone who might be trying to build the same project.</p>
<p>Check out our <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/troubleshooting.md">troubleshooting guide</a> for a list of known limitations and work-arounds.</p>
<h2 id="what-do-you-think">What do you think?</h2>
<p>Download the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Makefile Tools extension</a> for Visual Studio Code today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/microsoft/vscode-makefile-tools/issues">Issues section of our GitHub repository</a>.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/">Now announcing: Makefile support in Visual Studio Code!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ Extension: Cross-Compilation IntelliSense Configurations</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Tue, 09 Feb 2021 16:00:05 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27555</guid>

					<description><![CDATA[<p>The February 2021 update of the Visual Studio Code C++ extension is now available! This latest release provides support for cross-compilation IntelliSense configurations and over 60 bug fixes! To find out more about all the enhancements, check out our release notes on GitHub.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/">Visual Studio Code C++ Extension: Cross-Compilation IntelliSense Configurations</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The February 2021 update of the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Visual Studio Code C++ extension</a> is now available! This latest release provides <a href="https://github.com/microsoft/vscode-cpptools/issues/1083">support for cross-compilation IntelliSense configurations</a> and over 60 bug fixes! To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.2.0">release notes on GitHub.</a></p>
<h3 id="cross-compilation-intellisense-configurations">Cross-compilation IntelliSense configurations</h3>
<p>With this latest release, you can configure the extension to provide proper IntelliSense when compiling for a different <em>platform</em> than your host OS. That’s right— <em>platform</em>, not just architecture. The C++ extension no longer hardcodes system defines based on your host OS; it’ll use the system defines returned by your compiler.</p>
<p>Let’s say you’re developing on macOS and your project targets Linux. Assuming you have a compiler compatible with your project’s target platform and architecture, the C++ extension will query that compiler using the <strong>Compiler path</strong>, <strong>Compiler arguments, </strong>and<strong> IntelliSense mode</strong> settings in your IntelliSense configuration. If you’re using a custom configuration provider (like CMake Tools) or compile_commands.json, then you don’t need to worry about updating the C++ extension’s IntelliSense configuration; everything should just work.</p>
<p>Your project’s IntelliSense configurations are stored in the c_cpp_properties.json file under the .vscode folder. Edit these settings by selecting <strong>C/C++: Edit Configurations (UI)</strong> from the Command Palette.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations.png"><img class="alignnone wp-image-27564 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations.png" alt="The UI and JSON Edit Configurations options in the Command Palette" width="1458" height="237" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations.png 1458w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations-300x49.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations-1024x166.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations-768x125.png 768w" sizes="(max-width: 1458px) 100vw, 1458px" /></a></p>
<p>Under your configuration’s <strong>Compiler path </strong>setting<strong>, </strong>enter the path to the compiler compatible with your target platform and architecture.</p>
<p>Then use <strong>Compiler arguments</strong> to provide the target triplet that you use when cross-compiling your code with your compiler. For example, <em>&#8211;target=x86_64-linux</em> if you’re targeting Linux 64-bit. This allows the C++ extension to query the compiler for system defines and include paths specific to your target platform and architecture.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1.png"><img class="alignnone wp-image-27562 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1.png" alt="Passing --target=x86_64-linux as a compiler argument" width="1630" height="308" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-300x57.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-1024x193.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-768x145.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-1536x290.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></a></p>
<p>Next, set <strong>IntelliSense mode</strong> to the platform- and architecture-specific variant of the compiler you’re using (it should closely match the target triplet defined in <strong>Compiler arguments</strong>). If the information returned from querying the compiler doesn’t match the <strong>IntelliSense mode </strong>you chose, the C++ extension will automatically correct the IntelliSense mode for you.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1.png"><img class="alignnone wp-image-27563 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1.png" alt="Selecting linux-clang-x64 for IntelliSense mode" width="1636" height="314" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1.png 1636w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-300x58.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-1024x197.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-768x147.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-1536x295.png 1536w" sizes="(max-width: 1636px) 100vw, 1636px" /></a></p>
<p>Now when you open your project in VS Code, you’ll get IntelliSense for your target platform instead of macOS. No more squiggles from hardcoded system defines!</p>
<h3 id="additional-enhancements">Additional enhancements</h3>
<p>In addition to supporting cross-compilation IntelliSense configurations, the February 2021 update comes with the following enhancements:</p>
<ul>
<li>clang-format has been updated to version 11. <a href="https://github.com/microsoft/vscode-cpptools/issues/6326">#6326</a></li>
<li>We now ship a native ARM64 clang-format binary with the extension for ARM64 Windows devices (<a href="https://github.com/microsoft/vscode-cpptools/issues/6494">#6494</a>).</li>
<li>We added a command to generate EditorConfig contents from your code formatting settings (vcFormat) <a href="https://github.com/microsoft/vscode-cpptools/issues/6018">#6018</a></li>
<li>We support a new &#8220;console&#8221; launch config property for cppvsdbg (replacing the legacy “externalConsole” property). <a href="https://github.com/microsoft/vscode-cpptools/pull/6794">PR #6794</a></li>
</ul>
<h3 id="bug-fixes">Bug Fixes</h3>
<p>The February 2021 update of the C++ extension knocks out over 60 bug fixes! To name a few:</p>
<ul>
<li>Fix clang-format failing due to missing libtinfo5 on Linux ARM/ARM64. <a href="https://github.com/microsoft/vscode-cpptools/pull/6774">#6774</a></li>
<li>Fix handling of &#8211;sysrootand -isysroot with compileCommands. <a href="https://github.com/microsoft/vscode-cpptools/issues/1575">#1575</a></li>
<li>Fix IntelliSense not updating if a non-opened header is changed. <a href="https://github.com/microsoft/vscode-cpptools/issues/1780">#1780</a></li>
<li>Fix Switch Header/Source not switching to an existing file in another column if it&#8217;s not visible. <a href="https://github.com/microsoft/vscode-cpptools/issues/2667">#2667</a>, <a href="https://github.com/microsoft/vscode-cpptools/issues/6749">#6749</a></li>
<li>Allow the extension to run on x64 emulator of M1 Macs. <a href="https://github.com/microsoft/vscode-cpptools/issues/6713">#6713</a> (Thank you <a href="https://github.com/xymeng16"><strong>@xymeng16</strong></a>! <a href="https://github.com/microsoft/vscode-cpptools/pull/6601">PR #6601</a>)</li>
<li>Fix hover and Find All References for template function overloads. <a href="https://github.com/microsoft/vscode-cpptools/issues/4044">#4044</a>, <a href="https://github.com/microsoft/vscode-cpptools/issues/4249">#4249</a></li>
</ul>
<p>Check out <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.2.0">the release notes</a> for more!</p>
<h3 id="what-do-you-think">What do you think?</h3>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>. You can also join our Insiders program and get access to early builds of our release by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/">Visual Studio Code C++ Extension: Cross-Compilation IntelliSense Configurations</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Improved OpenMP Support for C++ in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Bran Hagger]]></dc:creator>
		<pubDate>Tue, 09 Feb 2021 15:00:37 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27530</guid>

					<description><![CDATA[<p>As devices with multiple cores and processors became ubiquitous, programming languages adapted to provide developers with control over how tasks are divided across processors. The OpenMP application program interface for C, C++, and Fortran was originally developed in the 1990s for this purpose,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/">Improved OpenMP Support for C++ in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>As devices with multiple cores and processors became ubiquitous, programming languages adapted to provide developers with control over how tasks are divided across processors. The <a href="https://www.openmp.org/">OpenMP application program interface</a> for C, C++, and Fortran was originally developed in the 1990s for this purpose, and today the standard continues to evolve to support new scenarios, such as off-loading to additional devices and providing more fine-grained control over which threads execute which tasks.</p>
<p>Microsoft Visual Studio has <a href="https://docs.microsoft.com/en-us/cpp/build/reference/openmp-enable-openmp-2-0-support">supported the OpenMP 2.0 standard</a> since 2005. In the initial release of Visual Studio 2019 we added the <strong>-openmp:experimental</strong> switch to enable <a href="https://devblogs.microsoft.com/cppblog/simd-extension-to-c-openmp-in-visual-studio/">minimal support for the OpenMP SIMD directive</a> first introduced in the OpenMP 4.0 standard.</p>
<h3 id="our-openmp-plans">Our OpenMP Plans</h3>
<p>Starting with Visual Studio 2019 version 16.9 we have begun adding experimental support for newer versions of the OpenMP standard in a more systematic way. As a first step, we added the option to generate code compatible with <a href="https://openmp.llvm.org/index.html">LLVM’s OpenMP runtime library</a> (libomp) on the x64 architecture. Going forward, support for additional OpenMP features will leverage LLVM’s OpenMP runtime. When we find issues in the LLVM OpenMP runtime on Windows, we will fix them in the version of libomp we ship and contribute fixes back to the LLVM community once they have been tested.</p>
<p>Moving forward, our next step for OpenMP support will be to support the additional features added in the OpenMP 3.1 standard on the x86 and arm64 architectures alongside x64. Then we will add support for the pragmas and clauses added in the OpenMP 4.5 standard that do not involve offloading. Which features are added after that will depend on user feedback. We would love to hear which specific OpenMP features you would like to see, so we can prioritize which features to support first.</p>
<h3 id="new-openmpllvm-switch">New -openmp:llvm switch</h3>
<p>A program can be compiled to target the LLVM OpenMP runtime by using the new experimental CL switch <strong>-openmp:llvm</strong> instead of <strong>-openmp</strong>. In Visual Studio 2019 version 16.9 the <strong>-openmp:llvm</strong> switch only works on the x64 architecture. The new switch currently supports all the same OpenMP 2.0 directives as <strong>-openmp</strong>, as well as support for unsigned integer indices in parallel for loops according to the OpenMP 3.0 standard. Support for more directives will be added in future releases. The <strong>-openmp:llvm switch</strong> is compatible with <a href="https://devblogs.microsoft.com/cppblog/simd-extension-to-c-openmp-in-visual-studio/">all the SIMD directives</a> supported by the <strong>-openmp:experimental</strong> switch.</p>
<p>Compiling an executable with the <strong>-openmp:llvm</strong> switch automatically adds a dynamic link to the appropriate libomp DLL. In order for the executable to run, it will need access to either libomp140d.x86_64.dll (if compiled with /DEBUG) or libomp140.x86_64.dll. These DLLs can be found in the Visual Studio installation directory under the Program Files or Program Files (x86) directory at VC\Redist\MSVC\&lt;version&gt;\debug_nonredist\x64\Microsoft.VC142.OpenMP.LLVM and will be automatically included in the PATH if the executable is run from an x64 NativeTools command prompt.</p>
<p>As the <strong>-openmp:llvm</strong> switch is still experimental, both the release and debug versions of the runtime still have asserts enabled, which makes detecting incorrect behavior easier but will affect performance. The DLLs were compiled with CMAKE_BUILD_TYPE=RelWithDebInfo and LLVM_ENABLE_ASSERTIONS=ON. Future versions of the libomp DLLs may not be backwards compatible and the current version of these DLLs is not redistributable.</p>
<p>The <strong>-openmp:llvm</strong> switch is not compatible with <strong>/clr</strong> or <strong>/ZW</strong>.</p>
<h3 id="improvements-with-openmpllvm">Improvements with -openmp:llvm</h3>
<p>Using the <strong>-openmp:llvm</strong> switch enables a few correctness fixes. In Visual Studio version 16.9 Preview 3 the lastprivate clause in <strong>#pragma omp sections</strong> is now correctly handled. When used with sections, the lastprivate clause guarantees that on exiting a sections block the variables listed in the clause will be set equal to the private version of that variable from the last section. For example, after executing the following code the value of x will be 6.</p>
<pre class="prettyprint">int x = 0;
#pragma omp parallel sections lastprivate(x)
{
   #pragma omp section
   x = 4;
   #pragma omp section
   x = 6;
}</pre>
<p>Visual Studio 2019 version 16.9 Preview 4 also includes fixes to the optimizer to correctly handle OpenMP constructs. MSVC will now avoid moving writes across an implicit or explicit flush boundary. Take the following code using <strong>#pragma omp flush</strong> as an example:</p>
<pre class="prettyprint">x = 7;
#pragma omp flush
if (omp_get_thread_num() == 0) {
    x = 10;
}</pre>
<p>In some cases, previous versions of the compiler could incorrectly optimize away the potential double write to x by changing this code to:</p>
<pre class="prettyprint">#pragma omp flush
x = (omp_get_thread_num() == 0) ? 7 : 10;</pre>
<p>However, this optimization does not respect the barrier guaranteed by the <strong>#pragma omp flush</strong>. With the original code, as omp_get_thread_num() returns 0 for exactly one thread in the group, only that thread would write to x after the flush point and x would be 10. Because after the optimization other threads could write to x after the flush point and create a race condition, the optimization was not legal.</p>
<p>The optimizer will also properly recognize that even a variable local to a function can be changed by other threads inside of an OpenMP parallel region. For example, in the following code the value of shared in the x &gt; shared test can not be replaced with -1 because another thread could have written to shared since the initial assignment:</p>
<pre class="prettyprint">int shared = -1;
#pragma omp parallel
{
    unsigned int x = omp_get_thread_num();
    #pragma omp critical
    {
        if (x &gt; shared) {
            shared = x;
        }
    }
}</pre>
<h3 id="new-features-with-openmpllvm">New Features with -openmp:llvm</h3>
<p>In addition to correctness fixes, the new <strong>-openmp:llvm</strong> switch already supports a few features added in the OpenMP 3.0 standard. Parallel for loops may now use unsigned integers as indices. Limited support for <strong>#pragma omp task</strong> has been added, but clauses on the task pragma are not guaranteed to work. Due to the many limitations in <strong>#pragma omp task</strong> at this time, the pragma is only supported under the <strong>-openmp:experimenta</strong>l switch.</p>
<h3 id="feedback">Feedback</h3>
<p>We encourage you to try out this new feature in <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 version 16.9 Preview</a>. As always, we welcome your feedback. If you encounter a correctness issue in code generated with the <strong>-openmp:llvm</strong> switch or bugs in the libomp140 DLLs shipped with Visual Studio, please let us know. We can be reached via the comments below, via twitter (@visualc), or via <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/">Improved OpenMP Support for C++ in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>10</slash:comments>
		
		
			</item>
		<item>
		<title>Abbreviated Function Templates and Constrained Auto</title>
		<link>https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/</link>
					<comments>https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Thu, 04 Feb 2021 15:00:50 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27526</guid>

					<description><![CDATA[<p>Declaring function templates in C++ has always been quite verbose. C++20 added a new way of doing so that is more terse and more consistent with lambdas: abbreviated function templates. This short post will show how to use this syntax and how it applies to C++20 concepts.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/">Abbreviated Function Templates and Constrained Auto</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Declaring function templates in C++ has always been quite verbose. C++20 added a new way of doing so that is more terse and more consistent with lambdas: abbreviated function templates. This short post will show how to use this syntax and how it applies to C++20 concepts.</p>
<h1 id="abbreviated-function-templates">Abbreviated Function Templates</h1>
<p>C++11 introduced lambdas, which look like this:</p>
<pre class="prettyprint">[captures] (type_1 param_1, type_2 param_2) { body(param_1, param_2); }
</pre>
<p>You can only call this lambdas with arguments of <code>type_1</code> and <code>type_2</code>. However we frequently use lambdas in situations where the types would be difficult to spell out in full (especially when using features like <a href="https://en.cppreference.com/w/cpp/ranges">ranges</a>). C++14 allowed you to make lambdas which can be called with arguments of any type by using the <code>auto</code> keyword:</p>
<pre class="prettyprint">[captures] (auto param_1, auto param_2) { body(param_1, param_2); }</pre>
<p>Now you can pass any types as the arguments. C++20&#8217;s abbreviated function templates allows you to apply this kind of syntax to function templates.</p>
<p>In C++17 you might write a function to give animals head scratches as a function template, so it can be called with any type of animal:</p>
<pre class="prettyprint">template &lt;class Animal&gt;
void give_head_scratches (Animal const&amp; the_animal);</pre>
<p>In C++20 you can simplify this using <code>auto</code>:</p>
<pre class="prettyprint">void give_head_scratches (auto const&amp; the_animal);</pre>
<p>This version is less verbose, requires coming up with fewer names, and is more consistent with C++14 lambdas.</p>
<h1 id="constrained-auto">Constrained Auto</h1>
<p>There&#8217;s a problem with the above function template though: according to the declaration we can pass literally anything to it. We can happily make calls that look like this:</p>
<pre class="prettyprint">give_head_scratches(42);
give_head_scratches(a_cactus);
give_head_scratches(blog_post);
give_head_scratches(the_platonic_ideal_of_a_chair);</pre>
<p>They might compile and do something weird, or they might fail to compile due to the implementation of the template doing something which those types don&#8217;t support. Ideally we&#8217;d want to both document the interface of this function template with what kind of types it supports and also give the compiler the ability to give detailed errors when the declaration is instantiated with in incompatible type.</p>
<p>C++20 gives us <a href="https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/">Concepts</a> to help solve this problem. If we have some <code>animal</code> concept which defines what interface a type representing an animal should have then we can use it like so:</p>
<pre class="prettyprint">template &lt;animal Animal&gt;
void give_head_scratches (Animal const&amp; the_animal);</pre>
<p>This is quite verbose and repetitive. Ideally we&#8217;d be able to use the concept name directly in the function parameter list like this:</p>
<pre class="prettyprint">void give_head_scratches (animal const&amp; the_animal);</pre>
<p>However, this syntax was rejected from standardization, because you can&#8217;t tell whether this is a function template or a regular function without knowing whether <code>animal</code> is a type or a concept.</p>
<p>Fortunately, a version of this syntax was included in C++20 which uses the <code>auto</code> keyword again:</p>
<pre class="prettyprint">void give_head_scratches (animal auto const&amp; the_animal);</pre>
<p>This checks that whatever is substituted for <code>auto</code> satisfies the <code>animal</code> concept. So if we instantiate the template with a <code>kitten</code> then <code>animal&lt;kitten&gt;</code> will be checked. This gives us back our terse syntax while also allowing us to constrain our template declarations.</p>
<h1 id="try-them-out">Try Them Out!</h1>
<p>Constrained auto has been supported in MSVC since <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2019 version 16.8,</a> and abbreviated function templates have recently been added to <a href="https://visualstudio.microsoft.com/vs/preview/">version 16.9 Preview 3</a>. We encourage you to download the tools and give the implementations a try! We can be reached via the comments below or via email (visualcpp@microsoft.com). If you find any problems you can use the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> tool in Visual Studio or head over to the <a href="https://developercommunity.visualstudio.com/spaces/62/index.html">Visual Studio Developer Community</a>. You can also find us on Twitter <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/">Abbreviated Function Templates and Constrained Auto</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/abbreviated-function-templates-and-constrained-auto/feed/</wfw:commentRss>
			<slash:comments>7</slash:comments>
		
		
			</item>
		<item>
		<title>Playground Games and Turn 10 Studios See 18.2X and 4.95X Link Time Improvements Respectively on Visual Studio 2019</title>
		<link>https://devblogs.microsoft.com/cppblog/playground-games-and-turn-10-studios-see-18-2x-and-4-95x-link-time-improvements-respectively-on-visual-studio-2019/</link>
					<comments>https://devblogs.microsoft.com/cppblog/playground-games-and-turn-10-studios-see-18-2x-and-4-95x-link-time-improvements-respectively-on-visual-studio-2019/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Tue, 02 Feb 2021 17:00:17 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[build throughput]]></category>
		<category><![CDATA[Build Time]]></category>
		<category><![CDATA[Compile Time]]></category>
		<category><![CDATA[Game Development]]></category>
		<category><![CDATA[Games]]></category>
		<category><![CDATA[gaming]]></category>
		<category><![CDATA[Iteration Time]]></category>
		<category><![CDATA[Linker]]></category>
		<category><![CDATA[Video Games]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27464</guid>

					<description><![CDATA[<p>Introduction</p>
<p>The C++ team at Visual Studio has delivered substantial build and link time improvements throughout Visual Studio 2019. This blog is Part 2 of a series of blogs showcasing real-world results of our efforts. See how the Gears 5 team benefited from iteration build time improvements in Part 1.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/playground-games-and-turn-10-studios-see-18-2x-and-4-95x-link-time-improvements-respectively-on-visual-studio-2019/">Playground Games and Turn 10 Studios See 18.2X and 4.95X Link Time Improvements Respectively on Visual Studio 2019</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="introduction">Introduction</h1>
<p><img class="aligncenter size-full wp-image-27478" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Sunrise_KeyArt_Horiz_RGB_Final-small.jpg" alt="Image Sunrise KeyArt Horiz RGB Final small" width="2173" height="1224" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Sunrise_KeyArt_Horiz_RGB_Final-small.jpg 2173w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Sunrise_KeyArt_Horiz_RGB_Final-small-300x169.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Sunrise_KeyArt_Horiz_RGB_Final-small-1024x577.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Sunrise_KeyArt_Horiz_RGB_Final-small-768x433.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Sunrise_KeyArt_Horiz_RGB_Final-small-1536x865.jpg 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Sunrise_KeyArt_Horiz_RGB_Final-small-2048x1154.jpg 2048w" sizes="(max-width: 2173px) 100vw, 2173px" /></p>
<p>The C++ team at Visual Studio has delivered substantial build and link time improvements throughout Visual Studio 2019. This blog is Part 2 of a series of blogs showcasing real-world results of our efforts. See how the <a href="https://devblogs.microsoft.com/cppblog/the-coalition-sees-27-9x-iteration-build-improvement-with-visual-studio-2019/">Gears 5 team benefited from iteration build time improvements in Part 1.</a></p>
<p>In this blog, the Forza Horizon 4 team shares tests results of compile and link times in three different versions of Visual Studio. Link times are now <strong>18.15X faster</strong> than in Visual Studio 2017. Likewise, Turn 10 Studios saw a <strong>4.95X</strong> improvement in link time. The decrease in build time enabled Playground Games to switch from <em>/debug:fastlink</em> to<em>/debug:full</em>. Analyzing the results, we can see not only massive iteration build time wins but also applicable real-world quality of life improvements.</p>
<p><em><strong>“Using full linking removes the debugger stalls associated with fastlink and allows our engineering team to focus on debugging the current build rather than waiting for the development environment to become responsive. Coupled with the overall improvements to build and link times, this leads to less workflow interruption and productivity improvements across the team.”</strong></em> – Andrew Sage from Playground Games</p>
<h2 id=""></h2>
<h2 id="building-forza-horizon-4">Building Forza Horizon 4</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-scaled.jpg"><img class="aligncenter size-full wp-image-27468" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-scaled.jpg" alt="Image ForzaHorizon4 Review 07 WM 4k" width="2500" height="1406" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-scaled.jpg 2500w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-300x169.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-1024x576.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-768x432.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-1536x864.jpg 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_Review_07_WM_4k-2048x1152.jpg 2048w" sizes="(max-width: 2500px) 100vw, 2500px" /></a></p>
<h3 id=""></h3>
<h3 id="methodology">Methodology</h3>
<p>The Forza Horizon 4 team at Playground Games measured build times using Incredibuild’s build monitor. The monitor shows wall clock time for each stage of the process. Compile time is measured at the start of the first file compile to immediately before linking. Link time is measured from start of the link step to the end of link step. Total time, measured by the start-to-end Incredibuild process, may be longer than compile and link times combined since some startup and post link steps are included in the measurement.</p>
<p>Tests were conducted during quiet times at the studio to ensure parallel compiles were not affected by network load. To further reduce noise in data, tests were averaged over multiple runs, and were started after all hard drive disk activity had finished and Intellisense had finished parsing.</p>
<h3 id=""></h3>
<h3 id="results">Results</h3>
<h4 id="version-15-9-4-debugfastlink-vs-16-8-debugfull">Version 15.9.4 /debug:<strong>fastlink</strong> vs 16.8 /debug:<strong>full</strong></h4>
<p>Comparing <em>/debug:fastlink</em> in Visual Studio 2017 and <em>/debug:full</em> in Visual Studio 2019 demonstrated real-world quality of life improvements. At first sight, total time has improved by a factor of <strong>1.26</strong>; however, considerable time of <strong>30-45 seconds</strong> per debug session was saved by switching to <em>/debug:full</em>, resulting in large productivity gains. The engineers at Playground Games have made the switch to <em>/debug:full</em> in order to both enjoy shorter build times and take advantage of the faster debugging experience afforded by <em>/debug:full</em>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-fastvsfull.png"><img class="aligncenter size-full wp-image-27476" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-fastvsfull.png" alt="Image FH fastvsfull" width="1900" height="1189" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-fastvsfull.png 1900w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-fastvsfull-300x188.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-fastvsfull-1024x641.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-fastvsfull-768x481.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-fastvsfull-1536x961.png 1536w" sizes="(max-width: 1900px) 100vw, 1900px" /></a></p>
<p>&nbsp;</p>
<table style="width: 100.067%;" width="451">
<tbody>
<tr>
<td style="width: 43.6123%; text-align: center;" width="198"><strong>Total Time (minutes)</strong></td>
<td style="width: 26.8722%; text-align: center;" width="122"><strong>Full rebuild</strong></td>
<td style="width: 184.263%; text-align: center;" width="131"><strong>Single file change</strong></td>
</tr>
<tr>
<td style="width: 43.6123%; text-align: center;" width="198">VS2017 15.9.4 /debug:<strong>fastlink</strong></td>
<td style="width: 26.8722%; text-align: center;" width="122">4:22</td>
<td style="width: 184.263%; text-align: center;" width="131">1:39</td>
</tr>
<tr>
<td style="width: 43.6123%; text-align: center;" width="198">VS2019 16.8    /debug:<strong>full</strong></td>
<td style="width: 26.8722%; text-align: center;" width="122">3:40</td>
<td style="width: 184.263%; text-align: center;" width="131">1:15</td>
</tr>
<tr>
<td style="width: 43.6123%; text-align: center;" width="198"><em>x times faster </em></td>
<td style="width: 26.8722%; text-align: center;" width="122">1.19</td>
<td style="width: 184.263%; text-align: center;" width="131">1.32</td>
</tr>
<tr>
<td style="width: 43.6123%; text-align: center;" width="198"><strong><em>average x times faster</em></strong></td>
<td style="width: 26.8722%; text-align: center;" width="122"><strong>1.26</strong></td>
<td style="width: 184.263%; text-align: center;" width="131"></td>
</tr>
</tbody>
</table>
<h4 id=""></h4>
<h4 id="version-15-9-4-vs-16-8-using-debugfull">Version 15.9.4 vs 16.8 using /debug:full</h4>
<p>In the second test, a comparison of builds using <em>/debug:full</em> was done over 3 versions of Visual Studio. The compilation time has been improved by a factor of <strong>1.52. </strong>When doing a full rebuild, the compile time decreased from 4 minutes 39 seconds in Visual Studio 2017 to 3 minutes 5 seconds in Visual Studio 2019 16.8. For a single file change, a 19 second reduction was observed. On average, the link times improved by a factor of <strong>18.15X. </strong>The full rebuild link time in Visual Studio 2019 16.8 <strong>decreased by 10 minutes 18 seconds</strong>, a monumental improvement.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-compile.png"><img class="aligncenter size-full wp-image-27469" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-compile.png" alt="Image FH compile" width="1898" height="1233" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-compile.png 1898w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-compile-300x195.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-compile-1024x665.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-compile-768x499.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-compile-1536x998.png 1536w" sizes="(max-width: 1898px) 100vw, 1898px" /></a></p>
<p>&nbsp;</p>
<table style="width: 99.6422%; height: 333px;" width="451">
<tbody>
<tr style="height: 55px;">
<td style="width: 41.63%; height: 55px; text-align: center;" width="189"><strong>Compile Time (minutes)</strong></td>
<td style="width: 29.0749%; height: 55px; text-align: center;" width="131"><strong>Full rebuild</strong></td>
<td style="width: 193.392%; height: 55px; text-align: center;" width="131"><strong>Single file change</strong></td>
</tr>
<tr style="height: 55px;">
<td style="width: 41.63%; height: 55px; text-align: center;" width="189">VS2017 15.9.4 /debug:full</td>
<td style="width: 29.0749%; height: 55px; text-align: center;" width="131">4:39</td>
<td style="width: 193.392%; height: 55px; text-align: center;" width="131">0:55</td>
</tr>
<tr style="height: 55px;">
<td style="width: 41.63%; height: 55px; text-align: center;" width="189">VS2019 16.7.2 /debug:full</td>
<td style="width: 29.0749%; height: 55px; text-align: center;" width="131">3:31</td>
<td style="width: 193.392%; height: 55px; text-align: center;" width="131">0:37</td>
</tr>
<tr style="height: 55px;">
<td style="width: 41.63%; height: 55px; text-align: center;" width="189">VS2019 16.8    /debug:full</td>
<td style="width: 29.0749%; height: 55px; text-align: center;" width="131">3:05</td>
<td style="width: 193.392%; height: 55px; text-align: center;" width="131">0:36</td>
</tr>
<tr style="height: 55px;">
<td style="width: 41.63%; height: 55px; text-align: center;" width="189"><em>x times faster</em></td>
<td style="width: 29.0749%; height: 55px; text-align: center;" width="131">1.51</td>
<td style="width: 193.392%; height: 55px; text-align: center;" width="131">1.53</td>
</tr>
<tr style="height: 55px;">
<td style="width: 41.63%; height: 55px; text-align: center;" width="189"><strong><em>average x times faster</em></strong></td>
<td style="width: 29.0749%; height: 55px; text-align: center;" width="131"><strong>1.52</strong></td>
<td style="width: 193.392%; height: 55px; text-align: center;" width="131"></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-link.png"><img class="aligncenter size-full wp-image-27471" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-link.png" alt="Image FH link" width="1901" height="1177" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-link.png 1901w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-link-300x186.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-link-1024x634.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-link-768x476.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-link-1536x951.png 1536w" sizes="(max-width: 1901px) 100vw, 1901px" /></a></p>
<p>&nbsp;</p>
<table style="width: 100.143%; height: 331px;" width="451">
<tbody>
<tr>
<td style="width: 41.63%; text-align: center;" width="189"><strong>Link Time (minutes)</strong></td>
<td style="width: 29.0749%; text-align: center;" width="131"><strong>Full rebuild</strong></td>
<td style="width: 192.07%; text-align: center;" width="131"><strong>Single file change</strong></td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189">VS2017 15.9.4 /debug:full</td>
<td style="width: 29.0749%; text-align: center;" width="131">10:53</td>
<td style="width: 192.07%; text-align: center;" width="131">11:28</td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189">VS2019 16.7.2 /debug:full</td>
<td style="width: 29.0749%; text-align: center;" width="131">1:23</td>
<td style="width: 192.07%; text-align: center;" width="131">1:39</td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189">VS2019 16.8    /debug:full</td>
<td style="width: 29.0749%; text-align: center;" width="131">0:35</td>
<td style="width: 192.07%; text-align: center;" width="131">0:39</td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189"><em>x times faster</em></td>
<td style="width: 29.0749%; text-align: center;" width="131"><strong>18.66</strong></td>
<td style="width: 192.07%; text-align: center;" width="131"><strong>17.64</strong></td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189"><strong><em>average x times faster</em></strong></td>
<td style="width: 29.0749%; text-align: center;" width="131"><strong>18.15</strong></td>
<td style="width: 192.07%; text-align: center;" width="131"></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total.png"><img class="aligncenter size-full wp-image-27491" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total.png" alt="Image FH total" width="2156" height="994" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total.png 2156w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total-300x138.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total-1024x472.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total-768x354.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total-1536x708.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FH-total-2048x944.png 2048w" sizes="(max-width: 2156px) 100vw, 2156px" /></a></p>
<table style="width: 99.265%; height: 332px;" width="451">
<tbody>
<tr>
<td style="width: 41.63%; text-align: center;" width="189"><strong>Total Time (minutes)</strong></td>
<td style="width: 29.0749%; text-align: center;" width="131"><strong>Full rebuild</strong></td>
<td style="width: 193.392%; text-align: center;" width="131"><strong>Single file change</strong></td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189">VS2017 15.9.4 /debug:full</td>
<td style="width: 29.0749%; text-align: center;" width="131">15:32</td>
<td style="width: 193.392%; text-align: center;" width="131">12:23</td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189">VS2019 16.7.2 /debug:full</td>
<td style="width: 29.0749%; text-align: center;" width="131">4:54</td>
<td style="width: 193.392%; text-align: center;" width="131">3:40</td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189">VS2019 16.8    /debug:full</td>
<td style="width: 29.0749%; text-align: center;" width="131">3:40</td>
<td style="width: 193.392%; text-align: center;" width="131">1:15</td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189"><em>x times faster </em></td>
<td style="width: 29.0749%; text-align: center;" width="131">4.24</td>
<td style="width: 193.392%; text-align: center;" width="131">9.91</td>
</tr>
<tr>
<td style="width: 41.63%; text-align: center;" width="189"><strong><em>average x times faster</em></strong></td>
<td style="width: 29.0749%; text-align: center;" width="131"><strong>7.07</strong></td>
<td style="width: 193.392%; text-align: center;" width="131"></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2 id="building-forza-motorsport">Building Forza Motorsport</h2>
<h3 id="methodology">Methodology</h3>
<p>At Turn 10 Studios, the Forza Motorsport team used MSBuild’s Structured Log Viewer to obtain build and compile times. Each of the times below are the result of an average over 4 runs. CL refers to cl.exe (MSVC Compiler) and Lib refers to lib.exe (Microsoft Library Manager). While Full Build indicates total time, Debug, CL, and Lib times were chosen to be showcased; each time was averaged individually.</p>
<h3 id="results">Results</h3>
<h4 id="version-15-9-vs-16-7-profile-build-with-debugfastlink">Version 15.9 vs 16.7 Profile Build with /debug:fastlink</h4>
<p>When doing a full Profile build with /debug:fastlink, we can see a moderate improvement in build time while link time has improved by a factor of <strong>1.96</strong>. Lib time has been decreased by <strong>9.34X</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fastlink.png"><img class="aligncenter size-full wp-image-27473" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fastlink.png" alt="Image FM fastlink" width="1653" height="992" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fastlink.png 1653w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fastlink-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fastlink-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fastlink-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fastlink-1536x922.png 1536w" sizes="(max-width: 1653px) 100vw, 1653px" /></a></p>
<p>&nbsp;</p>
<table style="width: 98.6891%; height: 221px;" width="597">
<tbody>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139"><strong>Time (seconds)</strong></td>
<td style="width: 21.393%; text-align: center;" width="128"><strong>Full Build (Profile)</strong></td>
<td style="width: 21.393%; text-align: center;" width="128"><strong>Debug Fastlink</strong></td>
<td style="width: 16.9154%; text-align: center;" width="101"><strong>CL</strong></td>
<td style="width: 138.806%; text-align: center;" width="101"><strong>Lib</strong></td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139">VS2017 15.9</td>
<td style="width: 21.393%; text-align: center;" width="128">285.5</td>
<td style="width: 21.393%; text-align: center;" width="128">18</td>
<td style="width: 16.9154%; text-align: center;" width="101">38.9</td>
<td style="width: 138.806%; text-align: center;" width="101">43.9</td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139">VS2019 16.7</td>
<td style="width: 21.393%; text-align: center;" width="128">249.75</td>
<td style="width: 21.393%; text-align: center;" width="128">9.2</td>
<td style="width: 16.9154%; text-align: center;" width="101">40.5</td>
<td style="width: 138.806%; text-align: center;" width="101">4.7</td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139"><em>x times faster </em></td>
<td style="width: 21.393%; text-align: center;" width="128">1.14</td>
<td style="width: 21.393%; text-align: center;" width="128">1.96</td>
<td style="width: 16.9154%; text-align: center;" width="101">0.96</td>
<td style="width: 138.806%; text-align: center;" width="101">9.34</td>
</tr>
</tbody>
</table>
<h4 id="version-15-9-vs-16-7-profile-build-with-debugfulllink">Version 15.9 vs 16.7 Profile Build with /debug:fulllink</h4>
<p>Using /debug:fulllink, we can see much more favorable numbers. Full build time is now <strong>1.71X</strong> faster. Similarly, link time has been improved by a factor of <strong>4.95</strong>. Lib time was also improved by <strong>10.86X</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fulllink.png"><img class="aligncenter size-full wp-image-27474" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fulllink.png" alt="Image FM fulllink" width="1653" height="993" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fulllink.png 1653w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fulllink-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fulllink-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fulllink-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-fulllink-1536x923.png 1536w" sizes="(max-width: 1653px) 100vw, 1653px" /></a></p>
<p>&nbsp;</p>
<table style="width: 99.2714%;" width="597">
<tbody>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139"><strong>Time (seconds)</strong></td>
<td style="width: 21.393%; text-align: center;" width="128"><strong>Full Build (Profile)</strong></td>
<td style="width: 21.393%; text-align: center;" width="128"><strong>Debug Fulllink</strong></td>
<td style="width: 16.9154%; text-align: center;" width="101"><strong>CL</strong></td>
<td style="width: 135.323%; text-align: center;" width="101"><strong>Lib</strong></td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139">VS2017 15.9</td>
<td style="width: 21.393%; text-align: center;" width="128">431</td>
<td style="width: 21.393%; text-align: center;" width="128">172</td>
<td style="width: 16.9154%; text-align: center;" width="101">34</td>
<td style="width: 135.323%; text-align: center;" width="101">38</td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139">VS2019 16.7</td>
<td style="width: 21.393%; text-align: center;" width="128">251.75</td>
<td style="width: 21.393%; text-align: center;" width="128">34.75</td>
<td style="width: 16.9154%; text-align: center;" width="101">34.75</td>
<td style="width: 135.323%; text-align: center;" width="101">3.5</td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139"><em>x times faster </em></td>
<td style="width: 21.393%; text-align: center;" width="128">1.71</td>
<td style="width: 21.393%; text-align: center;" width="128">4.95</td>
<td style="width: 16.9154%; text-align: center;" width="101">0.98</td>
<td style="width: 135.323%; text-align: center;" width="101">10.86</td>
</tr>
</tbody>
</table>
<h3 id=""></h3>
<h4 id="version-15-9-vs-16-7-release-build">Version 15.9 vs 16.7 Release Build</h4>
<p>For the Release Build, we see similar improvements as above. Build time decreased by <strong>1.81X</strong> and link time improved by a factor of <strong>2.44</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-release.png"><img class="aligncenter size-full wp-image-27475" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-release.png" alt="Image FM release" width="1653" height="993" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-release.png 1653w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-release-300x180.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-release-1024x615.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-release-768x461.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/FM-release-1536x923.png 1536w" sizes="(max-width: 1653px) 100vw, 1653px" /></a></p>
<p>&nbsp;</p>
<table style="width: 99.4975%;" width="597">
<tbody>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139"><strong>Time (seconds)</strong></td>
<td style="width: 21.393%; text-align: center;" width="128"><strong>Full Build (Release)</strong></td>
<td style="width: 21.393%; text-align: center;" width="128"><strong>Link</strong></td>
<td style="width: 16.9154%; text-align: center;" width="101"><strong>CL</strong></td>
<td style="width: 135.821%; text-align: center;" width="101"><strong>Lib</strong></td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139">VS2017 15.9</td>
<td style="width: 21.393%; text-align: center;" width="128">664</td>
<td style="width: 21.393%; text-align: center;" width="128">479</td>
<td style="width: 16.9154%; text-align: center;" width="101">30</td>
<td style="width: 135.821%; text-align: center;" width="101">34.5</td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139">VS2019 16.7</td>
<td style="width: 21.393%; text-align: center;" width="128">367</td>
<td style="width: 21.393%; text-align: center;" width="128">196</td>
<td style="width: 16.9154%; text-align: center;" width="101">29</td>
<td style="width: 135.821%; text-align: center;" width="101">29</td>
</tr>
<tr>
<td style="width: 23.2172%; text-align: center;" width="139"><em>x times faster </em></td>
<td style="width: 21.393%; text-align: center;" width="128">1.81</td>
<td style="width: 21.393%; text-align: center;" width="128">2.44</td>
<td style="width: 16.9154%; text-align: center;" width="101">1.03</td>
<td style="width: 135.821%; text-align: center;" width="101">1.19</td>
</tr>
</tbody>
</table>
<h2 id=""></h2>
<h2 id="analysis">Analysis</h2>
<p>The significant build iteration time improvement is a direct result of optimization efforts by the C++ Team. Linker performance was improved in version 16.0 and 16.2 by <a href="https://devblogs.microsoft.com/cppblog/game-performance-and-compilation-time-improvements-in-visual-studio-2019/">speeding up Program Database (PDB) file generation and type merging</a>. Algorithmic changes in 16.6 and worse case Incremental Linking improvements in 16.7 <a href="https://devblogs.microsoft.com/cppblog/faster-c-iteration-builds/">increased optimization of Linker performance</a>.  In version 16.8, multi-threading generation of PDB files further improved performance. Stay tuned for a technical blogpost detailing 16.8 improvements.</p>
<h2 id="developer-conversation">Developer Conversation</h2>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish.jpg"><img class="aligncenter size-full wp-image-27467" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish.jpg" alt="Image ForzaHorizon4 E3PressKit WM 11 ClassicBritish" width="2235" height="1258" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish.jpg 2235w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish-300x169.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish-1024x576.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish-768x432.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish-1536x865.jpg 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/ForzaHorizon4_E3PressKit_WM_11_ClassicBritish-2048x1153.jpg 2048w" sizes="(max-width: 2235px) 100vw, 2235px" /></a></p>
<p>We spoke with <strong>Andrew Sage</strong> <strong>from Playground Games</strong> (Forza Horizon 4) and <strong>Dan Tunnell</strong> <strong>from Turn 10 Studios</strong> (Forza Motorsport) for some insights into how the improvements have affected their studios.</p>
<p>Is the studio currently using Visual Studio 2019?</p>
<blockquote><p>“We have a mix of VS2017 and VS2019, depending on setup. Most engineers have moved to VS2019 for the main project, but we still have some tools projects that haven’t been updated yet and are still using 2017.” – Andrew</p></blockquote>
<p>&nbsp;</p>
<blockquote><p>“We just moved the whole studio to Visual Studio 2019 in the last week of January 2021.  We&#8217;ve had one of our development branches running it since before the holidays but it just reached broad adoption a couple of days ago.” – Dan</p></blockquote>
<p>&nbsp;</p>
<p>What were some immediate benefits that you saw from faster link times?</p>
<blockquote><p>“Reducing iteration time to build and test changes allows us to be more productive, especially as gains add up over the course of all of the engineers multiple times per day. The main benefit was the removal of stalls when debugging with fast link when switching to full link, as these would add 30-45 seconds per debug session, which can be repeated multiple times per build.” – Andrew</p></blockquote>
<p>&nbsp;</p>
<blockquote><p>“The biggest benefit I see is improved iteration time.  Even if we only shave 30 seconds off link time, multiplying that by the number of devs in the studio and the number of times they compile each day becomes a large number really quick.” – Dan</p></blockquote>
<p>&nbsp;</p>
<p>What are some potential long-term benefits?</p>
<blockquote><p>“Longer term, we will also be moving all our automated build servers over to Visual Studio 2019 to reduce our build validation and test turnaround times. This means a reduction in time from checking in code to knowing that the build has succeeded. Also, there will be less changes per build as these builds run continuously. Moving all our tools projects over to Visual Studio 2019 in the future would lead to a further productivity benefit for the tools team, and their ability to spend more time supporting our content creators.” – Andrew</p></blockquote>
<p>&nbsp;</p>
<blockquote><p>“One of the longer-term benefits is reduced build times on our server farm.  If someone checks in code that breaks the build, the faster we catch it the less downtime we experience.  It also gives us faster tooling iteration since the time between a developer checking in new tooling code and the build system checking in new tools binaries is reduced.  Additionally, there&#8217;s reduced time for &#8220;validation&#8221; builds.  Prior to checking in, each developer builds a representative sample of the game binaries to ensure that they haven&#8217;t broken anything.  This slows iteration (I&#8217;m sure you can see a pattern emerging &#8211; iteration time is king) and anything we can do to speed that up is extremely valuable.” – Dan</p></blockquote>
<p>&nbsp;</p>
<p>How might the link time improvements change the workflow patterns of the studio?</p>
<blockquote><p>“Besides the improvement in focusing on fixing issues rather than waiting for builds to complete across the team, I think we will be able to focus on other productivity gains which then become a larger overall proportion of our processes. For instance, reducing dependencies in our codebase can improve build times even with the faster toolset and distributed build systems, and we will continue to focus our efforts in this area in the future. Also, using full link allows for less mental ‘task switching’ overhead caused by the stalls, as often when someone hits a stall they might swap to another task for a bit and then back in later, which can cause workflow to become interrupted.” – Andrew</p></blockquote>
<p>&nbsp;</p>
<blockquote><p>“If I were to guess, I&#8217;d say that we&#8217;ll see less build breaks.  Validation builds take a significant amount of time to complete.  Even though they&#8217;re required, sometimes developers will omit that step if they&#8217;re in a hurry and feel confident that their fix is trivial enough to be safe.  The faster the build times are the lower that barrier to entry is and the more likely people will perform that step even for changes they consider to be trivial and/or safe.  I also think we might see less code changes between compilations.  The longer compilation and linking takes the more code a developer will add before they hit the button to compile.  If compilation and linking is almost instantaneous, most developers will use that as a quick sanity check to verify that the method/function/class/etc. that they just added compiles before moving on.” – Dan</p></blockquote>
<h1 id="upgrade-visual-studio">Upgrade Visual Studio</h1>
<p><a href="http://aka.ms/vspreview">Download the latest Visual Studio 2019 Preview</a> and experience faster end-to-end build iteration times for your own projects.</p>
<p>How will these improvements impact your day-to-day workflow? Talk to us in the comments below, on <a href="https://twitter.com/VisualC">Twitter (@VisualC)</a>, or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/playground-games-and-turn-10-studios-see-18-2x-and-4-95x-link-time-improvements-respectively-on-visual-studio-2019/">Playground Games and Turn 10 Studios See 18.2X and 4.95X Link Time Improvements Respectively on Visual Studio 2019</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/playground-games-and-turn-10-studios-see-18-2x-and-4-95x-link-time-improvements-respectively-on-visual-studio-2019/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Seamlessly Accelerate CMake Projects in Visual Studio with Incredibuild</title>
		<link>https://devblogs.microsoft.com/cppblog/seamlessly-accelerate-cmake-projects-in-visual-studio-with-incredibuild/</link>
					<comments>https://devblogs.microsoft.com/cppblog/seamlessly-accelerate-cmake-projects-in-visual-studio-with-incredibuild/#comments</comments>
		
		<dc:creator><![CDATA[Nick Uhlenhuth]]></dc:creator>
		<pubDate>Wed, 27 Jan 2021 15:00:18 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27444</guid>

					<description><![CDATA[<p>Visual Studio 2017 shipped with first-class CMake support. Since then, we’ve continued to improve our CMake support by adding new features based on your feedback. We previously blogged about the built-in Incredibuild support for accelerating and visualizing your vcxproj projects, and many of you asked to get this same level of support for your CMake projects.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/seamlessly-accelerate-cmake-projects-in-visual-studio-with-incredibuild/">Seamlessly Accelerate CMake Projects in Visual Studio with Incredibuild</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Visual Studio 2017 shipped with <a href="https://devblogs.microsoft.com/cppblog/cmake-support-in-visual-studio/">first-class CMake support</a>. Since then, we’ve continued to improve our CMake support by adding new features based on your feedback. We previously blogged about the <a href="https://devblogs.microsoft.com/cppblog/visualize-your-build-with-incredibuilds-build-monitor-and-visual-studio-2019/">built-in Incredibuild support for accelerating and visualizing your vcxproj projects</a>, and many of you asked to get this same level of support for your CMake projects. We’re happy to announce that Incredibuild can now be used to accelerate the Windows builds of your CMake projects from within Visual Studio.</p>
<h3 id="incredibuild-recap"><strong>Incredibuild Recap</strong></h3>
<p>The backbone of Incredibuild’s offering, <a href="https://www.incredibuild.com/technology?utm_source=visual_studio_blog&amp;utm_medium=referral">Virtualized Distributed Processing</a><img src="https://s.w.org/images/core/emoji/13.0.1/72x72/2122.png" alt="™" class="wp-smiley" style="height: 1em; max-height: 1em;" /> enables a workload that consists of multiple, concurrent processes to be automatically and dynamically distributed to hundreds, and even thousands of idle CPUs on remote machine across your network or public cloud. Because CMake builds consist of hundreds of compilation tasks that can be executed in parallel, having hundreds of cores at your disposal can highly accelerate build times, which is exactly what distributed computing offers.</p>
<p>Virtualized Distributed Processing<img src="https://s.w.org/images/core/emoji/13.0.1/72x72/2122.png" alt="™" class="wp-smiley" style="height: 1em; max-height: 1em;" /> can even use idle CPUs on remote machines while users are working on them – operating in the background. In organizations that have hundreds of machines, the aggregated number of idle CPUs in any given moment can easily be in the thousands. These are wasted cores that Incredibuild recaptures to accelerate time consuming workloads in need of computing power.</p>
<p>Incredibuild runs processes on remote machines in a secure sandbox. Everything a process requires to run properly is dynamically emulated by Incredibuild from the local host to the remote machine. <strong>This means all you need to install on remote machines is the Incredibuild Agent – there’s no need to install Visual Studio, nor your source code or any other build tools.</strong> Any output generated by the remotely executed process &#8211; std output, errors, return codes, files generated, etc. – is automatically synched back to the local host, as if the process had been executed locally.</p>
<h3 id="using-visual-studio-cmake-incredibuild"><strong>Using Visual Studio + CMake + Incredibuild</strong></h3>
<p>In the Visual Studio Installer, ensure that the checkboxes for “C++ CMake tools for Windows” and “IncrediBuild – Build Acceleration” are selected:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/installer.png"><img class="alignnone wp-image-27445 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/installer.png" alt="The checklist of optional features to install, including CMake Tools and Incredibuild" width="416" height="497" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/installer.png 416w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/installer-251x300.png 251w" sizes="(max-width: 416px) 100vw, 416px" /></a></p>
<p>Once installed, an Incredibuild toolbar and menu appear in the Visual Studio development environment, offering Incredibuild’s distributed Build and Rebuild operations.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/buildIDE.gif"><img class="alignnone wp-image-27446 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/buildIDE.gif" alt="Animated gif showing Incredibuild building a project in a distributed fashion on many cores " width="1552" height="818" /></a></p>
<h3 id="visualizing-your-build-with-incredibuilds-build-monitor"><strong>Visualizing your build with Incredibuild’s Build Monitor</strong></h3>
<p>Another benefit of Incredibuild that you can take advantage of from directly within the IDE is the <a href="https://www.incredibuild.com/the-build-monitor?utm_source=visual_studio_blog&amp;utm_medium=referral">Incredibuild Build Monitor</a> tool. This build visualization tool replaces your old text output with a sleek, intuitive graphic UI, transforming your build into a visual entity you can easily engage with, and helps you spot long durations, errors, warnings, bottlenecks, and dependencies.</p>
<p>Let’s take a look at the standard text output we’re all used to working with:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/terminal.jpg"><img class="alignnone wp-image-27447 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/terminal.jpg" alt="Plain text output" width="618" height="215" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/terminal.jpg 618w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/terminal-300x104.jpg 300w" sizes="(max-width: 618px) 100vw, 618px" /></a></p>
<p>Now take a look at how a build looks like with Incredibuild’s Build Monitor tool, seamlessly integrated into the Visual Studio experience:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitor.jpg"><img class="alignnone wp-image-27448 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitor.jpg" alt="Visual build monitor, showing passed tasks, tasks with warning, and a system utilization graph on a timeline" width="1430" height="754" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitor.jpg 1430w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitor-300x158.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitor-1024x540.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitor-768x405.jpg 768w" sizes="(max-width: 1430px) 100vw, 1430px" /></a></p>
<p>Each color represents the build task status, allowing you to immediately identify which build tasks were executed without a problem and which require your attention. The bar width represents the duration of a specific task, and the side navigation bar lays out the specific machine and core on which the task was executed.</p>
<p>For more information, refer to the <a href="https://devblogs.microsoft.com/cppblog/visualize-your-build-with-incredibuilds-build-monitor-and-visual-studio-2019/">previous blog post on Incredibuild’s Build Monitor</a>.</p>
<h3 id="how-much-faster-are-cmake-builds-with-incredibuild"><strong>How much faster are CMake builds with Incredibuild? </strong></h3>
<p>The following data is based on running CMake with MSBuild by compiling the popular core OpenCV open-source project to establish a known base line. This example uses the Ninja generator, but all the Visual Studio generators are supported. Here are the results with Incredibuild:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/chart.png"><img class="alignnone wp-image-27449 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/chart.png" alt="Graph showing the following results of number of machines and cores against build time: 1 machine, 8 cores took 16 minutes. 4 machines, 22 cores took 6:26. 5 machines, 30 cores took 4:42. 10 machines, 112 cores took 1:42." width="713" height="271" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/chart.png 713w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/chart-300x114.png 300w" sizes="(max-width: 713px) 100vw, 713px" /></a></p>
<p>Here is what the CMake OpenCV build looks like in the Build Monitor.</p>
<p><strong> <a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitorgif.gif"><img class="alignnone wp-image-27450 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/monitorgif.gif" alt="Animated gif showing the build monitor for a large build, with the tasks being distributed across many machines" width="600" height="338" /></a></strong></p>
<p>All in all, there is a 9.5X performance boost which means developers can spend more time building great code in the zone and less time waiting for code to build. In this specific use-case, adding additional cores to the Incredibuild pool, on top of the 100 cores used in this example, will result in even better compile time.</p>
<h3 id="continuous-integration-continuous-improvement"><strong>Continuous integration, Continuous improvement</strong></h3>
<p>You can use the same Incredibuild infrastructure to accelerate your CMake project under your CI/CD of choice for the full experience and to also accelerate unit tests that are part of your build or other compute intensive processes such as code analysis, code signing, various test types and more.</p>
<h3 id="talk-to-us">Talk To Us</h3>
<p>We encourage you to <a href="https://visualstudio.microsoft.com/downloads/">download Visual Studio 2019</a> and try the <a href="https://www.incredibuild.com/?utm_source=visual_studio_blog&amp;utm_medium=referral">Incredibuild</a> functionality. We can be reached via the comments below or via email (visualcpp@microsoft.com). If you encounter other problems with Visual Studio or have other suggestions you can use the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> tool in Visual Studio or head over to the <a href="https://developercommunity.visualstudio.com/spaces/62/index.html">Visual Studio Developer Community</a>. You can also find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/seamlessly-accelerate-cmake-projects-in-visual-studio-with-incredibuild/">Seamlessly Accelerate CMake Projects in Visual Studio with Incredibuild</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/seamlessly-accelerate-cmake-projects-in-visual-studio-with-incredibuild/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Blizzard Diablo IV debugs Linux core dumps from Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/blizzard-diablo-iv-debugs-linux-core-dumps-from-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/blizzard-diablo-iv-debugs-linux-core-dumps-from-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Erika]]></dc:creator>
		<pubDate>Tue, 26 Jan 2021 16:49:13 +0000</pubDate>
				<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27431</guid>

					<description><![CDATA[<p>Blizzard is using Visual Studio 2019 to debug Linux core dumps on WSL. The following blog post is written by Bill Randolph, a Senior Software Engineer at Blizzard working on the development of Diablo IV. Thanks for your partnership, Bill!</p>
<p>Introduction<br />
On Diablo IV we develop all our code on Windows and compile for multiple platforms. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/blizzard-diablo-iv-debugs-linux-core-dumps-from-visual-studio/">Blizzard Diablo IV debugs Linux core dumps from Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Blizzard is using Visual Studio 2019 to <a href="https://devblogs.microsoft.com/cppblog/debug-linux-core-dumps-in-visual-studio/">debug Linux core dumps on WSL</a>. <strong>The following blog post is written by Bill Randolph, a Senior Software Engineer at Blizzard working on the development of Diablo IV.</strong> Thanks for your partnership, Bill!</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/16_9_background_lilith.jpg"><img class="aligncenter size-full wp-image-27432" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/16_9_background_lilith.jpg" alt="A character from Diablo IV with the title &quot;Diablo IV&quot;." width="1920" height="1080" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/16_9_background_lilith.jpg 1920w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/16_9_background_lilith-300x169.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/16_9_background_lilith-1024x576.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/16_9_background_lilith-768x432.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/16_9_background_lilith-1536x864.jpg 1536w" sizes="(max-width: 1920px) 100vw, 1920px" /></a></p>
<h4 id="introduction">Introduction</h4>
<p>On Diablo IV we develop all our code on Windows and compile for multiple platforms.  This includes our servers, which run on Linux.  (The code includes conditional compilation and custom platform-specific code where necessary).  There are multiple reasons for this workflow.  For one, our team’s core competency is on Windows.  Even our server programmers are most familiar with Windows development, and we appreciate the ability for all the programmers on our team to use a common toolset and knowledge base.</p>
<p>The other, and most important reason that we develop on Windows is the functionality and robust toolset provided by Visual Studio.  There is nothing quite comparable in the Linux world, even if we were to develop natively in Linux.</p>
<p>However, this presents us with some challenges when a deployed server crashes and we want to debug the resulting core dump.  There is the option to remote login to the VM (or more specifically the container) that crashed and run gdb to diagnose the crash there.  But there are numerous disadvantages to this.  For one, we don’t deploy source with our binaries, so source is not available in a gdb session on a VM or container.</p>
<p>Another hurdle is gdb itself: unless you use gdb on a very regular basis, you don’t retain a level of proficiency with it that makes it convenient for our use.  Putting it simply, our developers would much rather use familiar tools to debug.  Since only 2 or 3 of our developers have much proficiency with gdb, they become the de-facto resource for diagnosing production crashes, and that’s not optimal.</p>
<p>We have always wanted a more intuitive approach for debugging our Linux cores.  That’s why we are so excited to be able to utilize the new Visual Studio feature that lets us do just that in the familiar environment of Visual Studio!  It really is not an exaggeration to say that this is a dream come true.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Combat-Crypts-Sorceress-Ghouls.jpg"><img class="aligncenter size-full wp-image-27433" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Combat-Crypts-Sorceress-Ghouls.jpg" alt="An image of combat gameplay in Diablo IV." width="1773" height="1080" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Combat-Crypts-Sorceress-Ghouls.jpg 1773w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Combat-Crypts-Sorceress-Ghouls-300x183.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Combat-Crypts-Sorceress-Ghouls-1024x624.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Combat-Crypts-Sorceress-Ghouls-768x468.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/Combat-Crypts-Sorceress-Ghouls-1536x936.jpg 1536w" sizes="(max-width: 1773px) 100vw, 1773px" /></a></p>
<h4 id="our-debugging-workflow">Our debugging workflow</h4>
<p>The Visual Studio Linux core debug workflow is enabled only if you install WSL or <a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-160&amp;viewFallbackFrom=vs-2019">add a Linux connection to the Connection Manager</a>. All our server developers install WSL, using the distribution we deploy on.  We run a script I wrote that also installs all the development tools and support libraries needed to build our server within WSL.</p>
<p>(As a brief side topic, I want to emphasize that we have found WSL to be the best available Linux environment for developers to test their changes in a Linux build.  It’s incredibly convenient to hop into WSL, cd into the shared code directory, and build right from there.  This is a much better solution than running a VM, or even a container.  If you are building with CMake, then you can also leverage Visual Studio’s <a href="https://devblogs.microsoft.com/cppblog/c-with-visual-studio-2019-and-windows-subsystem-for-linux-wsl/">native support for WSL</a>.)</p>
<p>Let me provide a little background about our build.  We develop our code on Windows and have a Windows version of our servers that can run under Windows.  This is useful for normal feature development.  However, we deploy our servers on Linux, which requires a build generated on Linux itself.  The Linux build is generated on a build farm that uses a build system on a Linux box to build the server, and its container that gets deployed.  The Linux executable is only deployed in a container and the developers normally don’t have access to it.</p>
<p>When a server crashes in our infrastructure an automated process notifies us and the core file is archived to a network share.  To debug a core in either Linux, or using Visual Studio, you must have the executable that was running; it also helps to debug with the exact shared libraries used on the deployed container.  We use another script to obtain these files.  First, we copy the core to our local machine then run the script and point it to the core. The script downloads the Docker container that was built with that version, extracts the server binary from it, along with certain shared runtime libraries for gdb’s use.  (This avoids gdb compatibility problems you may encounter if your WSL version does not exactly match the deployed Linux version.)  The script writes to ~/.gdbinit to set up the shared libraries as system libraries for the debug session.</p>
<p>Then we switch over to Visual Studio, where the fun begins. We load the solution to build our Windows version of our servers. Then we open the new debug dialog under <strong>Debug -&gt; Other Debug Targets -&gt; Debug Linux Core Dump with Native Only</strong>. We enable the checkbox that says “Debug on WSL” and fill in the (WSL-specific!) path to both the core file and the server binary. After that, we hit Debug &amp; watch the show!</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/coreDumpUI.png"><img class="aligncenter size-full wp-image-27434" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/coreDumpUI.png" alt="A dialog in Visual Studio with the title &quot;Debug Linux core dump (native only). The checkbox &quot;Debug on WSL&quot; is selected." width="819" height="382" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/coreDumpUI.png 819w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/coreDumpUI-300x140.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/coreDumpUI-768x358.png 768w" sizes="(max-width: 819px) 100vw, 819px" /></a></p>
<p>Visual Studio invokes gdb in our WSL behind the scenes. After some disk activity, up pops a call stack for the crash with the instruction pointer on the relevant line of code. It’s a brave new world!</p>
<p>So next comes the task of identifying the crash. We have a crash handler that intercepts the crash to perform some housekeeping, so the actual crash will be down the call stack in a single-threaded server. However, some of our servers are multi-threaded, and the crash could have originated from any of those threads. Our crash handler logs the source of the crash’s file and line number, so examining those variables gives us our first lead; we will look for the call stack that was executing that code.</p>
<p>In the old days of a few weeks ago, we would use gdb to get a backtrace of all threads and peruse the resulting list to see which thread had the most-likely call stack that would have crashed. For example, if a thread is just sleeping, it is most likely not the crashed thread. We would look for a stack that had some more content than a few frames capping with a “sleep” and examine the code to see if a problem is evident, or go into gdb itself to examine the process state.</p>
<p>However, Visual Studio gives us considerably more powerful options than that. For a multi-threaded core you can open the Threads window in your debug session and poke around in each thread to see what the stack looks like. This is pretty similar to the gdb approach, and if there are 50 threads it can be very tedious. Fortunately, there is a feature that makes this much easier: <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/using-the-parallel-stacks-window?view=vs-2019"><strong>Parallel Stacks</strong></a>.</p>
<p>I confess most of us did not know about Parallel Stacks until Erika Sweet and her team told us about it. Invoking Debug -&gt; Windows -&gt; Parallel Stacks (only available during your debug session) opens a new window that shows the call stack of every thread in your process. It’s a fascinating 30,000-foot view of your entire process space. You can double-click any stack frame in any thread, and Visual Studio will jump to that frame in both source and the call stack window. This is a huge time-saver for us.</p>
<p>Once we can see the code near the crash, we can inspect variables using mouse-hover, QuickWatch or any of the other plethora of tools in Visual Studio. It’s true that in a Release build, many variables are optimized out, but at the same time, many are not! We can hone in on a problem much faster using Visual Studio’s interface than we ever could have using just gdb.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/blizzcon_heroes_w_logo.jpg"><img class="aligncenter size-full wp-image-27435" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/blizzcon_heroes_w_logo.jpg" alt="Heroes from Diablo IV with the &quot;Diablo IV&quot; logo." width="1926" height="1080" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/blizzcon_heroes_w_logo.jpg 1926w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/blizzcon_heroes_w_logo-300x168.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/blizzcon_heroes_w_logo-1024x574.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/blizzcon_heroes_w_logo-768x431.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/01/blizzcon_heroes_w_logo-1536x861.jpg 1536w" sizes="(max-width: 1926px) 100vw, 1926px" /></a></p>
<h4 id="summary">Summary</h4>
<p>Our team is very excited about the ability to debug Linux cores from our production environment in Visual Studio! It is a game changer for us, as it allows many more developers to actively diagnose problems “in the wild”, and it makes the powerful toolset of Visual Studio debugging available to all of us. Once our initial setup is complete, it only takes a minute or so to be in a debugging session in Visual Studio. This feature will make finding problems in our code much faster and more efficient! Thanks to Erika and her team for working with us on this!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/blizzard-diablo-iv-debugs-linux-core-dumps-from-visual-studio/">Blizzard Diablo IV debugs Linux core dumps from Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/blizzard-diablo-iv-debugs-linux-core-dumps-from-visual-studio/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>A Year of Conference Talks from the Microsoft C++ Team</title>
		<link>https://devblogs.microsoft.com/cppblog/a-year-of-conference-talks-from-the-microsoft-c-team/</link>
					<comments>https://devblogs.microsoft.com/cppblog/a-year-of-conference-talks-from-the-microsoft-c-team/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 25 Jan 2021 15:00:07 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27426</guid>

					<description><![CDATA[<p>As we learned to adapt to virtual conferences last year we presented more than 20 talks on a wide range of topics. I&#8217;ve collected them all here so you can easily learn about the latest advances in our tooling as well as the cutting edge of C++ features.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-year-of-conference-talks-from-the-microsoft-c-team/">A Year of Conference Talks from the Microsoft C++ Team</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>As we learned to adapt to virtual conferences last year we presented more than 20 talks on a wide range of topics. I&#8217;ve collected them all here so you can easily learn about the latest advances in our tooling as well as the cutting edge of C++ features.</p>
<h3 id="c-europe-february">C++ Europe (February)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=uQFr33C36rU">Tools to Ease Cross-Platform C++ Development</a> by Augustin Popa &amp; Elizabeth Morrow</li>
</ul>
<h3 id="wslconf-march">WSLConf (March)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=50bokFFOvtA">C++ Cross Platform Development with Visual Studio and WSL</a> by Erika Sweet</li>
</ul>
<h3 id="pure-virtual-c-april">Pure Virtual C++ (April)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=drt3yXI-fqk&amp;list=PLReL099Y5nRdHYz4JwB0bq1kaVw2yGDag">Dynamic Polymorphism with Metaclasses and Code Injection</a> by Sy Brand</li>
<li><a href="https://www.youtube.com/watch?v=ow2zV0Udd9M&amp;list=PLReL099Y5nRdHYz4JwB0bq1kaVw2yGDag">Practical C++20 Modules and the Future of Tooling Around C++ Modules</a> by Cameron DaCamara</li>
<li><a href="https://www.youtube.com/watch?v=WqXrYfSKJXk&amp;list=PLReL099Y5nRdHYz4JwB0bq1kaVw2yGDag">C++ Development with Visual Studio Code</a> by Julia Reid</li>
<li><a href="https://www.youtube.com/watch?v=xO7JG0GarG4&amp;list=PLReL099Y5nRdHYz4JwB0bq1kaVw2yGDag">Peeking Safely at a Table with Concepts</a> by Gabriel Dos Reis</li>
<li><a href="https://www.youtube.com/watch?v=ArW8n0QBdiE&amp;list=PLReL099Y5nRdHYz4JwB0bq1kaVw2yGDag">Update on MSVC’s implementation of the C++20 Standard Library</a> by Mahmoud Saleh</li>
<li><a href="https://www.youtube.com/watch?v=ijmZKRIfoOI&amp;list=PLReL099Y5nRdHYz4JwB0bq1kaVw2yGDag&amp;index=3&amp;t=4s">C++ Cross-Platform Development with Visual Studio and the Windows Subsystem for Linux</a> by Erika Sweet</li>
<li><a href="https://www.youtube.com/watch?v=JplnRSDa29w&amp;list=PLReL099Y5nRdHYz4JwB0bq1kaVw2yGDag">Optimize Your C++ Development While Working From Home</a> by Nick Uhlenhuth</li>
</ul>
<h3 id="microsoft-build-may">Microsoft Build (May)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=Wgd6aqc7_rk">Modern C++ Development with Visual Studio</a> by Erika Sweet and Nick Uhlenhuth</li>
</ul>
<h3 id="c-on-sea-july">C++ on Sea (July)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=Jw2n5QSul34">Live Compiler Development with Cross-Platform Tools</a> by Sy Brand</li>
<li><a href="https://www.youtube.com/watch?v=pGO65OHo0EM">Objection: A Language Lawyer Story</a> by Sy Brand (lightning talk)</li>
</ul>
<h3 id="apaconf-august">APAConf (August)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=4Ji-vFDL52s">Live Compiler Development with Cross-Platform Tools</a> by Sy Brand</li>
</ul>
<h3 id="cppcon-september">CppCon (September)</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=Va9-Qe3WzJ8" target="_blank" rel="noopener noreferrer">A New Decade of Visual Studio: C++20, Open STL, and More</a> by Sy Brand and Marian Luparu</li>
<li><a href="https://www.youtube.com/watch?v=AGRWRwi7rD0" target="_blank" rel="noopener noreferrer">Building an Intuition for Composition</a> by Sy Brand</li>
<li><a href="https://www.youtube.com/watch?v=8c6BAQcYF_E" target="_blank" rel="noopener noreferrer">Dynamic Polymorphism with Metaclasses and Code Injection</a> by Sy Brand</li>
<li><a href="https://www.youtube.com/watch?v=K6qvL_buqc0&amp;feature=emb_logo" target="_blank" rel="noopener noreferrer">How to Cook a Chicken</a> by Sy Brand (lightning talk)</li>
<li><a href="https://www.youtube.com/watch?v=NsmRPRxhLn0" target="_blank" rel="noopener noreferrer">Introducing Microsoft’s New Open Source Fuzzing Platform</a> by Justin Campbell and Michael Walker</li>
<li><a href="https://www.youtube.com/watch?v=_pQGRr4P16w" target="_blank" rel="noopener noreferrer">Closing the Gap between Rust and C++ Using Principles of Static Analysis</a> by Sunny Chatterjee</li>
<li><a href="https://www.youtube.com/watch?v=8kjRx8vo6y4" target="_blank" rel="noopener noreferrer">C++20 STL Features: One Year of Development on GitHub</a> by Stephan T. Lavavej</li>
<li><a href="https://www.youtube.com/watch?v=qCn6zT76zTs" target="_blank" rel="noopener noreferrer">Collaborative C++ Development with Visual Studio Code</a> by Julia Reid</li>
<li><a href="https://www.youtube.com/watch?v=6lurOCdaj0Y" target="_blank" rel="noopener noreferrer">Empirically Measuring, and Reducing, C++’s Accidental Complexity</a> by Herb Sutter</li>
<li><a href="https://www.youtube.com/watch?v=oYCin0B037Y" target="_blank" rel="noopener noreferrer">Cross-Platform Pitfalls and How to Avoid Them</a> by Erika Sweet</li>
<li><a href="https://www.youtube.com/watch?v=HrOEyJVU5As" target="_blank" rel="noopener noreferrer">Effective Remote C++ Development with Codespaces</a> by Nick Uhlenhuth</li>
</ul>
<h3 id="meeting-c-november">Meeting C++ (November)</h3>
<ul>
<li>Building an Intuition for Composition by Sy Brand (video not yet available)</li>
<li><a href="https://www.youtube.com/watch?v=j4du4LNsLiI">Programming in the Large with C++20</a> by Gabriel Dos Reis</li>
<li><a href="https://www.youtube.com/watch?v=5Typh0bp2SY">Diversity and Inclusion Panel</a> with Sy Brand and Gabriel Dos Reis</li>
</ul>
<h3 id="let-us-know-your-thoughts">Let us know your thoughts</h3>
<p>We&#8217;d love to hear what you think about any of the talks we&#8217;ve given in the last year, or about any topics you&#8217;d like for us to cover in the future. You can reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or on Twitter <a href="https://twitter.com/visualc" target="_blank" rel="noopener noreferrer">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-year-of-conference-talks-from-the-microsoft-c-team/">A Year of Conference Talks from the Microsoft C++ Team</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/a-year-of-conference-talks-from-the-microsoft-c-team/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
	</channel>
</rss>
