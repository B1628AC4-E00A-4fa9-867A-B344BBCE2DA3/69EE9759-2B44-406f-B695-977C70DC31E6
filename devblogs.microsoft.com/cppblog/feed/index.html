<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Mon, 12 Sep 2022 22:12:01 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Integrating C++ header units into Office using MSVC (1/n)</title>
		<link>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/</link>
					<comments>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Mon, 12 Sep 2022 21:12:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[C++ language]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[modernization]]></category>
		<category><![CDATA[modules]]></category>
		<category><![CDATA[Office]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31007</guid>

					<description><![CDATA[<p>.cameron {<br />
    color: #4472c4;<br />
  }</p>
<p>C++20 has had a lot to offer and one feature in particular requires the most thought of all when integrating into our projects: C++ modules (or C++ header units in this particular case).  In this blog we will show a real world case of integrating a new C++20 feature into a large codebase that we might all be familiar with.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/">Integrating C++ header units into Office using MSVC (1/n)</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<style>
  .cameron {
    color: #4472c4;
  }
</style>
<p>C++20 has had a lot to offer and one feature in particular requires the most thought of all when integrating into our projects: C++ modules (or <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">C++ header units</a> in this particular case).  In this blog we will show a real world case of integrating a new C++20 feature into a large codebase that we might all be familiar with.  Just a few notes:</p>
<ul>
<li>This blog is authored in a style of two perspectives:</li>
<ul>
<li>Zachary Henkel&#8217;s perspective will be in black text.</li>
<li>Cameron DaCamara&#8217;s perspective will be in <span class="cameron">accent text</span>.</li>
</ul>
<li>This blog is the first in a series detailing experiences in integrating header units into the Office codebase.</li>
<li>The first blog here is very early results so do not expect to see very fine-grained numbers.</li>
</ul>
<p>Without further delay, let us jump right in!</p>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#problem-description">Problem description: Why header units?</a></li>
<li><a href="#baby-steps">Baby steps to start the work: Basic projects to target and early obstacles</a></li>
<li><a href="#larger-steps">Larger steps: How does Office package up header units for build?</a></li>
<li><a href="#together">Putting it all together: Smoke tests and early numbers</a></li>
<li><a href="#next-steps">Looking ahead: Build more headers and measure</a></li>
</ul>
<p></p>
<h2><span id="problem-description">How MSVC enables header units in a multi-platform codebase</span></h2>
<p>C++20 header units are a way to receive many of the benefits of modules, while still working with a codebase that was designed for classic header inclusion.  The benefits of header units looked appealing to Office, but we weren&#8217;t willing to extensively add platform #ifdefs for the sake of consuming them.  Fortunately, the C++ standard anticipated this scenario!  The flag MSVC <a href="https://docs.microsoft.com/en-us/cpp/build/reference/translateinclude?view=msvc-170"><code>/translateInclude</code></a> will automatically translate a textual inclusion to a header unit import when it encounters a #include specified in a command line mapping to the compiler.  This allows Office to build and consume header units without any code changes at all!</p>
<p><span class="cameron">It is worth noting that the <code>/translateInclude</code> feature is a standard-supported feature, <a href="https://eel.is/c%2B%2Bdraft/cpp.include#7"><code>[cpp.include]/7</code></a>. Include translation allows the implementation to replace <code>#include</code> with <code>import</code>.  It is essential for gradual codebase migration that there be a bridge such as include translation to enter the world of modules.  More importantly, a header unit can do something that a <a href="https://docs.microsoft.com/en-us/cpp/build/creating-precompiled-header-files?view=msvc-170">PCH</a> cannot: it can be moved around from project to project and reused!  So not only does the integration of header units require no source-level changes, but the build throughput potential for multiple projects is far beyond what PCH can offer.  One more point to header units compared to PCH: they&#8217;re small, really small compared to PCH.  In our measurements, a header unit can often times be 10x smaller than an equivalent PCH in content.</span></p>
<h3 id="selecting-header-unit-candidates">Selecting header unit candidates</h3>
<p>Once Office knew we wanted to use header units, the challenge became finding a good set of candidate headers.  Our low-level shared code components, that we&#8217;ve termed liblets, have properties that make them attractive header unit blocks.  All a liblet&#8217;s headers exposed as dependencies need to be self-contained and this property is enforced by existing tools!  Secondly, liblets clearly express their dependencies.  This allows us to build an acyclic graph of dependencies and build up sets of header units.</p>
<h2><span id="baby-steps">Baby Steps</span></h2>
<p>The first step Office took was simply to determine if we could build a header unit!  This <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">Microsoft docs</a> page has the full steps but summarized here are the key points:</p>
<ul>
<li>Turn on module support.  Ideally Office would be compiling all code as C++20 and header unit support would be available automatically.  Unfortunately, due to the size of the Office codebase, we&#8217;re not ready to make the switch.  Luckily Office already compiles with the compiler flag <a href="https://docs.microsoft.com/en-us/cpp/build/reference/permissive-standards-conformance?view=msvc-170"><code>/permissive-</code></a>.  By running the compiler in standards conformance mode Office is able to fall back on the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/experimental-module?view=msvc-170"><code>-experimental:module</code></a> flag for header unit support until the C++20 migration is complete.  It&#8217;s important to note that this <em>doesn&#8217;t do anything</em> other than enable the feature, it won&#8217;t force any code to compile as header units without additional flags.</li>
<li>Determine where in the build tree we will create the IFC artifacts and pass that location to the compiler with <a href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-alphabetically?view=msvc-170"><code>/ifcOutput</code></a></li>
<li>We enabled some additional compiler flags for the purposes of testing, more on this later.</li>
</ul>
<p>Right out of the gate Office hit a snag.  Our headers weren&#8217;t as self-contained as we had assumed.  Our tools that operate on headers in isolation rely on common textual includes being provided by the precompiled header!  Until the work to break our precompiled header dependency is complete, we&#8217;re force-including (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/fi-name-forced-include-file?view=msvc-170"><code>/FI</code></a>) the precompiled header into each header being compiled as a header unit.</p>
<p><span class="cameron">From this perspective, it is important that the compiler should make traditional PCH technology work along with the new modules technology (which is the same machinery the compiler uses to export and import header units).</span></p>
<p><span class="cameron">The first compiler bug on deck was the fact that the front-end has a rather&#8230; interesting approach to PCH.  The problem observed was that <em>sometimes</em> the compiler would error with &#8220;<code>error C7612: could not find header unit for 'X'</code>&#8220;.  The most curious thing was that the command line had the reference to header unit &#8216;X&#8217; clear as day.  It was not until I debugged the front-end with PCH turned on where the PCH interacted with certain identifiers that I discovered the culprit.  When the compiler starts, it allocates a table where hashed identifiers go, and when the compiler sees <a href="https://docs.microsoft.com/en-us/cpp/build/reference/headerunit?view=msvc-170"><code>/headerUnit:quote X=X.ifc</code></a> it will create hashed identifiers for the components of the name for fast comparison purposes.  The problem is that this processing happened too early because in the presence of a PCH the compiler will memmap the PCH file and <a href="https://en.wikipedia.org/wiki/Bit_blit">blit</a> the memory directly into existing compiler heap locations&#8230; exactly where we just inserted our identifiers from processing the <code>/headerUnit</code> arguments, which means we also get bogus identifiers when trying to find the matching header unit name to IFC combo.  One hefty comment and code rearranging later, our first bug was fixed!</span></p>
<p>The preprocessor presented another set of challenges. The set of preprocessor macros must be consistent between header unit creation and consumption. Inconsistent conditional compilation is forbidden in header units.  Eliminating cases, such as the following, will be an ongoing concern for Office as header unit usage increases.</p>
<pre>#if defined(Assert)
#define ASSUME( condition ) Assert( condition )
#else
#define ASSUME ( condition ) __noop()
#endif</pre>
<p>The experiment to create as many header units as possible helped uncover many outstanding bugs with code that was never instantiated by the compiler.  </p>
<p>One such example, this does not return on all code paths:</p>
<pre>inline HRESULT sink(std::unique_ptr&lt;Widget&gt; widget)
{
#if DEBUG
  if (!widget) return E_POINTER;
#endif
  m_widget = std::move(widget);
}</pre>
<p><span class="cameron">Let&#8217;s talk about inline functions.  Consider:</span></p>
<pre>void undef(); 
inline void f() {
  undef();
}
int main() { }</pre>
<p><span class="cameron">You might be surprised to find that every major compiler vendor will accept the above C++ code and link the program successfully!  It turns out that the standard wording here <a href="https://eel.is/c%2B%2Bdraft/dcl.inline#5"><code>[dcl.inline]/5</code></a> is quite special, and it allows for a unique optimization which allows a compiler front-end to tell the back-end that the definition of a specific function is never needed because said function is never referenced, so this bespoke definition can be discarded altogether, which further implies <code>undef</code> is also never referenced leading to a well-formed program.</span></p>
<p><span class="cameron">There has been a long-standing issue in the compiler where it was forced to emit every inline function definition into the associated .obj if the current translation unit was a module interface unit or a header unit.  While this will still lead to correct program semantics, it has two major drawbacks:</code></span></p>
<ol class="cameron">
<li>The compiler cannot enable the aforementioned optimization with inline functions, and</li>
<li>This compiler behavior means that <a href="https://docs.microsoft.com/en-us/cpp/build/reference/ltcg-link-time-code-generation?view=msvc-170">LTCG</a> is required for inlining of functions declared <code>inline</code> and defined in the imported translation unit.</li>
</ol>
<p><span class="cameron">It turns out that Office relied on &#8216;1&#8217;, a lot.  So, we just fixed the bug.  During the Office header unit integration, the compiler provided a switch to enable the behavior of emitting every inline function definition into the IFC which would be loaded on-demand if it was used on the import side.</span></p>
<p>Office has been on a long journey to ensure all our code is standards compliant via the MSVC <code>/Zc</code> flags and <code>/permissive-</code>.  The header unit pilot acted as a forcing function to accelerate our efforts to enable the standards conformant preprocessor (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/zc-preprocessor?view=msvc-170"><code>/Zc:preprocessor</code></a>) globally.</p>
<p><span class="cameron">Anybody familiar with the quirks of the traditional preprocessor in MSVC will understand that its behavior is something of an eldritch horror.  Adding to that, the traditional preprocessor has virtually no data model besides walking blobs of text to create a new stream of text for the compiler&#8217;s tokenizer.  The standard states that preprocessing should begin with a series of <a href="https://eel.is/c%2B%2Bdraft/lex.phases#1.3">pp-tokens</a> and end up with a series of lexical tokens which are then parsed.   The new preprocessor (<code>/Zc:preprocessor</code>) allows the compiler to store these pp-tokens into the IFC in a principled way.  These pp-tokens are needed as they compose the definition of <a href="https://eel.is/c%2B%2Bdraft/cpp.replace#general-2">object-like and function-like</a> macros and is the reason why <code>/Zc:preprocessor</code> is <a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-exportheader?view=msvc-170#remarks">required for header unit compilation</a>.</span></p>
<h2><span id="larger-steps">Larger Steps?</span></h2>
<p>Once Office could create header units it was time to consume them!  Again, the <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-header-units?view=msvc-170">Microsoft docs</a> page contains the full details but the key steps for Office were:</p>
<ul>
<li>Use the <code>/translateInclude</code> flag to avoid rewriting <code>#include</code> to <code>import</code>.</li>
<li>Pass the header unit mapping <code>/headerUnit liblet/header.h=&lt;ifc path&gt;</code>.</li>
<li>Decide what to do with the .obj file created as part of a header unit.</li>
</ul>
<p>In Office we bundle all header unit mappings per-liblet into a single <a href="https://docs.microsoft.com/en-us/cpp/build/reference/at-specify-a-compiler-response-file?view=msvc-170">response file</a>.  We&#8217;ve found this to strike the right balance of dependency tracking despite potentially over specifying the number of header units being consumed.</p>
<p>Header unit consumption started revealing heterogeneous build flags throughout the product.  Big pain points include static vs dynamic CRT (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=msvc-170"><code>/MT</code> vs <code>/MD</code></a>), unsigned char (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/j-default-char-type-is-unsigned?view=msvc-170"><code>/J</code></a>) and <code>/DUNICODE</code>.  It is possible to create a distinct header unit flavor for each combination, but so far, we&#8217;ve stuck to a single flavor with the most common options.</p>
<p>The obj file from a header unit is packaged into the pre-existing lib files to make consuming header units easy.</p>
<h2><span id="together">Putting it together</span></h2>
<p>The most recent milestone hit in the pilot is to successfully compile and link three of Office&#8217;s shared code dlls.  While building the dlls Office successfully compiled ninety distinct header units from pre-existing shared code headers.  To aid integration header units are enabled for all of a project&#8217;s publicly shared headers at once.  This means that even though each header unit that&#8217;s been created will be used <em>somewhere</em> in Office, there isn&#8217;t any guarantee it is consumed while building these specific dlls.  To build the dll we tested 2/5 of the generated header units were consumed, as validated by the report generated by the new <a href="https://docs.microsoft.com/en-us/cpp/build/reference/sourcedependencies?view=msvc-170"><code>/sourceDependencies</code></a> flag.  We anticipate these numbers to increase significantly with some upcoming work to replace the compiler&#8217;s brittle legacy ODR validation logic.</p>
<p><span class="cameron">The module machinery in the compiler has historically tried to use source locations to perform ODR matching (<a href="https://eel.is/c%2B%2Bdraft/basic.def.odr">One Definition Rule</a>).  The problem, of course, is that the header units can be moved around and locations change from machine-to-machine (even project-to-project) so the strategy of trying to perform an ODR match based on source location can be quite fragile, as mentioned above.  After working with Office it was abundantly clear that the compiler needs to adjust its strategy and perform more of a structural comparison when matching for ODR&mdash;a change which is still ongoing and targeting a future release.  Please note that ODR checking for named modules do not have any of the problems above as they provide better ODR guarantees vs being reliant on source location.</span></p>
<h2><span id="next-steps">Next steps</span></h2>
<p>We are just as anxious to get build throughput metrics internally as we expect all of you to be. Once we have a broad set of header units being generated and consumed, we plan to do gather extensive build timing data.  We want to see the effect building and consuming header units has on the build speed of both clean builds and incremental builds and we want to measure the effects both with and without our existing precompiled headers.  Additionally, we need to determine if there is a high enough throughput gain to justify creating additional header unit flavors for currently incompatible compiler flags. Do we have enough projects that require the static CRT or build without Unicode support to spend the compilation time generating header units in those configurations?</p>
<p>Finally, we want to add support for consuming header units outside of Office&#8217;s shared code.  We have a shared code architecture that makes it easy to create header units and track the downstream projects that depend on them.  We need to extend the build system support that has already been created to date so that Office&#8217;s client apps can also see the benefits of header units.  If you&#8217;d like to learn more about how Office architects its shared code, please catch the CppCon 2022 talk <a href="https://cppcon.digital-medium.co.uk/session/2022/how-microsoft-uses-c-to-deliver-office/">&#8220;How Microsoft Uses C++ to Deliver Office: Huge Size, Small Components&#8221;</a> once it&#8217;s available online.</p>
<p><span class="cameron">Office is nearly 100 million lines of native code and the compiler is seeing a lot of new code, which is both a blessing and a curse as it can halt development until a compiler fix is created but ultimately makes a product which is not only more robust for Office but for every customer using MSVC!</span></p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/all-header-units.png" alt="BUILD!" /></p>
<h4 id="closing">Closing</h4>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow Cameron DaCamara on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/">Integrating C++ header units into Office using MSVC (1/n)</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Team at CppCon 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 12 Sep 2022 13:00:27 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31039</guid>

					<description><![CDATA[<p>The Microsoft C++ team has an exciting lineup of sessions at CppCon 2022. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/">Microsoft C++ Team at CppCon 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><img class="size-full wp-image-24953 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png" alt="Microsoft @ CppCon" width="760" height="466" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp.png 760w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/09/atcpp-300x184.png 300w" sizes="(max-width: 760px) 100vw, 760px" /></p>
<p>The Microsoft C++ team has an exciting lineup of sessions at <a href="https://cppcon.org/">CppCon 2022</a>. Many of us will also be present at our team’s booth in the main hall for the first two days of the conference. Come say hi and let us know if you have any questions about our talks, products, or anything else! You can also join the <a href="https://aka.ms/cppcon/discord">#visual_studio channel on the CppCon Discord</a> to talk to us (note: to join, head to <a href="https://discord.com/channels/864799911358627861/864825142386622474">#directory</a> channel first, and check the checkbox next to &#8220;Visual Studio&#8221; box).</p>
<p>We’re also running a survey on the C++ ecosystem. If you have a moment, <a href="https://aka.ms/cppcon" target="_blank" rel="noopener noreferrer">please take our survey</a>, it&#8217;s quick.</p>
<p>Here’s the lineup:</p>
<h1 id="monday-september-12th">Monday, September 12th</h1>
<p><strong>09:00 – 10:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/whats-new-in-c23/">What’s New in C++23</a> – Sy Brand (online)</p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/the-imperatives-must-go/">The Imperatives Must Go</a> – Victor Ciura (online)</p>
<p><strong>14:00 – 15:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/c-dependencies-dont-have-to-be-painful/">C++ Dependencies Don’t Have To Be Painful: Why You Should Use a Package Manager</a> – Augustin Popa</p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/how-microsoft-uses-c-to-deliver-office/">How Microsoft Uses C++ to Deliver Office</a> – Zachary Henkel</p>
<h1 id="tuesday-september-13th">Tuesday, September 13th</h1>
<p><strong>09:00 – 10:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/high-performance-load-time-implementation-selection/">High-performance Load-time Implementation Selection</a> – Joe Bialek and Pranav Kant</p>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/c-mythbusters/">C++ MythBusters</a> – Victor Ciura (online)</p>
<h1 id="wednesday-september-14th">Wednesday, September 14th</h1>
<p><strong>16:45 – 17:45 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/memory-safe-c/">-memory-safe C++</a> – Jim Radigan</p>
<h1 id="thursday-september-15th">Thursday, September 15th</h1>
<p><strong>10:30 – 11:30 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/whats-new-for-you-in-visual-studio-code/">What’s New in Visual Studio Code</a> – Marian Luparu and Sinem Akinci (online)</p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/overcoming-embedded-development-tooling-challenges/">Overcoming Embedded Development Tooling Challenges</a> – Marc Goodner (online)</p>
<p><strong>15:15 – 16:15 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/reproducible-developer-environments/">Reproducible Developer Environments</a> – Michael Price</p>
<h1 id="friday-september-16th">Friday, September 16th</h1>
<p><strong>07:45 – 08:45 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/github-features-every-c-developer-should-know/">GitHub Features Every C++ Developer Should Know</a> – Michael Price</p>
<p><strong>09:00 – 10:00 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/whats-new-in-visual-studio-2022/">What&#8217;s New in Visual Studio 2022</a> – Sy Brand and Marian Luparu (online)</p>
<p><strong>16:15 – 18:15 (MDT):</strong></p>
<p><a href="https://cppcon.digital-medium.co.uk/session/2022/c-complexity/">C++ Simplicity, Safety, and Toolability</a> – Herb Sutter</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/">Microsoft C++ Team at CppCon 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-cppcon-2022/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Importing ST projects into Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/#respond</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Thu, 01 Sep 2022 18:50:15 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30966</guid>

					<description><![CDATA[<p>In the world of Arm microcontrollers there are many silicon vendors, one of the largest is STMicroelectronics. ST has a large catalog of available devices with many capabilities as well as supporting development boards for evaluating them. They also produce STM32CubeIDE,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/">Importing ST projects into Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In the world of Arm microcontrollers there are many silicon vendors, one of the largest is <a href="https://www.st.com/">STMicroelectronics</a>. ST has a large catalog of available devices with many capabilities as well as supporting development boards for evaluating them. They also produce <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a>, a custom IDE to use when targeting their devices, and <a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html">STM32CubeMX</a>, a configuration tool used in configuring properties of their devices and generating projects.</p>
<p>If you are a developer already using ST’s products I’m not telling you anything new. You may not be aware though of the work we have been doing to <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">enable embedded developers in Visual Studio Code</a>. This embedded experience relies on the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifacts capabilities</a> to help acquire toolchains and configure the dev environment. To make it easier for developers using ST devices to try Visual Studio Code we have been working with ST to enable importing STM32CubeIDE projects.</p>
<p>We accomplish this by generating a CMake project from the ST project. ST provides many sample projects across their portfolio. We’ve validated builds across ST’s sample projects with this mechanism, over 3,000 of them. At present we have a 94% pass rate which we are continuing to improve. This gives us confidence that our approach will be successful for importing your own ST projects. Our embedded tools extension also enables device flashing and debugging through the importer, though we have only validated this on the hardware we have.</p>
<p>This post is going to go over how this project importer functionality works in conjunction with vcpkg and ST’s tools.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode.png"><img class="alignnone size-full wp-image-30967" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode.png" alt="A STM32 project in VSCode" width="1430" height="951" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode.png 1430w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode-300x200.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode-1024x681.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/STM32-project-in-VSCode-768x511.png 768w" sizes="(max-width: 1430px) 100vw, 1430px" /></a></p>
<h4 id="using-st-projects-in-visual-studio-code">Using ST projects in Visual Studio Code</h4>
<p>This post assumes some familiarity with ST devices, development tools, and embedded development generally. If you need some background, we recommend the following articles on getting started with STM32 from <a href="https://shawnhymel.com/">Shawn Hymel</a>.</p>
<ul>
<li><a href="https://www.digikey.com/en/maker/projects/getting-started-with-stm32-introduction-to-stm32cubeide/6a6c60a670c447abb90fd0fd78008697">Introduction to STM32CubeIDE</a></li>
<li><a href="https://www.digikey.com/en/maker/projects/getting-started-with-stm32-introduction-to-freertos/ad275395687e4d85935351e16ec575b1">Introduction to FreeRTOS </a></li>
</ul>
<p>We rely on vcpkg for managing dependencies like CMake and Ninja, which includes acquiring them and making them available for use in your development environment. You can learn more about how we vcpkg in our <a href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Visual Studio Code embedded development overview</a>. You can install it in a single shell command for your platform.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre>iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>You will need the Embedded Tools extension version 0.3.0 or greater installed in Visual Studio Code to use the ST project importer.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3.png"><img class="alignnone size-full wp-image-30968" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3.png" alt="Embedded Tools extension page from VS Code" width="624" height="171" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/embtools0.3-300x82.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>Today our importer requires that you have the <a href="https://www.st.com/en/development-tools/stm32cubeide.html">STM32CubeIDE</a> software installed in the default location for your platform. We have been testing this capability with STM32CubeIDE 1.9.0 and STM32CubeMX 6.5.0. If you have multiple instances installed side by side we do not have the ability to control which is selected.</p>
<p>It is also necessary to acquire the board support package for your device in STM32CubeIDE. This is so that we can use the compilers and supporting applications provided by ST from within Visual Studio Code.</p>
<p>There will be a lighter weight package available from ST in the future. We plan to enable acquisition of the dependencies here via vcpkg as well.</p>
<p>With our prerequisites installed, from within Visual Studio Code in the command pallet (&lt;Ctrl&gt;+&lt;Shift&gt;+&lt;P&gt;) run “Create project from ST project”.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj.png"><img class="alignnone size-full wp-image-30969" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj.png" alt="Create ST project in VS Code command pallate" width="1456" height="189" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj.png 1456w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj-300x39.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj-1024x133.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/create-st-proj-768x100.png 768w" sizes="(max-width: 1456px) 100vw, 1456px" /></a></p>
<p>Navigate to where your ST .cproject is and select it. You can then select either the debug or release configuration. Now you can select Build to compile your firmware with CMake. To debug select the Debug view, then select the launch button. This will run the STM32 programmer to flash the firmware onto the device and connect using GDB. From here all of our embedded development views (<a href="https://docs.microsoft.com/cpp/embedded/serial-monitor?view=msvc-170&amp;tabs=visual-studio">serial</a>, <a href="https://docs.microsoft.com/cpp/embedded/rtos-view?view=msvc-170&amp;tabs=visual-studio">RTOS</a>, and <a href="https://docs.microsoft.com/cpp/embedded/peripheral-view?view=msvc-170&amp;tabs=visual-studio">peripherals</a>) are available.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode.png"><img class="alignnone size-full wp-image-30970" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode.png" alt="STM32 FreeRTOS project debugging in VS Code" width="1430" height="815" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode.png 1430w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode-300x171.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode-1024x584.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-freertos-debug-vscode-768x438.png 768w" sizes="(max-width: 1430px) 100vw, 1430px" /></a></p>
<p>If your project has an .ioc file you can open the context menu and open STM32CubeMX for your project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode.png"><img class="alignnone wp-image-30971" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode.png" alt="VS Code context menu for CubeMX .ioc file" width="655" height="366" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode.png 1106w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode-300x168.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode-1024x572.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32.ioc_.vscode-768x429.png 768w" sizes="(max-width: 655px) 100vw, 655px" /></a></p>
<p>If you make changes to your project in STM32CubeMX they will be recognized and the CMake cache will regenerate.</p>
<p>After you close Visual Studio Code for your next session with your project you will need to launch Visual Studio Code from a vcpkg activated prompt. To do so in your shell navigate to the project folder containing vcpkg-configuration.json, run vcpkg activate, then code .</p>
<p>In a future release this will no longer be necessary, activation will happen automatically.</p>
<h4 id="understanding-cmake-interaction">Understanding CMake interaction</h4>
<p>You can see the simple CMakeLists.txt that is generated in the root of the project where the .cproject is located. This has a dependency on generated CMake files under the cmake directory. There are paths in these files that are set to the discovered location of the ST compilers on your machine. If you intend to move to CMake from the ST project format we advise that you adjust these files to your needs, particularly for use in a team where the paths may vary.</p>
<p>The other thing to be aware of is that sometimes in the STM32CubeIDE samples, the project may be in a subdirectory of the source code. If you do not see your project files in the file view this may be why. Select the CMake targets view and you should see everything that CMake has used to generate the build.</p>
<p>Following from the above point we recommend that when generating projects using STM32CubeMX you leave the default selected in the Project Manager for “Generate Under Root”. This will keep your .cproject in the root of the folder with the generated source files. This is how STM32CubeIDE generates projects by default as well.</p>
<p>If you open the project again in STM32CubeIDE you will need to exclude the build directory used by CMake from your project. Right click the build directory and select Resource Configurations &gt; Exclude from Build.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig.png"><img class="alignnone size-full wp-image-30973" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig.png" alt="STM32IDE context menu for resource configuration" width="354" height="361" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig.png 354w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig-294x300.png 294w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig-24x24.png 24w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-resourceconfig-48x48.png 48w" sizes="(max-width: 354px) 100vw, 354px" /></a></p>
<p>Then select both Debug and Release in the Exclude from build dialog.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions.png"><img class="alignnone wp-image-30974" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions.png" alt="STM32 IDE build exclusions dialog" width="498" height="325" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions.png 732w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/09/stm32-ide-buildexclusions-300x196.png 300w" sizes="(max-width: 498px) 100vw, 498px" /></a></p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio Code for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/">Importing ST projects into Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/importing-st-projects-into-visual-studio-code/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg August 2022 Release is Now Available: CMake Version Update, Updated FAQ, Cross-compilation Fix for Apple Silicon</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Tue, 23 Aug 2022 16:23:27 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30936</guid>

					<description><![CDATA[<p>The August 2022 release of the vcpkg package manager is available. This blog post summarizes changes from July 25th, 2022 to August 14th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>8 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/">vcpkg August 2022 Release is Now Available: CMake Version Update, Updated FAQ, Cross-compilation Fix for Apple Silicon</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.08.15">August 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from July 25<sup>th</sup>, 2022 to August 14<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>8 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>192 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,975 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are over <strong>10,106 port versions</strong>.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.08.15">August release of the main vcpkg repo</a> includes <strong>204 commits</strong>.</li>
<li><strong>69 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.7k forks</strong> and <strong>16.5k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<p>This is a minor update and there was no tool update this month, so most of the changes are to the open-source ports registry or minor changes. See the full <a href="https://github.com/microsoft/vcpkg/compare/2022.07.25...2022.08.15">commit changelog</a> for details. We call out several of the more interesting changes below.</p>
<p>&nbsp;</p>
<h4 id="vcpkg-now-uses-cmake-v3-24">vcpkg now uses CMake v3.24</h4>
<p>Updated the version of CMake used by vcpkg to 3.24. Note: this doesn’t restrict what version of CMake a vcpkg user can use for their own projects, and vcpkg can be asked to use a version of CMake already installed on the user’s machine, as long as it is not an older version than 3.24.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/25365">Microsoft/vcpkg#25365</a> (thank you @<a href="https://github.com/Neumann-A">Neumann-A</a>!)</p>
<p>&nbsp;</p>
<h4 id="improved-cross-compilation-for-apple-silicon">Improved cross-compilation for Apple silicon</h4>
<p>A community PR improves correctness when cross-compiling from x86_64 to arm64 on macOS (and vice-versa). It also takes into account Rosetta’s capability to run x86_64 binaries on arm64 macOS systems.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/26240">Microsoft/vcpkg#26240</a> (thanks @<a href="https://github.com/ekilmer">ekilmer</a>!)</p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation changes</h4>
<p>The following documentation changes were made this release:</p>
<ul>
<li>Extensive changes to the FAQ page as it was out of date, taking account of new vcpkg features and tool targeting capabilities.</li>
<li>Updated triplets documentation to include the variable VCPKG_FIXUP_ELF_RPATH (thanks @Osyotr!)</li>
</ul>
<p>PRs: <a href="https://github.com/microsoft/vcpkg/pull/25400">Microsoft/vcpkg#25400</a>, <a href="https://github.com/microsoft/vcpkg/pull/26040">Microsoft/vcpkg#26040</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,775</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,828</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,741</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,755</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>939</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,364</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>891</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,697</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,765</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>Neumann-A (27 commits)</li>
<li>Thomas1664 (8 commits)</li>
<li>Osyotr (6 commits)</li>
<li>autoantwort (5 commits)</li>
<li>ekilmer (3 commits)</li>
<li>dg0yt (3 commits)</li>
<li>cenit (2 commits)</li>
<li>myd7349 (1 commit)</li>
<li>coryan (1 commit)</li>
<li>AenBleidd (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.08.15">full August release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/">vcpkg August 2022 Release is Now Available: CMake Version Update, Updated FAQ, Cross-compilation Fix for Apple Silicon</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Updates to Visual Studio Build Tools license for C and C++ Open-Source projects</title>
		<link>https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/</link>
					<comments>https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/#comments</comments>
		
		<dc:creator><![CDATA[Marian Luparu]]></dc:creator>
		<pubDate>Thu, 18 Aug 2022 18:40:37 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30919</guid>

					<description><![CDATA[<p>Visual Studio Build Tools (VSBT) can now be used for compiling open-source C++ dependencies from source without requiring a Visual Studio license, even when you are working for an enterprise on a commercial or closed-source project.<br />
This change expands user rights to the Build Tools and does not limit the existing Visual Studio Community license provisions around Open-Source development.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/">Updates to Visual Studio Build Tools license for C and C++ Open-Source projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual Studio Build Tools</a> (VSBT) can now be used for compiling open-source C++ dependencies from source without requiring a Visual Studio license, even when you are working for an enterprise on a commercial or closed-source project.</p>
<p>This change expands user rights to the Build Tools and does not limit the existing Visual Studio Community license provisions around Open-Source development. If you already are a developer contributing to OSS projects, you can continue to use Visual Studio and Visual Studio Build Tools together for free, just like before.</p>
<h3 id="new-license-benefits">New License Benefits</h3>
<p>If you are an enterprise developer or developing any closed-source projects, this change now allows you to use Visual Studio Build Tools to compile and build any C++ 3rd party open-source dependencies, without needing a paid Visual Studio license, when you’re not using Visual Studio for active C++ development.</p>
<p>For example, if your Node.js application depends on npm native modules like sqllite3, bufferutil, etc., in order to successfully install these npm packages on Windows, <a href="https://github.com/Microsoft/nodejs-guidelines/blob/master/windows-environment.md#compiling-native-addon-modules">you will need to use Visual Studio Build Tools</a>. Previously, if the application you were developing was not OSS, installing VSBT was permitted only if you had a valid Visual Studio license (e.g., Visual Studio Community or higher). With this new license option, if you do not need the full functionality of Visual Studio for your active development of your project, you have the flexibility to install Visual Studio Build Tools for free.</p>
<p>As noted above, if you and your team need to compile and develop proprietary C++ code with Visual Studio, a Visual Studio license will still be required.</p>
<p>You can review the latest Visual Studio Build Tools license here: <a href="https://visualstudio.microsoft.com/license-terms/vs2022-ga-diagnosticbuildtools/">License Terms | Microsoft Diagnostic Build Tools for Visual Studio 2022 &#8211; Visual Studio</a> (for full list of licenses check out the <a href="https://visualstudio.microsoft.com/license-terms/">Visual Studio Licenses &amp; EULA Directory</a>)</p>
<h3 id="background">Background</h3>
<p>The C++ OSS ecosystem is a vibrant one and you need to look no further than the growing popularity of <a href="https://vcpkg.io/">vcpkg, the multi-platform C++ dependency manager from Microsoft</a>, to see how it is becoming a fundamental building block for an increasing number of projects. We are thrilled to see the adoption of many of these C++ open-source libraries in the Python or node.JS communities as well. We hope these licensing changes will allow for further adoption of these C++ libraries in enterprise environments, where building from source:</p>
<ul>
<li>removes friction in securing the supply chain,</li>
<li>creates a smooth migration path to the latest MSVC versions,</li>
<li>presents opportunities for further runtime performance optimizations, and</li>
<li>potentially allows for more active OSS contributions to these libraries</li>
</ul>
<h3 id="whats-next">What&#8217;s Next</h3>
<p>We are actively working to further simplify the acquisition of the MSVC toolchain and all its dependencies, to make it as easy as possible to <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">bootstrap a C++ environment on Windows</a> for C++ developers as well as for other language communities that chose to depend on MSVC toolchain. Stay tuned for more news on our blog.</p>
<p>For questions or feedback on these licensing changes, please reach out to us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or on Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/">Updates to Visual Studio Build Tools license for C and C++ Open-Source projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/updates-to-visual-studio-build-tools-license-for-c-and-cpp-open-source-projects/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>proxy: Runtime Polymorphism Made Easier Than Ever</title>
		<link>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/</link>
					<comments>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/#comments</comments>
		
		<dc:creator><![CDATA[Mingxin Wang]]></dc:creator>
		<pubDate>Mon, 15 Aug 2022 15:00:41 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Experimental]]></category>
		<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30853</guid>

					<description><![CDATA[<p>proxy is a single-header cross-platform library that facilitates runtime polymorphism.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/">proxy: Runtime Polymorphism Made Easier Than Ever</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><code>proxy</code> is an open-source, cross-platform, single-header C++ library, making runtime polymorphism easier to implement and faster, empowered by our breakthrough innovation of Object-oriented Programming (OOP) theory in recent years. Consider three questions:</p>
<ol>
<li>Do you want to facilitate architecture design and matainance by writing non-intrusive polymorphic code in C++ as easily as in Rust or Golang?</li>
<li>Do you want to facilitate lifetime management of polymorphic objects as easily as in languages with runtime Garbage Collection (GC, like Java or C#), <em>without</em> compromising performance?</li>
<li>Have you tried other polymorphic programming libraries in C++ but found them deficient?</li>
</ol>
<p>If so, this library is for you. You can find the implementation at <a href="https://github.com/microsoft/proxy">our GitHub repo</a>, integrate with your project using <a href="https://github.com/microsoft/vcpkg">vcpkg</a> (search for <code>proxy</code>), or learn more about the theory and technical specifications from <a href="https://wg21.link/p0957">P0957</a>.</p>
<h2 id="overview">Overview</h2>
<p>In C++ today, there are certain architecture and performance limitations in existing mechanisms of polymorphism, specifically, virtual functions (based on inheritance) and various polymorphic wrappers (with value semantics) in the standard. As a result, <code>proxy</code> can largely replace the existing &#8220;virtual mechanism&#8221; to implement your vision in runtime polymorphism, while having no intrusion on existing code, with even better performance.</p>
<p>All the facilities of the library are defined in namespace <code>pro</code>. The 3 major class templates are <code>dispatch</code>, <code>facade</code> and <code>proxy</code>. Here is a demo showing how to use this library to implement runtime polymorphism in a different way from the traditional inheritance-based approach:</p>
<pre><code class="language-cpp">// Abstraction
struct Draw : pro::dispatch&lt;void(std::ostream&amp;)&gt; {
  template &lt;class T&gt;
  void operator()(const T&amp; self, std::ostream&amp; out) { self.Draw(out); }
};
struct Area : pro::dispatch&lt;double()&gt; {
  template &lt;class T&gt;
  double operator()(const T&amp; self) { return self.Area(); }
};
struct DrawableFacade : pro::facade&lt;Draw, Area&gt; {};

// Implementation (No base class)
class Rectangle {
 public:
  void Draw(std::ostream&amp; out) const
      { out &lt;&lt; "{Rectangle: width = " &lt;&lt; width_ &lt;&lt; ", height = " &lt;&lt; height_ &lt;&lt; "}"; }
  void SetWidth(double width) { width_ = width; }
  void SetHeight(double height) { height_ = height; }
  double Area() const { return width_ * height_; }

 private:
  double width_;
  double height_;
};

// Client - Consumer
std::string PrintDrawableToString(pro::proxy&lt;DrawableFacade&gt; p) {
  std::stringstream result;
  result &lt;&lt; "shape = ";
  p.invoke&lt;Draw&gt;(result);  // Polymorphic call
  result &lt;&lt; ", area = " &lt;&lt; p.invoke&lt;Area&gt;();  // Polymorphic call
  return std::move(result).str();
}

// Client - Producer
pro::proxy&lt;DrawableFacade&gt; CreateRectangleAsDrawable(int width, int height) {
  Rectangle rect;
  rect.SetWidth(width);
  rect.SetHeight(height);
  return pro::make_proxy&lt;DrawableFacade&gt;(rect);  // No heap allocation is expected
}</code></pre>
<h2 id="configure-your-project">Configure your project</h2>
<p>To get started, set the language level of your compiler to at least C++20 and get the header file (<a href="https://github.com/microsoft/proxy/blob/main/proxy.h">proxy.h</a>). You can also install the library via <a href="https://github.com/microsoft/vcpkg/">vcpkg</a>, which is a C++ library management software invented by Microsoft, by searching for &#8220;proxy&#8221;.</p>
<p>To integrate with CMake, 3 steps are required:</p>
<ol>
<li>Set up the vcpkg manifest by adding &#8220;proxy&#8221; as a dependency in your <code>vcpkg.json</code> file:
<pre><code class="language-json">{
"name": "&lt;project_name&gt;",
"version": "0.1.0",
"dependencies": [
{
  "name": "proxy"
}
]
}</code></pre>
</li>
<li>Use <code>find_package</code> and <code>target_link_libraries</code> commands to reference to the library <code>proxy</code> in your <code>CMakeLists.txt</code> file:
<pre><code class="language-cmake">find_package(proxy CONFIG REQUIRED)
target_link_libraries(&lt;target_name&gt; PRIVATE msft_proxy)</code></pre>
</li>
<li>Run CMake with vcpkg toolchain file:
<pre><code class="language-cmake">cmake &lt;source_dir&gt; -B &lt;build_dir&gt; -DCMAKE_TOOLCHAIN_FILE=&lt;vcpkg_dir&gt;/scripts/buildsystems/vcpkg.cmake</code></pre>
</li>
</ol>
<h2 id="what-makes-the-proxy-so-charming">What makes the &#8220;proxy&#8221; so charming</h2>
<p>As a polymorphic programming library, <code>proxy</code> has various highlights, including:</p>
<ol>
<li>being <em>non-intrusive</em></li>
<li>allowing lifetime management <em>per object</em>, complementary with smart pointers</li>
<li>high-quality code generation</li>
<li>supporting flexible composition of abstractions</li>
<li>optimized syntax for Customization Point Objects (CPO) and modules</li>
<li>supporting general-purpose static reflection</li>
<li>supporting expert performance tuning</li>
<li>high-quality diagnostics.</li>
</ol>
<p>In this section, we will briefly introduce each of the highlights listed above with concrete examples.</p>
<h3 id="highlight-1-being-non-intrusive">Highlight 1: Being non-intrusive</h3>
<p>Designing polymorphic types with inheritance usually requires careful architecting. If the design is not thought through enough early on, the components may become overly complex as more and more functionality is added, or extensibility may be insufficient if polymorphic types are coupled too closely. On the other hand, some libraries (including the standard library) may not have proper polymorphic semantics even if they, by definition, satisfy same specific constraints. In such scenarios, users have no alternative but to design and maintain extra middleware themselves to add polymorphism support to existing implementations.</p>
<p>For example, some programming languages provide base types for containers, which makes it easy for library authors to design APIs without binding to a specific data structure at runtime. However, this is not feasible in C++ because most of the standard containers are not required to have a common base type. I do not think this is a design defect of C++, on the contrary, I think it is reasonable not to overdesign for runtime abstraction before knowing the concrete requirements both for the simplicity of the semantics and for runtime performance. With <code>proxy</code>, because it is non-intrusive, if we want to abstract a mapping data structure from indices to strings for localization, we may define the following facade:</p>
<pre><code class="language-cpp">struct at : pro::dispatch&lt;std::string(int)&gt; {
  template &lt;class T&gt;
  auto operator()(T&amp; self, int key) { return self.at(key); }
};
struct ResourceDictionaryFacade : pro::facade&lt;at&gt; {};</code></pre>
<p>It could proxy any potential mapping data structure, including but not limited to <code>std::map&lt;int, std::string&gt;</code>, <code>std::unordered_map&lt;int, std::string&gt;</code>, <code>std::vector&lt;std::string&gt;</code>, etc.</p>
<pre><code class="language-cpp">// Library
void DoSomethingWithResourceDictionary(pro::proxy&lt;ResourceDictionaryFacade&gt; p) {
  try {
    std::cout &lt;&lt; p.invoke(1) &lt;&lt; std::endl;
  } catch (const std::out_of_range&amp; e) {
    std::cout &lt;&lt; "No such element: " &lt;&lt; e.what() &lt;&lt; std::endl;
  }
}

// Client
std::map&lt;int, std::string&gt; var1{{1, "Hello"}};
std::vector&lt;std::string&gt; var2{"I", "love", "Proxy", "!"};
DoSomethingWithResourceDictionary(&amp;var1);  // Prints "Hello"
DoSomethingWithResourceDictionary(&amp;var2);  // Prints "love"
DoSomethingWithResourceDictionary(std::make_shared&lt;std::unordered_map&lt;int, std::string&gt;&gt;());  // Prints "No such element: {implementation-defined error message}"</code></pre>
<p>Overall, inheritance-based polymorphism has certain limitations in usability. As <a href="https://www.youtube.com/watch?v=QGcVXgEVMJg">Sean Parent commented on NDC 2017</a>: <em>The requirements of a polymorphic type, by definition, comes from its use, and there are no polymorphic types, only polymorphic use of similar types. Inheritance is the base class of evil</em>.</p>
<h3 id="highlight-2-evolutionary-lifetime-management">Highlight 2: Evolutionary lifetime management</h3>
<p>It is such a pain to manage lifetime of objects in large systems written in C++. Because C++ does not have built-in GC support due to performance considerations, users need to beware of lifetime management of every single object. Although we have smart pointers since C++11 (i.e., <code>std::unique_ptr</code> and <code>std::shared_ptr</code>), and various 3rd-party fancy pointers like <code>boost::interprocess::offset_ptr</code>, they are not always sufficient for polymorphic use with inheritance. By using the <code>proxy</code> complementary with smart pointers, clients could care less about lifetime management as if there is runtime GC, but without compromising performance.</p>
<p>Before using any polymorphic object, the first step is always to create it. In other programming languages like Java or C#, we can <code>new</code> an object at any time and runtime GC will take care of lifetime management when it becomes unreachable, at the cost of performance. But how should we implement it in C++? Consider the <code>drawable</code> example in the &#8220;Overview&#8221; section: given there are 3 <code>drawable</code> types in a system: <code>Rectangle</code>, <code>Circle</code>, and <code>Point</code>. Specifically,</p>
<ul>
<li><code>Rectangle</code>s have width, height, transparency, and area</li>
<li><code>Circle</code>s have radius, transparency, and area</li>
<li><code>Point</code>s do not have any property; its area is always zero</li>
</ul>
<p>A library function <code>MakeDrawableFromCommand</code> shall be defined as a factory function responsible for creating a <code>drawable</code> instance by parsing the command line.</p>
<p>Here is how we usually define the types with inheritance:</p>
<pre><code class="language-cpp">// Abstraction
class IDrawable {
 public:
  virtual void Draw(std::ostream&amp; out) const = 0;
  virtual double Area() const = 0;
  // Don't forget the virtual destructor, otherwise `delete`ing a pointer of `IDrawable` may result in memory leak!
  virtual ~IDrawable() {}  
};

// Implementation
class Rectangle : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  void SetWidth(double width);
  void SetHeight(double height);
  void SetTransparency(double);
  double Area() const override;
};
class Circle : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  void SetRadius(double radius);
  void SetTransparency(double transparency);
  double Area() const override;
};
class Point : public IDrawable {
 public:
  void Draw(std::ostream&amp; out) const override;
  constexpr double Area() const override { return 0; }
};</code></pre>
<p>If we use <code>std::string</code> to represent the command line, the parameter type of <code>MakeDrawableFromCommand</code> could be <code>const std::string&amp;</code>, where there should not be much debate. But what should the return type be? <code>IDrawable*</code>? <code>std::unique_ptr&lt;IDrawable&gt;</code>? Or <code>std::shared_ptr&lt;IDrawable&gt;</code>? Specifically,</p>
<ul>
<li>If we use <code>IDrawable*</code>, the semantics of the return type is ambiguous because it is a raw pointer type and does not indicate the lifetime of the object. For instance, it could be allocated via <code>operator new</code>, from a memory pool or even a global object. Clients always need to learn the hidden contract from the author (or even need to learn the implementation details if the author and documentation are not available for consulting) and properly disposing of the object when the related business has finished via <code>operator delete</code> or some other way corresponding to how it was allocated.</li>
<li>If we use <code>std::unique_ptr&lt;IDrawable&gt;</code>, it means every single object is allocated individually from the heap, even if the value is potentially immutable or reusable (&#8220;flyweight&#8221;), which is potentially bad for performance.</li>
<li>If we use <code>std::shared_ptr&lt;IDrawable&gt;</code>, the performance could become better for flyweight objects due to the relatively low cost of copying, but the ownership of the object becomes ambiguous (a.k.a. &#8220;ownership hell&#8221;), and the thread-safety guarantee of copy-construction and destruction of <code>std::shared_ptr</code> may also add to runtime overhead. On the other hand, if we prefer <code>std::shared_ptr</code> across the whole system, every polymorphic type is encouraged to inherit <code>std::enable_shared_from_this</code>, which may significantly affect the design and maintenance of a large system.</li>
</ul>
<p>For <code>proxy</code>, with the definition from the &#8220;Overview&#8221; section, we can simply define the return type as <code>pro::proxy&lt;DrawableFacade&gt;</code> without further concern. In the implementation, <code>pro::proxy&lt;DrawableFacade&gt;</code> could be instantiated from all kinds of pointers with potentially different lifetime management strategy. For example, <code>Rectangle</code>s may be created every time when requested from a memory pool, while the value of <code>Point</code>s could be cached throughout the lifetime of the program:</p>
<pre><code class="language-cpp">pro::proxy&lt;DrawableFacade&gt; MakeDrawableFromCommand(const std::string&amp; s) {
  std::vector&lt;std::string&gt; parsed = ParseCommand(s);
  if (!parsed.empty()) {
    if (parsed[0u] == "Rectangle") {
      if (parsed.size() == 3u) {
        static std::pmr::unsynchronized_pool_resource rectangle_memory_pool;
        std::pmr::polymorphic_allocator&lt;&gt; alloc{&amp;rectangle_memory_pool};
        auto deleter = [alloc](Rectangle* ptr) mutable
            { alloc.delete_object&lt;Rectangle&gt;(ptr); };
        Rectangle* instance = alloc.new_object&lt;Rectangle&gt;();
        std::unique_ptr&lt;Rectangle, decltype(deleter)&gt; p{instance, deleter};  // Allocated from a memory pool
        p-&gt;SetWidth(std::stod(parsed[1u]));
        p-&gt;SetHeight(std::stod(parsed[2u]));
        return p;  // Implicit conversion happens
      }
    } else if (parsed[0u] == "Circle") {
      if (parsed.size() == 2u) {
        Circle circle;
        circle.SetRadius(std::stod(parsed[1u]));
        return pro::make_proxy&lt;DrawableFacade&gt;(circle);  // SBO may apply
      }
    } else if (parsed[0u] == "Point") {
      if (parsed.size() == 1u) {
        static Point instance;  // Global singleton
        return &amp;instance;
      }
    }
  }
  throw std::runtime_error{"Invalid command"};
}</code></pre>
<p>The full implementation of the example above could be found in our <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_integration_tests.cpp#L87-L116">integration tests</a>. In this example, there are 3 <code>return</code> statements in different branches and the return types are also different. Lifetime management with inheritance-based polymorphism is error-prone and inflexible, while <code>proxy</code> allows easy customization of any lifetime management strategy, including but not limited to raw pointers and various smart pointers with potentially pooled memory management.</p>
<p>Specifically, Small Buffer Optimization (SBO, a.k.a., SOO, Small Object Optimization) is a common technique to avoid unnecessary memory allocation (see the second <code>return</code> statement). However, for inheritance-based polymorphism, there are few facilities in the standard that support SBO; for other standard polymorphic wrappers, implementations may support SBO, but there is no standard way to configure it so far. For example, if the size of <code>std::any</code> is <code>n</code>, it is theoretically impossible to store the concrete value whose size is larger than <code>n</code> without external storage.</p>
<p><strong>The top secret making <code>proxy</code> both easy-to-use and fast is that it allows lifetime management <em>per object</em></strong>, which had not been addressed in traditional OOP theory (inheritance-based polymorphism) ever before.</p>
<p>If you have tried other polymorphic programming libraries in C++ before, you may or may not find this highlight of lifetime management unique to <code>proxy</code>. Some of these libraries claim to support various lifetime management model, but do not allow <em>per-object</em> customization like <code>proxy</code> does.</p>
<p>Take <a href="https://github.com/ldionne/dyno"><code>dyno</code></a> as an example. <code>dyno</code> is another non-intrusive polymorphic programming library in C++. Given an &#8220;interface&#8221; type <code>I</code>, <code>dyno</code> does not allow <code>dyno::poly&lt;I&gt;</code> to have a different lifetime management model. By default, <code>dyno::poly&lt;I&gt;</code> always allocates from the heap by the time this blog was written (see <a href="https://github.com/ldionne/dyno/blob/b05a51eeaa4ddd7deb9e3100984bf20cfbf94eab/include/dyno/poly.hpp#L64">typename Storage = dyno::remote_storage</a>). For example, if we want to take advantage of SBO, it is needed to override the <code>Storage</code> type, i.e., <code>dyno::poly&lt;I, dyno::sbo_storage&lt;...&gt;&gt;</code>, which is a different type from <code>dyno::poly&lt;I&gt;</code>. Therefore, <code>dyno::poly&lt;I&gt;</code> could not be used to implement features like <code>MakeDrawableFromCommand</code> above, where the optimal lifetime management model of each branch may differ. Whereas <code>proxy</code> does not have a second template parameter. Given a facade type <code>F</code>, <code>pro::proxy&lt;F&gt;</code> is compatible with <em>any</em> lifetime management model within the constraints of the facade.</p>
<h3 id="highlight-3-high-quality-code-generation">Highlight 3: High-quality code generation</h3>
<p>Not only does <code>proxy</code> allow efficient lifetime management per object, but also it could generate high quality code for every indirect call. Specifically,</p>
<ol>
<li>Invocations from <code>proxy</code> could be properly inlined, except for the virtual dispatch on the client side, similar to the inheritance-based mechanism.</li>
<li>Because <code>proxy</code> is based on pointer semantics, the &#8220;dereference&#8221; operation may happen inside the virtual dispatch, which always generates different instructions from the inheritance-based mechanism.</li>
<li>As tested, with &#8220;clang 13.0.0 (x86-64)&#8221; and &#8221; clang 13.0.0 (RISC-V RV64)&#8221;, <code>proxy</code> generates one more instruction than the inheritance-based mechanism, while the situation is reversed with &#8220;gcc 11.2 (ARM64)&#8221;. This may infer that <code>proxy</code> could have similar runtime performance in invocation with the inheritance-based mechanism at least on the 3 processor architectures (x86-64, ARM64, RISC-V RV64).</li>
</ol>
<p>More details of code generation analysis could be found in <a href="https://wg21.link/p0957">P0957</a>.</p>
<h3 id="highlight-4-composition-of-abstractions">Highlight 4: Composition of abstractions</h3>
<p>To support reuse of declaration of expression sets, like inheritance of virtual base classes, the <code>facade</code> allows combination of different dispatches with <code>std::tuple</code>, while duplication is allowed. For example,</p>
<pre><code class="language-cpp">struct D1;
struct D2;
struct D3;
struct FA : pro::facade&lt;D1, D2, D3&gt; {};
struct FB : pro::facade&lt;D1, std::tuple&lt;D3, D2&gt;&gt; {};
struct FC : pro::facade&lt;std::tuple&lt;D1, D2, D3&gt;, D1, std::tuple&lt;D2, D3&gt;&gt; {};</code></pre>
<p>In the sample code above, given <code>D1</code>, <code>D2</code> and <code>D3</code> are well-formed dispatch types, <code>FA</code>, <code>FB</code> and <code>FC</code> are equivalent. This allows &#8220;diamond inheritance&#8221; of abstraction without</p>
<ul>
<li>syntax ambiguity</li>
<li>coding techniques like &#8220;virtual inheritance&#8221;</li>
<li>extra binary size</li>
<li>runtime overhead</li>
</ul>
<h3 id="highlight-5-syntax-for-cpos-and-modules">Highlight 5: Syntax for CPOs and modules</h3>
<p>Along with the standardization of Customization Point Objects (CPO) and improved syntax for Non-Type Template Parameters (NTTP), there are two recommended ways to define a &#8220;dispatch&#8221; type:</p>
<p>The first way is to manually overload <code>operator()</code> as demonstrated before. This is useful when a dispatch is intended to be defined in a header file shared with multiple translation units, e.g., in <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_invocation_tests.cpp#L25-L33">tests/proxy_invocation_tests.cpp</a>:</p>
<pre><code class="language-cpp">template &lt;class T&gt;
struct ForEach : pro::dispatch&lt;void(pro::proxy&lt;CallableFacade&lt;void(T&amp;)&gt;&gt;)&gt; {
 template &lt;class U&gt;
 void operator()(U&amp; self, pro::proxy&lt;CallableFacade&lt;void(T&amp;)&gt;&gt;&amp;&amp; func) {
  for (auto&amp; value : self) {
   func.invoke(value);
  }
 }
};</code></pre>
<p>The second way is to specify a <code>constexpr</code> callable object as the second template parameter. It provides easier syntax if a corresponding CPO is defined before, or the &#8220;dispatch&#8221; is intended to be defined in a module with lambda expressions, e.g. in <a href="https://github.com/microsoft/proxy/blob/1.0.1/tests/proxy_invocation_tests.cpp#L23">tests/proxy_invocation_tests.cpp</a>:</p>
<pre><code class="language-cpp">struct GetSize : pro::dispatch&lt;std::size_t(), std::ranges::size&gt; {};</code></pre>
<h3 id="highlight-6-static-reflection">Highlight 6: Static reflection</h3>
<p>Reflection is an essential requirement in type erasure, and <code>proxy</code> welcomes general-purpose static (compile-time) reflection other than <code>std::type_info</code>.</p>
<p>In other languages like C# or Java, users are allowed to acquire detailed metadata of a type-erased type at runtime with simple APIs, but this is not true for <code>std::function</code>, <code>std::any</code> or inheritance-based polymorphism in C++. Although these reflection facilities add certain runtime overhead to these languages, they do help users write simple code in certain scenarios. In C++, as the reflection TS keeps evolving, there will be more static reflection facilities in the standard with more specific type information deduced at compile-time than <code>std::type_info</code>. It becomes possible for general-purpose reflection to become zero-overhead in C++ polymorphism.</p>
<p>As a result, we decided to make <code>proxy</code> support general-purpose static reflection. It&#8217;s off by default, and theoretically won&#8217;t impact runtime performance other than the target binary size if turned on. Here is an example to reflect the given types to <code>MyReflectionInfo</code>:</p>
<pre><code class="language-cpp">class MyReflectionInfo {
 public:
  template &lt;class P&gt;
  constexpr explicit MyReflectionInfo(std::in_place_type_t&lt;P&gt;) : type_(typeid(P)) {}
  const char* GetName() const noexcept { return type_.name(); }

 private:
  const std::type_info&amp; type_;
};

struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  using reflection_type = MyReflectionInfo;
};</code></pre>
<p>Users may call <code>MyReflectionInfo::GetName()</code> to get the implementation-defined name of a type at runtime:</p>
<pre><code class="language-cpp">pro::proxy&lt;MyFacade&gt; p;
puts(p.reflect().GetName());  // Prints typeid(THE_UNDERLYING_POINTER_TYPE).name()</code></pre>
<h3 id="highlight-7-performance-tuning">Highlight 7: Performance tuning</h3>
<p>To allow implementation balance between extensibility and performance, a set of constraints to a pointer is introduced, including maximum size, maximum alignment, minimum copyability, minimum relocatability and minimum destructibility. The term &#8220;relocatability&#8221; was introduced in <a href="https://wg21.link/p1144">P1144</a>, &#8220;equivalent to a move and a destroy&#8221;. This blog uses the term &#8220;relocatability&#8221; but does not depend on the technical specifications of <a href="https://wg21.link/p1144">P1144</a>.</p>
<p>While the size and alignment could be described with <code>std::size_t</code>, the constraint level of copyability, relocatability and destructibility are described with enum <code>pro::constraint_level</code>, which includes <code>none</code>, <code>nontrivial</code>, <code>nothrow</code> and <code>trivial</code>, matching the standard wording. The defaults are listed below:</p>
<table>
<thead>
<tr>
<th><strong>Constraints</strong></th>
<th><strong>Defaults</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Maximum size</td>
<td>The size of two pointers</td>
</tr>
<tr>
<td>Maximum alignment</td>
<td>The alignment of a pointer</td>
</tr>
<tr>
<td>Minimum copyability</td>
<td>None</td>
</tr>
<tr>
<td>Minimum relocatability</td>
<td>Nothrow</td>
</tr>
<tr>
<td>Minimum destructibility</td>
<td>Nothrow</td>
</tr>
</tbody>
</table>
<p>We can assume the default maximum size and maximum alignment greater than or equal to the implementation of raw pointers, <code>std::unique_ptr</code> with default deleters, <code>std::unique_ptr</code> with any one-pointer-size of deleters and <code>std::shared_ptr</code> of any type.</p>
<p>Note that the default minimum copyability is &#8220;None&#8221;, which means <code>proxy</code> could be instantiated from a non-copyable type like <code>std::unique_ptr</code>. However, if we never want to instantiate a <code>proxy</code> with non-copyable types (including <code>std::unique_ptr</code>) and want the <code>proxy</code> to be copyable, it is allowed to customize it in a facade definition:</p>
<pre><code class="language-cpp">// Abstraction
struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  static constexpr auto minimum_copyability = pro::constraint_level::nontrivial;
};

// Client
pro::proxy&lt;MyFacade&gt; p0 = /* Omitted */;
auto p1 = p0;  // Calls the constructor of the underlying pointer type</code></pre>
<p>In some cases where we clearly know we always instantiate a <code>proxy</code> with a raw pointer, and want to optimize the performance to the limit, it is allowed to add even more constraints in a facade definition, at the cost of reducing the scope of feasible pointer types:</p>
<pre><code class="language-cpp">// Abstraction
struct MyFacade : pro::facade&lt;/* Omitted */&gt; {
  static constexpr auto minimum_copyability = pro::constraint_level::trivial;
  static constexpr auto minimum_relocatability = pro::constraint_level::trivial;
  static constexpr auto minimum_destructibility = pro::constraint_level::trivial;
  static constexpr auto maximum_size = sizeof(void*);
  static constexpr auto maximum_alignment = alignof(void*);
};

// Client
static_assert(std::is_trivially_copy_constructible_v&lt;pro::proxy&lt;MyFacade&gt;&gt;);
static_assert(std::is_trivially_destructible_v&lt;pro::proxy&lt;MyFacade&gt;&gt;);</code></pre>
<p><strong>IMPORTANT NOTICE</strong>: clang will fail to compile if the <strong>minimum_destructibility</strong> is set to <strong>constraint_level::trivial</strong> in a facade definition. The root cause of this failure is that the implementation requires the language feature defined in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0848r3.html">P0848R3: Conditionally Trivial Special Member Functions</a>, but it has not been implemented in clang, according to its <a href="https://clang.llvm.org/cxx_status.html">documentation</a>, at the time this blog was written.</p>
<h3 id="highlight-8-diagnostics">Highlight 8: Diagnostics</h3>
<p>The design of <code>proxy</code> is SFINAE-friendly, thanks to the Concepts feature since C++20. If it is used incorrectly, compile error messages could be generated accurately at the spot. For example, if we call the constructor of <code>proxy</code> with a pointer, whose type does not meet the facade definition:</p>
<pre><code class="language-cpp">pro::proxy&lt;MyFacade&gt; p;
p.invoke&lt;nullptr_t&gt;();  // nullptr_t is not a valid dispatch type</code></pre>
<p>Here is the error message gcc 11.2 will report:</p>
<pre><code class="language-text">&lt;source&gt;:550:22: error: no matching function for call to 'pro::proxy&lt;MyFacade&gt;::invoke&lt;nullptr_t&gt;()'
  550 |   p.invoke&lt;nullptr_t&gt;();
      |   ~~~~~~~~~~~~~~~~~~~^~
&lt;source&gt;:445:18: note: candidate: 'template&lt;class D, class ... Args&gt; decltype(auto) pro::proxy&lt;F&gt;::invoke(Args&amp;&amp; ...) requires (pro::details::dependent_traits&lt;pro::details::facade_traits&lt;F&gt;, D&gt;::dependent_t&lt;pro::details::facade_traits&lt;F&gt;, D&gt;::applicable) &amp;&amp; (pro::details::BasicTraits::has_dispatch&lt;D&gt;) &amp;&amp; (is_convertible_v&lt;std::tuple&lt;_Args2 ...&gt;, typename D::argument_types&gt;) [with D = D; Args = {Args ...}; F = MyFacade]'
  445 |   decltype(auto) invoke(Args&amp;&amp;... args)
      |                  ^~~~~~
&lt;source&gt;:445:18: note:   template argument deduction/substitution failed:
&lt;source&gt;:445:18: note: constraints not satisfied</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p>We hope this has helped clarify how to take advantage of the library &#8220;proxy&#8221; to write polymorphic code easier. If you have any questions, comments, or issues with the library, you can comment below, file issues in <a href="https://github.com/microsoft/proxy">our GitHub repo</a>, or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via Twitter at <a href="https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/">proxy: Runtime Polymorphism Made Easier Than Ever</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/proxy-runtime-polymorphism-made-easier-than-ever/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Official Support for Arm64EC is Here </title>
		<link>https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/</link>
					<comments>https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/#respond</comments>
		
		<dc:creator><![CDATA[Pranav Srinivasan]]></dc:creator>
		<pubDate>Tue, 09 Aug 2022 15:00:54 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30839</guid>

					<description><![CDATA[<p>Last year, Microsoft announced x64 compatibility for Windows 11 on Arm, along with the new Arm64EC ABI, a new way to bring apps to Windows on Arm. With Arm64EC you can mix Arm and x64 code in the same process, allowing you to port existing x64 apps to Arm in an incremental way.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/">Official Support for Arm64EC is Here </a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW73064057 BCX8">Last year, Microsoft announced x64 </span><span class="NormalTextRun SCXW73064057 BCX8">compatibility</span><span class="NormalTextRun SCXW73064057 BCX8"> for Windows </span><span class="NormalTextRun SCXW73064057 BCX8">11</span><span class="NormalTextRun SCXW73064057 BCX8"> on Arm, along with the new </span></span><a class="Hyperlink SCXW73064057 BCX8" href="https://aka.ms/arm64ecannounceblog" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW73064057 BCX8" data-ccp-charstyle="Hyperlink">Arm64EC ABI</span></span></a><span class="TextRun SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW73064057 BCX8">, a new way to </span><span class="NormalTextRun SCXW73064057 BCX8">bring apps to Windows on Arm</span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW73064057 BCX8">. </span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW73064057 BCX8">With</span><span class="NormalTextRun SCXW73064057 BCX8"> Arm64EC you can mix Arm and x64 code in the same process</span><span class="NormalTextRun SCXW73064057 BCX8">, allowing you to </span><span class="NormalTextRun SCXW73064057 BCX8">port </span><span class="NormalTextRun SCXW73064057 BCX8">existing </span><span class="NormalTextRun SCXW73064057 BCX8">x64 </span><span class="NormalTextRun SCXW73064057 BCX8">apps </span><span class="NormalTextRun SCXW73064057 BCX8">to </span><span class="NormalTextRun CommentStart CommentHighlightPipeRest CommentHighlightRest SCXW73064057 BCX8">A</span><span class="NormalTextRun CommentHighlightRest SCXW73064057 BCX8">rm</span> <span class="NormalTextRun CommentHighlightPipeRest SCXW73064057 BCX8">in an incremental </span><span class="NormalTextRun SCXW73064057 BCX8">way</span><span class="NormalTextRun SCXW73064057 BCX8">.</span> <span class="NormalTextRun SCXW73064057 BCX8">We also announced experimental support for </span></span><a class="Hyperlink SCXW73064057 BCX8" href="https://devblogs.microsoft.com/cppblog/arm64ec-support-in-visual-studio/" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW73064057 BCX8" data-ccp-charstyle="Hyperlink">Arm64EC development in Visual Studio</span></span></a><span class="TextRun SCXW73064057 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW73064057 BCX8">.</span></span><span class="EOP SCXW73064057 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Now, after a year of bug fixes and product stabilization, we are here to announce that this toolset is leaving experimental mode in the 17.3 release, making it possible to build fully-supported Arm64EC applications for Windows 11 on Arm. We hope that using Arm64EC makes it easier for developers to target Windows on Arm, especially for applications that are blocked today from moving to Arm due to x64 plugins or dependencies.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="learn-more-about-arm64ec"><span data-contrast="none">Learn More about Arm64EC</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">Want to learn more about Arm64EC to determine if it is the best solution for your porting efforts? We have several resources detailing how Arm64EC works and how to use it, compiled here for your convenience.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ol>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">For getting started on building Arm64EC applications, check out this </span><a href="https://aka.ms/arm64ecgettingstarted"><span data-contrast="none">documentation</span></a><span data-contrast="auto"> on how to get the tools you’ll need.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">To see an end-to-end example of using x64 plugins for digital audio workstations, check out this post: </span><a href="https://devblogs.microsoft.com/windows-music-dev/load-x64-plug-ins-like-vsts-from-your-arm-code-using-arm64ec"><span data-contrast="none">Load x64 Plug-ins (like VSTs) from your Arm Code using Arm64EC</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">You can also build binaries that can be used by both Arm64 and Arm64EC/x64 processes on Windows on Arm devices. To learn more about this binary format and how to build them, check out this </span><a href="https://aka.ms/arm64xbinaryintro"><span data-contrast="none">documentation on Arm64X binaries</span></a><span data-contrast="auto">. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="%1." data-font="Calibri" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">For a more in-depth understanding of Arm64EC as an ABI and how the interoperability with emulated x64 works, check out the documentation on </span><a href="https://docs.microsoft.com/windows/arm/arm64ec-abi"><span data-contrast="none">Arm64EC assembly</span></a><span data-contrast="auto"> and the </span><a href="https://docs.microsoft.com/cpp/build/arm64ec-windows-abi-conventions"><span data-contrast="none">ABI</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ol>
<h1 aria-level="1" aria-level="1" id="whats-next"><span data-contrast="none">What’s Next?</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We are planning continued support for the toolchain in upcoming releases, with the intent of supporting the <code>__vectorcall</code> calling convention in Arm6EC as well as tackling performance optimizations. If you want to get in contact with us regarding issues with the toolchain or any feedback about its usage, we’re always listening on Developer Community.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/">Official Support for Arm64EC is Here </a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/official-support-for-arm64ec-is-here/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC Backend Updates in Visual Studio 2022 version 17.3</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/#respond</comments>
		
		<dc:creator><![CDATA[Chris Pulido]]></dc:creator>
		<pubDate>Tue, 09 Aug 2022 15:00:49 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[OpenMP]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30829</guid>

					<description><![CDATA[<p>In Visual Studio 2022 version 17.3 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a list of improvements for you to review.</p>
<p>Native Arm64 Visual Studio is now available for 17.3!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/">MSVC Backend Updates in Visual Studio 2022 version 17.3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In <a href="https://visualstudio.microsoft.com/vs/">Visual Studio 2022</a> version 17.3 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a list of improvements for you to review.</p>
<ul>
<li>Native Arm64 Visual Studio is now available for 17.3! See the <a href="https://devblogs.microsoft.com/visualstudio/arm64-visual-studio/">Visual Studio blog post</a> for details on how to install Arm64 Visual Studio, and what workloads are available for 17.3.</li>
<li>The C++ ARM64EC target is available for production development. To learn more about the ARM64EC ABI, see <a href="https://docs.microsoft.com/en-us/cpp/build/arm64ec-windows-abi-conventions?view=msvc-170">Overview of ARM64EC ABI conventions</a>, and <a href="https://docs.microsoft.com/en-us/windows/arm/arm64ec-abi">Understanding Arm64EC ABI and assembly code</a>. To learn more about using ARM64EC in Visual Studio, see <a href="https://docs.microsoft.com/en-us/windows/arm/arm64ec">Using Arm64EC to build apps for Windows 11 on Arm devices</a>.</li>
<li>The ARM64EC toolchain now emits an error when vectorcall semantics, <code>__m256</code> types or <code>__m512</code> types are used when compiling for ARM64EC as these are unsupported scenarios. Full vectorcall support is planned for a future release.</li>
<li>More progress has been made towards implementing OpenMP Standard 3.1 under the experimental <code>-openmp:llvm</code> switch, building on the <a href="https://devblogs.microsoft.com/cppblog/openmp-task-support-for-c-in-visual-studio/">previous release</a>:
<ul>
<li>Implemented atomics-related features from OpenMP 3.1.</li>
<li>Enabled use of pointers as induction variables in OpenMP loops.</li>
</ul>
</li>
<li>[Credit to our friends at AMD] Improved Superword-Level Parallelism (SLP) vectorizer, handling more types and vector widths. More details to come in a future blog post. Add the <code>/Qvec-report:1</code> switch and look for <code>info C5003: block vectorized</code> for more SLP vectorization.</li>
<li>Support for recognizing and building ARM64 NEON vector fused multiply-add (FMA) instructions after loop vectorization. Floating-point vector FMA instructions are only built under <code>/fp:fast</code>, or <code>/fp:contract</code> if <code>/fp:precise</code> is also specified. More details about <code>/fp</code> can be found in <a href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS 2022</a>, and the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fp-specify-floating-point-behavior?view=msvc-170">MSVC compiler options reference for /fp</a>.</li>
<li>More peephole optimizations. Here are some cases that were improved:
<ul>
<li><a href="https://developercommunity.visualstudio.com/t/Release-build-of-SSE-code-is-inserting-u/1536674">Release build of SSE code is inserting unnecessary shufps</a></li>
<li><a href="https://developercommunity2.visualstudio.com/t/string-view:-suboptimal-forwarding-of-va/1306660">string-view: suboptimal forwarding of values through vector registers</a></li>
<li><a href="https://developercommunity.visualstudio.com/t/Suspicious-codegen-for-assignment-of-ret/1695810">Suspicious codegen for assignment of return value with __vectorcall and /arch:AVX</a></li>
</ul>
</li>
</ul>
<p>Do you want to experience the new improvements of the C++ backend? Please <a href="https://visualstudio.microsoft.com/vs/">download the latest Visual Studio 2022</a> and give it a try! Any feedback is welcome. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc">@VisualC</a>)</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/">MSVC Backend Updates in Visual Studio 2022 version 17.3</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-3/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSBuild Low Priority Builds in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/#respond</comments>
		
		<dc:creator><![CDATA[Felix Huang]]></dc:creator>
		<pubDate>Wed, 27 Jul 2022 15:00:07 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30732</guid>

					<description><![CDATA[<p>The C++ team is happy to announce the completion of a highly upvoted C++ feedback ticket from Developer Community – Low Priority Builds. With your feedback and collaboration from our partner teams, you can now start Low Priority Builds within Visual Studio.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/">MSBuild Low Priority Builds in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ team is happy to announce the completion of a highly upvoted <a href="https://developercommunity.visualstudio.com/t/Limit-CPU-usage-of-Visual-Studio-during/436208">C++ feedback ticket</a> from Developer Community – Low Priority Builds. With your feedback and collaboration from our partner teams, you can now start Low Priority Builds within Visual Studio. This will ensure the MSBuild node spawns with a lower priority, affecting all compile and link processes. If the build is affecting you from having a responsive work environment, then this is the feature for you! </p>
<p>Internally, VS interfaces with MSBuild like a service. The <a href="https://github.com/dotnet/msbuild">MSBuild team</a> has added new API functionality to switch the priority of the MSBuild nodes. Starting in Visual Studio 2022 version 17.3 Preview 1, a new option under the Tools -&gt; Options -&gt; &#8220;Projects and Solutions&#8221; -&gt; &#8220;Build And Run&#8221; -&gt; &#8220;Run build at low process priority&#8221; allows you to lower the priority of the your next builds. If a MSBuild node is already running with the previous priority, then give them a few minutes to time out or restart the IDE to close them.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS.png"><img class="size-medium wp-image-30740 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS-300x96.png" alt="Image lowpriSS" width="300" height="96" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS-300x96.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS-768x247.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpriSS.png 989w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>For building directly on the command line, use msbuild.exe -lowPriority or -low for similar effect.<img class="size-medium wp-image-30748 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_cl-300x118.png" alt="Image lowpri taskman cl" width="300" height="118" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_cl-300x118.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_cl.png 714w" sizes="(max-width: 300px) 100vw, 300px" /></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild.png"><img class="size-medium wp-image-30749 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild-300x95.png" alt="Image lowpri taskman msbuild" width="300" height="95" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild-300x95.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/06/lowpri_taskman_msbuild.png 719w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>Try out low-priority MSBuild tasks by downloading the latest <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2022 Preview</a>! Any feedback is welcome. We can be reached via the comments below, Developer Community, reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>, and Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>For other build performance tips and tools: <br /><a href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/</a> </p>
<p>Thank you, </p>
<p>Felix Huang,<br />VC++</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/">MSBuild Low Priority Builds in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msbuild-low-priority-builds-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg July 2022 Release is Now Available: Shared Libraries on Linux, Improved vcpkg new, Optional name and version Fields, and More…</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Mon, 25 Jul 2022 18:23:53 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30808</guid>

					<description><![CDATA[<p>The July 2022 release of the vcpkg package manager is available. This blog post summarizes changes from June 16th, 2022 to July 24th, 2022 for the microsoft/vcpkg and microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>15 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/">vcpkg July 2022 Release is Now Available: Shared Libraries on Linux, Improved vcpkg new, Optional name and version Fields, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.07.25">July 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from June 16<sup>th</sup>, 2022 to July 24<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>15 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>360 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>1,967 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are <strong>10,106 port versions</strong>.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.07.25">July release of the main vcpkg repo</a> includes <strong>278 commits</strong>.</li>
<li><strong>90 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.7k forks</strong> and <strong>16.3k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<h4 id="better-support-for-shared-libraries-on-linux">Better support for shared libraries on Linux</h4>
<p>This update includes a community triplet for installing shared libraries on Linux: x64-linux-dynamic. This was made possible by adding rpath support to make ports relocatable. After building a port, the binaries are patched to have correct rpath values relative to lib/ (or debug/lib/). This update is significant because it makes it much easier to handle shared libraries on Linux, meaning users don’t have to install libraries statically on Linux to get the best user experience.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg/pull/23035">Microsoft/vcpkg#23035</a> (thank you @<a href="https://github.com/Osyotr">Osyotr</a>!)</p>
<p>&nbsp;</p>
<h4 id="vcpkg-new-now-generates-both-port-and-artifact-manifest-files">‘vcpkg new’ now generates both port and artifact manifest files</h4>
<p>As part of the vcpkg artifacts experience, a new command called new was added that can generate a vcpkg-configuration.json file. The file is a manifest for artifacts that vcpkg can install for a project. In this update, the implementation was re-written in C++ and the command now also generates a vcpkg.json file for declaring ports for a project. It also fills in the default registry with the current baseline git SHA. Going forward, vcpkg new will be useful for configuring a project for use with vcpkg, whether it requires ports or artifacts.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/613">Microsoft/vcpkg-tool#613</a></p>
<p>&nbsp;</p>
<h4 id="name-and-version-fields-are-no-longer-required-in-vcpkg-json-files">name and version fields are no longer required in vcpkg.json files</h4>
<p>We sometimes get asked by users why vcpkg.json files require a name and a version field to be filled in. This is a consequence of the same file being used both for authoring ports and for consuming them in an application. These fields are required metadata for ports so they can be organized and referenced appropriately by end users. However, it is clear that these fields don’t serve much purpose if you are only using vcpkg to acquire other dependencies and aren’t producing your own vcpkg ports.</p>
<p>As a result, we have made these fields optional in vcpkg.json. This is also consistent with how vcpkg-configuration.json is structured for artifacts. However, there are implications when generating manifests using vcpkg new – this command should be called with either a pair of &#8211;name and &#8211;version properties or with &#8211;application, which designates the manifest as one that won’t need these fields.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/605">Microsoft/vcpkg-tool#605</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-find-artifact-can-be-filtered-by-registry">vcpkg find artifact can be filtered by registry</h4>
<p>It is now possible to search for artifacts under a specific registry by running</p>
<p><code>vcpkg find artifact:&lt;registry name&gt;</code></p>
<p>Example:</p>
<p><img width="1439" height="221" class="wp-image-30810" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated.png" alt="Text Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated.png 1439w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated-300x46.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated-1024x157.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/07/text-description-automatically-generated-768x118.png 768w" sizes="(max-width: 1439px) 100vw, 1439px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/608">Microsoft/vcpkg-tool#608</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-init-ps1-installer-now-works-with-powershell-on-linux">vcpkg-init.ps1 installer now works with PowerShell on Linux</h4>
<p>When we announced the vcpkg artifacts experience, there were two ways to install vcpkg with this support. On Linux/macOS, we provided a bash script, and on Windows, a PowerShell script. In this release of vcpkg, the PowerShell installer script now also works on macOS and Linux, so you can freely use it in these environments. For updated instructions on how to install, use, or remove vcpkg using one of these scripts, see: <a href="https://github.com/microsoft/vcpkg-tool#installuseremove">microsoft/vcpkg-tool: Components of microsoft/vcpkg &#8216;s binary. (github.com)</a></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/611">Microsoft/vcpkg-tool#611</a></p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation changes</h4>
<p>The following documentation changes were made this release:</p>
<ul>
<li>Added documentation for remove command.</li>
<li>Added documentation for x-update-baseline command, used to update version baselines for configured registries.</li>
<li>Revised documentation for vcpkg_cmake_configure, a port helper function.</li>
<li>Revised documentation for vcpkg_extract_source_archive, a port helper function:
<ul>
<li>Don’t list deprecated overload first</li>
<li>Documents REF</li>
<li>Document each option in a list for improved discoverability, instead of a large block</li>
<li>Replace static list of ports with a GitHub query that will find uses in all ports</li>
</ul>
</li>
</ul>
<p>PRs: <a href="https://github.com/microsoft/vcpkg/pull/25264">Microsoft/vcpkg#25264</a>, <a href="https://github.com/microsoft/vcpkg/pull/25256">Microsoft/vcpkg#25256</a>, <a href="https://github.com/microsoft/vcpkg/pull/25255">Microsoft/vcpkg#25255</a>, <a href="https://github.com/microsoft/vcpkg/pull/25178">Microsoft/vcpkg#25178</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,772</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,820</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,719</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,733</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>936</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,362</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>887</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,688</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,754</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms x architectures, the list above is routinely tested to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>dg0yt (22 commits)</li>
<li>autoantwort (22 commits)</li>
<li>Osyotr (12 commits)</li>
<li>Thomas1664 (10 commits)</li>
<li>Neumann-A (4 commits)</li>
<li>coryan (3 commits)</li>
<li>AenBleidd (3 commits)</li>
<li>ekilmer (2 commits)</li>
<li>m-kuhn (2 commits)</li>
<li>eao197 (2 commits)</li>
<li>myd7349 (2 commits)</li>
<li>RT222 (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>cenit (1 commit)</li>
<li>Be-ing (1 commit)</li>
<li>bsiegert (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.07.25">full July release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/">vcpkg July 2022 Release is Now Available: Shared Libraries on Linux, Improved vcpkg new, Optional name and version Fields, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-july-2022-release-is-now-available-shared-libraries-on-linux-improved-vcpkg-new-optional-name-and-version-fields-and-more/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
	</channel>
</rss>
