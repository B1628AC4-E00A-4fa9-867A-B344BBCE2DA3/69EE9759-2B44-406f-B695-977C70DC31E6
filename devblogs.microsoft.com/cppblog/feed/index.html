<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>The latest in C++, Visual Studio, VS Code, and vcpkg from the MSFT C++ team</description>
	<lastBuildDate>Tue, 05 Aug 2025 20:34:38 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>What’s New in vcpkg (July 2025)</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Tue, 05 Aug 2025 20:34:38 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35637</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2025.07.25 registry release, 2025-06-20, 2025-07-16, and 2025-07-21 tool releases, as well as changes to vcpkg documentation throughout July. This release includes a new command for printing package SPDX licenses, binary caching optimizations, and support for visionOS, Solaris, and illumos systems. Some [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/">What’s New in vcpkg (July 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2025.07.25">2025.07.25</a> registry release, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-06-20">2025-06-20</a>, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-07-16">2025-07-16</a>, and <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-07-21">2025-07-21</a> tool releases, as well as changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout July. This release includes a new command for printing package SPDX licenses, binary caching optimizations, and support for visionOS, Solaris, and illumos systems.</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,653 total ports </strong>available in the vcpkg curated registry. A <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>34 new ports</strong> were added to the curated registry.</li>
<li><strong>282 ports were updated</strong>. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our 15 main <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>101 </strong>community contributors made commits.</li>
<li>The main vcpkg repo has over <strong>7,000 forks</strong> and <strong>25,300 stars</strong> on GitHub.</li>
</ul>
<h1>vcpkg changelog (2025.07.25 release)</h1>
<p>The following notable changes were made in this release:</p>
<ul>
<li>Added <a href="https://learn.microsoft.com/vcpkg/commands/license-report">new vcpkg command license-report</a>, which prints the SPDX licenses from the Software Bill of Materials (SBOMs) of all installed packages. In addition, SPDX licenses now also get printed for packages being installed via classic mode <code>vcpkg install &lt;port names&gt;</code> (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1514">Microsoft/vcpkg-tool#1514</a>).</li>
<li>Binary cache restore optimization: Now decompressing zip files ordered by size, resulting in time savings of up to 14% (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1715">Microsoft/vcpkg-tool#1715</a>, thanks @autoantwort!).</li>
<li>vcpkg now uses <em>azcopy</em> to upload large artifacts for binary caching, which enables binary cache entries &gt; 5GB in size (PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/1679">Microsoft/vcpkg-tool#1679</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1717">Microsoft/vcpkg-tool#1717</a>, thanks @dg0yt!).</li>
<li>Added support for visionOS as an available target platform for vcpkg builds (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1681">Microsoft/vcpkg-tool#1681</a>, thanks @colincornaby!).</li>
<li>Added support for building and using vcpkg on Solaris and illumos systems (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1684">Microsoft/vcpkg-tool#1684</a>, thanks @trisk!).</li>
<li>Other minor bug fixes and internal feature improvements.</li>
</ul>
<h1>Documentation changes</h1>
<ul>
<li>Minor documentation fixes (thanks @bgilbert and @ impugachev!).</li>
</ul>
<p>If you have any suggestions for our documentation, please <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a> or see the box at the bottom of a particular article.</p>
<h1>Total ports available for tested triplets</h1>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>2442</td>
</tr>
<tr>
<td>x64-windows</td>
<td>2564</td>
</tr>
<tr>
<td>x64-windows-release</td>
<td>2564</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2437</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2494</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1439</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>2157</td>
</tr>
<tr>
<td>arm64-windows-static-md</td>
<td>2138</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1406</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2433</td>
</tr>
<tr>
<td>arm64-osx</td>
<td>2359</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2551</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1980</td>
</tr>
<tr>
<td>x64-android</td>
<td>2041</td>
</tr>
<tr>
<td>arm64-android</td>
<td>2003</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<h1>Thank you to our contributors</h1>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a>, or <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs</a> repos in this release (listed by commit author or GitHub username):</p>
<table>
<tbody>
<tr>
<td>Aditya Rao</td>
<td>Craig Edwards</td>
<td>Kai Blaschke</td>
<td>Russell Greene</td>
</tr>
<tr>
<td>Albert Lee</td>
<td>Dewey Dunnington</td>
<td>Kai Pastor</td>
<td>S. M. Mohiuddin Khan Shiam</td>
</tr>
<tr>
<td>Aleksi Sapon</td>
<td>dg0yt</td>
<td>llm96</td>
<td>Saad</td>
</tr>
<tr>
<td>Alex Emirov</td>
<td>Dr. Patrick Urbanke</td>
<td>Loïc Bartoletti</td>
<td>Saikari</td>
</tr>
<tr>
<td>Alexis La Goutte</td>
<td>Egor Krugletsov</td>
<td>Luca Longinotti</td>
<td>Samuel Marks</td>
</tr>
<tr>
<td>Alexis Placet</td>
<td>Employee_NO427</td>
<td>Lukas Dürrenberger</td>
<td>Sander Cox</td>
</tr>
<tr>
<td>Ali Mohammad Pur</td>
<td>Ethrynto</td>
<td>Lukey</td>
<td>shixiong2333</td>
</tr>
<tr>
<td>Alonso Schaich</td>
<td>Fidel Yin</td>
<td>matlabbe</td>
<td>sidy3d</td>
</tr>
<tr>
<td>Amin Ya</td>
<td>Filippos Karapetis</td>
<td>Matthias Zronek</td>
<td>Stefano Sinigardi</td>
</tr>
<tr>
<td>An Tao</td>
<td>gav2xlin</td>
<td>Michał Petryka</td>
<td>Stephen Eckels</td>
</tr>
<tr>
<td>Anders Wind</td>
<td>GioGio</td>
<td>Michael MIGLIORE</td>
<td>SunBlack</td>
</tr>
<tr>
<td>Andrew Kaster</td>
<td>Igor Pugachev</td>
<td>miyanyan</td>
<td>Sylvain Doremus</td>
</tr>
<tr>
<td>Antony Peacock</td>
<td>ilya-fedin</td>
<td>Mzying2001</td>
<td>Taewon Park</td>
</tr>
<tr>
<td>autoantwort</td>
<td>Ivan</td>
<td>Nick D&#8217;Ademo</td>
<td>Takatoshi Kondo</td>
</tr>
<tr>
<td>avaliente-evs</td>
<td>Ivan Sorokin</td>
<td>Nick Logozzo</td>
<td>talregev</td>
</tr>
<tr>
<td>ayeteadoe</td>
<td>Jörg Bornemann</td>
<td>Oliver</td>
<td>Theodore Tsirpanis</td>
</tr>
<tr>
<td>Azure SDK Bot</td>
<td>JackeyLea</td>
<td>Osyotr</td>
<td>Thomas Arcila</td>
</tr>
<tr>
<td>Benjamin Gilbert</td>
<td>Jacopo Gasparetto</td>
<td>Pierre Wendling</td>
<td>Tim Flynn</td>
</tr>
<tr>
<td>Benjamin Pearce</td>
<td>James Grant</td>
<td>Pratik Chowdhury</td>
<td>toge</td>
</tr>
<tr>
<td>Branden Bonaby</td>
<td>Jeffrey Wardman</td>
<td>Rémy Tassoux</td>
<td>Vitalii Koshura</td>
</tr>
<tr>
<td>Bruce Mitchener</td>
<td>Jeremy Rifkin</td>
<td>Rafael Kitover</td>
<td>Weihang Ding</td>
</tr>
<tr>
<td>Carsten Rudolph</td>
<td>JoergAtGithub</td>
<td>RainChan</td>
<td>Yu SuiXian</td>
</tr>
<tr>
<td>Christian Panov</td>
<td>Johnny Willemsen</td>
<td>Raul Metsma</td>
<td>ZXShady</td>
</tr>
<tr>
<td>Chuck Walbourn</td>
<td>jreichel-nvidia</td>
<td>RippeR37</td>
<td>Russell Greene</td>
</tr>
<tr>
<td>Colin Cornaby</td>
<td>Juraj Zikmund</td>
<td>Rossmaxx</td>
<td></td>
</tr>
<tr>
<td>CQ_Undefine</td>
<td>Kadir</td>
<td>RuslanSemchenko</td>
<td></td>
</tr>
</tbody>
</table>
<h1>Learn more</h1>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases">main release notes</a> on GitHub. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to vcpkg documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/">What’s New in vcpkg (July 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2025/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Dynamically Update C++ syntax using Next Edit Suggestions</title>
		<link>https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Mon, 04 Aug 2025 16:36:10 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Copilot]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35626</guid>

					<description><![CDATA[<p>When working in a C++ repo, you often are maintaining and updating existing code just as often as you are writing new code. However, updating code in C++ can often require navigating to several different locations in a file to ensure consistency, which can disrupt your logical workflow. For example, changing a data member’s access [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/">Dynamically Update C++ syntax using Next Edit Suggestions</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>When working in a C++ repo, you often are maintaining and updating existing code just as often as you are writing new code. However, updating code in C++ can often require navigating to several different locations in a file to ensure consistency, which can disrupt your logical workflow. For example, changing a data member’s access level typically involves several steps: moving the member between the <code>public</code> and <code>private</code> sections of the class, adding getter/setter methods, and updating all references to respect this new access level.</p>
<p>GitHub Copilot now supports <strong>Next Edit Suggestions</strong> (or NES for short) to predict the next edits to come. NES in GitHub Copilot helps you stay in flow by not only helping predict where you’ll need to make updates, but also what you’ll need to change next.</p>
<h3>Example: Converting C code to C++</h3>
<p>At Microsoft Build, we showed how NES can dynamically update C++ code, including an example of updating code syntax that was using C functions to use the C++ Standard Template Library (STL).</p>
<p>For example, when updating code that reads from stdin from C-style code that uses raw character arrays to C++ code that uses the <code>std::string</code> type, NES predicts and suggests updates across all applicable areas near the cursor. NES replaces calls to <code>fgets</code> with calls to <code>std::getline</code> and replaces <code>atoi</code> with the C++ <code>std::stoi</code>, which has better error handling.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/nes-finalv2-ezgif.com-video-to-gif-converter-1.gif"><img fetchpriority="high" decoding="async" class="alignnone size-full wp-image-35627" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/nes-finalv2-ezgif.com-video-to-gif-converter-1.gif" alt="NES dynamically updating fgets to getline across a C++ file" width="800" height="600" /></a></p>
<p>You can then review and make any relevant updates – for example, in this case, any other areas that call on strings.</p>
<p>Next Edit Suggestions is now available in both <a href="https://learn.microsoft.com/en-us/visualstudio/ide/copilot-next-edit-suggestions?view=vs-2022">Visual Studio</a> and <a href="https://code.visualstudio.com/docs/copilot/ai-powered-suggestions#_next-edit-suggestions">VS Code</a>.  As you try out NES, we&#8217;d love to hear your feedback. Share your feedback on <a href="https://developercommunity.visualstudio.com/VisualStudio/suggest">Developer Community</a> for Visual Studio or on <a href="https://github.com/microsoft/vscode-copilot-release">GitHub</a> for VS Code to help shape what’s next and how we can improve. If NES streamlines your workflow or saves you time, let us know &#8211; drop a comment or email us at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. We’re excited to see how you’re using NES for C++!</p>
<h3>Agent Mode and other new Copilot features</h3>
<p>GitHub Copilot is evolving beyond typical code completion, with features like Next Edit Suggestions, Agent Mode, and MCP transforming how developers interact with AI. The Visual Studio session at Build not only showcased NES in action, but also Agent Mode and MCP and how they each revolutionize the traditional Copilot interfaces. While NES predicts your next code edits in the editor, agent mode can work as an iterative AI assistant that understands your intent to provide dynamic edits and information.</p>
<p>To learn more about the C++ NES use cases detailed above and these other new features available for developers in Visual Studio, watch “Top GitHub Copilot features you missed in Visual Studio 2022”.</p>
<p><iframe src="//www.youtube.com/embed/Fq7myF58Odc?embeds_referring_euri=https" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></p>
<h3>What do you think?</h3>
<p>Try out the latest Copilot features for your C++ workflows today. To access these updates to Copilot, you’ll need an <a href="https://github.com/features/copilot?utm_source=vscom&amp;utm_medium=hero&amp;utm_campaign=cta-get#pricing">active GitHub Copilot subscription</a> and <a href="http://aka.ms/vs">the latest version of Visual Studio</a>.</p>
<p>Our team is working hard on improving C++ integrations with Copilot, so please let us know any other enhancements you’d like to see. Share your thoughts with us on <a href="https://developercommunity.visualstudio.com/VisualStudio/suggest">Developer Community</a> for Visual Studio or on <a href="https://github.com/microsoft/vscode">GitHub</a> for VS Code to help shape what’s next and how we can improve. You can also reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com,</a> via X at <a href="https://twitter.com/visualc">@VisualC</a>, or via Bluesky at <a href="https://bsky.app/profile/msftcpp.bsky.social">@msftcpp.bsky.social</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/">Dynamically Update C++ syntax using Next Edit Suggestions</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/dynamically-update-c-syntax-using-next-edit-suggestions/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code CMake Tools Extension 1.21 Release: Multi-root improvements, CMake Presets v10, and more…</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Mon, 21 Jul 2025 12:10:34 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35611</guid>

					<description><![CDATA[<p>We’re excited to announce the latest 1.21 release of the CMake Tools extension for Visual Studio Code. This update brings a host of new updates, including addressing one of our top-voted issues for multi-root improvements and adding CMake presets version 10 support. To view the full list of updates with this release, please look at [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/">Visual Studio Code CMake Tools Extension 1.21 Release: Multi-root improvements, CMake Presets v10, and more…</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We’re excited to announce <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">the latest 1.21 release of the CMake Tools extension</a> for Visual Studio Code. This update brings a host of new updates, including addressing one of our top-voted issues for <strong>multi-root improvements</strong> and adding <strong>CMake presets version 10 support</strong>. To view the full list of updates with this release, please look at our <a href="https://github.com/microsoft/vscode-cmake-tools/blob/main/CHANGELOG.md">CHANGELOG</a>.</p>
<p>This release features the following ten contributions from our open-source community. Thank you for your continued support!</p>
<ul>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4273">Allow specifying a launch configuration which can be used when debugging tests via CTest</a> by <a href="https://github.com/Nerixyz">@nerixyz</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4422">Adding a new command cmake.cacheVariable</a> by <a href="https://github.com/malsyned">@malsyned</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/3953">Grouping default build targets based on CMake FOLDER property</a> by <a href="https://github.com/itzandroidtab">@itzandroidtab</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4340">Add name de-mangling for C++ symbols in the Test Explorer view</a> by <a href="https://github.com/rjaegers">@rjaegers</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4325">Fixes to case preservation for include paths on MacOS</a> by <a href="https://github.com/tringenbach">@tringenbach</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4458">Reduce heap usage with new optimized splits for large compile commands</a> by <a href="https://github.com/borjamunozf">@borjamunozf</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/pull/4321">Remove dependency for backtrace in presence of DEF_SOURCE_LINE</a> by <a href="https://github.com/rjaegers">@rjaegers</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/issues/2864">Fix gnuld error parsing false positive on make errors, false negatives due to trailing \r, and false parsing of new “multiple definitions” error</a> by <a href="https://github.com/0xemgy">@0xemgy</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/issues/4304">Fix bug where unrelated symlinks are read as variant files</a> by <a href="https://github.com/vitorramos">@vitorramos</a></li>
<li><a href="https://github.com/microsoft/vscode-cmake-tools/issues/2855">Fix ENOENT error at vs code startup on some circumstances</a> by <a href="https://github.com/JDESTM">@STMicroelectronics</a></li>
</ul>
<h3>Multi-root improvements</h3>
<p>We addressed one of our <a href="https://github.com/microsoft/vscode-cmake-tools/issues/1069">top-voted customer feedback issues</a> to improve multi-root integration and allow users more customizability to enable/disable certain folders in mixed-language circumstances.</p>
<p>Now, we have added support for a new <code>cmake.exclude</code> setting that allows users to select specific folders to ignore in multi-root scenarios.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude.png"><img decoding="async" class="size-full wp-image-35612 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude.png" alt="The CMake exclude setting ignoring test and third party libraries for Pioneer" width="1072" height="269" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude.png 1072w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude-300x75.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude-1024x257.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/cmake-exclude-768x193.png 768w" sizes="(max-width: 1072px) 100vw, 1072px" /></a></p>
<p>For example, when developing with 3<sup>rd</sup> party packages, you can specify for the extension to ignore these at build via this new setting, improving the overall user experience for your needs.</p>
<h3>CMake presets version 10 support</h3>
<p>We have also added support for the latest version 10 of CMake Presets, which adds two new features to enhance clarity and visualization in your build configurations: $<strong>comment</strong> and <strong>graphviz</strong> support.</p>
<p>CMake presets v10 introduces a new <code>$comment</code> field that allows developers to add inline documentation within their preset’s definitions, making it easier to understand and distinguish between different configurations. To learn more about using formatting using $comment, you can visit <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#format">Kitware’s documentation</a>.</p>
<p>Additionally, CMake presets now supports graphviz, which allows you to visualize the dependencies between targets and external libraries in your project. By specifying a <code>graphviz</code> field in your CMake presets, you can enable Graphviz DOT files that can be rendered via Graphviz.</p>
<h3>What do you think?</h3>
<p>Download <a href="https://code.visualstudio.com/Download">Visual Studio Code</a> and <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">the CMake Tools extension</a> and let us know what you think. We would love to see what you contribute to our<a href="https://github.com/microsoft/vscode-cmake-tools"> repo</a>. Please create an <a href="https://github.com/microsoft/vscode-cmake-tools/issues/">issue</a> if there’s anything you’d like to see and upvote/downvote any existing issues. Comment below or reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com,</a> via X at <a href="https://twitter.com/visualc">@VisualC</a>., or via Bluesky at <a href="https://bsky.app/profile/msftcpp.bsky.social">@msftcpp.bsky.social</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/">Visual Studio Code CMake Tools Extension 1.21 Release: Multi-root improvements, CMake Presets v10, and more…</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-cmake-tools-extension-1-21-release-multi-root-improvements-cmake-presets-v10-and-more/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Updates to Warning Suppressions in Microsoft C++ Code Analysis</title>
		<link>https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/</link>
					<comments>https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/#comments</comments>
		
		<dc:creator><![CDATA[Carson Radtke]]></dc:creator>
		<pubDate>Tue, 15 Jul 2025 18:00:13 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[code analysis]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35604</guid>

					<description><![CDATA[<p>Improvements to \#pragma warning and gsl::suppress in Microsoft C++ Code Analysis.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/">Updates to Warning Suppressions in Microsoft C++ Code Analysis</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Microsoft C++ Code Analysis is a powerful static analysis tool integrated into Visual
Studio that helps you identify and fix potential issues in your C++ code.
Large projects require effective management of analysis warnings to maintain code
quality and you sometimes need to suppress warnings, but must do so in a clear and
auditable way.</p>
<p>To that end, we are excited to announce significant updates to the warning suppression
mechanisms in Microsoft C++ Code Analysis. These enhancements provide better tracking,
justification, and overall management of warning suppressions, leading to a more
maintainable and robust codebase.</p>
<h2>What&#8217;s New in the SARIF Output?</h2>
<p>We enhanced the
<a href="https://sarif.info/">Static Analysis Results Interchange Format (SARIF)</a>
output to include detailed information about warning suppressions, most notably the
justification provided by you. This allows teams to easily review <em>why</em> a specific
warning was silenced.</p>
<p>To generate a SARIF file, use the <code>/analyze:log:format:sarif</code> compiler option. To ensure
that details about suppressed warnings (including their justifications) are included in
this SARIF log, you must also use the <code>/analyze:log:includesuppressed</code> option.</p>
<h2>What&#8217;s New in <code>gsl::suppress</code>?</h2>
<p>We have updated our support for <code>gsl::suppress</code> to align with the latest C++ Core
Guidelines syntax. Warnings can now be suppressed by using the <code>gsl::suppress</code> attribute
in the following way:</p>
<pre><code class="language-cpp">[[gsl::suppress( "&lt;warning_id&gt;", justification: "&lt;justification&gt;" )]]</code></pre>
<p>Where <code>&lt;warning_id&gt;</code> is the ID of the warning you want to suppress, and the optional
<code>&lt;justification&gt;</code> is a string that provides a justification for the suppression.</p>
<p><em>For now, <code>[[gsl::suppress]]</code> is only available for C++ codebases. For C codebases, you
must use the <code>#pragma warning(suppress)</code> syntax.</em></p>
<p>Example:</p>
<pre><code class="language-cpp">// CoreCheckExample.cpp
// Add CppCoreCheck package and enable code analysis in build for warnings.

int main()
{
    int arr[10];           // warning C26494
    int* p = arr;          // warning C26485

    [[gsl::suppress("bounds.1", justification : "This attribute suppresses Bounds rules #1")]]
    {
        int* q = p + 1;    // warning C26481 (suppressed)
        p = q++;           // warning C26481 (suppressed)
    }

    return 0;
}</code></pre>
<h2>What&#8217;s New in <code>#pragma warning</code>?</h2>
<p>We have extended <code>#pragma warning</code> to support the <code>justification</code> field. Here is how
you can use it starting in Visual Studio 2022 version 17.14:</p>
<pre><code class="language-cpp">#pragma warning(suppress : &lt;warning_id&gt;, justification : "&lt;justification&gt;")</code></pre>
<p>Where <code>&lt;warning_id&gt;</code> is the ID of the warning you want to suppress, and the optional
<code>&lt;justification&gt;</code> is a string that provides a justification for the suppression.</p>
<h2>Choosing Between <code>#pragma warning</code> and <code>gsl::suppress</code></h2>
<p>Both <code>#pragma warning(suppress)</code> and <code>[[gsl::suppress]]</code> offer fine-grained control over
warning suppression.</p>
<ul>
<li><code>#pragma warning(suppress)</code> is a general MSVC mechanism that can be used for any
compiler warning. It&#8217;s particularly useful when you need to suppress a warning in a
specific code block without altering the code&#8217;s structure significantly.</li>
<li><code>[[gsl::suppress]]</code> will only suppress warnings emitted by Microsoft C++ Code
Analysis. It is intended for use with the C++ Core Guidelines checks and can be applied
to a scope or a specific declaration.</li>
</ul>
<p>Whenever possible, we recommend using <code>[[gsl::suppress]]</code> for suppressing Microsoft C++
Code Analysis warnings.</p>
<h2>Why These Updates Matter</h2>
<p>These enhancements to warning suppression offer several key benefits:</p>
<ul>
<li><strong>Improved Auditability and Review:</strong> With justifications recorded directly in the
code and optionally in SARIF logs, code reviews become more effective. Team members can
quickly understand the rationale behind a suppression without needing to consult
external documentation or the original author.</li>
<li><strong>Enhanced Code Maintainability:</strong> Clear justifications prevent accidental
re-introduction of issues when code is refactored or suppressions are reviewed. They
provide a history of why certain warnings were deemed acceptable at a particular point.</li>
<li><strong>Better Management of Technical Debt:</strong> Suppressed warnings can be a form of
technical debt. Justifications help in tracking and prioritizing which suppressions
should be revisited and potentially fixed.</li>
<li><strong>Consistency Across Suppression Mechanisms:</strong> By adding justification support to both
<code>#pragma warning</code> and <code>gsl::suppress</code>, we provide a consistent experience for you. This
allows old code to use <code>#pragma warning</code> while new code can use <code>[[gsl::suppress]]</code>, all
while maintaining the ability to provide justifications.</li>
</ul>
<h3>Impact on Existing Workflows</h3>
<p>These new features are additive. Existing suppression mechanisms (without
justifications) will continue to work as before. However, we encourage you to
start using the <code>justification</code> attribute for new suppressions and to gradually update
existing ones where clarity is beneficial. There is no automatic migration, but the
process of adding justifications is straightforward.</p>
<h3>Availability</h3>
<p>These enhancements are available in the MSVC compiler toolset shipping with Visual
Studio 2022 version 17.14 and newer, and will be part of future Visual Studio releases.
Ensure your Visual Studio is updated to leverage these improvements.</p>
<h2>Try It Out</h2>
<pre><code class="language-c++">// example.cpp
// Compile with: cl /analyze:only /analyze:plugin EspxEngine.dll /analyze:log:format:sarif /analyze:log:includesuppressed example.cpp

int main()
{
    int arr[10];           // warning C26494
    int* p = arr;          // warning C26485

    [[gsl::suppress("bounds.1", justification : "This attribute suppresses Bounds rules #1")]]
    {
        int* q = p + 1;    // warning C26481 (suppressed)
        p = q++;           // warning C26481 (suppressed)
    }

    return 0;
}</code></pre>
<p>You can run the above code with the following options:
<code>/analyze /analyze:log:format:sarif /analyze:log:includesuppressed</code> to generate a SARIF
file that includes the suppression details.
(Note: <code>EspxEngine.dll</code> is the plugin that enables C++ Core Guidelines checks, which are
the target of <code>gsl::suppress</code>.)</p>
<pre><code class="language-powershell">&gt; cl /analyze:only /analyze:plugin EspxEngine.dll /analyze:log:format:sarif /analyze:log:includesuppressed .\example.cpp
Microsoft (R) C/C++ Optimizing Compiler Version 19.50.35305.95 for x64
Copyright (C) Microsoft Corporation.  All rights reserved.

example.cpp
D:\tmp\example.cpp(7) : warning C26485: Expression 'arr': No array to pointer decay (bounds.3).
D:\tmp\example.cpp(6) : warning C26494: Variable 'arr' is uninitialized. Always initialize an object (type.5).</code></pre>
<p>You will also find a file named <code>example.nativecodeanalysis.sarif</code>, you can open it with
VSCode (don&#8217;t forget to install the latest version of the
<a href="https://marketplace.visualstudio.com/items?itemName=MS-SarifVSCode.sarif-viewer">SARIF Viewer extension</a>).
After filtering to include suppressed warnings, you will see the warning details which
include the suppression information. Here is an example of what you will see:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2.png"><img decoding="async" class="alignnone size-full wp-image-35609" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2.png" alt="extension screenshot png image" width="2500" height="1359" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2.png 2500w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-300x163.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-1024x557.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-768x417.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-1536x835.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/07/extension_screenshot-scaled_v2-2048x1113.png 2048w" sizes="(max-width: 2500px) 100vw, 2500px" /></a></p>
<h2>Feedback</h2>
<p>We would love to hear your thoughts on the new changes to warning suppressions! Please
share your feedback and suggestions in the comments below. If you run into any issues,
please let us know by filing a feedback ticket on
<a href="https://developercommunity.visualstudio.com/cpp">Visual Studio Developer Community</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/">Updates to Warning Suppressions in Microsoft C++ Code Analysis</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/updates-to-warning-suppressions-in-microsoft-c-code-analysis/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Smarter, workspace-aware code completions for C++ in VS Code</title>
		<link>https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 08 Jul 2025 14:50:11 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Copilot]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35581</guid>

					<description><![CDATA[<p>C++ code understanding Developing C++ code can be complex. C++ project structure, style, and convention can vary widely from repository to repository, and critical context for a given task often spans multiple files. This can require C++ developers to open and navigate across several files to fully understand a given project and author new code. [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/">Smarter, workspace-aware code completions for C++ in VS Code</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h3>C++ code understanding</h3>
<p>Developing C++ code can be complex. C++ project structure, style, and convention can vary widely from repository to repository, and critical context for a given task often spans multiple files. This can require C++ developers to open and navigate across several files to fully understand a given project and author new code.</p>
<p>The GitHub Copilot team has focused on two areas to improve the C++ developer experience for code completions:</p>
<ul>
<li><strong>Upgrades to the underlying completions model</strong> to better understand C++ syntax and patterns across diverse codebases.</li>
<li><strong>Enhancing workspace awareness for C++</strong> so that Copilot can provide more relevant completions</li>
</ul>
<p>These improvements are designed to help the <a href="https://code.visualstudio.com/docs/copilot/ai-powered-suggestions">autocomplete-style inline GitHub Copilot code completions</a> be even more productive with C++ coding, minimizing manual intervention.</p>
<h3>Model updates for code completions</h3>
<p>The GitHub Copilot team has upgraded the base completions model to the new <a href="https://github.blog/changelog/2025-03-27-gpt-4o-copilot-your-new-code-completion-model-is-now-generally-available/">GPT-4o Copilot model</a>. This model has additional training on over 275,000 high-quality public repositories in over 30 popular programming languages (including C++) and improved latency. This base model is available across Visual Studio and VS Code by default.</p>
<h3>Updates to workspace awareness for C++ code completions</h3>
<p>Additionally, with the latest improvements to GitHub Copilot code completions, Copilot can detect even more relevant context in C++ projects in order to provide more accurate code suggestions in VS Code for your specific codebase. This is now available in <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/v1.26.3">the latest 1.26.3 release of the C/C++ extension</a>.</p>
<p>To access these improvements, ensure you are on 1.322.0 or later of the <a href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot">Copilot extension</a> and 1.26.3 or later of the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++ extension</a> with <a href="https://code.visualstudio.com/docs/cpp/configure-intellisense">IntelliSense configured</a>.</p>
<h3>What&#8217;s Next?</h3>
<p>We are committed to delivering similar improvements to Visual Studio 2022 17.14, so stay tuned for updates.</p>
<p>Our team is working hard on improving C++ integrations with Copilot, so please let us know any other enhancements you’d like to see. Share your thoughts with us on <a href="https://developercommunity.visualstudio.com/VisualStudio/suggest">Developer Community</a> for Visual Studio or on <a href="https://github.com/microsoft/vscode">GitHub</a> for VS Code to help shape what’s next and how we can improve. You can also reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via X at <a href="https://x.com/visualc">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/">Smarter, workspace-aware code completions for C++ in VS Code</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/smarter-workspace-aware-code-completions-for-c-in-vs-code/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New in vcpkg (June 2025)</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Fri, 04 Jul 2025 19:02:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35583</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2025.06.13 registry release, 2025-04-16, 2025-05-19, and 2025-06-02 tool releases, as well as changes to vcpkg documentation throughout May and June. This release includes bug fixes, several documentation changes, and the removal of the x-gha binary caching provider for GitHub (alternatives are [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/">What’s New in vcpkg (June 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2025.06.13">2025.06.13</a> registry release, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-04-16">2025-04-16</a>, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-05-19">2025-05-19</a>, and <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2025-06-02">2025-06-02</a> tool releases, as well as changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout May and June. This release includes bug fixes, several documentation changes, and the removal of the <code>x-gha</code> binary caching provider for GitHub (alternatives are described below).</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,621 total ports </strong>available in the vcpkg curated registry. A <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>35 new ports</strong> were added to the curated registry.</li>
<li><strong>517 ports were updated</strong>. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our 15 main <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>132 </strong>community contributors made commits.</li>
<li>The main vcpkg repo has over <strong>6,900 forks</strong> and <strong>25,100 stars</strong> on GitHub.</li>
</ul>
<h2>vcpkg changelog (2025.06.13 release)</h2>
<p>The following notable changes were made in this release:</p>
<ul>
<li>Due to <a href="https://github.com/actions/cache/discussions/1510">recent changes in GitHub Actions Cache’s API</a>, the <code>x-gha</code> binary caching provider has been rendered obsolete. As a result, we had to remove it from vcpkg (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1662">Microsoft/vcpkg-tool#1662</a>). Instead, you can use one of the following methods to cache binaries in GitHub; we welcome any feedback from our users about how this experience could be improved in the future:
<ul>
<li>Use <a href="https://learn.microsoft.com/vcpkg/consume/binary-caching-github-packages">GitHub Packages with NuGet</a>, which uses vcpkg’s caching mechanism and preserves caching granularity per port. This is the method the vcpkg team recommends.</li>
<li>Use <a href="https://github.com/actions/cache">actions/cache</a> in your workflow to cache the installed directory. The downside of this method is that the whole installed tree gets cached as a single artifact, so single port updates invalidate all packages.</li>
</ul>
</li>
<li>Fixed a bug causing permissions while using <code>upkg</code> to not be preserved (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1625">Microsoft/vcpkg-tool#1625</a>).</li>
<li>Improved diagnostics and bug fixes for vcpkg x-test-features command (PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/1649">Microsoft/vcpkg-tool#1649</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1650">Microsoft/vcpkg-tool#1650</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1663">Microsoft/vcpkg-tool#1663</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1676">Microsoft/vcpkg-tool#1676</a>, thanks @autoantwort!).</li>
<li>Fixed an issue causing slow binary cache insertions in some Docker containers (PRs: <a href="https://github.com/microsoft/vcpkg-tool/pull/1659">Microsoft/vcpkg-tool#1659</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/1669">Microsoft/vcpkg-tool#1669</a>, thanks @Thomas1664, @dg0yt!).</li>
<li>Other minor bug fixes and internal feature improvements (thanks @autoantwort, @dg0yt, @huangqinjin, @DewJunkie!).</li>
</ul>
<h2>Documentation changes</h2>
<ul>
<li>The vcpkg docs have moved to the MicrosoftDocs organization, under the URL <a href="https://github.com/MicrosoftDocs/vcpkg-docs">https://github.com/MicrosoftDocs/vcpkg-docs</a>. The existing repo has fully migrated with no loss in functionality. Links to the old repo should redirect to the new one automatically. The experience on the Learn website remains the same.</li>
<li>Added documentation for the new commands <a href="https://learn.microsoft.com/vcpkg/commands/format-feature-baseline">format-feature-baseline</a> and <a href="https://learn.microsoft.com/vcpkg/commands/test-features">x-test-features</a> (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/455">MicrosoftDocs/vcpkg-docs#455</a>).</li>
<li>Added documentation for vcpkg license-report command (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/491">MicrosoftDocs/vcpkg-docs#491</a>).</li>
<li>Updated <a href="https://learn.microsoft.com/vcpkg/consume/binary-caching-github-packages?pivots=windows-runner">Tutorial: Set up a vcpkg binary cache using GitHub Packages in a GitHub Actions workflow</a> to clarify that mono is no longer pre-installed by default for GitHub Actions Ubuntu runners (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/495">MicrosoftDocs/vcpkg-docs#495</a>).</li>
<li>Updated <a href="https://learn.microsoft.com/vcpkg/users/buildsystems/msbuild-integration">vcpkg in MSBuild projects</a> article to add instructions about how to pass MSBuild properties to vcpkg builds (PR: <a href="https://github.com/MicrosoftDocs/vcpkg-docs/pull/481">MicrosoftDocs/vcpkg-docs#481</a>).</li>
<li>Removed documentation references to GitHub Actions Cache and <code>x-gha</code> provider, de-indexed the associated tutorial, and added a removal notice on the reference page.</li>
<li>Other minor documentation improvements (thanks @Alan Pope, @Ivan Sorokin, @shijunz, @Tiago Freitas, @Yan Romao!).</li>
</ul>
<p>If you have any suggestions for our documentation, please <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a> or see the box at the bottom of a particular article.</p>
<h2>Total ports available for tested triplets</h2>
<table>
<tbody>
<tr>
<td><strong>Triplet</strong></td>
<td><strong>Ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>2406</td>
</tr>
<tr>
<td>x64-windows</td>
<td>2524</td>
</tr>
<tr>
<td>x64-windows-release</td>
<td>2524</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2398</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2450</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1410</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>2122</td>
</tr>
<tr>
<td>arm64-windows-static-md</td>
<td>2102</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1377</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2394</td>
</tr>
<tr>
<td>arm64-osx</td>
<td>2321</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2510</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1939</td>
</tr>
<tr>
<td>x64-android</td>
<td>1996</td>
</tr>
<tr>
<td>arm64-android</td>
<td>1961</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<h2>Thank you to our contributors</h2>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a>, or <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs</a> repos in this release (listed by commit author or GitHub username):</p>
<table>
<tbody>
<tr>
<td>Adrien Bourdeaux</td>
<td>Eugene Gershnik</td>
<td>Long Nguyen</td>
<td>Ryan Zoeller</td>
</tr>
<tr>
<td>Alan Pope</td>
<td>Faaux</td>
<td>Lukas Berbuer</td>
<td>Saad</td>
</tr>
<tr>
<td>Alexandre Bique</td>
<td>Fabien Pean</td>
<td>m7913d</td>
<td>Sander Cox</td>
</tr>
<tr>
<td>Alexis La Goutte</td>
<td>flightless-coder</td>
<td>Martin Valgur</td>
<td>Scott Hart</td>
</tr>
<tr>
<td>Alexis Placet</td>
<td>galabovaa</td>
<td>Matt H</td>
<td>Sebastian Goth</td>
</tr>
<tr>
<td>Alfred E. Heggestad</td>
<td>gastineau</td>
<td>Matthew Oliver</td>
<td>shijunz</td>
</tr>
<tr>
<td>Amin Ya</td>
<td>Harald</td>
<td>Maxime Gervais</td>
<td>SunBlack</td>
</tr>
<tr>
<td>Andrew Kaster</td>
<td>Henrique Teles</td>
<td>Mengna-Li</td>
<td>Szabolcs Horvát</td>
</tr>
<tr>
<td>Andrey</td>
<td>huangqinjin</td>
<td>Michał Petryka</td>
<td>Takahiro Ueda</td>
</tr>
<tr>
<td>Anthony Umfer</td>
<td>hy zhang</td>
<td>Michael R. P. Ragazzon</td>
<td>talregev</td>
</tr>
<tr>
<td>autoantwort</td>
<td>Hyunjin Song</td>
<td>miyanyan</td>
<td>Tamás PEREGI</td>
</tr>
<tr>
<td>Benno Waldhauer</td>
<td>i-curve</td>
<td>Moritz Beutel</td>
<td>Theodore Tsirpanis</td>
</tr>
<tr>
<td>blavallee</td>
<td>Ildar Khayrutdinov</td>
<td>mschollerer</td>
<td>Thomas1664</td>
</tr>
<tr>
<td>Buck Yeh</td>
<td>ilya-fedin</td>
<td>myd7349</td>
<td>Tiago Freitas</td>
</tr>
<tr>
<td>Carsten Rudolph</td>
<td>Ivan Sorokin</td>
<td>Mys Vac</td>
<td>Tim Flynn</td>
</tr>
<tr>
<td>Charlie</td>
<td>Jack Boos Yu</td>
<td>Nenad Banfic</td>
<td>Timofei Zhakov</td>
</tr>
<tr>
<td>Chase Knowlden</td>
<td>Jacob Wujciak-Jens</td>
<td>Nick D&#8217;Ademo</td>
<td>Timur Chernykh</td>
</tr>
<tr>
<td>chausner</td>
<td>JacobBarthelmeh</td>
<td>Nick Logozzo</td>
<td>toge</td>
</tr>
<tr>
<td>Chuck Walbourn</td>
<td>Jaka</td>
<td>nunupeke</td>
<td>Tom G. Huang</td>
</tr>
<tr>
<td>Clement Peron</td>
<td>Jean-Sebastien Paquet</td>
<td>Oleg Derevenetz</td>
<td>Tom Tan</td>
</tr>
<tr>
<td>CQ_Undefine</td>
<td>Jeremy Rifkin</td>
<td>Osyotr</td>
<td>Tomasz Kalisiak</td>
</tr>
<tr>
<td>Damian Dyńdo</td>
<td>JoergAtGithub</td>
<td>Pasukhin Dmitry</td>
<td>tomy2105</td>
</tr>
<tr>
<td>Daniel Bertalan</td>
<td>Johannes Meßmer</td>
<td>Pavel Kisliak</td>
<td>Vitalii Koshura</td>
</tr>
<tr>
<td>David Machaj</td>
<td>Jonathan Sweemer</td>
<td>Peter Adam Korodi</td>
<td>Vladimir Petrigo</td>
</tr>
<tr>
<td>Denis Barkar</td>
<td>jreichel-nvidia</td>
<td>Peter Steneteg</td>
<td>Vladimir Shaleev</td>
</tr>
<tr>
<td>DevFdv</td>
<td>Kadir</td>
<td>Rémy Tassoux</td>
<td>Wentsing Nee</td>
</tr>
<tr>
<td>DewJunkie</td>
<td>Kai Blaschke</td>
<td>Rafael Kitover</td>
<td>whyzix</td>
</tr>
<tr>
<td>Dr. Patrick Urbanke</td>
<td>Kai Pastor</td>
<td>Reupen Shah</td>
<td>wolfgitpr</td>
</tr>
<tr>
<td>eao197</td>
<td>karnigen</td>
<td>Reza Alizadeh Majd</td>
<td>xavier2k6</td>
</tr>
<tr>
<td>Egor Tyuvaev</td>
<td>Kevin Ring</td>
<td>Riccardo Ressi</td>
<td>xvitaly</td>
</tr>
<tr>
<td>Employee_NO427</td>
<td>l.feng</td>
<td>Ridwan Abdul Hafidh</td>
<td>Yan Romao</td>
</tr>
<tr>
<td>Eric Kilmer</td>
<td>Lars Fröhlich</td>
<td>Rimas Misevičius</td>
<td>Yury Bura</td>
</tr>
<tr>
<td>Ethan J. Musser</td>
<td>llm96</td>
<td>rinechran</td>
<td>Zhichao Wang</td>
</tr>
</tbody>
</table>
<h2>Learn more</h2>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases">main release notes</a> on GitHub. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to vcpkg documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/">What’s New in vcpkg (June 2025)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2025/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>How Electronic Arts standardized C++ builds across Windows and Linux with Visual Studio Build Tools</title>
		<link>https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/</link>
					<comments>https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Thu, 26 Jun 2025 12:00:43 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35568</guid>

					<description><![CDATA[<p>At Electronic Arts (EA), the Frostbite Enginering Workflows team has thousands of developers who work on powerful game engines behind popular games.  EA has relied on Visual Studio for years due to several features such as IntelliSense, Build Insights, and the overall debugging experience and eagerly use newer integrations such as GitHub Copilot.  They also [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/">How Electronic Arts standardized C++ builds across Windows and Linux with Visual Studio Build Tools</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>At Electronic Arts (EA), the Frostbite Enginering Workflows team has thousands of developers who work on powerful game engines behind popular games.  EA has relied on Visual Studio for years due to several features such as IntelliSense, Build Insights, and the overall debugging experience and eagerly use newer integrations such as GitHub Copilot.  They also use Visual Studio capabilities for their cross-platform development needs.</p>
<p>We&#8217;re proud to partner with EA to shape cross-platform development capabilities in Visual Studio. Read more in the full story about how we worked with EA to enable them to customize their build experience and ensure consistent builds for thousands of developers at: <strong><a href="http://aka.ms/ea-vs-game-dev">aka.ms/ea-vs-game-dev</a></strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB.jpg"><img decoding="async" class="alignnone size-full wp-image-35569" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB.jpg" alt="A picture of a college football game in a video game " width="1454" height="818" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB.jpg 1454w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB-300x169.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB-1024x576.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/06/MSFT-Blog_CFB-768x432.jpg 768w" sizes="(max-width: 1454px) 100vw, 1454px" /></a></p>
<p style="text-align: center;"><span style="font-size: 8pt;"><em>A snapshot from EA Sports College Football 25, a video game produced by Electronic Arts</em></span></p>
<h2>Send us feedback!</h2>
<p><a href="https://visualstudio.microsoft.com/vs/">Download Visual Studio</a> and give <a href="https://learn.microsoft.com/en-us/cpp/linux/download-install-and-setup-the-linux-development-workload?view=msvc-170">our cross-platform tooling</a> a try! If you have any feedback for us on how to improve our cross-platform tooling for you, please<a href="https://developercommunity.visualstudio.com/cpp?space=8&amp;entry=suggestion"> file a suggestion ticket on Developer Community</a>. The comments below are open and we are also available via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/">How Electronic Arts standardized C++ builds across Windows and Linux with Visual Studio Build Tools</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/how-electronic-arts-standardized-c-builds-across-windows-and-linux-with-visual-studio-build-tools/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Address Sanitizer Updates for Visual Studio 2022 Version 17.14</title>
		<link>https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/</link>
					<comments>https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/#comments</comments>
		
		<dc:creator><![CDATA[David Justo]]></dc:creator>
		<pubDate>Tue, 27 May 2025 20:04:30 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35494</guid>

					<description><![CDATA[<p>Introduction It has been an exciting few months for the Address Sanitizer (ASan) since our last update. In addition to our continuous focus on quality and correctness, our internal “dogfooding” (i.e. internal adoption) effort has reached several important milestones. In this update, I want to go over some of the quality improvements since Visual Studio [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/">Address Sanitizer Updates for Visual Studio 2022 Version 17.14</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>It has been an exciting few months for the <a href="https://learn.microsoft.com/cpp/sanitizers/asan?view=msvc-170">Address Sanitizer</a> (ASan) since our last update. In addition to our continuous focus on quality and correctness, our internal “dogfooding” (i.e. internal adoption) effort has reached several important milestones.</p>
<p>In this update, I want to go over some of the quality improvements since <a href="https://devblogs.microsoft.com/cppblog/msvc-address-sanitizer-updates-in-visual-studio-2022-version-17-13/">Visual Studio 2022 version 17.13</a><a href="https://devblogs.microsoft.com/cppblog/msvc-address-sanitizer-updates-in-visual-studio-2022-version-17-13/">,</a> and to give a peek into how ASan is now protecting our C++ toolset against memory safety errors during development.</p>
<h2>Some improvements in Visual Studio 2022 version 17.14</h2>
<ul>
<li>We increased the number of ASan flags that can be set through <code>__asan_default_options</code>, the alternative to the environment variable <code>ASAN_OPTIONS</code>. This was an adoption blocker for apps that, for security reasons, can’t access the environment during execution.</li>
<li>For <a href="https://developer.microsoft.com/games/articles/2021/07/address-sanitizer-now-available-for-xbox-developers/">Xbox developers</a>, we now have automated testing ensuring that ASan’s dependencies are compatible with the Xbox OS. This is important since we now integrate changes from upstream LLVM on a weekly basis, meaning that we need to actively guard against Xbox-incompatible changes.</li>
<li>We fixed a <a href="https://developercommunity.visualstudio.com/t/Access-violation-call-stack-not-fully-di/10827640">regression</a> that corrupted the callstack displayed during error reporting in x64.</li>
<li>Improved stability by removing the lazy loading of <code>DbgHelp</code> symbolization helpers, minimizing loader lock contention.</li>
<li><a href="https://github.com/microsoft/STL/pull/5241">In the STL</a>, we now allow ASan container annotations to be disabled on a per-allocator basis. This allows users to control container poisoning, which is useful when custom allocators (e.g. arenas) are in use.</li>
</ul>
<p>This release also contains several other improvements, many of which were contributed by the ASan open-source community in the <a href="https://github.com/llvm/llvm-project">LLVM repo</a>. By contributing to LLVM upstream, you are also contributing to MSVC’s ASan. We thank the entire LLVM ASan community for their efforts, and plan to continue contributing our improvements upstream as well.</p>
<h2>Protecting the C++ toolchain</h2>
<p>To protect the toolchain against memory safety errors, all PRs made against the MSVC toolset and libraries now need to pass ASan instrumentation tests. These are tests where the compiler itself is instrumented with ASan to catch memory safety violations while executing our compiler test suite.</p>
<p>To be clear, this is different from compiling test programs with ASan, i.e. having the compiler run <code>/fsanitize=address</code> on some <code>.cpp</code> file. Instead, the compiler itself is built with <code>/fsanitize=address</code> before executing its test matrix so that ASan may monitor allocations during compilation.</p>
<p>Through this process, we have learned a lot about how to adopt ASan in a large and historied codebase like MSVC and it’s helped us drive several improvements in both the toolset as well as in ASan itself, so we’re excited about the quality improvement cycle that dogfooding ASan within MSVC unlocks for us.</p>
<h2>Let’s harden our C++ code together!</h2>
<p>The ASan team is proud to help you secure your C++ applications, and we would love to hear from you. If you’re not using it already, download Visual Studio and give the Address Sanitizer a try. We can be reached out through the comments below and through our official support channels: <a href="https://developercommunity.visualstudio.com/cpp">Developer Community</a> or through Visual Studio by clicking <a href="https://learn.microsoft.com/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022">Help &gt; Send Feedback &gt; Report A Problem / Provide a suggestion in the product.</a></p>
<p>Until next time!</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/">Address Sanitizer Updates for Visual Studio 2022 Version 17.14</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/address-sanitizer-updates-for-visual-studio-2022-17-14/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New for C++ Developers in Visual Studio 2022 17.14</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-14/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-14/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 13 May 2025 17:27:47 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35467</guid>

					<description><![CDATA[<p>Visual Studio 2022 version 17.14 is now generally available! This post summarizes the new features you can find in this release for C++. You can download Visual Studio 2022 from the Visual Studio downloads page or upgrade your existing installation by following the Update Visual Studio Learn page. Standard Library and Compiler We’ve made a myriad of [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-14/">What’s New for C++ Developers in Visual Studio 2022 17.14</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Visual Studio 2022 version 17.14 is now generally available! This post summarizes the new features you can find in this release for C++. You can download Visual Studio 2022 from the <a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">Visual Studio downloads page </a>or upgrade your existing installation by following the <a href="https://learn.microsoft.com/en-us/visualstudio/install/update-visual-studio?view=vs-2022" target="_blank" rel="noopener">Update Visual Studio Learn page</a>.</p>
<h2>Standard Library and Compiler</h2>
<p>We’ve made a myriad of fixes and improvements to the MSVC compiler and standard library. See <a href="https://devblogs.microsoft.com/cppblog/c-language-updates-in-msvc-in-visual-studio-2022-17-14/">C++ Language Updates in MSVC in Visual Studio 2022 17.14 </a>for a full list of changes on the compiler side, and the <a href="https://github.com/microsoft/STL/wiki/Changelog">STL Changelog</a> for all the standard library updates.</p>
<h3>Compiler</h3>
<p>We’ve added support for several C++23 features, which are available under the <code>/std:c++latest</code> and <code>/std:c++23preview</code> flags.</p>
<p>You can now omit <code>()</code> in some forms of lambdas that previously required them, thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1102r2.html" target="_blank" rel="noopener">P1102R2</a>:</p>
<pre class="prettyprint language-cpp"><code class="language-cpp">auto lambda = [] constexpr { }; //no '()' needed after the capture list</code></pre>
<p>We implemented <code><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1938r3.html">if consteval</a></code>, with which you can run different code depending on whether the statement is executed at compile time or run time. This is useful for cases where your run time version can be heavily optimized with compiler intrinsics or inline assembly that are not available at compile time:</p>
<pre class="prettyprint language-cpp"><code class="language-cpp">constexpr size_t strlen(char const* s) {
    if consteval {
        // if executed at compile time, use a constexpr-friendly algorithm
        for (const char *p = s; ; ++p) {
            if (*p == '\0') {
                return static_cast&lt;std::size_t&gt;(p - s);
            }
        }
    } else {
        // if executed at run time, use inline assembly
        __asm__("SSE 4.2 magic");
    }
}
</code></pre>
<p>We now support <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2173r1.pdf">attributes for lambdas</a>:</p>
<pre class="prettyprint language-default"><code class="language-cpp">auto lambda = [] [[nodiscard]] [[deprecated]] { return 10; };

void f() {
    lambda(); // fires a deprecation warning and a discard of return value warning.
}</code></pre>
<p>We also now support <code><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1169r4.html">static operator()</a></code> and <code><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2589r1.pdf">static operator[]</a></code>. These allow the compiler to generate more efficient code for these operators when the implicit object parameter is not needed and therefore does not need to be passed as an argument to the function:</p>
<pre class="prettyprint language-cpp"><code class="language-cpp">struct X {
    static bool operator()(int) const;
};

inline constexpr X x;

int count_x(std::vector&lt;int&gt; const&amp; xs) {
    return std::count_if(xs.begin(), xs.end(), x);
}</code></pre>
<p>The performance of generated code improved due to 17.14 including earlier SSA optimizations and control-flow simplifications. The 17.14 compiler emits 20% faster code than the initial Visual Studio 2022 17 release.</p>
<p>For throughput, the 17.14 compiler incorporates a dataflow simplification that reduced the compile time of an UnrealEngine <code>/LTCG</code> link repro by 13%.</p>
<h3>Standard Library</h3>
<p>We have implemented parts of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3471r4.html">standard library hardening</a>, which checks for some instances of undefined behavior at runtime and reports them to the user. This is currently disabled by default, but you can enable it by defining <code>_MSVC_STL_HARDENING</code> to 1 project-wide. The proposal uses C++26 contract violations as the mechanism for reporting hardened precondition violations, but since we haven’t implemented contracts yet, we default to calling <code>__fastfail()</code>.</p>
<p>Another new safety feature we have added is destructor tombstones, which help mitigate use-after-free mistakes. This is also disabled by default, but can be enabled by defining <code>_MSVC_STL_DESTRUCTOR_TOMBSTONES</code> to 1 project-wide.</p>
<p>Some miscellaneous improvements we have made are:</p>
<ul>
<li>We now take advantage of our compiler support for <code>static operator()</code>, which gives slightly improved codegen.</li>
<li>We marked <code>std::expected</code>, <code>std::unexpected</code>, and all STL exception types as <code>[[nodiscard]]</code>. This will help protect you from misusing them.</li>
<li>Improved the visualizers for <code>std::basic_string_view</code> and its iterators.</li>
<li>Added or improved vectorized implementations of <code>std::basic_string::find()</code>, <code>find_first_of()</code>, and <code>find_last_of()</code>.</li>
</ul>
<h2>C++ Dynamic Debugging</h2>
<p>C++ Dynamic Debugging is a new compiler and IDE feature that gives you the performance of optimized builds with the debugging experience of unoptimized builds. It is now available as a <em>preview</em> feature exclusively with the MSVC toolset and works by dynamically deoptimizing functions that you set deoptimized breakpoints on or step into.</p>
<p>For example, without C++ Dynamic Debugging, you might see this in your Watch window:</p>
<p><img decoding="async" width="481" height="301" class="wp-image-35468" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/image-before.png" alt="Image before" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/image-before.png 481w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/image-before-300x188.png 300w" sizes="(max-width: 481px) 100vw, 481px" /></p>
<p>Many of the variables are unavailable, so the debugger cannot visualize them.</p>
<p>When you enable the feature, however, you’ll see this:</p>
<p><img decoding="async" width="508" height="267" class="wp-image-35469" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/image-after.png" alt="Image after" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/image-after.png 508w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/image-after-300x158.png 300w" sizes="(max-width: 508px) 100vw, 508px" /></p>
<p>The values of the variables are now available because the function has been dynamically deoptimized.</p>
<p>To begin, change your configuration to Release mode. Next, right-click on your project and click on Properties to open the Configuration Properties menu. In this menu, click on <em>Advanced</em> &gt; <em>Use C++ Dynamic Debugging</em> &gt; <strong>Yes</strong>. Lastly, rebuild your project. Setting this property will turn off Whole Program Optimization.</p>
<p><img decoding="async" width="624" height="212" class="wp-image-35470" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/screenshot-of-configuration-properties-activating.png" alt="screenshot of configuration properties activating C++ dynamic debugging" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/screenshot-of-configuration-properties-activating.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/screenshot-of-configuration-properties-activating-300x102.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></p>
<p>For all the details about C++ Dynamic Debugging, see <a href="https://learn.microsoft.com/visualstudio/debugger/cpp-dynamic-debugging">our documentation</a>.</p>
<h2>IDE</h2>
<p>You can now automatically populate template arguments in the template bar, which displays and allows editing of template parameters, when using <strong>Go to Definition</strong> or F12.</p>
<p>For example, pressing F12 on vector will now jump to vector with the template bar automatically populated, allowing you to quickly inspect and modify template parameters.</p>
<p>In the example below, using <strong>Go To Definition</strong> or pressing F12 will populate both the type and allocator in the template bar.</p>
<p><img decoding="async" width="800" height="305" class="wp-image-35471" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/auto-populate-template-intellisense.gif" alt="Auto Populate Template IntelliSense" /></p>
<p>We’ve also added support for controlling which headers appear in the include completion list when you type #include.</p>
<p>The dropdown setting in <strong>Tools → Options → Text Editor → C/C++ → IntelliSense → Include style for suggestions</strong> now affects both include suggestions and include completion, with the following refined behaviors:</p>
<ul>
<li><strong>Core Guidelines (Default)</strong>: Uses quotes for relative paths and angle brackets for everything else.</li>
<li><strong>Quotes mode</strong>: Uses quotes for all headers except standard headers, which use angle brackets.</li>
<li><strong>Angle brackets mode</strong>: Uses angle brackets for all headers that are part of the include path.</li>
</ul>
<p><img decoding="async" width="736" height="476" class="wp-image-35472" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/include-style-for-suggestions-setting.png" alt="Include Style for Suggestions Setting" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/include-style-for-suggestions-setting.png 736w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/include-style-for-suggestions-setting-300x194.png 300w" sizes="(max-width: 736px) 100vw, 736px" /></p>
<h2>CMake</h2>
<p>We have added support for IntelliSense-based completions and quick info for CMake modules in Visual Studio. Now, you can view all available CMake modules and learn more about them directly from the Visual Studio editor.</p>
<h3>Quick Info</h3>
<p>When you hover over a referenced CMake module, IntelliSense provides detailed information about the selected module, helping you understand its usage and functionality at a glance.</p>
<p><img decoding="async" width="787" height="108" class="wp-image-35473" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/cmake-information-in-the-quick-info.png" alt="CMake information in the Quick Info" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/cmake-information-in-the-quick-info.png 787w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/cmake-information-in-the-quick-info-300x41.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/cmake-information-in-the-quick-info-768x105.png 768w" sizes="(max-width: 787px) 100vw, 787px" /></p>
<h3>Completion</h3>
<p>When you start typing a CMake module in your CMakeLists.txt or other CMake script files, IntelliSense will provide a list of available modules to choose from.</p>
<p><img decoding="async" width="369" height="310" class="wp-image-35474" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/cmake-module-completion.png" alt="CMake module completion" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/cmake-module-completion.png 369w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/cmake-module-completion-300x252.png 300w" sizes="(max-width: 369px) 100vw, 369px" /></p>
<h2>GitHub Copilot</h2>
<p>We’ve added doc comment generation support for GitHub Copilot. With this feature enabled, you can type the comment pattern according to your settings configuration (e.g., <code>///</code>), and Copilot will complete the function description based on the code.</p>
<p><img decoding="async" width="768" height="295" class="wp-image-35475" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/ai-doc-comments.gif" alt="AI doc comments" /></p>
<p>Also new in this release is Next Edit Suggestions (NES). When you&#8217;re presented with an edit suggestion, if it is on a different line than the one you are on now, it will suggest you <strong>Tab to Navigate to the corresponding line</strong> first.</p>
<p>You can enable NES at<strong> Tools → Options → GitHub → Copilot → Copilot Completions → Enable Next Edit Suggestions.</strong></p>
<p><img decoding="async" width="642" height="311" class="wp-image-35476" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/nes-tab-to-jump-hint-bar.png" alt="NES Tab to Jump Hint Bar" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/nes-tab-to-jump-hint-bar.png 642w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/nes-tab-to-jump-hint-bar-300x145.png 300w" sizes="(max-width: 642px) 100vw, 642px" /></p>
<h2>Unreal Engine Blueprints Debugger</h2>
<p>The Unreal Engine Blueprint integration allows you to debug Blueprints directly within Visual Studio. This integration includes displaying Blueprint stack traces in the Visual Studio call stack tab and showing Blueprint node values in the local variables table. These features limit the need for you to switch between Visual Studio and the Unreal Editor, providing a seamless debugging experience and reducing context-switching.</p>
<p><img decoding="async" width="860" height="230" class="wp-image-35477" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/picture-1-picture.png" alt="Picture 1, Picture" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/picture-1-picture.png 860w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/picture-1-picture-300x80.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2025/05/picture-1-picture-768x205.png 768w" sizes="(max-width: 860px) 100vw, 860px" /></p>
<p>With the new functionality, developers can easily track interactions between Blueprints and C++ code, making it simpler to identify and fix bugs. Additionally, an <a href="https://github.com/microsoft/vc-ue-extensions">Unreal Engine plugin for Visual Studio</a> enhances this capability by tracking Blueprint execution flow and storing additional information, which the debugger extension can then display.</p>
<h2>Address Sanitizer</h2>
<p>We have resolved various issues and feedback tickets, enhancing the quality and stability of Address Sanitizer. We have published a comprehensive list of issues we resolved in Visual Studio 2022 17.13 <a href="https://devblogs.microsoft.com/cppblog/msvc-address-sanitizer-updates-in-visual-studio-2022-version-17-13/">here</a> and will publish a similar one for 17.14 soon.</p>
<p>To further improve the quality of both Address Sanitizer and our toolchain, we now instrument the entire toolchain with Address Sanitizer on each pull request. Then, internal test pipelines are executed against this instrumented toolset to protect against memory safety errors. This process enables the identification of novel memory safety issues within the toolset and improves the quality of Address Sanitizer through an expedited feedback loop. The Visual C++ Library implementation in the <a href="https://github.com/Microsoft/STL">STL GitHub repository</a> is also tested daily using Address Sanitizer using a <a href="https://dev.azure.com/vclibs/STL/_build?definitionId=5&amp;_a=summary">dedicated pipeline</a>.</p>
<h2>Send us your feedback</h2>
<p>We are very much interested in your feedback to continue to improve this experience. The comments below are open. Feedback can also be shared through <a href="https://developercommunity.visualstudio.com/cpp" target="_blank" rel="noopener">Visual Studio Developer Community</a>. You can also reach us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-14/">What’s New for C++ Developers in Visual Studio 2022 17.14</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-14/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Introducing the /forceInterlockedFunctions switch for ARM64</title>
		<link>https://devblogs.microsoft.com/cppblog/introducing-the-forceinterlockedfunctions-switch-for-arm64/</link>
		
		<dc:creator><![CDATA[Emily Bao]]></dc:creator>
		<pubDate>Tue, 13 May 2025 10:00:25 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[Backend]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=35259</guid>

					<description><![CDATA[<p>In Visual Studio 2022 17.14, we are introducing the /forceInterlockedFunctions[-] switch, which generates and links with out-of-line atomics that select Armv8.1+ Large System Extension (LSE) atomic instructions based on CPU support. This switch is on by default for Armv8.0 and off for Armv8.1+. Outlining is necessary in Armv8.0 because this version&#8217;s interlocked intrinsics use exclusive [&#8230;]</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/introducing-the-forceinterlockedfunctions-switch-for-arm64/">Introducing the /forceInterlockedFunctions switch for ARM64</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In Visual Studio 2022 17.14, we are introducing the <code>/forceInterlockedFunctions[-]</code> switch, which generates and links with out-of-line atomics that select Armv8.1+ Large System Extension (LSE) atomic instructions based on CPU support.</p>
<p>This switch is on by default for Armv8.0 and off for Armv8.1+. Outlining is necessary in Armv8.0 because this version&#8217;s interlocked intrinsics use exclusive instructions—<code>LoadExcl</code>/<code>StoreExcl</code>—that do not guarantee forward progress. This can cause performance issues due to intermittent livelocks. <a href="https://developer.arm.com/documentation/ddi0487/ka">See Arm Architecture Reference Manual for A-profile architecture</a>, section &#8220;B2.17.5 Load-Exclusive and Store-Exclusive instruction usage restrictions&#8221; for examples of when the <code>LoadExcl</code>/<code>StoreExcl</code> loop may not make forward progress.</p>
<p>Below is an example of code that was previously generated when using the <code>_InterlockedAdd64</code> intrinsic. You can see the <code>ldaxr</code> and <code>stlxr</code> instructions being used.</p>
<table style="width: 74.6316%;">
<tbody>
<tr>
<td style="width: 49.3177%;">Main.cpp</td>
<td style="width: 115.99%;">Main.asm snippet</td>
</tr>
<tr>
<td style="width: 49.3177%;">
<pre class="prettyprint language-cpp"><code class="language-cpp">#include &lt;intrin.h&gt;
#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;

void main() {
    volatile __int64 Addend = 5;
    __int64 Value = 1; _InterlockedAdd64(&amp;Addend, Value);
}</code></pre>
</td>
<td style="width: 115.99%;">
<pre class="prettyprint language-default"><code class="language-default">; _InterlockedAdd64(&amp;Addend, Value);
ldr x10,[sp]
add x9,sp,#8
|$LN3@main|
ldaxr x8,[x9]
add x8,x8,x10
stlxr wip0,x8,[x9]
cbnz wip0,|$LN3@main|
dmb ish</code></pre>
</td>
</tr>
</tbody>
</table>
<p>With the <code>/forceInterlockedFunctions</code> option you can see that the <code>ldaxr</code> and <code>stlxr</code> are gone and have been replaced with a <code>bl _InterlockedAdd64</code> instruction</p>
<table>
<tbody>
<tr>
<td>Main.cpp</td>
<td>Main.asm snippet</td>
</tr>
<tr>
<td>
<pre class="prettyprint language-cpp"><code class="language-cpp">#include &lt;intrin.h&gt;
#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;

void main() {
    volatile __int64 Addend = 5;
    __int64 Value = 1; _InterlockedAdd64(&amp;Addend, Value);
}</code></pre>
</td>
<td>
<pre class="prettyprint language-default"><code class="language-default">; InterlockedAdd64(&amp;Addend, Value);
ldr x1,[sp,#0x10]
add x0,sp,#0x18
bl _InterlockedAdd64
nop</code></pre>
</td>
</tr>
</tbody>
</table>
<p>The <code>/forceInterlockedFunctions</code> option only applies to Arm64 and will be ignored if not applicable. Additionally, enabling the LSE feature will override the default outlining behavior in Armv8.0.</p>
<p>Note that the option is on by default for all Arm64EC versions. We would not recommend turning the option off for ARM64EC, as outlining helps address the memory model differences between Arm64 and x64.</p>
<p>&nbsp;</p>
<p>This flag impacts the following interlocked intrinsics:</p>
<p>Key:</p>
<ul>
<li>Full: supports plain, <code>_acq</code>, <code>_rel</code>, and <code>_nf</code> forms.</li>
<li>None: Not supported</li>
</ul>
<table>
<tbody>
<tr>
<td><strong>Operation</strong></td>
<td><strong>8</strong></td>
<td><strong>16</strong></td>
<td><strong>32</strong></td>
<td><strong>64</strong></td>
<td><strong>128</strong></td>
<td><strong>Pointer</strong></td>
</tr>
<tr>
<td><code>Add</code></td>
<td>None</td>
<td>None</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>And</code></td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>CompareExchange</code></td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
</tr>
<tr>
<td><code>Decrement</code></td>
<td>None</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>Exchange</code></td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>Full</td>
</tr>
<tr>
<td><code>ExchangeAdd</code></td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>Increment</code></td>
<td>None</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>Or</code></td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>Xor</code></td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>bittestandset</code></td>
<td>None</td>
<td>None</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td><code>bittestandreset</code></td>
<td>None</td>
<td>None</td>
<td>Full</td>
<td>Full</td>
<td>None</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4><strong>See also</strong></h4>
<p><a href="https://learn.microsoft.com/cpp/build/reference/force-interlocked-functions?view=msvc-170">/forceInterlockedFunctions | Microsoft Learn</a></p>
<p><a href="https://learn.microsoft.com/cpp/intrinsics/arm64-intrinsics?view=msvc-170">ARM64 intrinsics | Microsoft Learn</a></p>
<p><a href="https://learn.microsoft.com/cpp/build/reference/feature-arm64?view=msvc-170">/feature (ARM64) | Microsoft Learn</a></p>
<p><a href="https://learn.arm.com/learning-paths/servers-and-cloud-computing/lse/intro/">Introduction to Large System Extensions | Arm Learning Paths</a></p>
<h4><strong>Feedback</strong></h4>
<p>That’s all about this new compiler option and default setting that you can find starting in Visual Studio 2022 version 17.14. Please give it a try and let us know how it goes! We always welcome feedback, questions, or concerns from the community, as it helps make Visual Studio better.</p>
<p>Please share your thoughts, comments and questions with us through <a href="https://developercommunity.visualstudio.com/home">Developer Community</a>. You can also reach us on X <a href="https://x.com/visualc">@VisualC</a>, or via email at visualcpp@microsoft.com.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/introducing-the-forceinterlockedfunctions-switch-for-arm64/">Introducing the /forceInterlockedFunctions switch for ARM64</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
