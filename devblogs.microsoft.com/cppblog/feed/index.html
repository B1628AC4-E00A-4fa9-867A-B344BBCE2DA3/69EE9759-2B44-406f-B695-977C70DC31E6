<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Thu, 29 Jul 2021 15:55:01 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/#respond</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Thu, 29 Jul 2021 15:59:04 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[debug]]></category>
		<category><![CDATA[debugging]]></category>
		<category><![CDATA[edit and continue]]></category>
		<category><![CDATA[hot reload]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28456</guid>

					<description><![CDATA[<p>Hot Reload support for C++ Applications<br />
In Visual Studio 2022 Preview 2, we are happy to announce that Hot Reload is now supported for C++.<br />
Hot Reload for C++, powered by Edit and Continue, is a new way of editing your code while actively debugging.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/">Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="hot-reload-support-for-c-applications">Hot Reload support for C++ Applications</h1>
<p>In Visual Studio 2022 Preview 2, we are happy to announce that Hot Reload is now supported for C++.</p>
<p>Hot Reload for C++, powered by Edit and Continue, is a new way of editing your code while actively debugging. Hot Reload allows you to apply code changes without stopping at a breakpoint or restarting your app.</p>
<p><span style="font-size: 14pt;"><em>Currently, Hot Reload is only supported for MSBuild C++ projects, but we are working on enabling support for CMake projects in an upcoming preview.</em> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/HRShort.gif"><img class="aligncenter size-full wp-image-28481" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/HRShort.gif" alt="Image Hot reload changing cube spin speed" width="1200" height="675" /></a></p>
<p>To learn more about Hot Reload, please refer to the Visual Studio Blog post: <a href="https://devblogs.microsoft.com/visualstudio/speed-up-your-dotnet-and-cplusplus-development-with-hot-reload-in-visual-studio-2022">Speed up your .NET and C++ development with Hot Reload in Visual Studio 2022</a></p>
<h1 id="we-want-your-feedback-survey">We Want Your Feedback: Survey</h1>
<p>As we are looking at these experiences, please let us know how Hot Reload and/or Edit and Continue support for C++ can be further enhanced to improve your day-to-day productivity. We’re looking forward to your feedback.</p>
<p><strong>Please participate in this 3-minute <a href="https://www.surveymonkey.com/r/B7GRLF6">Hot Reload for C++ Survey</a>.</strong></p>
<p>You can also reach us on Twitter (@VisualC).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/">Edit Your C++ Code while Debugging with Hot Reload in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/edit-your-c-code-while-debugging-with-hot-reload-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Wed, 28 Jul 2021 16:00:32 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28441</guid>

					<description><![CDATA[<p>The July 2021 update of the C++ extension for Visual Studio Code is here, bringing you brand new features— such as a Disassembly View while debugging, inline macro expansions, and debug support for Windows ARM64 architecture—along with a bunch of enhancements and bug fixes.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/">Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The July 2021 update of <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">the C++ extension for Visual Studio Code</a> is here, bringing you brand new features— such as a Disassembly View while debugging, inline macro expansions, and debug support for Windows ARM64 architecture—along with a bunch of enhancements and bug fixes. To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.5.0">release notes on GitHub.</a></p>
<h2 id="disassembly-view">Disassembly View</h2>
<p>We’re excited to announce that Disassembly View— our #1 upvoted GitHub issue (<a href="https://github.com/microsoft/vscode-cpptools/issues/206">#206</a>)— is publicly available in VS Code Insiders! Disassembly View allows you to debug assembly code corresponding to the instructions created by your compiler. It’ll be available in the 1.59 release of Visual Studio Code in August, but in the meantime you can <a href="https://code.visualstudio.com/insiders/">download VS Code Insiders</a> and try it out!</p>
<p>To open Disassembly View while debugging, right click your source code and select <strong>Open Disassembly View. </strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png"><img class="alignnone size-full wp-image-28452" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png" alt="Image showing the right-click menu option to Open Disassembly View" width="3101" height="1999" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1.png 3101w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-300x193.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-1024x660.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-768x495.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-1536x990.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/open-disassembly-view-1-2048x1320.png 2048w" sizes="(max-width: 3101px) 100vw, 3101px" /></a></p>
<p>In the Disassembly View, the yellow hollow marker represents the current instruction. For each instruction, you’ll see the memory address (left column) and the machine language instructions displayed as hex (middle column) and as assembly language (right column). You can navigate between instructions, step over (<strong>F10</strong>) and step in to (<strong>F11</strong>) instructions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png"><img class="alignnone size-full wp-image-28451" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png" alt="Image showing the Disassembly View opened side by side with source code" width="3105" height="1929" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1.png 3105w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-300x186.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-1024x636.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-768x477.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-1536x954.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-side-by-side-1-2048x1272.png 2048w" sizes="(max-width: 3105px) 100vw, 3105px" /></a></p>
<p>To set a breakpoint in the Disassembly View, hover over the instruction and click the red filled circle that appears to the left of the memory address.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png"><img class="alignnone wp-image-28450" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png" alt="Image showing the red filled circle that appears on hover to set a breakpoint at an instruction in Disassembly View" width="889" height="203" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1.png 1265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-300x69.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-1024x234.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-set-breakpoint-1-768x175.png 768w" sizes="(max-width: 889px) 100vw, 889px" /></a></p>
<p>Unset the breakpoint by clicking the red dot again, or by unchecking the box in the Breakpoints section of the Debug pane.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png"><img class="alignnone size-full wp-image-28449" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png" alt="Image showing the Breakpoints section of the Debug pane, where users can enable and disable breakpoints" width="530" height="184" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1.png 530w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-check-breakpoint-1-300x104.png 300w" sizes="(max-width: 530px) 100vw, 530px" /></a></p>
<p>Check out this GIF to see Disassembly View in action:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-view-sidey-by-side.gif"><img class="alignnone size-full wp-image-28447" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/disassembly-view-sidey-by-side.gif" alt="GIF showing how to open Disassembly View while debugging, navigate between instructions and set breakpoints" width="3116" height="1954" /></a></p>
<h2 id="macro-expansion">Macro Expansion</h2>
<p>With this latest release of the C++ extension, you can expand macros inline (GitHub issue <a href="https://github.com/microsoft/vscode-cpptools/issues/4183">#4183</a>), making it easier to read and understand your code. To expand a macro inline, click on it, select the lightbulb, and then click <strong>Inline macro.</strong></p>
<p><strong><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/macro-expansion.gif"><img class="alignnone size-full wp-image-28448" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/macro-expansion.gif" alt="GIF showing how to expand a macro inline" width="586" height="280" /></a></strong></p>
<h2 id="windows-arm64-debugging">Windows ARM64 Debugging</h2>
<p>Last year, we announced support for running the C++ extension on Windows ARM64 architecture, giving Surface Pro X users access to C++ IntelliSense, code navigation, and build support. With the July 2021 update of the C++ extension, you can debug projects on Windows ARM64, completing the end-to-end Surface Pro X C++ development experience in VS Code.</p>
<h2 id="what-do-you%e2%80%afthink">What do you think?</h2>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>. You can also join our Insiders program and get access to early builds of our release by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/">Visual Studio Code C++ July 2021 Update: Disassembly View, Macro Expansion and Windows ARM64 Debugging</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-july-2021-update-disassembly-view-macro-expansion-and-windows-arm64-debugging/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</title>
		<link>https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/</link>
					<comments>https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Wed, 21 Jul 2021 18:31:46 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[compiler command line]]></category>
		<category><![CDATA[modules]]></category>
		<category><![CDATA[MSVC]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28323</guid>

					<description><![CDATA[<p>In this three-part series we will explore how to build modules and header units from the command line as well as how to use/reference them.<br />
The goal of this post is to serve as a brief tour of compiling and using primary module interfaces from the command line and the options we use.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In this three-part series we will explore how to build modules and header units from the command line as well as how to use/reference them.</p>
<p>The goal of this post is to serve as a brief tour of compiling and using primary module interfaces from the command line and the options we use.</p>
<p><em>Note:</em> This tutorial will focus primarily on dealing with IFC and object file output. Other types of compiler output such as PDB info are not mentioned.</p>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#summary">Summary of C++ modules options.</a></li>
<li><a href="#interface-basics">Basics of building a module interface.</a></li>
<li><a href="#module-dependencies">Modules with interface dependencies.</a></li>
</ul>
<h4><span id="summary">Summary of C++ modules options</span></h4>
<table>
<tbody>
<tr>
<th>Option</th>
<th>Brief Description</th>
</tr>
<tr>
<td id="interface"><code>/interface</code></td>
<td>Tells the compiler that the input file is a module interface unit.</td>
</tr>
<tr>
<td><code>/internalPartition</code></td>
<td>Tells the compiler that the input file is an <a href="https://devblogs.microsoft.com/cppblog/c-modules-conformance-improvements-with-msvc-in-visual-studio-2019-16-5/#module-partitions">internal partition unit</a>.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-reference?view=msvc-160">/reference</a></code></td>
<td>Provides the compiler with an IFC file to reference for the nominated module interface name.</td>
</tr>
<tr>
<td id="ifc-search-dir"><code>/ifcSearchDir</code></td>
<td>When the compiler falls back to implicit module interface search, directories specified by this option will be used.</td>
</tr>
<tr>
<td><code>/ifcOutput</code></td>
<td>Tells the compiler where the IFC resulting from compilation should go. If that destination is a directory the compiler will generate a name based on the interface name or the header unit name.</td>
</tr>
<tr>
<td><code>/ifcOnly</code></td>
<td>Instructs the compiler to only produce an IFC as the result of compilation. No other outputs will be produced as the result of compilation even if other options are specified.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/module-exportheader?view=msvc-160">/exportHeader</a></code></td>
<td>Instructs the compiler to create a header unit from the input.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/headername?view=msvc-160">/headerName</a></code></td>
<td>Tells the compiler that the input designates the name of a header.</td>
</tr>
<tr>
<td><code><a href="https://docs.microsoft.com/en-us/cpp/build/reference/translateinclude?view=msvc-160">/translateInclude</a></code></td>
<td>Instructs the compiler to perform <code>#include</code> -&gt; <code>import</code> translation if the header-name nominates an importable header.</td>
</tr>
<tr>
<td><code>/showResolvedHeader</code></td>
<td>When building a header unit, show the fully resolved path to that header unit after compilation.</td>
</tr>
<tr>
<td><code>/validateIfcChecksum[-]</code></td>
<td>Off by default. Specifying this switch will enforce an extra security check using the stored content hash in the IFC.</td>
</tr>
</tbody>
</table>
<h4><span id="interface-basics">Basics of building a module interface</span></h4>
<p>For the content in this section, we will assume that you have an appropriate compiler environment command prompt set up and that you have navigated to the directory with your test files.</p>
<p>Let&#8217;s look at the most basic scenario we can for starters:</p>
<p><code>m.ixx</code>:</p>
<pre class="">export module MyModule;

export
void f() { }</pre>
<p><code>main.cpp</code>:</p>
<pre class="">import MyModule;

int main() {
  f();
}</pre>
<p>The simplest way to build this sample is the following:</p>
<pre>$ cl /c /std:c++latest m.ixx
$ cl /std:c++latest /reference MyModule=MyModule.ifc main.cpp m.obj
$ .\main.exe</pre>
<p>One quick note about the name of file <code>m.ixx</code> above, the <code>.ixx</code> extension is the default module interface extension for MSVC. If you wish to use a different extension then you must use <a href="#interface"><code>/interface</code></a> along with <a href="https://docs.microsoft.com/en-us/cpp/build/reference/tc-tp-tc-tp-specify-source-file-type?view=msvc-160"><code>/TP</code></a> in order to compile the input as both C++ and as a module interface. Here&#8217;s a quick example of compiling the module interface if the name were <code>my-module.cppm</code>:</p>
<pre>$ cl /c /std:c++latest /interface /TP my-module.cppm</pre>
<p>In the first line we compile the module interface, and two things happen implicitly:</p>
<ol>
<li>The compiler will derive a name for the resulting object file based on the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/specifying-the-pathname?view=msvc-160">base name of the input file</a>. The resulting object file in this case is derived from <code>m.ixx</code> transformed into <code>m.obj</code>.</li>
<li>The compiler will derive a name for the resulting IFC file based on the <em>module interface name</em>. The resulting IFC in this case is derived from the module name <code>MyModule</code> transformed into <code>MyModule.ifc</code>. Note that the name of the input file has no bearing on the exported module interface name, they are completely orthogonal to each other so if this file were named <code>foobar.ixx</code> the generated IFC name would still be <code>MyModule.ifc</code>.</li>
</ol>
<p>If we take away the two implicit points above, we will end up with a command line which looks like this:</p>
<pre>$ cl /c /std:c++latest m.ixx /ifcOutput MyModule.ifc /Fom.obj</pre>
<p>On the import side we could take advantage of the compiler&#8217;s implicit lookup behavior to find the module interface:</p>
<pre>$ cl /std:c++latest main.cpp m.obj
$ .\main.exe</pre>
<p>Whoa! Hold on there! What happened? Well, in MSVC the compiler implements a well-coordinated lookup to find the module interface implicitly. Because the compiler generates a module interface IFC based on the module name it can safely be assumed that if there is no direct <code>/reference</code> option on the command line then there could be an IFC somewhere on disk which is named after the module interface name. In the scenario above we are trying to import a module interface named <code>MyModule</code> so there might be a <code>MyModule.ifc</code> on disk, and indeed there is! It is worth pointing out that this implicit lookup behavior will search the current directory along with any directory added using <a href="#ifc-search-dir"><code>/ifcSearchDir</code></a>.</p>
<p>Let&#8217;s consider a scenario where the destination for the resulting IFC is not in the immediate directory. Consider the following directory structure:</p>
<pre>./
├─ src/
│  ├─ m.ixx
│  ├─ main.cpp
├─ bin/</pre>
<p>And let&#8217;s assume that our compiler command prompt is rooted at <code>./</code> and that we want all output to go into the <code>bin\</code> folder. Here&#8217;s what the fully explicit command lines look like:</p>
<pre>$ cl /c /std:c++latest src\m.ixx /Fobin\m.obj /ifcOutput bin\MyModule.ifc
$ cl /std:c++latest /reference MyModule=bin\MyModule.ifc src\main.cpp /Fobin\m.obj /Febin\main.exe bin\m.obj</pre>
<p>There are a lot of things going on so let&#8217;s narrow the scope of noise to just the command line options required to compile <code>main.cpp</code> and not link it.</p>
<pre>$ cl /c /std:c++latest /reference MyModule=bin\MyModule.ifc src\main.cpp /Fobin\m.obj</pre>
<p><em>Note:</em> The <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fo-object-file-name?view=msvc-160"><code>/Fo</code></a> tells the compiler where to put the resulting object file. Further, in order to ensure that the compiler can properly detect that the destination is a directory, please append the trailing &#8216;<code>\</code>&#8216; at the end of the argument.</p>
<p>If we wanted to take advantage of the compiler&#8217;s implicit naming mechanisms the command lines would be the following:</p>
<pre>$ cl /c /std:c++latest src\m.ixx /Fobin\ /ifcOutput bin\
$ cl /std:c++latest /ifcSearchDir bin\ src\main.cpp /Fobin\ /Febin\ bin\m.obj</pre>
<p>Notice that the difference here is we simply provide a directory as the argument to each of our command line options.</p>
<h4><span id="module-dependencies">Modules with interface dependencies</span></h4>
<p>Often, we don&#8217;t want to build a single module interface and call it a day, it is frequently the case that sufficiently large projects will be composed of many module interfaces which describe various parts of the system. In this section we&#8217;ll explore how to build translation units which depend on one or more interfaces.</p>
<p>Let&#8217;s consider a slightly more sophisticated directory layout:</p>
<pre>./
├─ src/
│  ├─ types/
│  │  ├─ types.ixx
│  ├─ util/
│  │  ├─ util.ixx
│  ├─ shop/
│  │  ├─ shop.ixx
│  │  ├─ shop-unit.cpp
│  ├─ main.cpp
├─ bin/</pre>
<p>The code for these files can be found <a href="https://gist.github.com/cdacamar/8226c1893dd8c8a81974c939be52809f">here</a>.</p>
<p>As you explore the code you will find that many of these modules/source files contain references to module interfaces and those interfaces may reference yet another interface. At its core, the most basic dependency graph looks like the following:</p>
<pre>   types.ixx
   /       \
util.ixx  shop.ixx
  \        /
shop-unit.cpp
      |
   main.cpp</pre>
<p>Without further ado, here are the explicit command lines in all their glory:</p>
<pre>$ cl /c /EHsc /std:c++latest src\types\types.ixx /Fobin\types.obj /ifcOutput bin\types.ifc
$ cl /c /EHsc /std:c++latest /reference types=bin\types.ifc src\util\util.ixx /Fobin\util.obj /ifcOutput bin\util.ifc
$ cl /c /EHsc /std:c++latest /reference types=bin\types.ifc src\shop\shop.ixx /Fobin\shop.obj /ifcOutput bin\shop.ifc
$ cl /c /EHsc /std:c++latest /reference types=bin\types.ifc /reference util=bin\util.ifc /reference shop=bin\shop.ifc src\shop\shop-unit.cpp /Fobin\shop-unit.obj
$ cl /EHsc /std:c++latest /reference shop=bin\shop.ifc /reference types=bin\types.ifc src\main.cpp /Fobin\main.obj /Febin\main.exe bin\types.obj bin\util.obj bin\shop.obj bin\shop-unit.obj</pre>
<p>That is quite a mouthful. One thing you might notice is that when we built <code>src\shop\shop-unit.cpp</code> we needed a reference to both <code>types</code> and <code>shop</code> even though there&#8217;s no explicit import of either interface. The reason for this is because <code>util</code> has an implicit dependency on <code>types</code> to resolve <code>Product</code> properly and because it is a module unit the line <code>module shop;</code> implicitly imports the module interface <code>shop</code>, this behavior is defined by the C++ standard.</p>
<p>Applying some techniques learned above we can drastically reduce the noise by using implicit naming/lookup:</p>
<pre>$ cl /c /EHsc /std:c++latest src\types\types.ixx /Fobin\ /ifcOutput bin\
$ cl /c /EHsc /std:c++latest /ifcSearchDir bin\ src\util\util.ixx /Fobin\ /ifcOutput bin\
$ cl /c /EHsc /std:c++latest /ifcSearchDir bin\ src\shop\shop.ixx /Fobin\ /ifcOutput bin\
$ cl /c /EHsc /std:c++latest /ifcSearchDir bin\ src\shop\shop-unit.cpp /Fobin\
$ cl /EHsc /std:c++latest /ifcSearchDir bin\ src\main.cpp /Fobin\ /Febin\ bin\types.obj bin\util.obj bin\shop.obj bin\shop-unit.obj</pre>
<p>This is looking much better. We can take it a step further by taking advantage of the fact that <code>cl.exe</code> will process each source file in a linear sequence:</p>
<pre>$ cl /EHsc /std:c++latest /ifcSearchDir bin\ src\types\types.ixx src\util\util.ixx src\shop\shop.ixx src\shop\shop-unit.cpp src\main.cpp /Fobin\ /Febin\main.exe /ifcOutput bin\</pre>
<p>The command above uses implicit naming/lookup along with <code>cl.exe</code>&#8216;s linear source processing behavior.</p>
<p><em>Note:</em> the above command line will <strong>not</strong> work if the option <a href="https://docs.microsoft.com/en-us/cpp/build/reference/mp-build-with-multiple-processes?view=msvc-160"><code>/MP</code></a> is used (compiling multiple inputs in parallel).</p>
<p>Just to be complete, we could also use explicit naming for our module interfaces in the single command line above:</p>
<pre>$ cl /EHsc /std:c++latest /reference shop=bin\shop.ifc /reference types=bin\types.ifc /reference util=bin\util.ifc src\types\types.ixx src\util\util.ixx src\shop\shop.ixx src\shop\shop-unit.cpp src\main.cpp /Fobin\ /Febin\main.exe /ifcOutput bin\</pre>
<p>The reason either of these command lines work is that the compiler will not try to do anything special with a <code>/reference</code> option unless the name designating the IFC is used and there is no extra cost to add <code>/reference</code> options for a command line if you know the module will be generated at some point in the input sequence.</p>
<h4 id="closing">Closing</h4>
<p>In part 2 we will cover how to handle module interface partitions. Finally, in part 3 we will cover how to handle header units.</p>
<p>We urge you to go out and try using Visual Studio 2019/2022 with Modules. Both Visual Studio 2019 and Visual Studio 2022 Preview are available through the <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio downloads</a> page!</p>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow me on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/">Using C++ Modules in MSVC from the Command Line Part 1: Primary Module Interfaces</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/using-cpp-modules-in-msvc-from-the-command-line-part-1/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Build and Debug C++ with WSL 2 Distributions and Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/#respond</comments>
		
		<dc:creator><![CDATA[Erika]]></dc:creator>
		<pubDate>Wed, 14 Jul 2021 18:58:54 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28300</guid>

					<description><![CDATA[<p>Visual Studio 2022 introduces a native WSL 2 toolset for C++ development. This toolset is available now in Visual Studio 2022 version 17.0 Preview 2. WSL 2 is the new, recommended version of the Windows Subsystem for Linux (WSL) architecture that provides better Linux file system performance,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/">Build and Debug C++ with WSL 2 Distributions and Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><div style="text-align:center"><a class="cta_button_link" href="https://aka.ms/vs2022preview" style="text-transform: titlecase; display: inline-block; background-color: #5C2D91; color: white; padding: 10px; margin:10px 0; text-decoration: none;" target="_blank">Download Visual Studio 2022 Preview</a></div>
Visual Studio 2022 introduces a native WSL 2 toolset for C++ development. This toolset is available now in <a href="https://visualstudio.microsoft.com/vs/preview/vs2022/">Visual Studio 2022 version 17.0 Preview 2</a>. WSL 2 is the new, recommended version of the <a href="https://docs.microsoft.com/en-us/windows/wsl/about">Windows Subsystem for Linux (WSL)</a> architecture that provides better Linux file system performance, GUI support, and full system call compatibility. Visual Studio’s WSL 2 toolset allows you to build and debug C++ code on WSL 2 distros from Visual Studio without ever adding an SSH connection. You can already build and debug C++ code on WSL 1 distros using the <a href="https://devblogs.microsoft.com/cppblog/c-with-visual-studio-2019-and-windows-subsystem-for-linux-wsl/">native WSL 1 toolset</a> introduced in Visual Studio 2019 version 16.1.</p>
<div style="text-align: center;"><iframe src="//www.youtube.com/embed/IKI2w75aAow" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></div>
<p>&nbsp;</p>
<p>Visual Studio’s WSL 2 toolset supports both CMake and MSBuild-based Linux projects. However, CMake is our recommendation for all C++ cross-platform development with Visual Studio because it allows you to build and debug the same project on Windows, WSL, and remote systems.</p>
<h4 id="how-does-the-wsl-2-toolset-work">How does the WSL 2 toolset work?</h4>
<p>Our C++ cross-platform support in Visual Studio assumes that all source files originate in the Windows file system. When targeting a WSL 2 distro, Visual Studio will execute a local rsync copy to copy files from the Windows file system to the WSL file system. This local rsync copy will occur automatically when Visual Studio detects that you are using a WSL 2 distro and will require no user intervention. See <a href="https://docs.microsoft.com/en-us/windows/wsl/compare-versions">Comparing WSL 1 and WSL 2</a> to learn more about the differences between WSL 1 and WSL 2.</p>
<p>Continue reading for a step-by-step guide on getting started with CMake and WSL 2 and an overview of our MSBuild-based WSL 2 support.</p>
<h4 id="cross-platform-cmake-development-with-a-wsl-2-distro">Cross-platform CMake development with a WSL 2 distro</h4>
<p>The WSL 2 toolset is supported by our CMake Presets integration in Visual Studio. You can learn more about CMake Presets in our <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">announcement blog post</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">documentation</a>. Follow the instructions below to build and debug a CMake project on a WSL 2 distro.</p>
<p>1. Install WSL and a WSL 2 distro with the <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">Windows Subsystem for Linux Installation Guide for Windows 10</a>.</p>
<p>2. Install the required build tools on your WSL 2 distro. You will need a C++ compiler, gdb, CMake, an underlying build system generator, rsync, and zip. You can install these dependencies on distros that use apt with the following commands:</p>
<div style="text-align: center;">
<pre class="prettyprint">sudo apt update
sudo apt install g++ gdb make ninja-build rsync zip</pre>
</div>
<p>In this tutorial I’ll use GCC and Ninja on Ubuntu. I will install a recent version of CMake using Visual Studio’s CMake binary deployment in step 9.</p>
<p>3. Open a CMake project in Visual Studio 2022 version 17.0 Preview 2 or later. Visual Studio defines a CMake project as a folder with a CMakeLists.txt file at the project root. You can either clone a CMake repository (like <a href="https://github.com/esweet431/bullet3">bullet3</a>), open a local CMake project, or create a new CMake project with the CMake Project template. In this tutorial I’m going to create a new CMake project with the CMake Project template.
<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started.png"><img class="aligncenter size-full wp-image-28301" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started.png" alt="The &quot;Get started&quot; menu in the Visual Studio Installer. Options are &quot;Clone a repository&quot;, &quot;Open a project or solution&quot;, &quot;Open a local folder&quot;, or &quot;Create a new project&quot;." width="384" height="417" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started.png 384w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/get-started-276x300.png 276w" sizes="(max-width: 384px) 100vw, 384px" /></a>
4. Enable Visual Studio’s CMake Presets integration. You can add a CMakePresets.json file to the root of the project or enable the integration globally in <strong>Tools &gt; Options &gt; CMake &gt; General</strong>. You must close and reopen the folder in Visual Studio to activate the integration. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#enable-cmakepresetsjson-integration-in-visual-studio-2019">Enable CMake Presets integration</a> for more information.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets.png"><img class="aligncenter size-full wp-image-28302" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets.png" alt="An image of the checkbox to enable CMake Presets integration in Tools &gt; Options &gt; CMake &gt; General in Visual Studio. The option to &quot;Prefer using CMake Presets for CMake configure, build, and test&quot; is checked and highlighted red." width="732" height="248" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets.png 732w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/enable-cmakepresets-300x102.png 300w" sizes="(max-width: 732px) 100vw, 732px" /></a></p>
<p>5. You should now see three dropdowns across the menu bar. Use the dropdown on the left to select your active Target System. This is the system where CMake will be invoked to configure and build the project. Visual Studio queries for WSL installations with <strong>wsl -l -v</strong>. In the example below, my Target System is <strong>WSL2: Ubuntu-20.04.</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system.png"><img class="aligncenter size-full wp-image-28303" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system.png" alt="An image of the Target System dropdown in Visual Studio. The options are &quot;Local Machine&quot;, &quot;172.26.1.64&quot;, &quot;WSL2: Ubuntu-20.04&quot; and &quot;WSL1: Debian&quot;. &quot;WSL2: Ubuntu-20.04&quot; is selected." width="737" height="165" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system.png 737w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/target-system-300x67.png 300w" sizes="(max-width: 737px) 100vw, 737px" /></a></p>
<p>Note: If Visual Studio starts to configure your project automatically, read step 9 to manage CMake binary deployment and then return to step 6. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#modify-automatic-configuration-and-cache-notifications">Modify automatic configuration and cache notifications</a> to customize this behavior.</p>
<p>6. Use the dropdown in the middle to select your active Configure Preset. Configure Presets tell Visual Studio how to invoke CMake and generate the underlying build system. In the example in Step 5 (above), my active Configure Preset is the <strong>linux-default</strong> Preset created by Visual Studio. If you want to create a custom Configure Preset, select <strong>Manage Configurations…</strong>. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#select-a-configure-preset">Select a Configure Preset</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#edit-presets">Edit Presets</a> for more information.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manage-configs.png"><img class="aligncenter size-full wp-image-28304" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manage-configs.png" alt="An image of the Configure Preset dropdown. The only option is &quot;linux-default&quot;, which is selected." width="210" height="92" /></a></p>
<p>7. Use the dropdown on the right to select your active Build Preset. Build Presets tell Visual Studio how to invoke build. In the example in Step 5 (above), my active Build Preset is the <strong>Default </strong>Preset created by Visual Studio. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#select-a-build-preset">Select a Build Preset</a> for more information.</p>
<p>8. Configure the project on WSL 2. If project generation does not start automatically, then you can manually invoke configure with <strong>Project &gt; Configure &lt;project-name&gt;</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation.png"><img class="aligncenter size-full wp-image-28305" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation.png" alt="An image of the Project menu in Visual Studio. &quot;Configure CMakeProject&quot; is selected." width="307" height="223" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation.png 307w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/manual-generation-300x218.png 300w" sizes="(max-width: 307px) 100vw, 307px" /></a></p>
<p>9. If you do not have a supported version of CMake installed on your WSL 2 distro, then Visual Studio will prompt you to deploy a recent version of CMake. Select “Yes” to deploy CMake binaries to your WSL 2 distro.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment.png"><img class="aligncenter size-full wp-image-28306" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment.png" alt="Image binary deployment" width="757" height="95" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment.png 757w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/binary-deployment-300x38.png 300w" sizes="(max-width: 757px) 100vw, 757px" /></a></p>
<p>10. Confirm that the configure step has completed and that you can see the <strong>CMake generation finished</strong> message in the CMake pane of the Output Window. Note that build files are written to a directory in the WSL 2 distro’s file system.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output.png"><img class="aligncenter size-full wp-image-28307" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output.png" alt="The CMake pane of the Output Window is open in Visual Studio. The last line of output reads &quot;CMake generation finished.&quot;" width="1118" height="309" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output.png 1118w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output-300x83.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output-1024x283.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/output-768x212.png 768w" sizes="(max-width: 1118px) 100vw, 1118px" /></a></p>
<p>11. Select the active debug target. The debug dropdown menu lists all the CMake targets available to the project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debug-drop.png"><img class="aligncenter size-full wp-image-28308" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debug-drop.png" alt="An image of the debug dropdown menu in Visual Studio. The CMake target &quot;CMakeProject&quot; is selected." width="300" height="144" /></a></p>
<p>12. Set a breakpoint. Expand the project subfolder in the Solution Explorer and in the .cpp file set a breakpoint in main(). You can also navigate to CMake Targets View by selecting the View Picker button in the Solution Explorer.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view.png"><img class="aligncenter size-full wp-image-28309" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view.png" alt="Image targets view" width="356" height="137" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view.png 356w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/targets-view-300x115.png 300w" sizes="(max-width: 356px) 100vw, 356px" /></a></p>
<p>13. Now click “Start” (Debug &gt; Start) or press F5. Your project will build, the executable will launch on your WSL 2 distro, and you will hit your breakpoint. You can see the output of your program (in this case, “Hello CMake.”) in the Linux Console Window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging.png"><img class="aligncenter size-full wp-image-28310" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging.png" alt="CMakeProject.cpp is open and running under the debugger. A breakpoint is set and hit at line 11. The Linux Console Window is open and reads &quot;Hello CMake.&quot;" width="1170" height="832" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging.png 1170w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging-300x213.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging-1024x728.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/debugging-768x546.png 768w" sizes="(max-width: 1170px) 100vw, 1170px" /></a></p>
<h4 id="msbuild-based-linux-development-with-a-wsl-2-distro">MSBuild-based Linux development with a WSL 2 distro</h4>
<p>CMake is our recommendation for all C++ cross-platform development with Visual Studio because it allows you to build and debug the same project on Windows, WSL, and remote systems. If you are already using a MSBuild-based Linux project, then you can upgrade to the WSL 2 toolset in <strong>Property Pages &gt; General &gt; Platform Toolset</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild.png"><img class="aligncenter size-full wp-image-28311" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild.png" alt="Property Pages are open in a MSBuild-based Linux project. The &quot;Platform Toolset&quot; option is selected, and &quot;WSL2 Toolset&quot; is the selected value." width="558" height="162" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild.png 558w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/07/msbuild-300x87.png 300w" sizes="(max-width: 558px) 100vw, 558px" /></a></p>
<h4 id="talk-to-us">Talk to us!</h4>
<p>Our native WSL 2 toolset and CMake Presets integration are still in preview. We’ll continue to address your feedback in future releases of Visual Studio. The best way to file a bug or suggest a feature is with the <strong>Send Feedback</strong> button in the upper right-hand corner of the IDE. See <a href="https://docs.microsoft.com/en-us/visualstudio/ide/feedback-options?view=vs-2019#:~:text=In%20Visual%20Studio%2C%20choose%20the%20feedback%20icon%20in,information%2C%20see%20Suggest%20a%20feature%20for%20Visual%20Studio.">Visual Studio feedback options</a> for more information.</p>
<p>We’d love to learn how your team is adopting our support for WSL 2. If you have feedback or a success story to share, you can contact us at vcpp-linux@microsoft.com. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/">Build and Debug C++ with WSL 2 Distributions and Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/build-and-debug-c-with-wsl-2-distributions-and-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Code Scanning C++ with GitHub Actions</title>
		<link>https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/#comments</comments>
		
		<dc:creator><![CDATA[Nick Uhlenhuth]]></dc:creator>
		<pubDate>Wed, 07 Jul 2021 15:25:27 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28264</guid>

					<description><![CDATA[<p>Last year, GitHub released code scanning, which enables developers to incorporate security checks into their CI/CD environment and developer workflow. This post demonstrates the basics of using CodeQL, the analysis engine behind code scanning, with GitHub Actions.<br />
What is CodeQL?<br />
CodeQL is an analysis engine that automates security checks by running queries against a database generated from your codebase.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/">Code Scanning C++ with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Last year, GitHub <a href="https://github.blog/2020-09-30-code-scanning-is-now-available/">released code scanning</a>, which enables developers to incorporate security checks into their CI/CD environment and developer workflow. This post demonstrates the basics of using CodeQL, the analysis engine behind code scanning, with GitHub Actions.</p>
<h1 id="what-is-codeql">What is CodeQL?</h1>
<p><a href="https://codeql.github.com/docs/codeql-overview/">CodeQL</a> is an analysis engine that automates security checks by running queries against a database generated from your codebase. This CodeQL database is created during the build process and represents the source code in relational form. By default, code scanning runs standard CodeQL queries written by GitHub researchers and the community, but you can also author your own custom queries.</p>
<p>The default set includes queries such as “Pointer overflow check”, “Potentially overflowing call to snprintf”, “Uncontrolled format string”, and more.</p>
<p>&nbsp;</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.jpg"><img class="alignnone size-full wp-image-28274" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.jpg" alt="Image Capture" width="2366" height="1274" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.jpg 2366w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-300x162.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-1024x551.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-768x414.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-1536x827.jpg 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture-2048x1103.jpg 2048w" sizes="(max-width: 2366px) 100vw, 2366px" /></a></p>
<h1 id="setting-up-codeql-with-github-actions">Setting up CodeQL with GitHub Actions</h1>
<p>Code scanning with CodeQL is free for public repositories, and is part of GitHub Advanced Security for GitHub Enterprise. Here are instructions for the quick, <a href="https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/setting-up-code-scanning-for-a-repository">4-click setup process</a>. Alternatively, I’ve included a gif of the steps below:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/codeqlsetup.gif"><img class="alignnone size-full wp-image-28267" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/codeqlsetup.gif" alt="Image codeqlsetup" width="2080" height="1342" /></a></p>
<p>And just like that, you’re off to the races! The default CodeQL analysis workflow is configured to analyze your code each time you push a chance or raise a pull request against the default branch. This means code scanning automatically happened after I committed the new file directly to the main branch.</p>
<p>You can <a href="https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/setting-up-code-scanning-for-a-repository#viewing-the-logging-output-from-code-scanning">view the logging output</a> of the scan under the Actions tab, and you can <a href="https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/managing-code-scanning-alerts-for-your-repository">view/manage any code scanning alerts</a> under the Security tab.</p>
<h1 id="baselining">Baselining</h1>
<p>Sometimes, especially for large legacy codebases, the number of alerts can be overwhelming. For that reason, CodeQL only shows new/fixed alerts in pull requests. If you want to manage existing alerts, you can do so in the “Code scanning alerts” section under the “Security” tab.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-scaled.jpg"><img class="alignnone size-full wp-image-28275" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-scaled.jpg" alt="Image Capture2" width="2500" height="1138" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-scaled.jpg 2500w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-300x137.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-1024x466.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-768x350.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-1536x699.jpg 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture2-2048x932.jpg 2048w" sizes="(max-width: 2500px) 100vw, 2500px" /></a></p>
<p>It’s important to understand the distinction between <em>Dismiss </em>and <em>Delete</em>. One key distinction is that by <em>Dismissing </em>an alert, the same code won’t regenerate the alert. By <em>Deleting</em> an alert, the same code will generate the same alert the next time it is scanned. In the case that you want to bulk-dismiss alerts, you can do this from the summary of alerts (after filtering the list to whatever set of alerts you’d like to dismiss).</p>
<h1 id="feedback">Feedback</h1>
<p>This post just scratches the surface of code scanning in your CI/CD environment. Once you get the understand the basics, you may choose to author your own custom CodeQL queries or adjust the frequency of scanning. We hope you give code scanning with GitHub Actions a try, and we look forward to your feedback.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/">Code Scanning C++ with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Customized Warning Levels and Code Analysis for External Headers</title>
		<link>https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/</link>
					<comments>https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/#comments</comments>
		
		<dc:creator><![CDATA[Will Buik]]></dc:creator>
		<pubDate>Wed, 30 Jun 2021 16:17:45 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28162</guid>

					<description><![CDATA[<p>If you have tried to keep your code clean by selecting strict compiler warning levels or code analysis rulesets, you likely know how frustrating it can be to see these warnings for headers that are not part of your project. To alleviate this,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">Customized Warning Levels and Code Analysis for External Headers</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>If you have tried to keep your code clean by selecting strict compiler warning levels or code analysis rulesets, you likely know how frustrating it can be to see these warnings for headers that are not part of your project. To alleviate this, we’ve made it easy to mark headers as external to your project in the latest <a href="https://visualstudio.microsoft.com/vs/preview/">preview Visual Studio 2019</a>. This is something we have been working on for a while with help and feedback from the community. Some of you may remember our previous post, <a href="https://devblogs.microsoft.com/cppblog/broken-warnings-theory/">Broken Warnings Theory</a>, when we added experimental external header support to the Microsoft C++ Compiler. I’m happy to announce that, thanks to this feedback, external headers are now officially supported by the compiler, code analysis, and integrated into the IDE.</p>
<p>These external headers can have their own compiler warning level, code analysis, and template diagnostics settings. This leaves you free to choose stricter settings for your project’s code to enforce code quality without getting bogged down with warnings from headers that are beyond your control.</p>
<h2 id="adding-external-headers-to-your-projects">Adding External Headers to Your Projects</h2>
<p>You can find a new “External Include Directories” property for your projects under “VC++ Directories” which can be used to designate any include directory as containing external headers. This external include directory will be added to the include search path as normal, but every header that in that directory or a subdirectory of it will be treated as external. From a compilation standpoint, you won’t notice any differences, but you can choose a different set of warning levels and other analysis settings for headers in these directories.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated.png"><img class="size-full wp-image-28164 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated.png" alt="Specify “External Include Directories” in the project properties “VC++ Directories” tab." width="786" height="544" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated.png 786w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/VCpp-Directories-External-Includes-Annotated-768x532.png 768w" sizes="(max-width: 786px) 100vw, 786px" /></a></p>
<p>By default, all headers from the toolset and the Windows SDK are included as external headers. However, you can add any other include directories (such as 3<sup>rd</sup> party libraries) to this new property, separated by a semicolon as well.</p>
<p>Keep in mind that this new property will be ignored by earlier versions of the toolset. If you want to ensure that the project builds properly with earlier versions, you will need to make sure that any “External Include Directories” are also listed in the “Include Directories” property or they will not be found by the compiler. In Visual Studio 2019, we will continue to also include the toolset and Windows SDK headers in the existing “Include Directories” property for backwards compatibility, but in the next major release of Visual Studio this will be removed.</p>
<h2 id="customizing-warning-levels-external-headers">Customizing Warning Levels External Headers</h2>
<p>You can customize the way external headers are treated in the project properties “C/C++ &gt; External Includes” tab.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes.png"><img class="size-full wp-image-28165 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes.png" alt="Set the warning level, code analysis, and other settings for external header in the project properties “C/C++ &gt; External Includes” tab." width="786" height="544" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes.png 786w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Cpp-Settings-External-Inlcudes-768x532.png 768w" sizes="(max-width: 786px) 100vw, 786px" /></a></p>
<h2 id="customizing-code-analysis-settings-for-external-headers">Customizing Code Analysis Settings for External Headers</h2>
<p>Being able to mark certain headers as external to the project will make Code Analysis much easier to use. The examples below show some of the ways you can leverage this new feature to get the most out of Code Analysis.</p>
<h3 id="migration-from-undocumented-caexcludepath-to-external-and-analyzeexternal-options">Migration from undocumented CAExcludePath to /external:* and /analyze:external* options</h3>
<p>To support one of the most common requirements of suppressing code analysis warnings for defects in library headers over which developers have no control, we created a temporary solution to use a special environment variable (“CAExcludePath”), that can be used to specify directories for which code analysis will not report any warnings.</p>
<p>We now have a better solution to control code analysis behavior for external files. While we decided to leave “CAExcludePath” option as is, we strongly recommend to switch to the /external:* and /analyze:external* options. With these options, code analysis of external headers can be turned off, or use a separate ruleset from the rest of the codebase. These come with even better usability and maintainability as they are all available through the VS IDE.</p>
<h3 id="using-analyzeexternal-with-external">Using /analyze:external- with /external:*</h3>
<p>Consider the following header and source files, with no meaningful functionality but intentionally injected bugs:</p>
<p><strong>Header File (externallib.h)</strong></p>
<pre class="prettyprint">#pragma once
 
#include &lt;Windows.h&gt;
 
#pragma warning (disable:26440 26497)
namespace ExternalLib
{
#pragma warning(disable:4700)
    int GetValue()
    {
        int arr[2];
        return arr[2];
    }
 
    template &lt;typename T&gt;
    T GetValue(T, _In_range_(0, sizeof(T) - 1) int)
    {
        T arr[4];
        return arr[sizeof(T)];
    };
}</pre>
<p><strong>Source File (MyApp1.cpp)</strong></p>
<pre class="prettyprint">#include &lt;externallib.h&gt;
 
using namespace ExternalLib;
 
void foo()
{
    auto sum = GetValue(3ll, 4);
    sum += GetValue(3, 3);
    sum += GetValue(L'a', 2);
    sum += GetValue('a', 1);
}</pre>
<p>When analyzed with default options we get code analysis warnings for functions from both the header file and source file:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External.png"><img class="size-full wp-image-28167 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External.png" alt="Errors without /External" width="1081" height="369" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External.png 1081w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External-300x102.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External-1024x350.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/1-Errors-without-External-768x262.png 768w" sizes="(max-width: 1081px) 100vw, 1081px" /></a></p>
<p>Now, if we add the directory for the externallib.h to the “External Include Directories” as follows:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External.png"><img class="size-full wp-image-28168 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External.png" alt="Add Include to External" width="750" height="519" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External.png 750w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/2-Add-Include-to-External-300x208.png 300w" sizes="(max-width: 750px) 100vw, 750px" /></a></p>
<p>And then set the “Disable Code Analysis for External Headers” to “Yes (/analyze:external-)” as follows:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External.png"><img class="size-full wp-image-28169 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External.png" alt="Disable Code Analysis for External" width="750" height="522" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External.png 750w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/3-Disable-Code-Analysis-for-External-300x209.png 300w" sizes="(max-width: 750px) 100vw, 750px" /></a></p>
<p>Executing “Run Code Analysis” will no longer report any Code Analysis warnings from the external header file:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only.png"><img class="size-full wp-image-28170 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only.png" alt="Errors from Source File Only" width="1100" height="144" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only.png 1100w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only-300x39.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only-1024x134.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/4-Internal-Errors-Only-768x101.png 768w" sizes="(max-width: 1100px) 100vw, 1100px" /></a></p>
<p>Some templates may have bugs depending on the template arguments. If you want to analyze templates even if they are in the external files, you can set the “Template Diagnostics in External Headers” option to “Yes (/external:templates-)”. Now, executing “Run Code Analysis” will report Code Analysis warnings for the template functions even if they are in the external header file:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors.png"><img class="size-full wp-image-28171 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors.png" alt="Errors from External Templates" width="1103" height="234" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors.png 1103w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors-300x64.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors-1024x217.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/5-Template-Errors-768x163.png 768w" sizes="(max-width: 1103px) 100vw, 1103px" /></a></p>
<h3 id="using-analyzeexternalruleset-with-external">Using /analyze:external:ruleset with /external:*</h3>
<p>Instead of turning off code analysis for external files, it is now possible to analyze external files with a different ruleset from the rest of the codebase by specifying a different ruleset file with the “Analysis Ruleset for External Headers” option.</p>
<p>For this example, I have created a custom ruleset “ExternalHeaderRules” that enables only two rules, C6021 and C6385, as warnings. Then I selected it for the “Analysis Ruleset for External Headers” option:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset.png"><img class="size-full wp-image-28172 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset.png" alt="Custom Ruleset for External Headers" width="750" height="522" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset.png 750w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/6-Custom-Ruleset-300x209.png 300w" sizes="(max-width: 750px) 100vw, 750px" /></a></p>
<p>Please note that the “Disable Code Analysis for External Headers” option is set to “No”, enabling code analysis on the external headers. With this change, code analysis will now analyze functions from external files using the custom “ExternalHeaderRules” ruleset, and report following warnings:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors.png"><img class="size-full wp-image-28173 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors.png" alt="Errors from Custom Ruleset" width="1097" height="226" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors.png 1097w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors-300x62.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors-1024x211.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/7-Custom-Ruleset-Errors-768x158.png 768w" sizes="(max-width: 1097px) 100vw, 1097px" /></a></p>
<p>Currently, the &#8220;Template Diagnostics in External Headers” option is ignored if “Analysis Ruleset for External Headers” is used. We plan to change the behavior to honor the option and treat templates as non-external and apply the general ruleset instead of the ruleset for external headers.</p>
<h3 id="bonus-even-better-code-analysis-performance">Bonus: Even Better Code Analysis Performance</h3>
<p>While we were working on this feature, we realized some of the built-in checkers were not really skipping functions from the files that are excluded through “CAExcludePath” environment variable. Instead, they were analyzed just like others and the resultant warnings from those functions were simply filtered out. As we add support for the /external:* option, we updated them to honor “CAExcludePath” as well as /external:* and /analyze:external- options, and to skip analysis of functions from excluded or external files. This resulted in observed performance improvements in our production codebase, ranging from 25% to 30%. Actual performance improvements will vary depending on how much of the codebase is from excluded or external header files, and how much of the project uses PCH, etc.</p>
<h2 id="external-headers-and-the-microsoft-c-compiler">External Headers and the Microsoft C++ Compiler</h2>
<p>Several new flags have been added to the Microsoft C++ Compiler to specify external include directories and their warning and code analysis settings. You can learn more about the behavior of these flags on our <a href="https://docs.microsoft.com/en-us/cpp/build/reference/external-external-headers-diagnostics?view=msvc-160">compiler documentation pages</a>.</p>
<h2 id="send-us-feedback">Send Us Feedback</h2>
<p>Please grab a copy of the <a href="https://visualstudio.microsoft.com/downloads/">latest Visual Studio 2019 preview</a> and try it out. We would love to hear your feedback about Visual Studio. If you have feedback, suggestions, or any other comments please submit them to <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/">Customized Warning Levels and Code Analysis for External Headers</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/customized-warning-levels-and-code-analysis-for-external-headers/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>STL Visualizers on GitHub</title>
		<link>https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/</link>
					<comments>https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/#comments</comments>
		
		<dc:creator><![CDATA[Anju Del Moral Gonzalez]]></dc:creator>
		<pubDate>Wed, 23 Jun 2021 15:06:37 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28219</guid>

					<description><![CDATA[<p>We are happy to announce that now it’s possible to contribute to the STL Visualizers for Visual Studio&#8217;s debugger on GitHub.<br />
A visualizer is a file with .natvis extension that allows you to manipulate the way native types appear in the debugger&#8217;s watch window. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/">STL Visualizers on GitHub</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">We are happy to announce that now it’s possible to contribute to the STL Visualizers for Visual Studio&#8217;s debugger on <a href="https://github.com/microsoft/STL/blob/main/stl/debugger/STL.natvis">GitHub</a>.</span></p>
<p><span data-contrast="auto">A visualizer is a file with .natvis extension that allows you to manipulate the way native types appear in the debugger&#8217;s watch window.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><img class="aligncenter wp-image-28229" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/watch-simpleview.png" alt="A visualisation for vectors of ints" width="271" height="282" /></p>
<p><span data-contrast="auto">We&#8217;ve been working on fixing existing issues with the visualizers and augmenting them, but with C++20 coming with new types, they have been falling behind. We decided to open source them so that the community can benefit and collaborate.</span></p>
<p>&nbsp;</p>
<h1 id="whats-available"><span data-contrast="auto">What’s Available? </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">The file is now in the GitHub repo under </span><a href="https://github.com/microsoft/STL/blob/main/stl/debugger/STL.natvis"><span data-contrast="none">stl\debugger\STL.natvis</span></a><span data-contrast="auto">. We also have available documentation for the .natvis file format </span><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2019"><span data-contrast="none">here</span></a><span data-contrast="auto">. All changes made on GitHub will be ported to Visual Studio.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">This has been up already for a couple of weeks and we are happy to see that there are already contributors helping in this new area. We would like to thank AdamBucior, statementreply, SuperWig and joemmett. Some of the PRs add visualizers to coroutines, chrono, ranges, the spaceship operator, source location, span, and more. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}">  </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> <a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/112188892-57bd2d80-8bfb-11eb-9044-66bca3e1b2b0.png"><img class="aligncenter wp-image-28228" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/112188892-57bd2d80-8bfb-11eb-9044-66bca3e1b2b0.png" alt="Visualisation of various chrono types" width="743" height="368" /></a></span></p>
<p>&nbsp;</p>
<h1 id="contribute-now"><span data-contrast="auto">Contribute now!</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">We are happy with the results of this change, and we would like to see more. After you make changes to the visualizer you can test them by adding the natvis file to any Visual Studio C++ project by right clicking your project, selecting Add &gt; Existing Item, and choosing the STL.natvis file. After doing this you should be able to see your changes in a Visual Studio debugging session. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.png"><img class="aligncenter wp-image-28227" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Capture.png" alt="Selecting the STL.natvis file" width="257" height="189" /></a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/">STL Visualizers on GitHub</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/stl-visualizers-on-github/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>Address Sanitizer Now in “Early Release” for Xbox Developers</title>
		<link>https://devblogs.microsoft.com/cppblog/address-sanitizer-now-in-early-release-for-xbox-developers/</link>
					<comments>https://devblogs.microsoft.com/cppblog/address-sanitizer-now-in-early-release-for-xbox-developers/#respond</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Tue, 22 Jun 2021 17:29:43 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[address sanitizer]]></category>
		<category><![CDATA[debugging]]></category>
		<category><![CDATA[dump]]></category>
		<category><![CDATA[memory]]></category>
		<category><![CDATA[xbox]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28236</guid>

					<description><![CDATA[<p>The following blog post is authored by Tad Swift, a Principal Software Engineer on the Xbox Advanced Technology Group (ATG).<br />
Introduction<br />
Address Sanitizer (ASan) is a valuable tool for lighting up hard-to-find memory bugs. Since the MSVC release in Visual Studio version 16.9,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/address-sanitizer-now-in-early-release-for-xbox-developers/">Address Sanitizer Now in “Early Release” for Xbox Developers</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Xbox_2020_horz_Grn_RGB.png"><img class="aligncenter size-full wp-image-28237" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Xbox_2020_horz_Grn_RGB.png" alt="Image Xbox 2020 horz Grn RGB" width="1659" height="793" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Xbox_2020_horz_Grn_RGB.png 1659w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Xbox_2020_horz_Grn_RGB-300x143.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Xbox_2020_horz_Grn_RGB-1024x489.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Xbox_2020_horz_Grn_RGB-768x367.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/Xbox_2020_horz_Grn_RGB-1536x734.png 1536w" sizes="(max-width: 1659px) 100vw, 1659px" /></a></p>
<p><strong>The following blog post is authored by Tad Swift, a Principal Software Engineer on the Xbox Advanced Technology Group (ATG). </strong></p>
<h1 id="introduction">Introduction</h1>
<p><strong>Address Sanitizer</strong> (<a href="https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-windows-with-msvc/">ASan</a>) is a valuable tool for lighting up hard-to-find memory bugs. Since the MSVC release in <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/">Visual Studio version 16.9</a>, we&#8217;ve been working with our partners to bring ASan to the Xbox platform.</p>
<p>With the recent release of the June Xbox GDK, we are happy to announce Address Sanitizer is available in <em>&#8220;early release&#8221;</em> form.</p>
<p>In this blog post, we will showcase how to get ASan working with the Xbox platform.</p>
<h1 id="building-with-address-sanitizer">Building with Address Sanitizer</h1>
<p>Setting up an Xbox project for ASan should follow the same guidelines as the PC version, with the Address Sanitizer being integrated into the usual Visual Studio debugging experience. However, there are some specific use-cases for Xbox developers that were not supported by default under ASan.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example.png"><img class="aligncenter size-full wp-image-27733" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example.png" alt="Image ASan example" width="1428" height="949" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example.png 1428w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example-300x199.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example-1024x681.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example-768x510.png 768w" sizes="(max-width: 1428px) 100vw, 1428px" /></a></p>
<p>Modern games consist of highly complicated, multi-threaded code whose goal is to run as fast as possible while holding a target frame rate. This means that the code is tested frequently through development by means of an automated build and test setup. These server machines may build the code, deploy it to a console, and run the game without a debugger connection meaning that they might miss any ASan error reports shown in the debug output. Ideally, the test server could collect crash dumps from any Asan errors, but due to differences in the Xbox GDK, extra steps must be taken to extract Address Sanitizer crash dump information from automated runs.</p>
<h1 id="enhanced-debugger-support">Enhanced Debugger Support</h1>
<p><a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan-offline-crash-dumps?view=msvc-160">MSVC’s ASan implementation</a> can create a crash dump with detailed exception information, but this could only be enabled from an environment variable which isn’t supported on Xbox. To get crash dumps on Xbox, developers must specify a function in their code to supply the dump filename.</p>
<p>Here are two examples of what the function looks like:</p>
<pre class="prettyprint">extern "C" const wchar_t* __vcasan_save_dumps()
{
    return L"myCrashDump.dmp";
}</pre>
<pre class="prettyprint">extern "C" const WCHAR* __vcasan_save_dumps()
{
    // Choose to create a crash dump based on a runtime flag
    if ( gCollectCrashDumps )
    {
        return L"myCrashDump.dmp";
    }
    else
    {
        // Returning NULL stops ASan creating a crash dump
        return NULL;
    };
}
</pre>
<p>There are no specific requirements around the name returned by this function, but it must be a valid filepath on the target device where the code is being run.</p>
<p>Now that we can support crash dumps on Xbox, we also decided to give developers more flexibility around the type of crash dump that is produced. There are instances where a simple “Triage” dump is sufficient to see the callstack of where the process failed, but within games, there is usually the requirements to see more of the surrounding memory when the issue occurred. To this end, we have provided three configurable crash dump types that are supported by the Xbox platform and match the crash dumps developers expect from their Xbox consoles.</p>
<p><strong><em><u>Note:</u></em></strong> As with the previous function, this override is <strong><em>optional</em></strong> on Xbox, but it is highly recommended if you want to use crash dumps to collect ASan information without a debugger attached.  If you provide the dump filename but <strong><em>not</em></strong> a dumptype override, then it will fail to generate a valid crash dump on Xbox.</p>
<p>This callback returns a number to indicate the dump type required. Valid types are shown in the example below:</p>
<pre class="prettyprint">extern "C" const signed int __vcasan_override_dumptype()
{
    // The current valid values are:
    // 0 : Triage Dump
    // 1 : Mini Dump
    // 2 : Heap Dump
    // Values outside this range are defaulted to 2 (Full Heap)

    // This example uses Heap Dumps which give the most information
    return 2;
}
</pre>
<p>Both callback functions are available as part of 16.9.8, 16.10.2 or a future 16.11 preview release of Visual Studio.</p>
<h1 id="example-code">Example code</h1>
<p>This code demonstrates how easily these functions can be added into an existing codebase and adapted as required:</p>
<pre class="prettyprint">#include &lt;cstdio&gt;
 
extern "C" const wchar_t* __vcasan_save_dumps()
{
    // Specify dump filename
    return L"myCrashDump.dmp";
}
 
extern "C" const signed int __vcasan_override_dumptype()
{
    // Full Heap dump requested
    return 2;
}
 
static const int arraySize = 8;
static int asanArray[arraySize];
static int asanAccumulator = 0;
 
int main()
{
    // ASan should use the callback functions that we have provided
    for (int loop = 0; loop &lt;= arraySize; loop++)
    {
        // We don’t really care about accumulating the values
        // We just want to access outside the array causing an ASan error
        asanAccumulator += asanArray[loop];
    }
 
    // If we get here, we have failed as ASAN should have caught the error above
    printf("fail");
 
    return 0;
}
</pre>
<p>Compile the code via this command line:</p>
<pre class="prettyprint">cl /nologo /fsanitize=address /Zi AsanTest.cpp</pre>
<p>This code, when run should throw an ASan exception and produce a crash dump as specified by our functions above. You can integrate these functions into existing code and generate crash dumps of your choosing.</p>
<h1 id="summary">Summary<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/XBOXecoVS65.jpg"><img class="aligncenter size-full wp-image-28247" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/XBOXecoVS65.jpg" alt="Xbox Eco System " width="1920" height="1080" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/XBOXecoVS65.jpg 1920w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/XBOXecoVS65-300x169.jpg 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/XBOXecoVS65-1024x576.jpg 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/XBOXecoVS65-768x432.jpg 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/06/XBOXecoVS65-1536x864.jpg 1536w" sizes="(max-width: 1920px) 100vw, 1920px" /></a></h1>
<p>With Address Sanitizer now being available on Xbox, developers can leverage this powerful technology to help debug memory issues in their titles.  Combined with the crash dump changes detailed here, it should provide all the flexibility required to support your automated tests suites and enable you to find issues quickly and easily.  We welcome any feedback on these changes and would ask you to raise any issues through the Xbox forums in the usual way.</p>
<p>Further references for more information:</p>
<ul>
<li>Detailed information regarding the setup and available options in the Microsoft documentation: <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-160">Address Sanitizer | Microsoft Docs</a></li>
<li>Discussion around where this technology has been useful: <a href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/">Finding Bugs with AddressSanitizer: Patterns from Open Source Projects</a></li>
</ul>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/address-sanitizer-now-in-early-release-for-xbox-developers/">Address Sanitizer Now in “Early Release” for Xbox Developers</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/address-sanitizer-now-in-early-release-for-xbox-developers/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 version 16.10</title>
		<link>https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-version-16-10/</link>
		
		<dc:creator><![CDATA[Jordan Maples]]></dc:creator>
		<pubDate>Thu, 10 Jun 2021 16:00:10 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[cppcorecheck]]></category>
		<category><![CDATA[static analysis]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28184</guid>

					<description><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the  C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-version-16-10/">Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team is committed to making your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the  <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">C++ Developer Community</a> page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Below is the compilation of improvements and bug fixes that were made from Visual Studio 2019 versions 16.9 to 16.10 for <a href="https://docs.microsoft.com/en-us/cpp/build/reference/analyze-code-analysis">code analysis</a> and <a href="https://docs.microsoft.com/en-us/cpp/code-quality/using-the-cpp-core-guidelines-checkers">CppCoreCheck</a>.</p>
<h2 id="new-features">New features:</h2>
<ul>
<li><a href="https://aka.ms/cpp/warnings/C26479">C26479</a> is a new warning that supports <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f48-dont-return-stdmovelocal">F.48</a>, don’t return a local variable with <code>std::move</code>.</li>
<li><a href="https://aka.ms/cpp/warnings/C26458">C26458</a> is a new warning that serves as a path-sensitive version of <a href="https://aka.ms/cpp/warnings/C26446">C26446</a>. C26458 had a dedicated blog post in mid-May. In case you missed it, you can read more about the new warning <a href="https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/">here</a>.</li>
<li><a href="https://aka.ms/cpp/warnings/C26800">C26800</a>, which is used to detect if a variable is used after it has been moved from, is no longer an experimental rule and is now a part of the default rule set.</li>
<li>The lifetime warnings <a href="https://aka.ms/cpp/warnings/C26810">C26810</a> and <a href="https://aka.ms/cpp/warnings/C26811">C26811</a>, originally introduced in 16.2 and discussed <a href="https://devblogs.microsoft.com/cppblog/new-code-analysis-checks-in-visual-studio-2019-use-after-move-and-coroutine/">here</a>, are no longer experimental and can be used by selecting the default ruleset or <code>“CppCoreCheckLifetimeRules”</code>.</li>
<li>Sarif suppression properties will only be populated when <code>/analyze:log:includesuppressed</code> is specified. This can be useful for auditing the rules that are suppressed in a codebase.</li>
</ul>
<h2 id="analysis-crash-fixes">Analysis crash fixes:</h2>
<ul>
<li>Fixed a crash in the analysis engine caused by an empty brace initializer in an initializer list.</li>
</ul>
<pre class="prettyprint">struct TestStruct {
public:
    enum TestEnum : char { Dummy };

    TestEnum m1 : 1;
    TestEnum m2 : 1;
    short m3;
};

TestStruct Test2()
{
    return{ TestStruct::Dummy, TestStruct::Dummy, {} };
}</pre>
<ul>
<li>Fixed analysis engine crash when using the drivers plugin from the WDK.</li>
</ul>
<h2 id="bug-fixes-and-optimizations">Bug fixes and optimizations:</h2>
<ul>
<li><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual">C.35</a> no longer is issued on functions marked override in classes that are marked <code>final</code>.</li>
<li>The message string for <a href="https://aka.ms/cpp/warnings/C26434">C26434</a> has been updated to remove the reference to <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final">C.128</a>. This warning does not align to C.128 but is still a helpful warning to prevent hiding member functions.</li>
<li>Fix false negative for <a href="https://aka.ms/cpp/warnings/C26414">C26414</a> for some unique pointers returned from <code>std::make_unique</code> where no arguments are passed to <code>std::make_unique</code></li>
</ul>
<pre class="prettyprint">#include &lt;memory&gt;
struct struct_1
{
    void method_1();
};
void c26414()
{
    auto ptr = std::make_unique&lt;struct_1&gt;(); //now issues C26414
    ptr-&gt;method_1();
}</pre>
<ul>
<li><a href="https://aka.ms/cpp/warnings/C26800">C26800</a> – Use of a moved from object.
<ul>
<li>Prevent analysis in function bodies where called functions do not have rvalue reference parameters.</li>
<li>Fixed false positive that appeared when using coroutines.</li>
</ul>
</li>
<li>Improved the detection of <a href="https://aka.ms/cpp/warnings/C26812">C26812</a>, “prefer <code>enum class</code> over <code>enum</code>”</li>
<li>Fixed false positive for <a href="https://aka.ms/cpp/warnings/C6285">C6285</a> and <a href="https://aka.ms/cpp/warnings/C6237">C6237</a> when code contains <code>if constexpr</code>.</li>
</ul>
<pre class="prettyprint">constexpr void f1()
{
    constexpr int val1 = false;
    constexpr int val2 = false;
    if constexpr (val1 == true || val2 == true)
    {
        //...
    }
    if (val1 == true || val2 == true) // C6285
    {
        //...
    }
}

constexpr bool foo()
{
    return false;
}
constexpr bool bar()
{
    return true;
}
constexpr void f2()
{
    constexpr bool fooVal = foo();
    if constexpr (fooVal &amp;&amp; bar())
    {
        //...
    }
    if (fooVal &amp;&amp; bar()) //C6237
    {
        //...
    }
}</pre>
<ul>
<li>Improvements for the coroutine checks:
<ul>
<li>Fixed problem that caused warnings to be issued against an incorrect line.</li>
<li>Improved detection for cases using rvalue references.</li>
<li>Fixed a false positive in code using <code>std::suspend_never</code></li>
</ul>
</li>
<li>Fixed false positive in local lifetime check caused by use of <code>std::optional</code></li>
</ul>
<pre class="prettyprint">void assignToReferenceArg( std::optional&lt;double&gt;&amp; x )
{
    x = 1.0; // Used to produce false positive
}</pre>
<ul>
<li>Fixed bounds warning for code in <code>if constexpr</code> block.</li>
</ul>
<pre class="prettyprint">constexpr void test_constexpr()
{
    int arr[] = {1,2,3};
    constexpr int index = -1;

    if constexpr (index != -1)
    {
        arr[index]; //No C6201
    }

    if constexpr (index == -1)
    {
        arr[index]; //C6201
    }
}</pre>
<ul>
<li>Fixed analysis failure for file paths that contained non-ASCII characters.</li>
<li>General improvements to the <code>uninit</code> check. See this <a href="https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/">post</a> for more information on how this
affects analysis.</li>
</ul>
<h2 id="try-it-out-and-let-us-know-what-you-think">Try it out and let us know what you think:</h2>
<p>The work that we do is heavily influenced by feedback we receive on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check. Stay tuned for more C++ static analysis blogs. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-version-16-10/">Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>&#060;format&#062; in Visual Studio 2019 version 16.10</title>
		<link>https://devblogs.microsoft.com/cppblog/format-in-visual-studio-2019-version-16-10/</link>
					<comments>https://devblogs.microsoft.com/cppblog/format-in-visual-studio-2019-version-16-10/#comments</comments>
		
		<dc:creator><![CDATA[Charlie Barto]]></dc:creator>
		<pubDate>Wed, 09 Jun 2021 16:00:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28122</guid>

					<description><![CDATA[<p>C++20 adds a new text formatting facility to the standard library, designed primarily to replace snprintf and friends with a fast and type safe interface. The standardized library is based on the existing {fmt} library, so users of that library will feel at home.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/format-in-visual-studio-2019-version-16-10/">&lt;format&gt; in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>C++20 adds a new text formatting facility to the standard library, designed primarily to replace <code>snprintf</code> and friends with a fast and type safe interface. The standardized library is based on the existing <a href="https://github.com/fmtlib/fmt">{fmt}</a> library, so users of that library will feel at home.</p>
<p>Before diving into how <code>std::format</code> works I want to thank Victor Zverovich, Elnar Dakeshov, Casey Carter, and miscco, all of whom made <a href="https://github.com/microsoft/STL/pulls?q=is:pr+label:format+">substantial contributions</a> to this feature, and were the reason why we could complete it so quickly.</p>
<h2 id="overview">Overview</h2>
<p>To start using <code>&lt;format&gt;</code> you just need to be using Visual Studio 2019 version 16.10 or later and you need to be compiling with <code>/std:c++latest</code>. You can get the latest Visual Studio preview <a href="https://visualstudio.microsoft.com/vs/preview/">here</a>.</p>
<p>The simplest and most common way to use <code>&lt;format&gt;</code> is to call:</p>
<pre class="prettyprint">template&lt;class... Args&gt;
string format(string_view fmt, const Args&amp;... args);</pre>
<p><code>fmt</code> is the format-string and <code>args</code> are the things you’d like to format. The format string consists of some text interspersed with curly brace delimited replacement fields. For example: <code>"Format arguments: {} {}!"</code> is a format string for formatting two arguments. Each replacement field corresponds to the next argument passed. So <code>std::format("Format arguments {} {}!", 2, 1)</code> would produce the string <code>"Format arguments 2 1!"</code></p>
<p>Format strings can also contain numbered replacement fields, for example <code>"Format arguments {1} {0}!"</code>. These refer to the numbered argument passed in, starting from zero. Numbered and un-numbered (automatic) replacement fields can not be mixed in the same format string.</p>
<p>There are all sorts of modifiers you can use to change the way a particular parameter is formatted. These are called “format specifiers” and are specified in the replacement field like so: <code>std::format("{:&lt;specifiers&gt;}", &lt;arg&gt;)</code>. Let’s look at an example that has one of everything.</p>
<pre class="prettyprint"><code>std::format("{:&#x1f431;^+#12.4La}", 4.f);</code></pre>
<p>This returns the string <code>“&#x1f431;+1.0000p+2&#x1f431;”</code> (printing this string out to the console on Windows can be a bit difficult). Let’s go through what each component of the above string told <code>std::format</code> to do. First we have<code> “&#x1f431;^”</code> the “fill and align” part of the format specifiers, saying we’d like our output center aligned and padded with cat emojis. Next we have <code>“+”</code>, meaning we’d like a sign character no matter what (the default is <code>“-”</code> to only print the<code> “-”</code> sign for negatives, and you can also use a space to ask for a minus sign or a space). After that we specify <code>“#”</code>, meaning “alternate form”. For floats the alternate form causes format to always insert a decimal point. Next we specify <code>“12.4”</code> to get a width of 12 and a precision of 4. That means format will use the “fill” and “alignment” settings to make sure our output is at least 12 characters wide and the float itself will be printed to 4 digits of precision. Next the <code>“L”</code> specifier causes format to use locale specific formatting to print things like decimal separators. Finally <code>“a”</code> causes the output to be in hexfloat format. More detailed information about the possible format specifications can be found at <a href="https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification">cppreference</a>.</p>
<p>For width and precision specifiers you may reference a format argument instead of using a literal value like so:</p>
<pre class="prettyprint">std::format("{0:{1}.{2}}", 4.2f, 4, 5);</pre>
<p>This results in a width of 4 and a precision of 5. The rules for mixing automatic and manual indexing (don’t do it) still apply, but you can use automatic indexing to reference width and precision as in:</p>
<pre class="prettyprint">std::format("{:{}.{}}", 4.2f, 4, 5);</pre>
<p>The assignment of automatic indices is performed left to right, so the above two examples are equivalent.</p>
<h2 id="performance">Performance</h2>
<p>In general <code>std::format</code> performance should be in the same ballpark as <code>fmt::format</code> and <code>snprintf</code> if you compile your code with the <code>/utf-8</code> <a href="https://docs.microsoft.com/en-us/cpp/build/reference/utf-8-set-source-and-executable-character-sets-to-utf-8?view=msvc-160"> </a>. If you don’t use the <code>/utf-8</code> option then performance can be significantly degraded because we need to retrieve your system locale to correctly parse the format string. While we’re working to improve performance for this case in a future release we recommend you use <code>/utf-8</code> for the best experience.</p>
<h2 id="unicode">Unicode</h2>
<p><code>std::format</code> doesn’t do any transcoding between different text encodings, however it is aware of the “execution character set” and uses it to interpret the format string. The versions of <code>std::format</code> taking a wide (<code>wchar_t</code>) format string are <em>always</em> interpreted as UTF-16. The versions of <code>std::format</code> taking a narrow (char) format string interpret the format string as UTF-8 if we detect the<code> /utf-8</code> (or <code>/execution-charset:utf-8</code>) option. Otherwise we interpret the format string as being encoded in the active system codepage. This means that if you compile your code with a non-UTF-8 execution charset it may not run correctly on systems with a different system codepage setting. There’s also a <em>significant</em> performance cost to figuring out the system codepage, so for best performance we recommend you compile with<code> /utf-8</code>. We’re working to improve the performance of format in non-UTF execution character sets in future releases.</p>
<p>Unicode also comes into play when dealing with width and precision specification for strings. When we interpret the format string as UTF-8 or UTF-16 we compute the “estimated width” of a string taking into account a rough estimate of the size of each code-point. If we’re interpreting the format string as a non-Unicode encoding we just estimate the width as the number of code units (not code points) in the string. In a future release we’ll add grapheme clusterization to the width computations for Unicode encodings.</p>
<h2 id="locales">Locales</h2>
<p>While we always parse the <em>format string</em> according to the rules above, the locale used for things like decimal separator positions can be customized. By default no locale is used. If you use the <code>L</code> specifier then some locale specific formatting may be used. By default it’s the current global locale as returned by a default constructed <code>std::locale</code>, however each formatting function has a version allowing you to pass in your own <code>std::locale</code> object to override that behavior.</p>
<h2 id="future-work">Future work</h2>
<p>Over the next few Visual Studio releases we’ll be improving the performance of <code>std::format</code>, and fixing bugs. Additionally C++23 will likely add compile time format checking to format literals and we may implement that before 2023 (for code you want to work great in C++23 don’t rely on catching <code>std::format_errors</code> from invalid format strings!). C++23 will also make a small change to the definitions of <code>std::vformat_to</code> and <code>std::format_to</code> that reduces code size but can be observable, for forward compatibility make sure any custom formatters work with all output iterators. More information on these changes can be found in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2216r3.html">p2216r3</a>. C++23 may also bring additional functionality like <code>std::print</code> and better ways to handle Unicode text.</p>
<h2 id="differences-from-fmt-not-exhaustive">Differences from {fmt} (not exhaustive)</h2>
<p>For those familiar with <code>{fmt}</code>, a quick list of differences from the standardized version of the library:</p>
<ul>
<li>Named arguments are not supported.</li>
<li>None of the miscellaneous formatting functions like <code>fmt::print</code> or <code>fmt::printf</code> are supported.</li>
<li>Format strings are not checked at compile time</li>
<li>There is no support for automatically formatting types with an <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const T&amp;)</code> overload</li>
<li>The behavior of some format specifiers is slightly different (for example the default alignment for <code>void*</code>, and allowing sign specifiers for unsigned types)</li>
</ul>
<h2 id="give-us-feedback">Give us feedback</h2>
<p>Try out format in your own code, and file any bugs on our <a href="https://github.com/microsoft/STL/issues">out GitHub issue tracker</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/format-in-visual-studio-2019-version-16-10/">&lt;format&gt; in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/format-in-visual-studio-2019-version-16-10/feed/</wfw:commentRss>
			<slash:comments>28</slash:comments>
		
		
			</item>
	</channel>
</rss>
