<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Thu, 06 May 2021 10:58:23 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Ignoring Automatic Initialization for Code Analysis</title>
		<link>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/</link>
					<comments>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/#respond</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Thu, 06 May 2021 15:00:15 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27927</guid>

					<description><![CDATA[<p>Reading uninitialized memory is one of the major sources of security vulnerabilities in C and C++ programs. Microsoft developed many tools to find such errors including compiler warnings, static analysis checks, and more recently: code instrumentation.  For a more detailed overview of uninitialized memory related vulnerabilities and mitigations please refer to Microsoft Security Response Center’s great blog post.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/">Ignoring Automatic Initialization for Code Analysis</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">Reading uninitialized memory is one of the major sources of security vulnerabilities in C and C++ programs. Microsoft developed many tools to find such errors including compiler warnings, static analysis checks, and more recently: code instrumentation.  For a more detailed overview of uninitialized memory related vulnerabilities and mitigations please refer to <a href="https://msrc-blog.microsoft.com/2020/05/13/solving-uninitialized-stack-memory-on-windows/">Microsoft Security Response Center’s great blog post</a></span><span data-contrast="auto">. This blog post summarizes the potential interactions between code analysis and code instrumentation and improvements we&#8217;ve made in Visual Studio 2019 version 16.9.1.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">When we turn on the automatic initialization features of MSVC it will initialize certain constructs on the stack with a pattern. This solution can help mitigate the risks of reading uninitialized memory. However, to keep the performance costs of this mitigation minimal, the compiler will not initialize everything. It is a best effort method that tries to hit a good balance in mitigating security risks and avoiding noticeable performance regressions. Moreover, this is a non-standard feature that might not be available (or might behave differently) in other compilers, or in other versions of the same compiler. As a result, users should never rely on such an instrumentation. The proper fix is to explicitly initialize memory in the source code and only use instrumentation as a mitigation for any error that slipped through the code reviews, static analysis or any other tools of the QA process.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">As a result, we want the compiler to warn on the following code regardless of the options used to compile the code:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint">void g(int); 
void f() { 
    int l; 
    g(l); // Warning C6001 expected regardless of the build configuration. 
}</pre>
<p><span data-contrast="auto">Starting from Visual Studio 2019 version 16.9.1, and 16.10 Preview 2 we ensured that the code analysis always sees the code as written as opposed to the instrumented version.  This behavior is in line with other toolchains and encourages developers to not rely on the automatic initialization feature.</span></p>
<p>Download the latest <a href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noopener">Visual Studio 2019 Preview</a> today and give it a try. We’d love to hear from you to help us prioritize and build the right features for you. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/spaces/8/index.html" target="_blank" rel="noopener">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>). The best way to file a bug or suggest a feature is via Developer Community.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/">Ignoring Automatic Initialization for Code Analysis</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Pure Virtual C++ 2021 is Today</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/</link>
					<comments>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Mon, 03 May 2021 09:41:17 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27954</guid>

					<description><![CDATA[<p>Pure Virtual C++, a free one-day virtual conference for the whole C++ community, is starting today (May 3rd) at 14:30 UTC. You can watch it and interact with the speakers at Learn TV. There&#8217;ll be sessions on C++20 modules, CMake, vcpkg,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/">Pure Virtual C++ 2021 is Today</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png"><img class="aligncenter size-full wp-image-27841" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png" alt="Image word image" width="1376" height="362" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w" sizes="(max-width: 1376px) 100vw, 1376px" /></a></p>
<p><a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event-2021/">Pure Virtual C++</a>, a free one-day virtual conference for the whole C++ community, is starting today (May 3rd) at 14:30 UTC. You can watch it and interact with the speakers at <a href="https://docs.microsoft.com/en-gb/learn/tv/">Learn TV</a>. There&#8217;ll be sessions on C++20 modules, CMake, vcpkg, and code analysis.</p>
<p>All of our pre-conference demos, including what&#8217;s new in C++20 support in MSVC, are now live on <a href="https://www.youtube.com/playlist?list=PLReL099Y5nRcWPNnKO4cwxN5RJZl9A48P">YouTube</a>.</p>
<p>Hope to see you there!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/">Pure Virtual C++ 2021 is Today</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-is-today/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Pure Virtual C++ 2021 Schedule Available</title>
		<link>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 20 Apr 2021 18:03:44 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27919</guid>

					<description><![CDATA[<p>The schedule for Pure Virtual C++ 2021 is now live on the event website. Remember to sign up to be the first to access our extra on-demand C++ demos and get more virtual surprises.<br />
Schedule<br />
All times are on Monday 3rd May 2021 UTC.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/">Pure Virtual C++ 2021 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The schedule for Pure Virtual C++ 2021 is <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">now live on the event website</a>. Remember to sign up to be the first to access our extra on-demand C++ demos and get more virtual surprises.</p>
<h1 id="schedule">Schedule</h1>
<p>All times are on Monday 3<sup>rd</sup> May 2021 UTC. Abstracts and speaker bios are available on the <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event/">website</a>.</p>
<ul>
<li>14:30-15:00 UTC: Visibility, Reachability, Linkage &#8211; The Three Secret Spices of C++ Modules by Daniela Engert</li>
<li>15:00-15:30 UTC: An Introduction to CMakePresets.json by Erika Sweet, Kyle Edwards, and Bill Hoffman</li>
<li>15:40-16:10 UTC: Manage code dependencies at work with new vcpkg features by Augustin Popa</li>
<li>16:15-16:45 UTC: Code Analysis: Empowering developers to write performant, reliable, and safe C++ by Sunny Chatterjee</li>
<li>16:50-17:20 UTC: C++ Modules: Year 2021 by Gabriel Dos Reis</li>
</ul>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/">Pure Virtual C++ 2021 Schedule Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/pure-virtual-cpp-2021-schedule-available/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>CMake Presets integration in Visual Studio and Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/#comments</comments>
		
		<dc:creator><![CDATA[Erika]]></dc:creator>
		<pubDate>Tue, 20 Apr 2021 16:30:20 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27911</guid>

					<description><![CDATA[<p>CMakePresets.json was released in CMake 3.19 and 3.20 and allows users to specify common configure, build, and test options and share them with others. We have added support for CMakePresets.json in Visual Studio and the CMake Tools extension for Visual Studio Code.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">CMake Presets integration in Visual Studio and Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">CMakePresets.json</a> was released in CMake 3.19 and 3.20 and allows users to specify common configure, build, and test options and share them with others. We have added support for CMakePresets.json in Visual Studio and the CMake Tools extension for Visual Studio Code. You can now invoke CMake with the same CMakePresets.json file in Visual Studio, in Visual Studio Code, in a Continuous Integration pipeline, and from the CLI on Windows, Linux, and macOS.</p>
<p>Our CMake Presets integration is now available in preview in <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 version 16.10 Preview 2</a> and <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools">CMake Tools version 1.7</a>.</p>
<h4 id="why-should-i-use-cmake-presets">Why should I use CMake Presets?</h4>
<p>CMake released support for <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#configure-preset">Configure Presets</a> in CMake 3.19. Our team at Microsoft contributed support for <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#build-preset">Build Presets</a> and <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html#test-preset">Test Presets</a> in CMake 3.20. We’re excited to adopt CMake Presets to address some common problems related to CMake configuration and build.</p>
<ul>
<li><strong>Move seamlessly between Visual Studio and Visual Studio Code. </strong>With the adoption of CMakePresets.json, the same file can be used to drive CMake in both Visual Studio and Visual Studio Code. This makes it easier for developers on your team to hop between Visual Studio and Visual Studio Code and work in the development environment that best suits their needs.</li>
<li><strong>Project-specific information can always be checked in. </strong>CMake supports two files: CMakePresets.json and CMakeUserPresets.json. CMakePresets.json is intended to save project-wide presets, while CMakeUserPresets.json is intended for developers to save their own local presets. This ensures project-specific information can always be checked into source control and makes it easier for new team members to get up-and-running. It also makes it easier for teams to synchronize changes to their CMake builds across the entire team. Both CMakePresets.json and CMakeUserPresets.json are supported in Visual Studio and Visual Studio Code.</li>
<li><strong>Reproduce builds in Visual Studio and Visual Studio Code from the CLI. </strong>Since CMakePresets.json is supported by CMake itself, the same CMakePresets.json file can be used to invoke CMake in Visual Studio, in Visual Studio Code, in a Continuous Integration pipeline, and from the CLI on Windows, Linux, and macOS. CMake 3.20 or higher is required to build with CMakePresets.json from the CLI.</li>
<li><strong>Streamline build instructions for open source CMake projects. </strong>You can pull down any project that has a CMakePresets.json file at the root of the repository and build and test it locally using the instructions encoded in a preset. All command arguments that can be passed to CMake or CTest from the command line can be specified in a Configure, Build, or Test Preset.</li>
</ul>
<p>For more information on CMake Presets, you can check out my recent <a href="https://www.youtube.com/watch?v=-NhaPNq16Qk">session at ACCU</a> where I demonstrate how to use CMakePresets.json in Visual Studio, from the CLI, and in a GitHub Actions pipeline. You can also view a <a href="https://github.com/esweet431/box2d-lite/blob/main/CMakePresets.json">sample CMakePresets.json file</a>, register for <a href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2021-conference/">Pure Virtual C++</a>, or read the <a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html">official CMake documentation</a>. More information on CMake Presets integration in Visual Studio and VS Code is below.</p>
<h4 id="cmake-presets-in-visual-studio">CMake Presets in Visual Studio</h4>
<p>The best resource to learn about our CMake Presets integration in Visual Studio is our <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">documentation</a>. CMake Presets integration in Visual Studio is still in preview.</p>
<p>CMakePresets.json will be a recommended alternative to CMakeSettings.json. Visual Studio will never read from both CMakePresets.json and CMakeSettings.json at the same time. You can enable CMake Presets integration for all projects in <strong>Tools &gt; Options &gt; CMake &gt; General</strong>. You must close and reopen the folder in Visual Studio to activate the integration.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable.png"><img class="aligncenter size-full wp-image-27912" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable.png" alt="The Tools &gt; Options &gt; CMake dialog in Visual Studio. The option to &quot;Use CMakePresets.json to drive CMake configure, build, and test&quot; is checked and underscored in red." width="740" height="429" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable.png 740w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/enable-300x174.png 300w" sizes="(max-width: 740px) 100vw, 740px" /></a>You can enable CMake Presets integration for a single project by adding a CMakePresets.json file to the root of the open folder. Again, you must close and reopen the folder to activate the integration. See <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#enable-cmakepresetsjson-integration-in-visual-studio-2019">Enable CMake Presets integration in Visual Studio 2019</a> for more information.</p>
<p>Once CMake Presets integration is enabled, you will see three dropdowns across the menu bar.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets.png"><img class="aligncenter size-full wp-image-27914" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets.png" alt="The menu bar has 3 dropdowns. The dropdown on the left reads &quot;WSL: ubuntu2004&quot;, the dropdown in the middle reads &quot;ninja-debug&quot;, and the dropdown on the right reads &quot;verbose-build&quot;. " width="664" height="158" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets.png 664w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/cmakepresets-300x71.png 300w" sizes="(max-width: 664px) 100vw, 664px" /></a></p>
<p>The dropdown on the left indicates the active <strong>Target System</strong>. This is the system where CMake will be invoked to configure and build the project. This dropdown lists your local machine, all SSH connections in the <a href="https://docs.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-160#set-up-the-remote-connection">Connection Manager</a> by host name, and all Windows Subsystem for Linux (WSL) installations that Visual Studio can find.</p>
<p>The dropdown in the middle indicates the active <strong>Configure Preset</strong>. This is the Configure Preset that will be used when CMake is invoked to generate the project build system. This dropdown lists the union of non-hidden Configure Presets defined in CMakePresets.json and CMakeUserPresets.json that apply to the active <strong>Target System</strong>. The active Configure Preset in the image above is ninja-debug.</p>
<p>The dropdown on the right indicates the active <strong>Build Preset</strong>. This is the Build Preset that will be used when CMake is invoked to build the project. This dropdown lists the union of non-hidden Build Presets defined in CMakePresets.json and CMakeUserPresets.json that apply to the active <strong>Configure Preset</strong>. The active Build Preset in the image above is verbose-build. Check out our documentation on <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160#configure-and-build">CMake configuration and build</a> to learn more.</p>
<p>With Visual Studio you can edit, build, and debug your CMake targets on Windows, WSL, and remote systems from the comfort of a single IDE. Visual Studio will automatically copy your source code to the specified target system, but your build tools (CMake, generator, compilers), rsync, zip, and gdb must be already installed. See <a href="https://docs.microsoft.com/en-us/cpp/linux/download-install-and-setup-the-linux-development-workload?view=msvc-160#options-for-creating-a-linux-environment">Creating a Linux environment</a> for more information.</p>
<p>For more information on adding presets, editing presets, running tests, and more, see our documentation on <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">CMake Presets integration in Visual Studio</a>.</p>
<h4 id="cmake-presets-in-the-cmake-tools-extension-for-visual-studio-code">CMake Presets in the CMake Tools extension for Visual Studio Code</h4>
<p>The best resource to learn about CMake Presets integration in the CMake Tools extension is our <a href="https://github.com/microsoft/vscode-cmake-tools/blob/develop/docs/cmake-presets.md">documentation</a>. CMake Presets integration in the CMake Tools extension is still in preview.</p>
<p>CMakePresets.json will be a recommended alternative to kits and variants files. CMake Tools will never read from both CMakePresets.json and kits and variants files at the same time. You can enable CMake Presets integration by modifying the value of cmake.useCMakePresets in settings.json.</p>
<table>
<tbody>
<tr>
<td width="163">
<p style="text-align: center;"><strong>Setting</strong></p>
</td>
<td width="221">
<p style="text-align: center;"><strong>Description</strong></p>
</td>
<td width="144">
<p style="text-align: center;"><strong>Accepted values</strong></p>
</td>
<td width="96">
<p style="text-align: center;"><strong>Default value</strong></p>
</td>
</tr>
<tr>
<td style="text-align: center;" width="163">cmake.useCMakePresets</td>
<td style="text-align: center;" width="221">Use CMakePresets.json to drive CMake configure, build, and test</td>
<td style="text-align: center;" width="144">always, never, auto</td>
<td style="text-align: center;" width="96">auto</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><strong>auto </strong>evaluates to <strong>always</strong> if there’s a CMakePresets.json in the cmake.sourceDirectory of the active folder. It evaluates to <strong>never</strong> if there isn’t a CMakePresets.json file in the cmake.sourceDirectory of the active folder. Set cmake.useCMakePresest to <strong>always </strong>or <strong>never</strong> to explicitly enable or disable CMake Presets integration for all CMake projects. See <a href="https://github.com/microsoft/vscode-cmake-tools/blob/develop/docs/cmake-presets.md#enable-cmakepresetsjson-in-the-cmake-tools-extension">Enable CMake Presets in the CMake Tools extension</a> for more information.</p>
<p>Once CMake Presets integration is enabled, you can run several new commands.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette.png"><img class="aligncenter size-full wp-image-27915" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette.png" alt="The command palette is open in Visual Studio Code and reads &quot;&gt;CMake: Preset&quot;. Several commands specific to CMake Presets are available including &quot;CMake: Add Configure Preset&quot; and &quot;CMake: Select Build Preset&quot;. " width="619" height="189" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette.png 619w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/command-palette-300x92.png 300w" sizes="(max-width: 619px) 100vw, 619px" /></a></p>
<p>Use the commands <strong>CMake: Select Configure Preset</strong>, <strong>CMake: Select Build Preset</strong>, and <strong>CMake: Select Test Preset</strong> to select your active presets. Your active presets are displayed in the status bar.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar.png"><img class="aligncenter size-full wp-image-27916" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar.png" alt="Image status bar" width="863" height="41" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar.png 863w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar-300x14.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/status-bar-768x36.png 768w" sizes="(max-width: 863px) 100vw, 863px" /></a></p>
<p>In the image above, <strong>[active-configure-preset]</strong> indicates the active Configure Preset, <strong>[active-build-preset] </strong>indicates the active Build Preset, and <strong>[active-test-preset] </strong>indicates the active Test Preset.</p>
<p>For more information on adding presets, editing presets, running CMake, and more, see our documentation on <a href="https://github.com/microsoft/vscode-cmake-tools/blob/develop/docs/cmake-presets.md">CMake Presets integration in Visual Studio Code</a>.</p>
<h4 id="whats-next">What&#8217;s next?</h4>
<p>CMake Presets integration in Visual Studio and Visual Studio Code is still in preview. We’ll continue to add to our integration and address your feedback in future release of Visual Studio and the CMake Tools extension for VS Code.</p>
<p>In Visual Studio, the best way to file a bug or suggest a feature is with the <strong>Send Feedback</strong> button in the upper right-hand corner of the IDE. See <a href="https://docs.microsoft.com/en-us/visualstudio/ide/feedback-options?view=vs-2019#:~:text=In%20Visual%20Studio%2C%20choose%20the%20feedback%20icon%20in,information%2C%20see%20Suggest%20a%20feature%20for%20Visual%20Studio.">Visual Studio feedback options</a> for more information.</p>
<p>In VS Code, the best way to file a bug or suggest a feature is by creating (or upvoting) an issue in the <a href="https://github.com/microsoft/vscode-cmake-tools/issues">extension’s GitHub repository</a>.</p>
<p>We’d love to learn how your team is adopting CMakePresets.json. If you have feedback or a success story to share, you can contact us at <a href="mailto:cmake@microsoft.com">cmake@microsoft.com</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">CMake Presets integration in Visual Studio and Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/feed/</wfw:commentRss>
			<slash:comments>11</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ Extension April 2021 Update: CUDA C/C++ IntelliSense and Apple Silicon Support</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Thu, 15 Apr 2021 14:45:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27888</guid>

					<description><![CDATA[<p>The April 2021 update of the Visual Studio Code C++ extension is now available! This latest release offers brand new features—such as IntelliSense for CUDA C/C++ and native language server support for Apple Silicon— along with a bunch of enhancements and bug fixes. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/">Visual Studio Code C++ Extension April 2021 Update: CUDA C/C++ IntelliSense and Apple Silicon Support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">The April 2021 update of the </span><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"><span data-contrast="none">Visual Studio Code C++ extension</span></a><span data-contrast="auto"> is now available! This latest release offers brand new features—such as IntelliSense for CUDA C/C++ and native language server support for Apple Silicon— along with a bunch of enhancements and bug fixes. To find out more about all the enhancements, check out our </span><a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.3.0"><span data-contrast="none">release notes on GitHub.</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h2 aria-level="1" aria-level="1" id="cuda-c-c-intellisense"><b><span data-contrast="auto">CUDA C/C++ IntelliSense</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">We’re excited to announce that the C++ extension now provides IntelliSense for CUDA C/C++! CUDA is a parallel programming platform, enabling developers to interact with the GPU. Microsoft and NVIDIA have partnered together to light up the CUDA C/C++ development experience in VS Code. IntelliSense for CUDA C/C++ is currently available with <a href="https://code.visualstudio.com/insiders/">Visual Studio Code Insiders</a>. Build and debug support for GPU kernels is coming soon with NVIDIA Nsight Visual Studio Code Edition— check out </span><a href="https://developer.nvidia.com/blog/announcing-nvidia-nsight-visual-studio-code-edition-new-addition-to-the-nsight-developer-tools-suite"><span data-contrast="none">NVIDIA’s Developer Blog</span></a><span data-contrast="auto"> to learn more!</span></p>
<h2 aria-level="1" aria-level="1" id="apple-silicon-arm64-support"><b><span data-contrast="auto">Apple Silicon ARM64 support</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">In February, Visual Studio Code announced </span><a href="https://code.visualstudio.com/updates/v1_54#_apple-silicon"><span data-contrast="none">its first release of stable Apple Silicon builds</span></a><span data-contrast="none">.</span><span data-contrast="auto"> With this latest release, the C++ extension’s language server binaries also run natively on Apple Silicon. Running the language server natively on Apple Silicon is more efficient than running it with an emulator, leading to better performance and longer battery life.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="auto">The C++ extension language server provides IntelliSense (code editing features like Quick Info and Autocomplete), code navigation (Go to Definition/Declaration, Find All References), and some refactoring features (like Rename symbol). Debugging C++ projects natively on Apple Silicon will be supported in the future, and you can check out this </span><a href="https://github.com/microsoft/vscode-cpptools/issues/7035"><span data-contrast="none">GitHub issue (#7035)</span></a><span data-contrast="auto"> for updates.</span></p>
<h2 aria-level="1" aria-level="1" id="additional-enhancements"><b><span data-contrast="auto">Additional enhancements</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">In addition to supporting CUDA C/C++ IntelliSense and Apple Silicon ARM64 architecture, the April 2021 update comes with a bunch of enhancements! We’re especially excited about </span><a href="https://github.com/microsoft/vscode-cpptools/issues/882"><span data-contrast="none">Auto-adding parentheses for function calls (#882)</span></a><span data-contrast="auto">, which was one of our top voted GitHub issues!</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="auto">To enable automatically adding parentheses after function calls, go to </span><b><span data-contrast="auto">File</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Preferences</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Settings</span></b><span data-contrast="auto"> and under </span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">C/C++, </span></b><span data-contrast="auto">check the box under</span><b><span data-contrast="auto"> “C_cpp: Autocomplete Add Parentheses.” </span></b><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis.png"><img class="alignnone size-full wp-image-27891" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis.png" alt="Screenshot of the C++ extension's setting called Autocomplete Add Parenthesis in VS Code's Preferences UI. The setting is enabled by marking the checkbox." width="1812" height="193" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis.png 1812w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-300x32.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-1024x109.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-768x82.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/auto-add-parenthesis-1536x164.png 1536w" sizes="(max-width: 1812px) 100vw, 1812px" /></a></p>
<p><span class="TextRun SCXW229310597 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">Then, when you insert a function call, </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">parentheses will </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">be added automatically</span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">,</span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3"> with the cursor placed inside or outside depending on </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">whether</span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3"> the function requires </span><span class="NormalTextRun SCXW229310597 BCX8" data-ccp-parastyle="heading 3">parameters.</span></span><span class="EOP SCXW229310597 BCX8" data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/completion-list-parentheses.gif"><img class="alignnone size-full wp-image-27892" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/completion-list-parentheses.gif" alt="GIF that shows a member function being selected from a completion list, and then parentheses being added automatically after the function call" width="1816" height="1020" /></a></p>
<p><span data-contrast="auto">The April 2021 release also offers:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Highlighting of matching conditional preprocessor statements. </span><a href="https://github.com/microsoft/vscode-cpptools/issues/2565"><span data-contrast="none">#2565</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="auto">Commands for navigating to matching preprocessor directives in conditional groups. </span><a href="https://github.com/microsoft/vscode-cpptools/issues/4779"><span data-contrast="none">#4779</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Auto-closing of include completion brackets. </span><a href="https://github.com/microsoft/vscode-cpptools/issues/7054"><span data-contrast="none">#7054</span></a><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></li>
</ul>
<p><span data-contrast="auto">And more! Check out our </span><a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.3.0"><span data-contrast="none">release notes</span></a><span data-contrast="auto"> to learn about additional enhancements and over 25 bug fixes.</span><span data-ccp-props="{&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559738&quot;:60,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></p>
<h2 aria-level="1" aria-level="1" id="what-do-you%e2%80%afthink"><b><span data-contrast="auto">What do you think?</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools"><span data-contrast="none">Download the C++ extension for Visual Studio Code</span></a><span data-contrast="auto"> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the </span><a href="https://github.com/Microsoft/vscode-cpptools/issues"><span data-contrast="none">Issues section of our GitHub repository</span></a><span data-contrast="auto">. You can also join our Insiders program and get access to early builds of our release by going to </span><b><span data-contrast="auto">File</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Preferences</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">Settings</span></b><span data-contrast="auto"> and under </span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto"> &gt; </span><b><span data-contrast="auto">C/C++,</span></b><span data-contrast="auto"> change the “</span><b><span data-contrast="auto">C_Cpp: Update Channel</span></b><span data-contrast="auto">” to “</span><b><span data-contrast="auto">Insiders</span></b><span data-contrast="auto">.” Then under </span><b><span data-contrast="auto">Features </span></b><span data-contrast="auto">&gt; </span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto">, enable “</span><b><span data-contrast="auto">Extensions</span></b><span data-contrast="auto">:</span><b><span data-contrast="auto"> Auto Update</span></b><span data-contrast="auto">.”</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="auto">We can be reached via the comments below or in email at </span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="auto">. You can also find our team on Twitter at </span><a href="https://twitter.com/visualc"><span data-contrast="none">@</span></a><a href="https://twitter.com/visualc"><span data-contrast="none">VisualC</span></a><span data-contrast="none">.</span><span data-ccp-props="{&quot;134233117&quot;:true,&quot;134233118&quot;:true,&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/">Visual Studio Code C++ Extension April 2021 Update: CUDA C/C++ IntelliSense and Apple Silicon Support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-april-2021-update-cuda-c-c-intellisense-and-apple-silicon-support/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC Backend Updates in Visual Studio 2019 version 16.10 Preview 2</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/#comments</comments>
		
		<dc:creator><![CDATA[Helena Gregg]]></dc:creator>
		<pubDate>Wed, 14 Apr 2021 17:27:30 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27875</guid>

					<description><![CDATA[<p>In Visual Studio 2019 version 16.10 Preview 2 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a brief list of improvements for you to review. </p>
<p>Address Sanitizer </p>
<p>Fixed false negative bugs, </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/">MSVC Backend Updates in Visual Studio 2019 version 16.10 Preview 2</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="none">In </span><a href="https://visualstudio.microsoft.com/vs/preview/"><span data-contrast="none">Visual Studio 2019</span></a><span data-contrast="none"> version 16.10 Preview 2 we have continued to improve the C++ backend with new features, new and improved optimizations, build throughput improvements, and better security. Here is a brief list of improvements for you to review.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><b><span data-contrast="none">Address Sanitizer</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="2"><span data-contrast="auto">Fixed false negative bugs, fixed false positive bugs, and improved debugger step-over fidelity of ASan-instrumented code.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><b><span data-contrast="auto">ARM64 support for /guard:ehcont</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="2"><span data-contrast="auto">The /guard:ehcont flag can be added to both compilation and linking of an executable to generate metadata that could be used by the OS to perform security checks at exception handling continuation points. Previously, this was only generated and supported for AMD64, but with 16.10 it is also possible to compile ARM64 executables with this metadata.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="3" data-aria-level="2"><span data-contrast="auto">Documentation for this switch: </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/guard-enable-eh-continuation-metadata?view=msvc-160"><span data-contrast="none">/guard:ehcont (Enable EH Continuation Metadata) | Microsoft Docs</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="4" data-aria-level="2"><span data-contrast="auto">See Windows blog for Control-Flow Integrity (CFI) mitigations using ehcont: </span><a href="https://techcommunity.microsoft.com/t5/windows-kernel-internals/developer-guidance-for-hardware-enforced-stack-protection/ba-p/2163340"><span data-contrast="none">Developer Guidance for Hardware-enforced Stack Protection &#8211; Microsoft Tech Community</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><b><span data-contrast="auto">OpenMP</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="5" data-aria-level="2"><span data-contrast="auto">Made /openmp:llvm available on x86 and ARM64</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><b><span data-contrast="auto">Bigger stack reserve for link.exe and mspdbsrv.exe</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="2"><span data-contrast="auto">Increased stack reserve for link.exe and mspdbsrv.exe (x86 and amd64 hosted only) from the default 1MB to 4MB, to accommodate recursive type merging at link time.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="2"><span data-contrast="auto">Feedback: </span><a href="https://developercommunity2.visualstudio.com/t/Unhandled-Exception-During-Linking-IN-li/1300875"><span data-contrast="none">Unhandled Exception During Linking IN link.exe &#8211; Visual Studio Feedback</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><b><span data-contrast="auto">Added flags to enable/disable the SSA peeps for amd64 and x86 </span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="3" data-aria-level="2"><span data-contrast="auto">Added retail flags (-post-color-ssa-peeps, post-color-ssa-peeps-) to allow users to disable post-color ssa peeps and -pre-color-ssa-peeps and -pre-color-ssa-peeps- to enable them. This should allow users affected by an overly aggressive peep to work around their issue without having to completely disable the optimizer.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><b><span data-contrast="auto">Avoid PDB size overgrowth from incremental linking</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="2"><span data-contrast="auto">Feedback: </span><a href="https://developercommunity2.visualstudio.com/t/PDBs-keep-growing-in-size-on-incremental/1307614"><span data-contrast="none">PDBs keep growing in size on incremental links &#8211; Visual Studio Feedback</span></a><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="4" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><b><span data-contrast="auto">Debug mode performance improvements</span></b><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li style="list-style-type: none;">
<ul>
<li data-leveltext="o" data-font="Courier New" data-listid="4" aria-setsize="-1" data-aria-posinset="2" data-aria-level="2"><span data-contrast="auto">Removed unnecessary overhead due to </span><a href="https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks?view=msvc-160"><span data-contrast="none">runtime checks</span></a><span data-contrast="auto">. This may increase performance of your code compiled in debug mode by up to 3x.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
</li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><strong>Added additional peephole optimizations for ARM64</strong><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:276}"> </span></li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="6" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><strong>Enabled volatile metadata by default when targeting x64 to improve emulation performance</strong></li>
</ul>
<p><span data-contrast="none">Do you want to experience the new improvements of the C++ backend? Please download </span><a href="https://visualstudio.microsoft.com/vs/preview/"><span data-contrast="none">the latest Visual Studio 2019</span></a><span data-contrast="none"> and give it a try! Any feedback is welcome. We can be reached via the comments below, </span><a href="https://developercommunity.visualstudio.com/spaces/8/index.html"><span data-contrast="none">Developer Community</span></a><span data-contrast="none">, email (</span><a href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="none">), and Twitter (</span><a href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span data-contrast="none">).</span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/">MSVC Backend Updates in Visual Studio 2019 version 16.10 Preview 2</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2019-version-16-10-preview-2/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Finding Bugs with AddressSanitizer: MSVC Compiler</title>
		<link>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/</link>
					<comments>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 07 Apr 2021 23:31:51 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27854</guid>

					<description><![CDATA[<p>Special thanks to Aaron Gorenstein for authoring this blog post.<br />
The AddressSanitizer (ASan) is generally available for MSVC since the recently-released Visual Studio 2019 version 16.9. We’ve already shown how easy it can be to find bugs in even production-ready code like EASTL.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/">Finding Bugs with AddressSanitizer: MSVC Compiler</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><em>Special thanks to Aaron Gorenstein for authoring this blog post. </em></p>
<p>The AddressSanitizer (ASan) is <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/">generally available</a> for MSVC since the recently-released Visual Studio 2019 version 16.9. We’ve already <a href="https://www.youtube.com/watch?v=4YzFdiYPeVw&amp;t=4065s">shown</a> how easy it can be to find bugs in even production-ready code like EASTL. Here I’ll share an example of how it found a real bug in the MSVC compiler itself.</p>
<p>The idea was straightforward: ASan finds bugs, and we’re always interested in finding bugs in the compiler. Just like you can turn ASan on in your projects and run your tests, we’ve been turning on ASan on our project (the compiler) and running it on our tests. Sure enough, this found bugs.</p>
<p>&nbsp;</p>
<h3 id="building-our-binary-with-asan">Building our Binary with ASan</h3>
<p>It was easy to turn on ASan in our build system. We’ve documented ways to turn ASan on in <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-160#ide-msbuild">common</a> <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-160#ide-cmake">build</a> scenarios. In our case, I added <code>/fsanitize=address</code> to the build’s cl.exe command line, and our old, ever-evolving build system needed the extra manual step of specifying where our <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan-debugger-integration?view=msvc-160">extension</a> library lived.</p>
<p>That was all it took! I now was able to build my binary, c2.dll, “just like normal”, but now it had lots of excellent ASan instrumentation imbued to help find bugs. I was ready to run our inner-ring test suite and see if anything cropped up.</p>
<p>&nbsp;</p>
<h3 id="finding-the-bug">Finding the Bug</h3>
<p>Our inner-test loop is about 4,000 separate C++ files, containing a mix of real-world-code, synthetic tests, benchmarks, and regression tests. We have a home-made test-runner that is only accessible from the command-line. Running it, we almost passed, but hit exactly 1 failure. I looked in our log file and see the characteristic trace:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-1.png"><img class="alignnone size-full wp-image-27861" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-1.png" alt="Image ASan MSVC error - stack buffer underflow" width="1875" height="253" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-1.png 1875w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-1-300x40.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-1-1024x138.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-1-768x104.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-1-1536x207.png 1536w" sizes="(max-width: 1875px) 100vw, 1875px" /></a></p>
<p>A couple things I would like to highlight:</p>
<ol>
<li>The error reported is “stack-buffer-underflow”: this is a <em>stack </em> ASan is able to find both stack and heap issues.</li>
<li>Note the line “stack of thread T3”. As that suggests, there is also a T1 and T2 (and more): c2.dll executes many threads in parallel. ASan can handle multiple threads like that no problem!</li>
</ol>
<p>Most importantly: <strong>ASan never has false positives</strong>. This trace I found is definitely a bug, so I already know I found something to fix.</p>
<p>Fortunately, the triggering input is a single file. I can easily repeat the command that repro’s the bug manually. To be clear, at this point this was all I needed to do to hit the issue:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2.png"><img class="alignnone size-full wp-image-27863" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2.png" alt="Image ASan MSVC error - stack buffer underflow" width="2373" height="358" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2.png 2373w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2-300x45.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2-1024x154.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2-768x116.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2-1536x232.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-MSVC-error-2-2048x309.png 2048w" sizes="(max-width: 2373px) 100vw, 2373px" /></a></p>
<p>I’ve truncated the output, but the terminal contained the full ASan command-line diagnostics. I could use that information (starting with the stack-trace you can see above) to investigate the issue. However, I like examining these in the full IDE and debugging experience. With this command line, I can reproduce the ASan issue but attach it to the debugger:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging.png"><img class="alignnone size-full wp-image-27864" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging.png" alt="Image ASan debugging" width="2365" height="118" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging.png 2365w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging-300x15.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging-1024x51.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging-768x38.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging-1536x77.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/ASan-debugging-2048x102.png 2048w" sizes="(max-width: 2365px) 100vw, 2365px" /></a></p>
<p>Starting the debugger-attached version of my binary, I see:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/Debugging-ASan-in-VS.png"><img class="alignnone size-full wp-image-27866" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/Debugging-ASan-in-VS.png" alt="Image Debugging ASan in VS" width="1874" height="1178" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/Debugging-ASan-in-VS.png 1874w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/Debugging-ASan-in-VS-300x189.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/Debugging-ASan-in-VS-1024x644.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/Debugging-ASan-in-VS-768x483.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/Debugging-ASan-in-VS-1536x966.png 1536w" sizes="(max-width: 1874px) 100vw, 1874px" /></a></p>
<p>The IDE is able to provide a wealth—<em>interactively</em>—of information about what’s going on <em>the moment</em> a memory violation is detected. You can see the ASan issue is reported as an exception, bringing me right to the correct line number, along with my familiar debugger call-stack and everything else. The output window is still available for those accustomed to it.</p>
<p>Any guesses of where the bug may be lurking?</p>
<p>Hint: “<code>sz</code>” likely stands for “size”. Observe recall how ASan reports “stack buffer <em>underflow</em>”.</p>
<p>&nbsp;</p>
<h3 id="fixing-the-bug">Fixing the Bug</h3>
<p>Examining the value of <code>sz</code> made it clear enough: <code>MscIsFloatOrVectorConstant</code> returns the size of the constant <em>if it is found</em>, and 0 otherwise. In this buggy case, it returns 0, and we underflow the array field in the function-local struct <code>vval</code>. The fix is equally straightforward: following idioms in the rest of the file, we simply add a check for that before line 16828. This fix has been integrated and will be included in version 16.10.</p>
<p>This particular bug is very unlikely to strike “in the wild”: the stack would need to have garbage values in just-the-right way (to pass the condition on line 16831). However, in theory this bug—and more generally, bugs just like it—could lead to an improper optimization in your code. That is among the worst sort of bug a compiler can have: silent-bad-codegen. I’m very pleased to have squashed this one. I’m also very glad to have been able to share just how easy ASan can make bugfixing with you.</p>
<p>&nbsp;</p>
<h3 id="conclusion">Conclusion</h3>
<p>We don’t typically write blog posts about fixing a bug in the compiler, but of course the real story is just how easily and effectively ASan helps find and fix bugs:</p>
<ul>
<li>Our bespoke, command-line driven build system needed just a few lines of changes to integrate the build-with-ASan option.</li>
<li>Once built, testing our binary was seamless: I ran my typical inner-dev-loop test suite.</li>
<li>Once it found an issue, it was equally seamless to repeat the steps in our IDE’s debugger, pointing me right to the source line to examine.
<ul>
<li>In more sophisticated circumstances, <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan-offline-crash-dumps?view=msvc-160">consider the ability to save a dump file</a>!</li>
</ul>
</li>
<li>The exact source line, coupled with ASan’s ability to characterize the issue (a stack <em>underflow</em>), made the investigation quick and easy. No long hours or brilliant insight needed: of course I still had to confirm and actually fix the issue, but compared to a traditional bugfix so much of the investigation was short-circuited.</li>
</ul>
<p>It is exactly the speed, effectiveness, and simplicity of ASan that I hope this story helps illustrate. Moreover, and most compellingly to me: ASan found a memory violation <em>that hadn’t yet manifested as bad behavior</em> in our program. It <em>could</em> manifest, but here we were able to pin it down and squash it without an expensive, more indirect investigation—and hopefully without it ever having affected our customers!</p>
<p>&nbsp;</p>
<h3 id="try-out-addresssanitizer-for-windows">Try out AddressSanitizer for Windows</h3>
<p>To get started with this experience, check out our <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan">AddressSanitizer documentation for MSVC and Visual Studio</a> as well as our announcement blog post: <a href="https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/">Address Sanitizer for MSVC Now Generally Available</a>.</p>
<p>ASan for MSVC was done due to feedback from developers like you. If you have suggestions on the future of undefined-behavior-, memory-, thread-, or other-sanitizers, please share them as a <a href="https://developercommunity2.visualstudio.com/search?entry=suggestion&amp;space=62&amp;ftype=idea">suggestion on Developer Community</a>! If you suspect you’ve hit an issue or bug, please also don’t hesitate to <a href="https://developercommunity2.visualstudio.com/search?entry=suggestion&amp;space=62&amp;ftype=problem&amp;q=asan">open a ticket on Developer Community</a>!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/">Finding Bugs with AddressSanitizer: MSVC Compiler</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>Sign Up for the Pure Virtual C++ 2021 Conference</title>
		<link>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2021-conference/</link>
					<comments>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2021-conference/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 06 Apr 2021 08:00:25 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27840</guid>

					<description><![CDATA[<p>Last year we ran the first Pure Virtual C++, a free one-day virtual conference for the whole C++ community. This May we&#8217;re doing it again! Sign-up for free on the website to be the first to hear about our program schedule,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2021-conference/">Sign Up for the Pure Virtual C++ 2021 Conference</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><img width="1376" height="362" class="wp-image-27841" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image.png 1376w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-300x79.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-1024x269.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/04/word-image-768x202.png 768w" sizes="(max-width: 1376px) 100vw, 1376px" /></p>
<p>Last year we ran the first Pure Virtual C++, a free one-day virtual conference for the whole C++ community. This May we&#8217;re doing it again! <a href="https://visualstudio.microsoft.com/pure-virtual-cpp-event-2021/">Sign-up for free on the website</a> to be the first to hear about our program schedule, access our extra on-demand C++ demos, and get more virtual surprises.</p>
<p>The live event will run <strong>May 3<sup>rd</sup> 14:30-17:30 UTC</strong> on <a href="https://docs.microsoft.com/en-us/learn/tv/">Microsoft Learn TV</a>. It will also be streamed to YouTube and videos will be available to watch after the event.</p>
<p>The full program will be announced soon, but expect content on C++20 modules, code analysis, CMake, vcpkg, and MSVC&#8217;s progress on conformance. In addition to the live sessions, we&#8217;ll be releasing on-demand content in the run-up to the conference.</p>
<p>The Pure Virtual C++ conference is organized by Microsoft and will be run under the <a href="https://berlincodeofconduct.org/">Berlin Code of Conduct</a>.</p>
<p>Get involved in the conversation on Twitter using the #purevirtualcpp hashtag.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2021-conference/">Sign Up for the Pure Virtual C++ 2021 Conference</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/sign-up-for-the-pure-virtual-cpp-2021-conference/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg Host Dependencies for Cross-Compilation</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/#comments</comments>
		
		<dc:creator><![CDATA[Robert Schumacher]]></dc:creator>
		<pubDate>Wed, 31 Mar 2021 18:28:10 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27828</guid>

					<description><![CDATA[<p>If you’re not familiar with our C++ library manager vcpkg, welcome! This post covers an intermediate/advanced topic, so you may want to first get an overview and try things out from the vcpkg GitHub page or some of our previous blogs.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/">vcpkg Host Dependencies for Cross-Compilation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[</p>
<p>If you’re not familiar with our C++ library manager vcpkg, welcome! This post covers an intermediate/advanced topic, so you may want to first get an overview and try things out from the <a href="https://github.com/Microsoft/vcpkg">vcpkg GitHub page</a> or some of <a href="https://devblogs.microsoft.com/cppblog/?s=vcpkg">our previous blogs</a>.</p>
<p>&nbsp;</p>
<h3 id="introduction">Introduction</h3>
<p>One of the best features of C++ is that it generates tailored, specialized code for each specific machine, enabling you to squeeze every ounce of performance per watt. It enables clean abstractions to coexist peacefully with low-level platform-specific bit twiddling. However, this comes at a price for many developers that venture beyond their own machine: you must build different binaries for your developer machine compared to your final target, be it a phone, a cloud server, or an embedded microcontroller.</p>
<p>For most small-to-medium sized projects, this isn’t a problem. You already have a compiler, a code editor, and a build system, which is plenty to make tons of incredible applications. However, since time immemorial some developers need even more flexibility, extensibility, and power than just the compiler; they need to generate sophisticated code at build time. Maybe it’s computing a <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">perfect hash function</a> over your known data set, maybe it’s a <a href="https://en.wikipedia.org/wiki/Yacc">table-driven parser</a>, or maybe it’s a bunch of <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">foreign function interface</a> boilerplate into your embedded scripting language. For whatever reason, you need the flexibility of C++ <em>for your development environment</em> in addition to the final runtime target.</p>
<p>In this blog post we’ll cover the newly shipped vcpkg feature designed to enable all these scenarios and more: <strong>Host Dependencies</strong>.</p>
<p>&nbsp;</p>
<h3 id="simultaneous-compilation">Simultaneous Compilation</h3>
<p>As mentioned in the introduction, because C++ compiles all the way down to the metal, you generally can’t use the same compiler and flags to simultaneously target your final runtime and your developer machine. If you’re using a multi-targeting compiler like Clang/LLVM you’ll need at least different flags and if you’re using a single-target compiler like GCC or MSVC you’ll need an entirely different compiler.</p>
<p>If you’re lucky, your buildsystem has specific documentation for how to handle this case. Even then, it can sometimes be extremely subtle to ensure things are wired up correctly: Did you accidentally pass the flags for the target to the developer machine build? What if you need libraries for your code generator to run? What about code generators generating code for other code generators? It’s a tricky problem space that has ramifications on every aspect of the build environment.</p>
<p>&nbsp;</p>
<h3 id="triplets">Triplets</h3>
<p>In vcpkg, we label each target universe as a separate &#8220;triplet&#8221;. For example, x64 Windows Desktop using dynamic CRT and MSVC, but building static libraries might be named <code>x64-windows-static-md</code>. Each library built within that universe links against other libraries from that universe, keeping everything super consistent. We include many triplet definitions in the box, but you can easily make your own to tweak compiler flags or adjust settings on a per-library basis (maybe you’d like Qt to be built dynamically, but your JSON parser built statically).</p>
<p>Naturally, your developer environment also matches one of these universes. By default, we pick <code>x64-windows</code>, <code>x64-linux</code>, or <code>x64-osx</code> as appropriate but it’s fully configurable at runtime via <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/host-dependencies.md#specifying-the-host-triplet">several methods</a>.</p>
<p>&nbsp;</p>
<h3 id="host-dependencies">Host Dependencies</h3>
<p>Despite having a triplet matching the developer environment, vcpkg didn’t have syntax for libraries to express a dependency upon a port built for that environment. We’ve gotten very far with imperfect approaches, like dynamically attempting to consume libraries from a hardcoded set of fallback triplets, however these would always fall short of the ideal and required imperfect, copied code between different ports. These workarounds also fall completely flat in <a href="https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/">manifest mode</a>, which is specifically designed to prevent the flaky behaviors that occur with these sorts of “dynamic” accesses. The fix is, of course, a way to naturally and directly express a requirement upon ports built for the developer environment.</p>
<p><strong>Enter: Host Dependencies. Available now, ports and consumers can now declare dependencies upon other ports built against the developer environment.</strong></p>
<p>The syntax to activate this is simply setting <code>"host"</code> to <code>true</code> in the manifest dependency object:</p>
<pre class="prettyprint">{
    "dependencies": [
        { "name": "contoso-cgen", "host": true }
    ]
}</pre>
<p>During execution, a port can rely on all host dependencies having been installed to <code>CURRENT_HOST_INSTALLED_DIR</code> (the analog of <code>CURRENT_INSTALLED_DIR</code>) and they can get the currently configured host triplet via <code>HOST_TRIPLET</code> (the analog of <code>TARGET_TRIPLET</code>).</p>
<pre class="prettyprint">set(CGEN ${CURRENT_HOST_INSTALLED_DIR}/tools/contoso-cgen/cgen${VCPKG_HOST_EXECUTABLE_SUFFIX})
vcpkg_cmake_configure(
    SOURCE_PATH ${SOURCE_PATH}
    OPTIONS -DCODE_GENERATOR=${CGEN}
)</pre>
<p>For projects that have their own code generators embedded inside, it’s perfectly valid to require <em>yourself</em> built for the host:</p>
<pre class="prettyprint">{
    "name": "protobuf",
    "dependencies": [
        { "name": "protobuf", "host": true }
    ]
}</pre>
<p>Then, the port can determine if it is cross-building or native-building by comparing the triplets:</p>
<pre class="prettyprint">if(HOST_TRIPLET STREQUAL TARGET_TRIPLET)
  # Native compilation, set build flags to build and install the code generator
else()
  # Cross compilation, set build flags to consume the prebuilt code generator
  # from ${CURRENT_HOST_INSTALLED_DIR}
endif()</pre>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback!</h3>
<p>Try out vcpkg by visiting our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. We welcome your feedback on the tool and the new features <a href="https://github.com/microsoft/vcpkg/issues">in our issue tracker</a>. </p>
<p>We&#8217;ve only just begun incorporating this powerful new facility into the existing catalog, such as for Boost.Build (<a href="https://github.com/microsoft/vcpkg/blob/b5bb1511f0a07be530e0bde3ae098eb3d8e83e68/ports/boost-date-time/vcpkg.json#L10-L13">vcpkg/vcpkg.json at master · microsoft/vcpkg (github.com)</a>) and Protobuf (<a href="https://github.com/microsoft/vcpkg/blob/b5bb1511f0a07be530e0bde3ae098eb3d8e83e68/ports/protobuf/vcpkg.json#L8-L11">vcpkg/vcpkg.json at master · microsoft/vcpkg (github.com)</a>). It&#8217;s an enormous step forward for vcpkg users targeting important platforms such as iOS, Android, and Emscripten/WebAssembly.</p>
<p>The current up-to-date documentation on Host Dependencies can be found on our GitHub at <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/host-dependencies.md">vcpkg/host-dependencies.md at master · microsoft/vcpkg (github.com)</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/">vcpkg Host Dependencies for Cross-Compilation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 16.9</title>
		<link>https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/</link>
					<comments>https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/#comments</comments>
		
		<dc:creator><![CDATA[Jordan Maples]]></dc:creator>
		<pubDate>Wed, 17 Mar 2021 10:58:32 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[Writing Code]]></category>
		<category><![CDATA[cppcorecheck]]></category>
		<category><![CDATA[static analysis]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27707</guid>

					<description><![CDATA[<p>The C++ static analysis team&#8217;s goal is to make your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/">Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 16.9</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team&#8217;s goal is to make your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">C++ Developer Community</a> page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Going forward, the C++ team will provide a list of code analysis bug and crash fixes with every GA release of Visual Studio. Below is the compilation of improvements and bug fixes that were made from VS 2019 16.8 to 16.9 for <a href="https://docs.microsoft.com/en-us/cpp/build/reference/analyze-code-analysis">code analysis</a> and <a href="https://docs.microsoft.com/en-us/cpp/code-quality/using-the-cpp-core-guidelines-checkers">Cpp Core Check</a>.</p>
<h3 id="analysis-crash-fixes">Analysis crash fixes:</h3>
<ul>
<li>Using an index operator on the address of a non-address and non-array object.</li>
</ul>
<pre class="prettyprint">void function() {
    int buf{};
    ((unsigned char*)&amp;buf)[3] = 1;
}</pre>
<ul>
<li>Functions with more than 255 arguments would cause a crash during analysis.</li>
<li>Array member field addresses were incorrectly converted in dynamic initializer function.</li>
<li>Fixed internal compiler error for aggregate initialization in /analyze.</li>
</ul>
<pre class="prettyprint">char c[]{'1', {}};</pre>
<ul>
<li>Fixed a crash caused during analysis of bitfields and enums.</li>
</ul>
<pre class="prettyprint">struct TestStruct {
public:
    enum TestEnum : char { Dummy };
    TestEnum    m1 : 1;
    TestEnum    m2 : 1;
    short       m3;
}

TestStruct Test() {
    return{ TestStruct::Dummy, TestStruct::Dummy, {} };
}</pre>
<ul>
<li>Specifying an array of three elements but only providing two elements in the initializer list.</li>
</ul>
<pre class="prettyprint">#include &lt;array&gt;
#include &lt;string&gt;
using namespace std;
void function() {
    array&lt;string, 3&gt; arr {"one", "two"};
}</pre>
<ul>
<li>Fixed crash on empty KMDF projects.</li>
</ul>
<h3 id="bug-fixes">Bug fixes:</h3>
<ul>
<li>Addressed noisy warnings in an object&#8217;s destructor when a function that would have initialized or updated the object fails.</li>
<li>Support for the GSL functions <code>gsl::as_bytes</code> and <code>gsl::as_writable_bytes</code> was added to prevent <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26710">C26710</a> warnings from being issued against otherwise valid buffer accesses.</li>
</ul>
<pre class="prettyprint">#include &lt;gsl/span&gt;
void fn1(gsl::span&lt;int, 5&gt; view, byte val) {
    auto bview = as_writable_bytes(view);
    bview[19] = val;  // OK
    bview[20] = val;  // C26710 &amp; C26000
}</pre>
<ul>
<li>Fixed ruleset loading failures that occurred when a relative path of a ruleset was used in combination with the exact path of a ruleset directory.
E.g: <code>/analyze:rulesetdirectory f:\customRuleset /analyze:ruleset myrules.ruleset</code></li>
<li>Fixed false positives of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c6237">C6237</a> and <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c6285">C6285</a> on <code>if constexpr</code> expressions.</li>
</ul>
<pre class="prettyprint">constexpr bool get_condition_a() { return false; }
constexpr bool some_other_check() { return true; }
constexpr void f1() {
    constexpr bool some_condition = get_condition_a();
    if constexpr (some_condition &amp;&amp; some_other_check()) {  //Previously issued C6237
        //...
    }
}

constexpr void f2() {
    constexpr int print_debug = false;
    constexpr int headers_debug = false;
    if constexpr (print_debug == true || headers_debug == true) { //Previously issued C6285
        //...
    }
}</pre>
<ul>
<li>Fixed false positive of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26444">C26444</a> when returning upon construction.</li>
</ul>
<pre class="prettyprint">struct Test {
    int i{};
};

Test foo() {
    return Test(); //Previously issued C26444
}</pre>
<ul>
<li>Fixed issue where casts with the same source and destination types were being misidentified as reinterpret cast, which would produce <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26490">C26490</a> instead of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26473">C26473</a>.</li>
</ul>
<pre class="prettyprint">struct S{};
void foo(S* s) {
    S* s2 = static_cast&lt;S*&gt;(s); //Previously C26490, now C26473
}</pre>
<ul>
<li>Fixed an incorrect <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26465">C26465</a> warning when attempting to cast away const. <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26492">C26492</a> will now be issued instead.</li>
</ul>
<pre class="prettyprint">struct S{};
void foo(const S&amp; s) {
    const S* pS = &amp;s;
    S* s2 = const_cast&lt;S*&gt;(pS); //Previously C26465, now C26492
}</pre>
<ul>
<li>Fixed false positive for <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26814">C26814</a> that would be issued on <code>const</code> member variables.</li>
<li>Fixed corner case where PREFast entered an infinite loop while examining buffer extents.</li>
<li>Fixed false positive of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26815">C26815</a> that fired when assigning a value to a <code>std::optional</code> that is passed by reference into a function.</li>
<li>Fixed false positive <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26816">C26816</a> when returning a pointer from a vector of pointers.</li>
<li>Fixed false positive of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26485">C26485</a> which appeared when calls to printf used string literals chosen by a ternary operator.</li>
</ul>
<h3 id="additional-changes">Additional changes:</h3>
<ul>
<li>Updated support for SARIF format to conform to the version 2.1 specification.</li>
<li>Added SARIF support for additional rule action levels for ruleset files.
The rule actions can now be specified as “None”, “Default”, “Info”, “Warning”, and “Error”.</li>
<li>Removed <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26443">C26443</a> – The enforcement for <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final">C.128</a> has changed making C26443 obsolete.</li>
</ul>
<pre class="prettyprint">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RuleSet Name="Example For Warning Levels" Description="" ToolsVersion="16.0"&gt;
  &lt;IncludeAll Action="Info" /&gt;
  &lt;Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis"
         RuleNamespace="Microsoft.Rules.Native"&gt;
    &lt;Rule Id="C6001" Action="Error" /&gt;
    &lt;Rule Id="C6011" Action="Warning" /&gt;
    &lt;Rule Id="C6101" Action="Info" /&gt;
    &lt;Rule Id="C6201" Action="Default" /&gt;
    &lt;Rule Id="C6386" Action="None" /&gt;
  &lt;/Rules&gt;
&lt;/RuleSet&gt;</pre>
<ul>
<li>Using a C-style void cast to ignore return values decorated with <code>[[nodiscard]]</code> previously issued <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26493">C26493</a> urging developers to not use C-style casts. The new rule <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26457">C26457</a> will be issued in its place, guiding the developer to assign the return value to <code>std::ignore</code> if they intend to discard the return value.</li>
</ul>
<pre class="prettyprint">#include &lt;tuple&gt;

struct S{};
[[nodiscard]] S fn1();

void function() {
    (void)fn1(); //Previously C26493, now C26457
    std::ignore = fn1();
}</pre>
<ul>
<li>The text for <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26496">C26496</a> was updated from <code>“The variable '%variable%' is assigned only once, mark it as const (con.4)”</code> to <code>“The variable '%variable%' does not change after construction, mark it as const (con.4)”.</code></li>
</ul>
<p>As mentioned earlier, the work that we do is heavily influenced by feedback we receive on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check.</p>
<p>Stay tuned for more C++ static analysis blogs as we work towards 16.10. Coming soon are posts on improvements to C++ Core Check rules, improved diagnostics, and an update on the Microsoft/GSL GitHub project. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/">Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 16.9</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/feed/</wfw:commentRss>
			<slash:comments>17</slash:comments>
		
		
			</item>
	</channel>
</rss>
