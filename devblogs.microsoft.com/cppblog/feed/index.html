<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Tue, 21 Dec 2021 18:04:52 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Visual Studio Code C++ December 2021 Update: clang-tidy</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Tue, 14 Dec 2021 19:26:50 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++ extension]]></category>
		<category><![CDATA[clang]]></category>
		<category><![CDATA[clang-tidy]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[CPP]]></category>
		<category><![CDATA[cpptools]]></category>
		<category><![CDATA[linter]]></category>
		<category><![CDATA[static analysis]]></category>
		<category><![CDATA[tidy]]></category>
		<category><![CDATA[vs code]]></category>
		<category><![CDATA[VSCode]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29926</guid>

					<description><![CDATA[<p>The latest insiders release of the C++ extension is here, bringing clang-tidy support to VS Code! Clang-tidy is a clang-based C++ linter tool that detects common errors in your code, like style violations and bugs that can be deduced via static analysis.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/">Visual Studio Code C++ December 2021 Update: clang-tidy</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The latest <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.8.0-insiders2">insiders release</a> of the C++ extension is here, bringing clang-tidy support to VS Code! <a href="https://clang.llvm.org/extra/clang-tidy/">Clang-tidy</a> is a clang-based C++ linter tool that detects common errors in your code, like style violations and bugs that can be deduced via static analysis. <a href="https://github.com/microsoft/vscode-cpptools/issues/2908">Clang-tidy integration</a> was one of our top asks on GitHub, so we’re excited to announce that it’s ready for you to try!</p>
<h1 id="getting-started">Getting started</h1>
<h2 id="do-i-need-to-install-clang-tidy">Do I need to install clang-tidy?</h2>
<p>Nope! Clang-tidy now comes bundled with the C++ extension. But if you already have clang-tidy installed (and it’s on your environment’s path), the C++ extension will use that one instead. You can point the C++ extension to any clang-tidy binary by editing the C++ extension’s <strong>Clang Tidy: Path</strong> setting.</p>
<h2 id="how-do-i-run-clang-tidy-in-vs-code">How do I run clang-tidy in VS Code?</h2>
<p>To manually run clang-tidy, open the <strong>Command Palette (Ctrl + Shift + P)</strong> and type <strong>“Run Code Analysis.” </strong>You can run clang-tidy on the active file, on all open files, or on the entire workspace.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png"><img class="alignnone size-full wp-image-29937" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png" alt="Screenshot showing how to manually run clang-tidy from the Command Palette" width="2024" height="380" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png 2024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-300x56.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-1024x192.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-768x144.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-1536x288.png 1536w" sizes="(max-width: 2024px) 100vw, 2024px" /></a></p>
<p>If there are certain workspace files or folders that you <em>don’t</em> want to run clang-tidy on, add them to the <strong>Clang Tidy: Exclude</strong> setting (C_Cpp.codeAnalysis.exclude in settings.json).</p>
<p>You can also set clang-tidy to run automatically whenever you open or save a file. To turn on automatic code analysis, open your project settings by selecting <strong>“Preferences: Open Settings (UI)”</strong> from the <strong>Command Palette (Ctrl + Shift + P).</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png"><img class="alignnone size-full wp-image-29936" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png" alt="Screenshot showing how to open VS Code settings from the Command Palette" width="1742" height="184" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png 1742w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-300x32.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-1024x108.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-768x81.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-1536x162.png 1536w" sizes="(max-width: 1742px) 100vw, 1742px" /></a></p>
<p>Then search for <strong>“code analysis” </strong>to find all the clang-tidy settings and set <strong>Clang Tidy: Enabled</strong> to true.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png"><img class="alignnone size-full wp-image-29929" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png" alt="Screenshot of the Clang Tidy: Enabled setting in VS Code, which must be set to true in order for code analysis to run automatically in the background" width="1770" height="284" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png 1770w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-300x48.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-1024x164.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-768x123.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-1536x246.png 1536w" sizes="(max-width: 1770px) 100vw, 1770px" /></a></p>
<p><strong>Note:</strong> You can set clang-tidy settings globally (in the User tab) or at the workspace level.</p>
<p>You can check if clang-tidy is running by looking for the fire icon in the blue status bar at the bottom of the window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png"><img class="alignnone size-full wp-image-29935" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png" alt="Screenshot of the fire icon in the status bar. Users can hover over this icon to see the status of clang-tidy." width="590" height="192" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png 590w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover-300x98.png 300w" sizes="(max-width: 590px) 100vw, 590px" /></a></p>
<p>To pause or cancel clang-tidy, click on the fire icon and then choose an option from the drop down.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png"><img class="alignnone size-full wp-image-29927" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png" alt="Screenshot showing the Cancel and Pause options for clang-tidy from a dropdown in VS Code" width="1746" height="242" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png 1746w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-300x42.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-1024x142.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-768x106.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-1536x213.png 1536w" sizes="(max-width: 1746px) 100vw, 1746px" /></a></p>
<h2 id="how-do-i-configure-clang-tidy-checks-and-check-options">How do I configure clang-tidy checks and check options?</h2>
<p>If you have a .clang-tidy configuration file in your project directory, the C++ extension will honor the checks and options defined in that file. If you have multiple .clang-tidy configuration files in your workspace, clang-tidy will use the configuration file closest to the source file by searching up the path in its parent directories. Alternatively, you can specify a clang-tidy configuration with the <strong>Clang Tidy: Config</strong> setting. <strong>Clang Tidy: Config</strong> accepts checks and check options as a YAML/JSON-formatted string.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png"><img class="alignnone size-full wp-image-29928" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png" alt="Screenshot of the Clang Tidy: Config setting in VS Code, where users can pass a string in YAML/JSON format to specify clang-tidy checks and options" width="1860" height="376" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png 1860w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-300x61.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-1024x207.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-768x155.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-1536x311.png 1536w" sizes="(max-width: 1860px) 100vw, 1860px" /></a></p>
<p>If a source file doesn’t have a .clang-tidy configuration file in any of its parent directories, and the <strong>Clang Tidy: Config</strong> property is left empty, then the fallback configuration (defined in C_Cpp.codeAnalysis.clangTidy.fallbackConfig) will be used for that file.</p>
<p>You can enable and disable more checks by using the <strong>Clang Tidy &gt; Checks: Enabled</strong> and <strong>Clang Tidy &gt; Checks: Disabled</strong> settings. The checks defined in these settings are run in addition to the checks in the .clang-tidy file.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png"><img class="alignnone size-full wp-image-29934" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png" alt="Screenshot of the Clang Tidy &gt; Checks: Enabled setting in VS Code, where users pick which clang-tidy settings to run on their project" width="1558" height="504" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png 1558w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-300x97.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-1024x331.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-768x248.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-1536x497.png 1536w" sizes="(max-width: 1558px) 100vw, 1558px" /></a></p>
<p>Selecting <strong>Add Item</strong> shows a list of all clang-tidy checks.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png"><img class="alignnone size-full wp-image-29940" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png" alt="Screenshot showing the list of available clang-tidy checks after selecting Add Item in the Clang Tidy &gt; Checks: Enabled settings" width="1630" height="1162" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-300x214.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-1024x730.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-768x547.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-1536x1095.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></a></p>
<p>You can add as many checks as you’d like to both the <strong>Clang Tidy &gt; Checks: Enabled</strong> and <strong>Clang Tidy &gt; Checks: Disabled</strong> settings.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png"><img class="alignnone size-full wp-image-29933" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png" alt="Screenshot of the Clang Tidy &gt; Checks: Disabled and Clang Tidy &gt; Checks: Disabled settings in VS Code, where users can choose which clang-tidy checks to run or not run for their workspace" width="1602" height="1244" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png 1602w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-300x233.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-1024x795.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-768x596.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-1536x1193.png 1536w" sizes="(max-width: 1602px) 100vw, 1602px" /></a></p>
<h2 id="how-do-i-pass-command-line-args-to-clang-tidy">How do I pass command line args to clang-tidy?</h2>
<p>If you typically pass <a href="https://clang.llvm.org/extra/clang-tidy/">command line options</a> to clang-tidy, you can specify those in the <strong>Clang Tidy: Args</strong> property. The <strong>Clang Tidy: Args</strong> setting takes precedence over the equivalent Clang Tidy settings in the editor (such as Clang Tidy &gt; Checks: Enabled and Clang Tidy &gt; Checks: Disabled).</p>
<h1 id="viewing-check-results-in-the-editor">Viewing check results in the editor</h1>
<p>The results of clang-tidy checks (warnings and errors) are displayed in the <strong>Problems panel</strong> and as squiggles beneath relevant sections of code.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png"><img class="alignnone size-full wp-image-29930" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png" alt="Screenshot of the results of clang-tidy checks showing up in the Problems pane in VS Code" width="1646" height="1312" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png 1646w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-300x239.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-1024x816.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-768x612.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-1536x1224.png 1536w" sizes="(max-width: 1646px) 100vw, 1646px" /></a></p>
<p>Clicking on the problem in the Problems panel takes you to the issue in your source file. To clear the code analysis squiggles, click on the Quick Actions lightbulb, and then select <strong>Clear code analysis squiggles.</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png"><img class="alignnone size-full wp-image-29931" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png" alt="Screenshot of the &quot;Clear Code Analysis Squiggles&quot; Quick Action, which is visible when selecting the lightbulb next to underlined code " width="1172" height="388" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png 1172w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-300x99.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-1024x339.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-768x254.png 768w" sizes="(max-width: 1172px) 100vw, 1172px" /></a></p>
<h1 id="clang-tidy-settings">Clang-tidy settings</h1>
<p>Here’s a list of new VS Code settings to help you configure clang-tidy for your workspace.</p>
<table>
<tbody>
<tr>
<td width="282"><strong>Setting name</strong></td>
<td width="60"><strong>Type</strong></td>
<td width="84"><strong>Default value</strong></td>
<td width="198"><strong>Description</strong></td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.enabled</p>
<p>&nbsp;</td>
<td width="60">Boolean</td>
<td width="84">False</td>
<td width="198">When true, clang-tidy will be enabled and run automatically if C_Cpp.codeAnalysis.runAutomatically is set to true</p>
<p>&nbsp;</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.runAutomatically</td>
<td width="60">Boolean</td>
<td width="84">True</td>
<td width="198">When true, runs clang-tidy on file open and file save.</p>
<p>&nbsp;</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.path</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">The full path to the clang-tidy executable.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.checks.enabled</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">List of enabled clang-tidy checks. The values are appended to the Checks in a .clang-tidy file or C_Cpp › Code Analysis › Clang Tidy: Config.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.checks.disabled</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">List of disabled clang-tidy checks. The values are appended to the Checks in a .clang-tidy file or C_Cpp › Code Analysis › Clang Tidy: Config, if any.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.config</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Specifies a clang-tidy configuration in YAML/JSON format: {Checks: &#8216;-*,clang-analyzer-*&#8217;, CheckOptions: [{key: x, value: y}]}. When empty, any found .clang-tidy files will be used.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.fallbackConfig</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Specifies a clang-tidy configuration in YAML/JSON format to be used as a fallback when C_Cpp › Code Analysis › Clang Tidy: Config is not set and no .clang-tidy file is found.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.args</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">Command line arguments to pass to clang-tidy. These take precedence over the equivalent C_Cpp.codeAnalysis.clangTidy.* settings.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.exclude</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Configure glob patterns for excluding folders and files for code analysis.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.headerFilter</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">A POSIX extended regular expression (ERE) matching the names of the headers to output diagnostics from. It overrides the HeaderFilterRegex option in a .clang-tidy file, if any.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.maxConcurrentThreads</p>
<p>(User level only)</td>
<td width="60">Int</td>
<td width="84">Null (empty)</td>
<td width="198">The maximum number of concurrent threads to use for code analysis. The default of null (empty) uses half the value inherited from C_Cpp: Max Concurrent Threads.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.maxMemory</p>
<p>(User level only)</td>
<td width="60">Int</td>
<td width="84">Null (empty)</td>
<td width="198">Fewer code analysis processes will run concurrently after this memory usage (in MB) is exceeded. The default of null (empty) uses the value inherited from C_Cpp: Max Memory.</td>
</tr>
</tbody>
</table>
<h1 id="coming-soon">Coming soon</h1>
<p>Hang tight! Applying suggested fixes in the editor is coming soon.</p>
<h1 id="what-do-you-think">What do you think?</h1>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today and join our Insiders program to access this initial release of clang-tidy integration. To join our Insiders program, go to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/">Visual Studio Code C++ December 2021 Update: clang-tidy</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>The /fp:contract flag and changes to FP modes in VS2022</title>
		<link>https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/#respond</comments>
		
		<dc:creator><![CDATA[Gautham Beeraka (Intel Americas Inc)]]></dc:creator>
		<pubDate>Tue, 14 Dec 2021 00:25:13 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[Floating Point]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29915</guid>

					<description><![CDATA[<p>The /fp:contract flag and changes to FP modes in VS2022<br />
In this blog we will cover a new feature we have added to the MSVC version 17.0 compiler in VS2022 that impacts the generation of Floating-Point contractions such as Fused Multiply Add (FMA) instructions.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022">The /fp:contract flag and changes to FP modes in VS2022</h1>
<p>In this blog we will cover a new feature we have added to the MSVC version 17.0 compiler in VS2022 that impacts the generation of Floating-Point contractions such as Fused Multiply Add (FMA) instructions. We will cover how FMA contractions are supported in pre-VS2022 MSVC compiler releases, a new /fp:contract flag and changes to existing Floating-Point pragmas in VS2022 MSVC compiler allowing explicit control over generation of contractions</p>
<p>A contraction, as used here, is where two operations in the source code are performed by a single instruction in the executable code. Examples are Fused Multiply-Add (FMA) and reciprocal square root. The former computes ((a * b) + c), while the later computes (1/sqrt(a)). The advantages of contractions are increased speed of calculations involved and decrease in the code size of your application. The reason you might not want to use a contraction is because the intermediate result isn’t rounded, so the result might differ slightly from what you would get from separate instructions. That is often not a problem, but we’re particular about what we mean by “precise” and don’t want to promise something we’re not delivering. Giving you control over whether contractions are used or not gives the best of both worlds, where you can get consistent results when you need them and can use contractions when you don’t.</p>
<h2 id="pre-vs2022-behavior-for-contractions">Pre-VS2022 behavior for contractions</h2>
<p>In the versions of Visual Studio prior to VS2022, under the default FP mode of /fp:precise, the generation of contractions was inconsistent. This inconsistency was between different platforms and between scalar and vector versions of FMAs. The compiler could generate both scalar and vector versions of FMAs on the ARM and ARM64 platforms. On x86 and x64 platforms supporting FMA instructions, the compiler could only generate vector FMA instructions. We are addressing this inconsistency and updating the documentation on FP modes in VS2022.</p>
<h2 id="vs2022-behavior-for-contractions">VS2022 behavior for contractions</h2>
<p>Although contractions tend to improve the performance of your application, they can produce inconsistent results between debug and release builds and ISA targeting (example: SSE2 vs AVX2) and may result in breaking existing assumptions in test coverage. To account for this and address the aforementioned inconsistency, contractions will not be generated by default under the /fp:precise mode on all platforms starting from VS2022 version 17.0. We have introduced a new /fp:contract flag which can be used along with /fp:precise to enable contractions. The /fp:contract flag will enable both vector and scalar contractions on all platforms. The /fp:contract flag and the updated behavior for /fp:precise is documented <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fp-specify-floating-point-behavior?view=msvc-170">here</a>. The table below summarizes the behavior for VS2022.</p>
<table>
<tbody>
<tr>
<td><strong>Compiler FP-mode flag</strong></td>
<td><strong>VS2022 17.0 default behavior</strong></td>
<td><strong>VS2022 17.0 behavior with /fp:contract</strong></td>
</tr>
<tr>
<td>/fp:strict</td>
<td>No contractions</td>
<td>Incompatible (compiler error)</td>
</tr>
<tr>
<td>/fp:precise</td>
<td>No contractions</td>
<td>Allow contractions</td>
</tr>
<tr>
<td>/fp:fast</td>
<td>Allow contractions</td>
<td>Allow contractions</td>
</tr>
</tbody>
</table>
<p>The behavior of Floating-Point pragmas was also modified to agree with the behavior of the Floating-Point flags. The float_control pragmas will now disable contractions when turned on and will restore the previous setting for contractions when turned off. This new behavior is documented for <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/float-control?view=msvc-170">float_control</a>, <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/fenv-access?view=msvc-170">fenv_access</a> and <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/fp-contract?view=msvc-170">fp_contract</a> pragmas.</p>
<p>With this new behavior, there can be performance regressions since contractions are no longer generated by default. Adding the /fp:contract flag should mitigate this. The behavior of contractions can be further controlled at a function level using the Floating-Point pragmas.</p>
<p>Note that intrinsic functions such as: fma<em>, </em>fmaf<em> and </em>fmal can still be used to generate FMA machine instructions if the target architecture supports them.</p>
<h2 id="how-to-enable-fpcontract-in-vs2022">How to enable /fp:contract in VS2022</h2>
<p>To enable /fp:contract for your project:</p>
<p>In Visual Studio, add the /fp:contract option in the Additional Options box (Project|Properties|Configuration Properties|C/C++|Command Line|Additional Options)</p>
<p><img width="796" height="553" class="wp-image-29916" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1.png" alt="Graphical user interface, text, application, email Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1.png 796w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1-768x534.png 768w" sizes="(max-width: 796px) 100vw, 796px" /></p>
<p>Figure 1. Add the /fp:contract compiler option for each desired configuration.</p>
<p>Since generation of contractions is an optimization, adding the /fp:contract flag may not produce contractions for debug builds.</p>
<p>If you are upgrading your project from VS2019 to VS2022 and see different floating-point results, these are the things you should check:</p>
<ul>
<li>If your code is built with /fp:fast, this can be the expected behavior. /fp:fast allows the compiler to optimize things more aggressively with some loss in FP precision. More optimizations are likely firing in this case.</li>
<li>If your code is built with /fp:precise (or no /fp model is specified), try throwing /fp:contract to confirm if contractions were the cause of the FP changes. If it was, see if that makes sense for your scenario to continue to throw /fp:contract.</li>
<li>If your code is built with /fp:strict then <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">let us know</a>, there may be a compiler bug.</li>
</ul>
<h2 id="closing-notes">Closing Notes</h2>
<p>We’d love for you to download <a href="https://visualstudio.microsoft.com/vs/">Visual Studio 2022</a> and give it a try to see how the changes described above affect your applications. Your feedback is key to deliver the best experience. If you have any questions, please feel free to ask us below. You can also send us your comments through <a href="mailto:visualcpp@microsoft.com">e-mail</a>. If you encounter problems with the experience or have suggestions for improvement, please <a href="mailto:https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report A Problem</a> or reach out via <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">Developer Community</a>. You can also find us on Twitter <a href="mailto:https://twitter.com/visualc">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/#respond</comments>
		
		<dc:creator><![CDATA[John Morgan (Intel Corporation)]]></dc:creator>
		<pubDate>Mon, 13 Dec 2021 22:48:48 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Compatibility]]></category>
		<category><![CDATA[conformance]]></category>
		<category><![CDATA[Conversion]]></category>
		<category><![CDATA[Floating Point]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29902</guid>

					<description><![CDATA[<p>Microsoft Visual Studio 2022 and Floating-point to Integer Conversions<br />
Quick Summary:</p>
<p>/QIfist is going away<br />
MSVC is compatible with Standard C++ for all floating-point to integer conversions<br />
For floating-point to signed integer conversions nothing changed<br />
VS2022 is compatible with VS2017 and earlier by default for all floating-point to integer conversions<br />
For floating-point to unsigned integer conversions in VS2019:</p>
<p>When targeting x64,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/">Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="microsoft-visual-studio-2022-and-floating-point-to-integer-conversions">Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</h1>
<h2 id="quick-summary">Quick Summary:</h2>
<ul>
<li>/QIfist is going away</li>
<li>MSVC is compatible with Standard C++ for all floating-point to integer conversions</li>
<li>For floating-point to signed integer conversions nothing changed</li>
<li>VS2022 is compatible with VS2017 and earlier by default for all floating-point to integer conversions</li>
<li>For floating-point to unsigned integer conversions in VS2019:
<ul>
<li>When targeting x64, it is usually compatible with VS2017</li>
<li><span style="font-size: 1rem;">When targeting x86, it is usually compatible with AVX-512</span></li>
<li>Version 16.7 and later can use /fpcvt:BC for VS2017 compatibility and /fpcvt:IA for AVX-512 compatibility</li>
</ul>
</li>
<li><span style="font-size: 1rem;">Intrinsic functions give you more options and better control</span></li>
</ul>
<p>See also the MSDN documentation on /fpcvt <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fpcvt?view=msvc-170">here</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>As some of you may be aware, Microsoft Visual Studio 2019 changed some floating-point to integer conversions for Intel Architecture (IA). When targeting 32-bit IA (x86), most conversions match the Intel AVX-512 conversion instructions. For signed integers this is the same as Visual Studio 2017. With unsigned integers the results of invalid conversions can be different, as I will explain later. With 64-bit IA (x64), the AVX-512 instructions are used when /arch:AVX512 is selected, but otherwise there was no change from VS2017. Unfortunately, we did not announce this change and we didn’t provide an option for backward compatibility until version 16.7.</p>
<p>By default, Visual Studio 2022 reverts back to the way Visual Studio 2017 handled these conversions. It also keeps the option of using conversions compatible with AVX-512. This post tells you more about this, including other options you might want to use.</p>
<h2 id="background">Background</h2>
<p>Standard C++ specifies how valid conversions work, but invalid conversions can do anything at all. Valid conversions start by truncating the floating-point value, which discards any fractional part and leaves only the integer value. This is also known as &#8220;rounding toward zero&#8221;. The conversion is valid if the truncated value can be represented in the result type, and the result must be that value. MSVC has been compatible with this for well over a decade, and only invalid conversions to unsigned types have changed.</p>
<p>Most floating-point operations indicate an invalid operation by returning a special &#8220;Not-a-Number&#8221; (NaN) value, but conversion to integer doesn&#8217;t allow that option. Any result value can come from a valid conversion, and t<span style="font-size: 1rem;">here is no single “correct” result for an invalid conversion. </span>Of course, completely random results for such conversions aren&#8217;t useful, so two different approaches are commonly used. Intel Architecture (IA) uses the result value farthest from zero as a substitute for NaN, so that any invalid conversion returns this <em>sentinel</em> value. (The specific value returned depends on the result type.) The sentinel value is easy to test for, and it will often cause distinctive behavior during testing and debugging.</p>
<p>The other common approach is called <em>saturation</em>, where any floating-point value too high to fit in the destination type gives the highest possible destination value, and any value too low to fit gives the lowest possible value. If the source value is NaN, zero will be returned for the result. Even if the result is wrong, it is as close as possible to the correct result and may be less likely to cause failures. ARM uses saturation for its conversion instructions.</p>
<h2 id="conversions-with-visual-studio-2017">Conversions with Visual Studio 2017</h2>
<p>Intel Architecture has had instructions to convert from floating-point to signed integer types since before the first IBM PC, but instructions to convert to unsigned integer types were first introduced in AVX-512.  Up through Visual Studio 2017, conversions to unsigned integer types are based on conversion to type <em>long long</em>. Converting to <em>unsigned</em> first converts to <em>long long</em> and then truncates to 32 bits. When converting to <em>unsigned long long</em>, valid source values that are too high for <em>long long</em> are handled as a special case. All other values are simply converted to <em>long long</em> and recast. This gets around the lack of unsigned conversion instructions, but the values returned for invalid conversions aren’t especially useful.</p>
<h2 id="conversions-with-visual-studio-2019">Conversions with Visual Studio 2019</h2>
<p>For VS2019, we intended to make all FP to integer conversions compatible with the corresponding Intel Architecture conversion instructions. That allows using VCVTTSD2USI and VCVTTSS2USI when /arch:AVX512 is selected with no change in behavior. Unfortunately, this change was a bit more difficult than we expected and some cases were not completed. It is only enabled on x64 when /arch:AVX512 is selected. On x86 it was not enabled when /arch:IA32 or /arch:SSE is selected. In addition, on x86 the behavior of a conversion of a floating-point value returned from a function call could be either way. Although this was still compatible with Standard C++, it was obviously undesirable, and we introduced the /fpcvt option to allow developers to select which behavior they want.</p>
<h2 id="the-fpcvt-compilation-option">The /fpcvt Compilation Option</h2>
<p>Starting with Visual Studio 2019 version 16.7, the <em>/fpcvt</em> compilation option controls the results of floating-point to unsigned integer conversions. There are two selections: <em>/fpcvt:BC</em> which specifies the backward compatible VS2017 behavior, and <em>/fpcvt:IA</em> which specifies the new AVX-512 instruction behavior. This option works with either x86 or x64 targets, and it applies whether or not <em>/arch:AVX512</em> is specified. With VS2022 the default has changed to be the same as <em>/fpcvt:BC</em>, but the <em>/fpcvt:IA</em> selection is still available for both x86 and x64.</p>
<h2 id="intrinsic-functions-for-conversion">Intrinsic Functions for Conversion</h2>
<p>There are three problems that the <em>/fpcvt</em> option does not address:</p>
<ul>
<li>It applies to all compiled conversions, even where that isn’t the best option.</li>
<li>It applies to headers and source code modules that may have been written to expect other behavior.</li>
<li>Neither <em>/fpcvt</em> option generates saturating conversions. Saturation provides compatibility with languages such as Rust and WebAssembly, as well as code compiled to target ARM.</li>
</ul>
<p>Visual Studio 2022 provides intrinsic functions to address these issues. These sentinel and saturating conversion functions are fully defined on IA, so the behavior doesn’t change due to compilation settings or context.</p>
<p>In addition to these functions, there are fast conversion functions which execute as quickly as possible for valid conversions. Unlike the saturating and sentinel conversions, these are not fully defined, and may generate different values or exceptions for invalid conversions depending on target platform, compilation settings and context. They are useful for handling values that have already been range-checked or values that are generated in a manner that can never cause an invalid conversion.</p>
<table style="width: 99.2273%;">
<tbody>
<tr>
<td style="width: 33.2273%;">Fast conversion functions</td>
<td style="width: 33.3863%;">Saturating conversion functions</td>
<td style="width: 136.363%;">Sentinel conversion functions</td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>int </code>
<code><strong>_cvt_ftoi_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>int </code>
<code><strong>_cvt_ftoi_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>int </code>
<code><strong>_cvt_ftoi_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>long long </code>
<code><strong>_cvt_ftoll_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>long long </code>
<code><strong>_cvt_ftoll_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>long long </code>
<code><strong>_cvt_ftoll_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned </code>
<code><strong>_cvt_ftoui_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned </code>
<code><strong>_cvt_ftoui_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned </code>
<code><strong>_cvt_ftoui_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_ftoull_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_ftoull_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_ftoull_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>int </code>
<code><strong>_cvt_dtoi_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>int </code>
<code><strong>_cvt_dtoi_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>int </code>
<code><strong>_cvt_dtoi_sent</strong> (double a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>long long </code>
<code><strong>_cvt_dtoll_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>long long </code>
<code><strong>_cvt_dtoll_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>long long </code>
<code><strong>_cvt_dtoll_sent</strong> (double a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned </code>
<code><strong>_cvt_dtoui_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned </code>
<code><strong>_cvt_dtoui_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned </code>
<code><strong>_cvt_dtoui_sent</strong> (double a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_dtoull_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_dtoull_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_dtoull_sent</strong> (double a);</code></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2 id="termination-of-qifist-support">Termination of /QIfist Support</h2>
<p>Visual Studio 2022 version 17.0 still supports the deprecated <em>/QIfist</em> option on x86, but we will remove it in an update. This option allowed floating-point to <strong>int</strong> conversions to round according to the current rounding mode (usually <em>round-to-nearest with ties to even</em>) instead of always truncating as specified in Standard C++. This option supports legacy code written on x86 before truncation was adopted as standard. It has never been supported on other target platforms and has been marked <em>deprecated</em> for many releases. Use intrinsic functions to round floating-point values before converting to integer, since this is clearer, faster, and more portable.</p>
<h2 id="closing-notes">Closing Notes</h2>
<p>We’d love for you to download <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2022</a> and see how these options can be used in your applications. Your feedback is key to deliver the best experience. If you have questions, please feel free to ask us below. You can also send us your comments through <a href="mailto:visualcpp@microsoft.com">email</a>. If you encounter problems with the experience or have suggestions for improvement, please <a href="mailto:https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report A Problem</a> or reach out via <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">Developer Community</a>. We are also found on Twitter <a href="mailto:https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/">Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Embedded Software Development in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 16:29:06 +0000</pubDate>
				<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29828</guid>

					<description><![CDATA[<p>We are happy to announce that we have added new embedded development capabilities to Visual Studio 2022 Preview. Used in conjunction with the new vcpkg artifact capabilities you can quickly bootstrap an embedded development machine and get started.<br />
In this post we will walk you through Visual Studio installation of the embedded workload,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Software Development in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that we have added new embedded development capabilities to <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2022 Preview</a>. Used in conjunction with the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifact capabilities</a> you can quickly bootstrap an embedded development machine and get started.</p>
<p>In this post we will walk you through Visual Studio installation of the embedded workload, how to acquire embedded tool dependencies with vcpkg, then demonstrate edit, build, deploy, and debugging directly in Visual Studio with new peripheral register and RTOS object views. We will demonstrate all of this with an Azure RTOS ThreadX project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png"><img class="alignnone wp-image-29829 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png" alt="VS embedded development screenshot" width="1712" height="1122" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png 1712w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-300x197.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-1024x671.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-768x503.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-1536x1007.png 1536w" sizes="(max-width: 1712px) 100vw, 1712px" /></a></p>
<p>Azure RTOS ThreadX is a widely used Real Time Operating System (RTOS) used on billions of microcontrollers (MCUs) in products around the world. We have dedicated pages for Visual Studio usage in the getting started guides for the <a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/VS.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/blob/master/NXP/MIMXRT1060-EVK/VS.md">NXP 1060</a>, and <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L4S5I-IOT01A/VS.md">STMicro STM32L4_L4+</a> boards. The techniques used for interacting with these boards should be applicable to other targets by changing configuration information.</p>
<h4 id="installation">Installation</h4>
<p>To get started install the latest preview release of Visual Studio 2022 and select the Linux and embedded development with C++ workload. The components you need are selected by default.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png"><img class="alignnone size-full wp-image-29830" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png" alt="Installation screen for embedded workload" width="910" height="460" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png 910w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded-300x152.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded-768x388.png 768w" sizes="(max-width: 910px) 100vw, 910px" /></a></p>
<p>One of the challenges in embedded development is getting the tools necessary installed and configured. It is not uncommon to have different compilers used for different projects, custom debug tools, etc. This is where the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts">artifact capabilities in vcpkg</a> can help us. Today we’ll demonstrate using vcpkg from a PowerShell prompt to activate our embedded development environment. In a future release this will be integrated into Visual Studio for a more seamless experience.</p>
<p>From a PowerShell prompt, clone the Azure RTOS getting started repo. This sample will serve as our example project for the remainder of this post.</p>
<pre class="prettyprint">git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Navigate to the subfolder for the board you are using, here I’m using the Azure IoT DevKit.</p>
<pre class="prettyprint">cd .\getting-started\MXChip\AZ3166\</pre>
<p>If you haven’t already, install vcpkg.</p>
<pre class="prettyprint">iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>In the project folder, there is a file vcpkg_configuration.json. This manifest file was created with vcpkg and has recorded the tools you need to build and debug this project. See <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts">the vcpkg artifacts post</a> for details on how to create your own manifest. Running the vcpkg activate command will use this file to determine if I have those tools, install them if I do not, then activate them in my environment for use.</p>
<pre class="prettyprint">vcpkg activate</pre>
<p>So, in three commands we have cloned our embedded project, installed vcpkg, acquired and activated the necessary tools for building the project.</p>
<h4 id="using-visual-studio-for-embedded-development">Using Visual Studio for embedded development</h4>
<p>In the previous section we used vcpkg to acquire the tools for our embedded project. Today vcpkg is not integrated in Visual Studio. So, at present we need to launch Visual Studio from the environment we activated at the command line so those tools are available for its use as well.</p>
<pre class="prettyprint">Start-Process devenv .</pre>
<p>Note that if you have more than one version of Visual Studio installed this may not launch the current preview, in that case you will need to use the full path to your preview installation, for example</p>
<pre class="prettyprint">C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\IDE\devenv</pre>
<p>Now that we have the project open in Visual Studio it is ready to go as any other CMake project. <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">Visual Studio can run the CMake build using the preconfigured CMakePresets file</a> with the compilers vcpkg acquired.</p>
<p>All the editing power of Visual Studio is now available for use with the embedded project. With this Azure RTOS project we’ll cover code navigation, IntelliSense, build, deploy, debugging. We will also cover new diagnostic capabilities around peripheral registers and RTOS object views.</p>
<h5 id="code-navigation-and-intellisense">Code Navigation and IntelliSense</h5>
<p>Use Ctrl + T to open Go to All and type button, select the button_a_callback function to navigate to it. Note on hover that this function expands to TIM3-&gt;CCR1 which is a peripheral register on the board which we’ll inspect while we are debugging.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png"><img class="alignnone size-full wp-image-29831" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png" alt="IntelliSense function expansion screenshot" width="763" height="471" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png 763w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd-300x185.png 300w" sizes="(max-width: 763px) 100vw, 763px" /></a></p>
<h5 id="build-deploy-and-debug-on-hardware">Build, Deploy, and Debug on hardware</h5>
<p>Set a breakpoint on RGB_LED_SET_R().</p>
<p>To see how the launch is controlled select view all files in the solution explorer and open <a href="https://docs.microsoft.com/cpp/build/launch-vs-schema-reference-cpp?view=msvc-170">.vs\launch.vs.json</a>. You can see the miDebuggerPath set to use arm-none-eabi-gdb while the debugServerPath is set to invoke openocd with the configuration script in debugServerArgs. The information for describing peripheral registers is provided by the MCU manufacturer in an SVD file that we point to with svdPath. This project is configured to break on entry with the property stopAtConnect.</p>
<p>Now, with your board plugged into the PC (and <a href="https://www.st.com/en/development-tools/stsw-link009.html">ST-LINK drivers</a> installed), set the debug target to Launch and F5 will work using openocd acquired by vcpkg to flash and debug the attached board. Execution stops at the entry function, so here we see the assembly code for that. We can also view the disassembly by going to the menu Debug &gt; Windows &gt; Disassembly.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png"><img class="alignnone size-full wp-image-29832" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png" alt="Assembly source and disassembly screenshot" width="936" height="164" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly-300x53.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly-768x135.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>Press continue to let execution continue.</p>
<h5 id="peripheral-registers">Peripheral Registers</h5>
<p>Now press the A button on the board. This has triggered our breakpoint. We can now go to the menu Debug &gt; Windows &gt; Embedded Registers. This opens the peripheral register view using the information from our SVD file specified in the launch configuration. We can now scroll through this list to find the register we are interested in, here TIM3-&gt;CCR1 which will update when we step over the RGB_LED_SET_R function.</p>
<p>On break</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png"><img class="alignnone size-full wp-image-29833" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png" alt="Register on break screenshot" width="936" height="349" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak-300x112.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak-768x286.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>After stepping</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png"><img class="alignnone size-full wp-image-29834" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png" alt="Register after stepping" width="936" height="395" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep-300x127.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep-768x324.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<h5 id="rtos-object-views">RTOS Object Views</h5>
<p>The application in the getting started project has several threads, but you won’t see them with the existing threads window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png"><img class="alignnone size-full wp-image-29839" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png" alt="Threads window screenshot" width="1348" height="223" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png 1348w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-300x50.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-1024x169.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-768x127.png 768w" sizes="(max-width: 1348px) 100vw, 1348px" /></a></p>
<p>Why not? A good explanation can be found in this <a href="https://azure.microsoft.com/resources/real-time-operating-system">white paper on Real Time Operating Systems</a>.</p>
<p>&#8220;A Real-Time Operating System is system software that provides services and manages processor resources for applications. These resources include processor cycles, memory, peripherals, and interrupts. The main purpose of a Real-Time Operating System is to allocate processing time among various duties the embedded software must perform. This typically involves a division of the software into pieces, commonly called “tasks” or “threads,” and creating a run-time environment that provides each thread with its own virtual microprocessor (“Multithreading”). Basically, a virtual microprocessor consists of a virtual set of microprocessor resources, e.g., register set, program counter, stack memory area, and a stack pointer. Only while executing does a thread use the physical microprocessor resources, but each thread retains its own copy of the contents of these resources as if they were its own private resources (the thread”s “context”).&#8221;</p>
<p>So for embedded development ideally you would have views that could show you information about these RTOS objects. To see the new available RTOS objects views, go to the menu Debug &gt; Windows &gt; RTOS Objects. Here you will see options for the objects that ThreadX provides, here we’ll select Threads.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png"><img class="alignnone size-full wp-image-29840" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png" alt="Debug RTOS menu options" width="325" height="297" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png 325w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu-300x274.png 300w" sizes="(max-width: 325px) 100vw, 325px" /></a></p>
<p>The threads view shows at a glance much of the information you would commonly need during embedded development, thread ids and names, how many times they have run, where the stack starts, ends, and its size as well as the maximum stack usage.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png"><img class="alignnone size-full wp-image-29842" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png" alt="RTOS threads window" width="1440" height="177" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png 1440w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-300x37.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-1024x126.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-768x94.png 768w" sizes="(max-width: 1440px) 100vw, 1440px" /></a></p>
<p>There are other views for additional ThreadX objects like block and byte pools, events, mutexes, queues, and timers. We also have RTOS object views for FreeRTOS though the available objects there differ based on what it supports.</p>
<h5 id="hardware-breakpoint-limits">Hardware breakpoint limits</h5>
<p>One last debugging capability to call out is that embedded hardware targets commonly have a limited set of hardware breakpoints available. Setting too many can corrupt the debugger state. As such we have added hardwareBreakpoints to launch.vs.json. For this board that is set to what it supports which is 6. If we set more than that we will see the breakpoint is not set and we get a warning that it won’t be hit. This prevents corrupting the connection to the board and allows us the opportunity to unset some other breakpoints and continue debugging uninterrupted.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png"><img class="alignnone size-full wp-image-29843" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png" alt="hardware breakpoint exceeded warning" width="667" height="124" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png 667w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning-300x56.png 300w" sizes="(max-width: 667px) 100vw, 667px" /></a></p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>If you are on Linux or Mac and looking for similar capabilities, yes, we will be bringing embedded development capabilities to VS Code soon as well. We have provided VS Code getting started guides for Azure RTOS the same boards as VS (<a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/vscode.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/tree/master/NXP/MIMXRT1060-EVK">NXP 1060</a>, and <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L475E-IOT01A/VS.md">STMicro STM32L4_L4+</a>), though today the capabilities are limited to acquisition with vcpkg, edit, build, deploy, and debug. Similar embedded specific views will be coming in a future extension.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Software Development in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/feed/</wfw:commentRss>
			<slash:comments>12</slash:comments>
		
		
			</item>
		<item>
		<title>Bootstrap your dev environment with vcpkg artifacts</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 16:27:55 +0000</pubDate>
				<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29826</guid>

					<description><![CDATA[<p>We are happy to announce a new experience for acquiring artifacts using vcpkg. We define an artifact as a set of packages required for a working development environment. Examples of relevant packages include compilers, linkers, debuggers, build systems, and platform SDKs.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">Bootstrap your dev environment with vcpkg artifacts</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce a new experience for acquiring artifacts using vcpkg. We define an artifact as a set of packages required for a working development environment. Examples of relevant packages include compilers, linkers, debuggers, build systems, and platform SDKs. With this important change, vcpkg can not only download and build your libraries from source, it can also bootstrap the rest of your environment, acquiring pre-built binary dependencies for your projects.</p>
<p>The experience is in preview and currently focused on embedded developers. We will expand the scope in the future to include any developers targeting Linux, macOS, or Windows.</p>
<p>This post focuses on using vcpkg artifacts at the command line. Check out the <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Development in Visual Studio blogpost</a> for how the capabilities are used there.</p>
<p>Here we are going to show how to acquire vcpkg, then activate artifacts for building an embedded project. Following that we’ll cover specific vcpkg capabilities for finding and using artifacts, then how to create a manifest and add artifacts to it. We will also cover how you can use artifacts of your own that are not part of the default artifact registry.</p>
<h4 id="using-vcpkg-artifacts">Using vcpkg artifacts</h4>
<p>We’ll look at some embedded development scenarios to understand the new artifact capabilities in vcpkg. Embedded development is particularly known for being difficult to get a new developer machine started. Projects often have specific compiler requirements, special debug tools needed, etc. What we will show here is how through using vcpkg with a manifest you can capture these requirements and easily restore an environment for an embedded project. You do not need a device to follow along as we will not show any device interactivity. These steps except where noted are consistent cross platform.</p>
<h5 id="acquire-vcpkg">Acquire vcpkg</h5>
<p>We have also added a new way to acquire vcpkg in a single step without a git clone of the repo. Depending on your platform use one of the following commands to get vcpkg.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre class="prettyprint">iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>CMD Shell</p>
<pre class="prettyprint">curl -LO https://aka.ms/vcpkg-init.cmd &amp;&amp; .\vcpkg-init.cmd</pre>
<h5 id="clone-the-example-project">Clone the example project</h5>
<p>The example project is the Azure RTOS getting started repo, so start by cloning that with this command.</p>
<pre class="prettyprint">git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>This repo has many projects within is, each for a specific board. Use the Azure IoT DevKit by switching to that directory.</p>
<pre class="prettyprint">cd .\getting-started\MXChip\AZ3166\</pre>
<h5 id="vcpkg-activate">vcpkg activate</h5>
<p>In the project folder, there is a file vcpkg-configuration.json. This manifest file has recorded the tools you need to build and debug this project. Running the vcpkg activate command will use this file to determine if those tools have been acquired before, acquire them not, then activate them in your environment for use.</p>
<pre class="prettyprint">vcpkg activate</pre>
<p>This is a new vcpkg command that works with artifacts. As this is the first time you are using vcpkg for artifacts it acquires the new vcpkg-ce component on demand. The ce in this component name stands for configure environment. This name was chosen as vcpkg will modify your current environment to use the artifacts in the manifest with your C++ projects.</p>
<p>To demonstrate that build the project. To do so generate the CMake configuration, then build the project using the preset provided by CMakePresets.json in the project with the following two commands.</p>
<pre class="prettyprint">cmake --preset arm-gcc-cortex-m4
cmake --build --preset arm-gcc-cortex-m4</pre>
<p>So, in just a few commands you have installed vcpkg, cloned an embedded project, acquired and activated the necessary tools for building the project, and successfully compiled it.</p>
<h5 id="finding-artifacts">Finding artifacts</h5>
<p>There is a vcpkg search command already that finds ports of libraries in the vcpkg registry. We needed a way to distinguish between the existing vcpkg port concept and the new artifacts concept in areas where the commands could mean either. As such we have introduced a new find command that can be used as find port name, or find artifact name. The existing search command is still present with its existing behavior that only returns ports.</p>
<p>Try finding an artifact, like CMake, with the following command.</p>
<pre class="prettyprint">vcpkg find artifact cmake</pre>
<p>This will output anything that matches the short name used, currently the below.</p>
<pre class="prettyprint">vcpkg-ce ('configure environment') is experimental and may change at any time.
 Artifact                       Version  Summary
 microsoft:tools/kitware/cmake  3.20.1   Kitware's cmake tool
</pre>
<h5 id="using-artifacts">Using artifacts</h5>
<p>Now that you have found an artifact you want to use, you can with the vcpkg use command. Try this command to use CMake.</p>
<pre class="prettyprint">vcpkg use cmake 
vcpkg-ce ('configure environment') is experimental and may change at any time.
 Artifact                           Version    Status     Dependency  Summary

 microsoft:tools/kitware/cmake      3.20.1     installed              Kitware's cmake tool

Activating individual artifacts
</pre>
<p>Yes, you can activate more than one artifact at a time. The following command activates gcc, cmake, and ninja, a complete C++ build system in one command. Note this is the Arm GCC compiler as that is the only one presently in the registry.</p>
<pre class="prettyprint">vcpkg use gcc cmake ninja</pre>
<h5 id="creating-your-own-manifest">Creating your own manifest</h5>
<p>The manifest, vcpkg-configuration.json, in the example above was also created with vcpkg. To create a manifest with tools needed for your own use vcpkg new. Make sure to run the subsequent commands in a new directory that is not a subfolder of an existing project.</p>
<pre class="prettyprint">vcpkg new</pre>
<h5 id="adding-artifacts-to-your-manifest">Adding artifacts to your manifest</h5>
<p>Now that we have a manifest and found artifacts we want to use with our project it is simple to add them. Note that the add command requires us to specify an artifact as it can also be used to add ports to a manifest.</p>
<pre class="prettyprint">vcpkg add artifact cmake

vcpkg-ce ('configure environment') is experimental and may change at any time.

 Artifact                       Version  Status     Dependency  Summary

 microsoft:tools/kitware/cmake  3.20.1   installed  *           Kitware's cmake tool

Project c:\source\newprj activated</pre>
<p>Now you can check in vcpkg-configuration.json with your source. Anyone else who uses your project can install vcpkg with a single command, then activate the artifacts in your manifest and reproduce the same results locally.</p>
<h4 id="subsequent-use-of-vcpkg">Subsequent use of vcpkg</h4>
<p>In the above examples vcpkg was available on the command line after installation. There is a quick way to get it back in new instances of your favorite terminal.</p>
<p>Linux/macOS</p>
<pre class="prettyprint">. ~/.vcpkg/vcpkg-init.sh</pre>
<p>PowerShell</p>
<pre class="prettyprint">. ~/.vcpkg/vcpkg-init.ps1</pre>
<p>CMD Shell</p>
<pre class="prettyprint">%USERPROFILE%\.vcpkg\vcpkg-init.cmd</pre>
<h4 id="removing-vcpkg">Removing vcpkg</h4>
<p>That was fun, how do you remove vcpkg installed from your system using the instructions above? Simply delete the .vcpkg folder in your home directory. No other changes have been made to your system through installing or using it.</p>
<h4 id="using-your-own-registry">Using your own registry</h4>
<p>The current artifacts in the default registry are limited to the embedded scenarios we have been developing the tool around which focus on Azure RTOS. In the future this set will expand to desktop development scenarios. The default registry can be found here: <a href="https://github.com/microsoft/vcpkg-ce-catalog">https://github.com/microsoft/vcpkg-ce-catalog</a>. Note that we are not taking pull requests of artifact additions to the default registries at this time.</p>
<p>We fully expect people to have their own artifacts they would like to use, or to provide for others to use.</p>
<p>As an example, what if you want to use a newer Arm compiler? Our example uses the one set by the example Azure RTOS project so that is the only one we put into the registry. In the steps below I will show how I added a new Arm compiler to my own registry. You can follow the same steps, modified for the artifact you need, to create your own registry of artifacts for use with vcpkg.</p>
<p>To create a new Arm gcc artifact metadata file I looked at the existing artifact metadata for the gcc compiler in the vcpkg-ce-catalog repo, <a href="https://github.com/microsoft/vcpkg-ce-catalog/blob/main/compilers/arm/gcc/gcc-2020.10.0.yaml">compilers/arm/gcc/ gcc-2020.10.0.yaml</a>.</p>
<p>On my local machine I copied that file into a folder, myregistry, under the same path for consistency. I then went to Arm’s website to find the latest compilers they provide. I then renamed the metadata file to match, gcc-2021.10.0.yaml. I updated the fields in the file for the version, the artifact urls under install &gt; unzip, and added the sha256 information. Note that Arm only provides md5 sums for their artifacts, this meant I had to download the artifacts manually first to generate my own sha256 sums to use. You can find this file in my personal GitHub repository here, <a href="https://github.com/robotdad/myregistry/blob/main/compilers/arm/gcc/gcc-2021.10.0.yaml">gcc-2021.10.0.yaml</a>.</p>
<p>Now, to test this I created a test folder and created a manifest with vcpkg new. I then opened this manifest and added a registry section pointing to my local folder with the artifact metadata.</p>
<pre class="prettyprint">{
    "registries": [
      {
        "name": "myregistry",
        "location": "c:/source/myregistry",
        "kind": "artifact"
      }
    ]
}</pre>
<p>Note that I specified the full path, alias like ~ are not supported.  Now, to find this entry I specified the name as part of the search query.</p>
<pre class="prettyprint">vcpkg find artifact myregistry:gcc

vcpkg-ce ('configure environment') is experimental and may change at any time.
Artifact                 Version    Summary
myregistry:compilers/arm/gcc  2021.10.0  GCC compiler for ARM CPUs.</pre>
<p>Once verified I added it to the manifest in the same way.</p>
<pre class="prettyprint">vcpkg add artifact local:gcc

vcpkg-ce ('configure environment') is experimental and may change at any time.
Artifact                      Version    Status     Dependency Summary
myregistry:compilers/arm/gcc  2021.10.0  installed  *          GCC compiler for ARM CPUs.

Project c:\source\test activated
</pre>
<p>Now my manifest looks like this:</p>
<pre class="prettyprint">{
  "registries": [
    {
      "name": "myregistry",
      "location": "c:/source/myregistry",
      "kind": "artifact"
    }
  ],
  "requires": {
    "myregistry:compilers/arm/gcc": "* 2021.10.0"
  }
}</pre>
<p>I wouldn’t want to share a manifest with others where a local path was used for a registry. Network paths are supported which works if I am only sharing internally. Note I had to escape the path in the location field.</p>
<pre class="prettyprint">"location": "\\\\myshare\\folder\\myregistry",</pre>
<p>I wanted to share my registry on GitHub to support this post which requires a couple of extra steps. The first extra step is to generate an index file. To do so I ran the following experimental command (this is likely to change in the future).</p>
<pre class="prettyprint">vcpkg z-ce regenerate c:/source/myregistry</pre>
<p>This generated an index.yaml for all of the artifact metadata files in the specified location.</p>
<p>To use a registry published in a GitHub repo I needed to specify the endpoint that provides an archive of the repository. This allows vcpkg to acquire all the artifact metadata in a single request. For a GitHub repo this is available at the path /archive/refs/heads/main.zip under the repository. For this example, I published my registry in my personal GitHub account here, <a href="https://github.com/robotdad/myregistry">https://github.com/robotdad/myregistry</a>, the location for that is specified as below in the manifest.</p>
<pre class="prettyprint">"location": "https://github.com/robotdad/myregistry/archive/refs/heads/main.zip",</pre>
<h4 id="give-us-your-feedback">Give us your feedback!</h4>
<p>We are very interested in hearing your thoughts on the new artifact capabilities in vcpkg. We have a separate repo for the component that provides those, <a href="https://github.com/microsoft/vcpkg-ce">vcpkg-ce</a>, where you can file any issues you encounter. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. As capabilities around artifacts in vcpkg evolve, your thoughts are critical to us for creating an excellent developer experience.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">Bootstrap your dev environment with vcpkg artifacts</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/feed/</wfw:commentRss>
			<slash:comments>11</slash:comments>
		
		
			</item>
		<item>
		<title>Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</title>
		<link>https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/</link>
					<comments>https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/#respond</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 15:20:01 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++ extension]]></category>
		<category><![CDATA[compilation database]]></category>
		<category><![CDATA[compile commands]]></category>
		<category><![CDATA[compile_commands.json]]></category>
		<category><![CDATA[CPP]]></category>
		<category><![CDATA[make]]></category>
		<category><![CDATA[makefile]]></category>
		<category><![CDATA[makefile tools]]></category>
		<category><![CDATA[problem matcher]]></category>
		<category><![CDATA[vs code]]></category>
		<category><![CDATA[VSCode]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29854</guid>

					<description><![CDATA[<p>The December 2021 update of the Makefile Tools extension for Visual Studio Code is here, bringing you support for problem matchers (to easily view errors and warnings in the editor), the ability to generate a compile_commands.json file for your project, and a bunch of other enhancements and bug fixes!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/">Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The December 2021 update of <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">the Makefile Tools extension for Visual Studio Code</a> is here, bringing you <a href="https://github.com/microsoft/vscode-makefile-tools/issues/7">support for problem matchers</a> (to easily view errors and warnings in the editor), the ability to <a href="https://github.com/microsoft/vscode-makefile-tools/issues/104">generate a compile_commands.json file</a> for your project, and a bunch of other enhancements and bug fixes! To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-makefile-tools/releases/tag/v0.3.0">release notes on GitHub.</a></p>
<h1 id="problem-matchers">Problem matchers</h1>
<p>If you’ve used the C++ extension for VS Code, you’re probably familiar with the <strong>Problems</strong> panel, where you can navigate through a list of compiler errors and warnings found in your project. VS Code uses a <a href="https://code.visualstudio.com/Docs/editor/tasks#_processing-task-output-with-problem-matchers">problem matcher</a> to display the errors and warnings in the Problems panel.</p>
<p>For example, if you’re missing a semi-colon in your source file, you’ll see the compiler error in the <strong>Problems</strong> panel. Selecting the problem brings you to the line of code generating the error or warning. To fix the problem, click on the lightbulb and choose from a list of Quick Actions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png"><img class="alignnone size-full wp-image-29856" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png" alt="A screenshot of the Problems Pane in VS Code, showing errors and warnings found by GCC and make in the project" width="3036" height="2054" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png 3036w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-300x203.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-1024x693.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-768x520.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-1536x1039.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-2048x1386.png 2048w" sizes="(max-width: 3036px) 100vw, 3036px" /></a></p>
<p>Now, let’s say you don’t have any compiler errors, but make displays a bunch of warnings when you build your project. Until now, there wasn’t a way to see those warnings in the Problems panel. With this latest release of the Makefile Tools extension, you’ll see all of make’s errors and warnings in the Problems panel after you build your program.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png"><img class="alignnone size-full wp-image-29857" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png" alt="A screenshot showing make's warnings in the Problems Pane in VS Code after building a project with Makefile Tools." width="3036" height="2062" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png 3036w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-300x204.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-1024x695.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-768x522.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-1536x1043.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-2048x1391.png 2048w" sizes="(max-width: 3036px) 100vw, 3036px" /></a></p>
<p>To enable make errors and warnings in the Problems panel, add <strong>&#8220;problemMatchers&#8221;: [&#8220;$gcc&#8221;]</strong> to your makefile configuration in settings.json, like this:</p>
<pre class="prettyprint">"makefile.configurations": [

        {

            "name": "MyConfiguration",

            "problemMatchers": [

                "$gcc"

            ],

            "makeArgs": ["any", "other", "args", "you", "want"]

        },

]</pre>
<p>If you’re on Windows using MSVC, set the problemMatcher to <strong>&#8220;$msCompile&#8221;</strong> instead of <strong>&#8220;$gcc&#8221;</strong>. Contributions from the community to support additional problem matchers are welcome! Problem matchers are defined in the extension’s <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/package.json#L198">package.json</a> file.</p>
<h1 id="generate-compile_commands-json">Generate compile_commands.json</h1>
<p>As a C++ developer, you might find yourself wanting a compilation database, which is a file that stores compilation instructions for the source files in your project. Compilation databases are used by many <a href="https://clang.llvm.org/docs/ClangTools.html">Clang tools</a> and editors/IDEs. A common compilation database format is compile_commands.json, which contains command objects, one for each translation unit in the project. Each command object specifies the translation unit’s main file, the compile command, and the working directory where the compile command is run.</p>
<p>With this latest release of the Makefile Tools extension, you can generate a compile_commands.json file for your project. All you have to do is specify the path to the target compile_commands.json file in settings.json, like this:</p>
<pre class="prettyprint">"makefile.compileCommandsPath": ".vscode/compile_commands.json"</pre>
<p>Then configure your project to generate compile_commands.json at the specified location.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png"><img class="alignnone size-full wp-image-29855" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png" alt="A screenshot of the contents of a compile_commands.json file generated by the Makefile Tools extension" width="3088" height="1888" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png 3088w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-300x183.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-1024x626.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-768x470.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-1536x939.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-2048x1252.png 2048w" sizes="(max-width: 3088px) 100vw, 3088px" /></a></p>
<p>Thank you <a href="https://github.com/rapgenic">rapgenic</a> for the request and for contributing to this feature!</p>
<h1 id="give-it-a-try">Give it a try</h1>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Download the Makefile Tools extension for Visual Studio Code</a> today, give it a try, and let us know what you think. Check out <a href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/">this blog post</a> to learn how to get started with Makefile Tools.</p>
<p>If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-makefile-tools/issues">Issues section of our GitHub repository</a>. Be sure to check out the <a href="https://github.com/microsoft/vscode-makefile-tools/tree/main/docs">Makefile Tools documentation</a> for troubleshooting tips and a list of tested repositories and their configuration instructions.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:makefiletools@microsoft.com">makefiletools@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/">Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>C++ build throughput investigation and tune up</title>
		<link>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/</link>
					<comments>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/#comments</comments>
		
		<dc:creator><![CDATA[olgaark]]></dc:creator>
		<pubDate>Fri, 19 Nov 2021 09:41:12 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29790</guid>

					<description><![CDATA[<p>Building C++ code is a complex process, launching many build tools in parallel and often running for a long time. It is always desirable to make it faster, but also a challenge to understand what the most effective way would be to achieve this.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">C++ build throughput investigation and tune up</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Building C++ code is a complex process, launching many build tools in parallel and often running for a long time. It is always desirable to make it faster, but also a challenge to understand what the most effective way would be to achieve this.</p>
<p>We’d like to share some techniques we use to get a “bigger” picture of the build, as well as tools that can help to see what is taking time in a particular part of the build. We’ll also talk about MSBuild project options which can improve build parallelism without overwhelming the system, as well as other (not immediately obvious) options which might affect build throughput.</p>
<p>This blog is more like a list of what is currently available, full of instructions and details. Some of the suggestions should be useful for any C++ build, but most of the measurements and tuning options are for MSBuild based projects (vcxproj).</p>
<p>As any performance improvement starts with the measurement, here we are – measure your build.</p>
<p>Note that the total build time can vary quite noticeably between several identical builds on the same machine – the system is adjusting to the active processes. So, if you compare builds before and after making some options changes, it is more reliable to run the build several times and get the average. It is also helpful to measure not only the total build time but get more detailed information, so if you get a surprising result, you can figure out why it happened. For MSBuild we recommend running it on the command line and collecting a <a href="http://www.msbuildlog.com/">binary log</a>.</p>
<h2 id="measure-your-build-time-using-msbuild-performance-summary">Measure your build time using MSBuild Performance Summary</h2>
<p>If your build is MSBuild based, the first thing to do when investigating build performance is to see which projects and which tasks/targets inside the projects are taking most of the build time. The performance summary data is also very useful for comparing builds using different options.</p>
<p>To get a performance summary for your full build, you can do the following: open a Developer (or MSBuild) Command Prompt and run the build of your solution with the following options (replace Configuration and Platform values with the ones your solution actually has):</p>
<pre class="prettyprint">msbuild /m /t:clean /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln 
msbuild  /m /fl  -flp:PerformanceSummary;v=q;LogFile=Perf.log /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln
</pre>
<p>The “quet” or “minimal” verbosity setting (<code>-flp:PerformanceSummary;v=q</code>) is recommended as console logging itself takes noticeable time. But you can set the verbosity to other levels if you want more build info in the Perf.log. You can also add <code>/detailedSummary</code> to see msbuild.exe <a href="https://devblogs.microsoft.com/visualstudio/msbuild-4-detailed-build-summary/#gimme-some-numbers">nodes utilization</a>).</p>
<p>The same information can be extracted from a binary log. We recommend creating binary logs when investigating your builds. To create a binary log, run:</p>
<pre><code class="language-txt">msbuild /m /t:clean /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln 
msbuild /m /bl:build.binlog /p:Configuration=”Debug”;Platform=”x86” YourSolution.sln</code></pre>
<p>To extract the perf info into Perf.log, run:</p>
<pre><code class="language-txt">msbuild -noconlog -flp:PerformanceSummary -flp:v=q  build.binlog
ren msbuild.log Perf.log</code></pre>
<p>You can also enable “Build Timings” for VC projects in the IDE by setting “Tools/Options/Projects and Solutions/VC++ Project Settings/Build Timings” = “Yes”. This will create the Perf Summary for each project, but not for the whole solution build. Thus, using the command line is better to see the “whole picture”.</p>
<p>In the Perf.log you’ll find times (in ms) it took to build the whole solution, each project (in the time increasing order) and commutative time of all targets and tasks (also in the time increasing order). Note that project build time and some targets (like ResolveProjectReferences target) include the wait for referenced projects to be built. You can use the Timeline tab of the binlog viewer to see if other projects were built as a part of a particular project build.</p>
<p>For a solution containing mostly C++ projects, cl and link would usually be the tasks taking most of the time:</p>
<pre><code class="language-txt">Project Performance Summary:
…
    1100252 ms  d:testMySolution.sln          1 calls  solution build time (msbuild /m)

Task Performance Summary:
…
     22495731 ms  Link    250 calls 
    152500624 ms  CL      250 calls </code></pre>
<p>The task time is the sum of all times the task was executing for all projects and thus it can be bigger than the total build time. For CL and Link tasks their time is very close to the cl.exe and link.exe time.</p>
<h2 id="use-build-insights-to-see-the-build-timeline-for-cl-exe-and-link-exe">Use Build Insights to see the build timeline for cl.exe and link.exe</h2>
<p>Most of the C++ builds time is usually spent in the compiler. To visualize what is going on during the build, see the processes running in parallel and pivot on the parts that take most of the time, you can use the <a href="https://devblogs.microsoft.com/cppblog/introducing-c-build-insights/">Build Insights</a> tool.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/word-image.gif"><img class="alignnone wp-image-25179 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2019/11/word-image.gif" alt="" width="881" height="680" /></a></p>
<h2 id="change-options-to-improve-c-build-throughput">Change options to improve C++ build throughput</h2>
<p>There are many parameters which can affect build throughput and different codebases can benefit from different sets of options. Here we&#8217;ll talk about antivirus and project settings which are easy to change and which can potentially greatly improve your build throughput.</p>
<h3 id="1-check-your-antivirus-settings">1. Check your antivirus settings</h3>
<p>C++ builds produce a lot of intermediate files and we often see the file system as a bottleneck there. With your antivirus scanning all build outputs, the problem is greatly amplified.</p>
<p>Windows Defender Antivirus automatically excludes most of the common build tools when they are found in the default install locations. But if you install Visual Studio in a custom location or use many additional build tools, your build throughput might be affected.</p>
<p>To see if Windows Defender scans are impacting your build, you can use <a href="https://techcommunity.microsoft.com/t5/microsoft-defender-for-endpoint/announcing-performance-analyzer-for-microsoft-defender-antivirus/ba-p/2713911">Performance Analyzer for Microsoft Defender Antivirus</a>. The tool collects minimal data so you can run it for a good chunk of your build (10-20 min is usually enough) if not the whole build. We recommend closing all application unrelated to the build before collecting the data to avoid seeing unrelated to build processes in the report.</p>
<p>To collect the data and see the affected build processes:</p>
<ul>
<li>Open a Windows PowerShell and run:
<pre><code class="language-txt">New-MpPerformanceRecording -RecordTo MyBuild.etl</code></pre>
</li>
<li>Rebuild your code in the IDE or on the command line</li>
<li>After the build is finished (or after 10-20 min) go back to the PowerShell and stop the recording by hitting any key</li>
<li>In PowerShell run
<pre><code class="language-txt">Get-MpPerformanceReport -TopProcesses:20 MyBuild.etl</code></pre>
<p>This will give you the list of the affected processes, similar to the following one:</p>
<pre><code class="language-txt">TopProcesses
============

Count TotalDuration MinDuration AverageDuration MaxDuration MedianDuration ProcessPath
----- ------------- ----------- --------------- ----------- -------------- -----------
8193  62272.1020ms    0.1790ms        7.6006ms  119.5682ms       6.8465ms   D:Visual Studio 17VCToolsMSVC14.30.30528binHostx64x86cl.exe
1068  14587.9547ms    3.2531ms       13.6591ms 927.2716ms       6.0416ms    D:Visual Studio 17VCToolsMSVC14.30.30528binHostx64x86link.exe
…</code></pre>
<p>You can add the build tools from the trusted locations to the excluded files or directories list in the <a href="https://docs.microsoft.com/microsoft-365/security/defender-endpoint/configure-extension-file-exclusions-microsoft-defender-antivirus?view=o365-worldwide#exclusion-lists">Windows Defender settings.</a></li>
</ul>
<h3 id="2-redefine-tmp-directory">2. Redefine TMP directory.</h3>
<p>During compilation, cl.exe creates a tmp file per each source in the TMP folder. When many cl.exe processes are running in parallel and simultaneously creating a lot of files in the same folder it creates a lot of stress for the file system.</p>
<p>Using different TMP folders for different projects (and preferably not on the system drive) often makes the build faster, especially on powerful machines with many CPUs where disk I/O and file system are more often a bottleneck.</p>
<p>We are planning to address this problem in the future VS releases, but meanwhile you can redefine the TMP environment variable to be different for different projects. See the proposed <code>Directory.Build.props</code> sample at the end of the blog.</p>
<h3 id="3-tune-build-options-for-better-parallelism">3. Tune build options for better parallelism.</h3>
<p>Many C++ build operations support parallel execution. A general assumption is that the build should be faster when more build operations are running in parallel. This is true, but only to a point when the build is not overwhelming the system capacity to distribute machine resources between processes and threads.</p>
<p>Most of the build tools are heavy users of CPU, memory, and the file system. Depending on the number of source files, their size, and content, any of these components can be a bottleneck preventing the build from being faster when more tools are running in parallel. When a resource limit is hit, running more build operations in parallel will make the build slower, rather than faster, sometimes significantly. For instance, the <code>msbuild /m</code> + <code>cl /MP</code> resource overuse problem has been known for quite some time, but recently became more frequent as more and more computers have 32+ logical CPUs.
The problem of optimal build parallelism is quite complex as it is hard to predict up front the resource usage of a particular build operation and pretty much impossible to predict actual resource availability for the whole time of that build operation. But some heuristics can be used, at least for the number of running processes and threads.</p>
<h4 id="msbuild-resource-manager"><em>MSBuild Resource Manager</em></h4>
<p>In VS 2019 16.10, MSBuild introduced <a href="https://github.com/dotnet/msbuild/blob/main/documentation/specs/resource-management.md">cross-process resource management</a>, which allows build parts (tasks) of different projects communicating their anticipated CPU usage and limiting this usage if resources are already reserved by other build parts. All C++ build tasks that launch several processes (like cl.exe or custom build tools) or the ones that are known to use many threads (like link.exe) participate in this communication.</p>
<p>In VS 2022 17.0 VC project’s build uses the MSBuild Resource Manager by default. The MSBuild Resource Manager support is also available VS 2019 16.11, but off by default. To activate it the following property should be defined as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample):</p>
<p><code>set UseMSBuildResourceManager=true</code></p>
<p>If you don’t use <code>/MP</code> for your build currently, turn it on and give it a try. To affect all projects, define the following property as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample):</p>
<p><code>set CL_MP = true</code></p>
<p>By default, the MSBuild Resource Manager will allow maximum 2*(number of CPU cores) to be used simultaneously by all project’s tasks. The 2x cores (instead of just 1x) limit is partially dictated by the current MSBuild scheduler architecture, but also seems to allow better build throughput on average. Most of the time the build will use less than 2xCPUs and when it does, the system usually tolerates 2x CPU oversubscription quite well unless bottlenecks other than the CPU are hit by the build (see Many Cores Machines section).</p>
<p>There are also a couple of “knobs” to try if the default behavior is not good enough.
In addition to setting the maximum number of projects allowed to be built in parallel (<code>msbuild /m:nProjects</code>), you can set the following environment variables (cannot be MSBuild properties) to modify the behavior:</p>
<ul>
<li><code>MSBUILDCORELIMIT=N</code> where N is the max number of cores to be given to one project. By default it’s the number of logical CPUs on the machine</li>
<li><code>MSBUILDNODECOREALLOCATIONWEIGHT= [0 – 100]</code>
0% means that MSBuild nodes don’t consider using CPUs and 100% means that each MSBuild node would be considered using 1 CPU. In C++ builds, MSBuild processes CPU usage is small comparing to the compiler CPU usage, so 0 should be OK. But for mixed C# and C++ solutions it probably should be set to something between 50 and 100.</li>
</ul>
<p>If for some reason building with the MSBuild Resource Manager is slower for your build and you don’t want to experiment with other options, you can disable it by setting <code>UseMSBuildResourceManager</code> as false.</p>
<h4 id="multitooltask-mtt"><em>MultiToolTask (MTT)</em></h4>
<p>Other options which can be used to limit the number of cl.exe processes running in parallel are described in <a href="https://devblogs.microsoft.com/cppblog/improved-parallelism-in-msbuild/">Improve Parallelism in MSBuild</a>.</p>
<p>To activate MTT mode set the following properties as environment variables or as MSBuild properties for all projects (see also the <code>Directory.Build.props</code> sample below):</p>
<pre><code class="language-txt">set UseMultiToolTask=true
set EnforceProcessCountAcrossBuilds=true</code></pre>
<p>This will make the build launch a separate cl.exe process for each C/C++ source and limit the number of simultaneously running cl processes (across all project builds) to <code>CL_MPCOUNT</code>, which is by default set to the number of logical processors.</p>
<p>MultiToolTask mode can be also used together with the MSBuild Resource Manager. This might be beneficial for some builds as instead of asking the MSBuild Resource Manager for available resources only once before launching the top-level <code>cl.exe /MP</code>, the build will ask it before launching cl.exe for each source file.</p>
<p>Note, that for projects with many small and simple C/C++ files (i.e., when individual file compilation is not taking a long time), launching a separate cl.exe processes for each file would bring a noticeable overhead. So, this option is recommended to use when most of the source files are relatively large and complex.</p>
<p>In VS 2022, the new experimental &#8220;ClServer&#8221; mode has been added to address the process creation overhead in MTT mode by using server-client model similar to <code>cl.exe /MP</code>. The server would spawn worker cl.exe processes, then dispatch work via IPC. The server resides in MSBuild process so is in-sync with the resource manager while scheduling work dynamically—allocating more workers or freeing resources to scaling down to deal with &#8220;long pole&#8221; compiles.</p>
<p>To enable this mode the following property should be defined as an environment variable or as an MSBuild property for all projects (see Directory.Build.props sample below):</p>
<p><code>set EnableClServerMode=true</code></p>
<h4 id="increase-build-parallelism-for-native-c-projects-experimental"><em>Increase build parallelism for native C++ projects (experimental)</em></h4>
<p>This option is experimental and works only for command line builds currently (not supported for the IDE build).</p>
<p>By default, if project B is referencing project A, the build of project B will not start until project A’s build is finished.
This makes sense for managed projects where assemblies must exist before they can be used as references in the compilation.</p>
<p>But native C++ code compilation usually does not use any build outputs from the referenced projects, only the linker does.
Even with C++20 modules, where compilation does use the build outputs (modules) from the referenced projects, it only needs to wait for the referenced project compilation step to finish but does not need to wait for the link to be complete.</p>
<p>To allow the compilation step of the referencing projects to start as soon as the compilation step of the referenced projects is finished:</p>
<p><code>set BuildPassReferences=true</code></p>
<p>To allow parallel compilation of all native sources in spite of project references (implies <code>BuildPassReferences=true</code>): (Note that this mode won&#8217;t work if the code is using C++ 20 modules built as a part of the solution)</p>
<p><code>set AllowParallelCompileInReferencedProjects=true</code></p>
<p>As these options would allow more build parts running simultaneously, make sure to enable the MSBuild Resource Manager and/or MultiToolTask with <code>EnforceProcessCountAcrossBuilds</code>.</p>
<p>The command line should look like:</p>
<p><code>msbuild /p:Configuration=Debug;Platform= x64 /t:BuildGenerateSources;BuildCompile;BuildLink solution.sln</code></p>
<p>How it works:</p>
<p>By default, MSBuild starts project build execution after all projects it references finish building.
Each VC project build consists of BuildGenerateSources, BuildCompile and BuildLink targets executed one after another. They are historically called “build passes”.</p>
<p>The default build timeline for two projects where ProjectB is referencing ProjectA looks like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/Build.png" alt="Regular build" /></p>
<p>When <code>BuildPassReferences</code> is set to true, a project B’s <code>BuildGenerateSources</code> target will be executed as soon as project A’s <code>BuildGenerateSources</code> target finish building. The project B’s <code>BuildCompile</code> target will wait for project B’s <code>BuildGenerateSources</code> target to finish executing, as well as project A’s <code>BuildCompile</code> targets. Similarly, a project B’s <code>BuildLink</code> target will wait for project B’s <code>BuildCompile</code> target and project A’s <code>BuildLink</code> target.</p>
<p>So, with <code>BuildPassReferences = true</code>, the build timeline would look like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/BuildPasses.png" alt="Build with pass references" /></p>
<p>When <code>AllowParallelCompileInReferencedProjects</code> is true, the build will allow even the same targets of the referencing and referenced projects to run in parallel. This will only work if a target does not use outputs from the same target of the referenced project. Note, that .lib and .implib are created as a part of <code>BuildCompile</code> so they are always available for <code>BuildLink</code>.</p>
<p>The project B’s <code>BuildGenerateSources</code> target can be executed at the same time as project A&#8217;s <code>BuildGenerateSources</code> target.
The project B’s <code>BuildCompile</code> target will wait for project B’s and project A&#8217;s <code>BuildGenerateSources</code> targets to finish executing.
The project B’s <code>BuildLink</code> target will wait for project B’s and project A&#8217;s <code>BuildCompile</code> targets.</p>
<p>So, with <code>AllowParallelCompileInReferencedProjects=true</code> the timeline would look like</p>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/ParallelCompile.png" alt="Build with parallel compilation" /></p>
<h3 id="4-tune-sources-includes-and-precompiled-headers-pch">4. Tune sources, includes and precompiled headers (PCH)</h3>
<p>To see which sources are taking most of the compiler time, use <a href="https://devblogs.microsoft.com/cppblog/introducing-c-build-insights/">Build Insights</a>. This tool will help you to see if adding a particular include to the pch would save a lot of compilation time. It will also allow you to view the build timeline.</p>
<p>Check the following blog post for adjusting PCH files:
<a href="https://devblogs.microsoft.com/cppblog/precompiled-header-pch-issues-and-recommendations/">Precompiled Header (PCH) issues and recommendations</a></p>
<p>If your files are well isolated, you can also try using Unity(Jumbo) builds:
<a href="https://devblogs.microsoft.com/cppblog/support-for-unity-jumbo-files-in-visual-studio-2017-15-8-experimental/">Support for Unity (Jumbo) Files in Visual Studio 2017 15.8 (Experimental)</a></p>
<h3 id="5-special-considerations-for-machines-with-64-cpus">5. Special considerations for machines with 64+ CPUs</h3>
<p>The following recommendations are based on the build time measurements performed on a 192 cores Windows Server machine.</p>
<ul>
<li>If you are running Windows Server 2016 on such a machine, it is highly recommended to upgrade it to WS2019. WS2016 was not optimized for launching many (64+) instances of the same exe, which resulted in poor performance of 64+ cl.exe running together.</li>
<li>When using Windows Server 2019, make sure that antivirus check is not affecting your build and TMP directory is redefined (i.e. follow recommendations #1 and #2 of this blog, see the chart below).</li>
<li>The build is likely to hit file system and disk I/O bottleneck when running a lot of build tools in parallel. If you’ve adjusted your build options for the best parallelism (#3), but still see low CPU utilization during build, it is likely that build is hitting a bottleneck other than CPU. Try limiting the number of projects running in parallel, as well as setting <code>MSBUILDCORELIMIT</code> to a lower number &#8211; this might actually improve your build throughput.</li>
</ul>
<p>In one of our tests, we’ve built a generated solution containing 250 projects, 250 cpp files each, with no project references. The C++ code was also generated and, admittedly, quite simple, containing one class per file, up to 30 methods each.</p>
<p>The following chart shows build times of this solution with different system and TMP options.
Each bar corresponds to the <code>msbuild /m:[nProjects]</code> build time, no other options were set. As the test projects did not have any project references, that was enough to achieve best parallelism.
Each series contains build times when number of projects built in parallel (and thus max number of cl.exe instances running together) was 10, 20, 30, 40, 60, 80, 100, 120, 140, 160, and 180.</p>
<p>The system/TMP setting for each series are:</p>
<ol>
<li>WS2016 Default settings</li>
<li>WS2019 Default settings, custom VS install location (Defender on, no exclusions, default TMP folder <code>c:users[username]AppDataLocalTemp</code>)</li>
<li>WS2019* Build tools are excluded from the Defender scan. Default TMP folder, not excluded from Defender scan.</li>
<li>WS2019** Build tools and default TMP folder are excluded from the Defender scan</li>
<li>WS2019*** Build tools are excluded from the Defender scan, TMP is set to project specific location, different for each project.</li>
</ol>
<p><img src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/11/Chart.png" alt="Build time (ms)" /></p>
<p>Note that in all series, build time did not improve much (and even got worse) when building more projects in parallel after some point. For this particular solution, building just ~40 projects in parallel showed the best results.</p>
<p>We’ve also tested other generated solutions with different number of projects, longer code, project references, etc. We also used different build options, especially the ones we recommend using in section#3.
The trends were quite similar, though the optimal number of parallel processes might differ.</p>
<p>The “real” code compilation usually takes much longer than the compilation of our small and simple generated files, so File System bottleneck might be not so pronounced there. But changing the antivirus and TMP settings improved the build times there as well, though not as much.</p>
<h2 id="directory-build-props-sample-to-set-options-for-all-projects">Directory.Build.props sample to set options for all projects</h2>
<p>Create<code> Directory.Build.props</code> in the root directory to affect all projects under this root.
This is a sample content of<code> Directory.Build.props</code> you can use to try different build settings.</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;Project&gt;
  &lt;PropertyGroup&gt;
    &lt;!-- To enable project specific directory for temporary files. --&gt;
    &lt;UseProjectTMPDirectory&gt;true&lt;/UseProjectTMPDirectory&gt;

    &lt;!-- To enable MSBuild Resource Manager in VS 2019 16.11 (on by default in VS 2022) --&gt;
    &lt;UseMSBuildResourceManager&gt;true&lt;/UseMSBuildResourceManager&gt;

    &lt;!-- Uncomment to enable MultiToolTask (MTT) mode. --&gt;
    &lt;!--&lt;UseMultiToolTask&gt;true&lt;/UseMultiToolTask&gt;
      &lt;EnforceProcessCountAcrossBuilds&gt;true&lt;/EnforceProcessCountAcrossBuilds&gt;--&gt;

    &lt;!-- Uncomment to enable experimental MTT ClServer mode, available in VS 2022. --&gt;
    &lt;!--&lt;EnableClServerMode&gt;true&lt;/EnableClServerMode&gt;--&gt;

    &lt;!-- Uncomment and change the value to control the maximum number of cl.exe processes running in parallel. 
         If using MTT without MSBuild Resource Manager, 10-20% oversubscription is often beneficial. --&gt;
    &lt;!--&lt;CL_MPCount&gt;20&lt;/CL_MPCount&gt;--&gt;

    &lt;!--Uncomment to allow executing more build operations in parallel--&gt;
    &lt;!--&lt;BuildPassReferences&gt;true&lt;/BuildPassReferences&gt; --&gt;
    &lt;!--&lt;AllowParallelCompileInReferencedProjects&gt;true&lt;/AllowParallelCompileInReferencedProjects&gt; --&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemDefinitionGroup&gt;
    &lt;!--  Enable parallel compilation (cl.exe /MP) --&gt;
    &lt;ClCompile&gt;
      &lt;MultiProcessorCompilation&gt;true&lt;/MultiProcessorCompilation&gt;
    &lt;/ClCompile&gt;
    &lt;!--  Enable parallel execution of a custom build tool--&gt;
    &lt;CustomBuild&gt;
      &lt;BuildInParallel&gt;true&lt;/BuildInParallel&gt;
    &lt;/CustomBuild&gt;
  &lt;/ItemDefinitionGroup&gt;

  &lt;!-- Define project specific directory for temporary files --&gt;
  &lt;Target Name="SetProjectTMPDirectory"
          Condition="'$(UseProjectTMPDirectory)' == 'true'"
          AfterTargets="SetBuildDefaultEnvironmentVariables"&gt;
    &lt;MakeDir Directories="$(IntDir)TMP"/&gt;
    &lt;SetEnv Name   ="TMP"
            Value  ="$(IntDir)TMP"
            Prefix ="false"&gt;
    &lt;/SetEnv&gt;
  &lt;/Target&gt;
&lt;/Project&gt;</code></pre>
<h2 id="send-us-feedback">Send Us Feedback</h2>
<p>Build is a complex process, and its performance depends on many factors and circumstances. Building different codebases on different hardware would benefit from different build settings. We hope you can try some of the options described in the blog and see if they improve your build time.</p>
<p>If you try any suggestions, please let us know, we love to hear from you! You can leave your comments below or email us at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/">C++ build throughput investigation and tune up</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/cpp-build-throughput-investigation-and-tune-up/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>What’s new for C++ cross-platform developers in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/#comments</comments>
		
		<dc:creator><![CDATA[Erika Sweet]]></dc:creator>
		<pubDate>Thu, 18 Nov 2021 15:33:43 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29778</guid>

					<description><![CDATA[<p>Visual Studio 2022 is available now! Check out the video below to learn what’s new for C++ developers who are building for more than just Windows, or who are developing with an eye to open source. This video covers: </p>
<p>Building with Visual Studio’s CMake Presets integration  <br />
Managing dependencies with a vcpkg manifest file and binary caching  <br />
Editing CMake scripts with CMake in-editor documentation and language services for CMake <br />
Building and debugging a Linux GUI application on WSL 2 with Visual Studio’s native support for WSL 2  <br />
Reproducing local builds with CMake Presets and GitHub Actions <br />
Debugging a remote process with LLDB </p>
<p>Contact us<br />
Have questions or comments about Visual Studio 2022?</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/">What’s new for C++ cross-platform developers in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">Visual Studio 2022 is </span><a href="https://visualstudio.microsoft.com/downloads/"><span data-contrast="none">available now</span></a><span data-contrast="auto">! Check out the video below to learn what’s new for C++ developers who are building for more than just Windows, or who are developing with an eye to open source. This video covers:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Building with Visual Studio’s <a href="https://aka.ms/cmakepresetsvs">CMake Presets integration</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="2" data-aria-level="1"><span data-contrast="auto">Managing dependencies with a <a href="https://vcpkg.io/en/index.html">vcpkg manifest file and binary caching</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Editing CMake scripts with <a href="https://devblogs.microsoft.com/cppblog/in-editor-documentation-for-cmake-in-visual-studio/">CMake in-editor documentation</a> and <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170#language-services-for-cmake">language services for CMake</a></span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto">Building and debugging a Linux GUI application on WSL 2 with <a href="https://docs.microsoft.com/en-us/cpp/build/walkthrough-build-debug-wsl2?view=msvc-170">Visual Studio’s native support for WSL 2</a> </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><span data-contrast="auto"><a href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-170#run-cmake-from-the-command-line-or-a-ci-pipeline">Reproducing local builds with CMake Presets</a> and GitHub Actions</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="1" aria-setsize="-1" data-aria-posinset="3" data-aria-level="1"><a href="http://aka.ms/lldb"><span data-contrast="auto">Debugging a remote process with LLDB</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></a></li>
</ul>
<p><center>
<iframe src="//www.youtube.com/embed/yImev317_Ns" width="560" height="314" allowfullscreen="allowfullscreen"></iframe></center></p>
<h3 id="contact-us">Contact us</h3>
<p><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">Have</span><span class="NormalTextRun SCXW106660144 BCX8"> </span><span class="NormalTextRun SCXW106660144 BCX8">questions or comments about</span><span class="NormalTextRun SCXW106660144 BCX8"> Visual Studio 2022? Want to </span><span class="NormalTextRun SCXW106660144 BCX8">share feedback with our team? </span><span class="NormalTextRun SCXW106660144 BCX8">You can contact us </span><span class="NormalTextRun SCXW106660144 BCX8">at </span></span><a class="Hyperlink SCXW106660144 BCX8" href="mailto:visualcpp@microsoft.com" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">visualcpp@microsoft.com</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> </span><span class="NormalTextRun SCXW106660144 BCX8">or</span><span class="NormalTextRun SCXW106660144 BCX8"> on Twitter (</span></span><a class="Hyperlink SCXW106660144 BCX8" href="https://twitter.com/visualc" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">@VisualC</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">). The best way to file a bug or suggest a feature is with the </span></span><strong><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8">Send Feedback</span></span></strong><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> button in the upper right-hand corner of the IDE. See </span></span><a class="Hyperlink SCXW106660144 BCX8" href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW106660144 BCX8" data-ccp-charstyle="Hyperlink">How to report a problem with Visual Studio or Visual Studio Installer</span></span></a><span class="TextRun SCXW106660144 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW106660144 BCX8"> for more information. </span></span><span class="EOP SCXW106660144 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/">What’s new for C++ cross-platform developers in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-c-cross-platform-developers-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>5</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Code Analysis with GitHub Actions</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Winsor]]></dc:creator>
		<pubDate>Tue, 26 Oct 2021 11:23:10 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29701</guid>

					<description><![CDATA[<p>We previously talked about GitHub Code Scanning capabilities which enabled developers to incorporate security checks into their CI/CD environment and developer workflow. CodeQL is the default analysis engine behind Code Scanning. Today we are introducing support for MSVC Code Analysis which will provide a great companion to CodeQL for C++ GitHub repos with Windows workflows.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">Microsoft C++ Code Analysis with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We previously talked about <a href="https://devblogs.microsoft.com/cppblog/code-scanning-with-github-actions/">GitHub Code Scanning capabilities</a> which enabled developers to incorporate security checks into their CI/CD environment and developer workflow. <a href="https://codeql.github.com/">CodeQL</a> is the default analysis engine behind Code Scanning. Today we are introducing support for MSVC Code Analysis which will provide a great companion to CodeQL for C++ GitHub repos with Windows workflows.</p>
<p>This <a href="https://github.com/marketplace/actions/microsoft-c-code-analysis-action">Action</a> will take the variety of Code Quality and Security warnings available in Visual Studio today and process them as alerts, displaying them in the <a href="https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/managing-code-scanning-alerts-for-your-repository">Security view of a GitHub repository</a>. The code scanning alerts produced will power the <a href="https://github.com/features/security/code">existing features</a> available through GitHub. These include highlighting the source code of contributors’ PRs with any warnings they may have introduced or allowing repository owners to view and manage the backlog of alerts under the Security tab.</p>
<p><img class="alignnone" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/CodeScanning.png" alt="Analysis results annotated in Pull Request UI" width="933" height="557" /></p>
<p>Alongside the support for analysis alerts inside of GitHub, the results can also be published as workflow artifacts, allowing contributors to download and view them locally in the IDE. This is enabled by our <a href="https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/">support for SARIF</a>, which is a standardized file format for analysis tooling. This format can be viewed inside of Visual Studio Code using the <a href="https://marketplace.visualstudio.com/items?itemName=MS-SarifVSCode.sarif-viewer">SARIF Viewer extension</a>. This will provide additional information highlighted on the source code, allowing the developer to easily resolve any problems found.</p>
<p>The repository will need to support CMake to ensure information about how the project is built can be extracted. We chose CMake because it provides a good abstraction for the varied nature of C++ projects and due to its wide adoption in the open-source community. It also provides an easy path for teams not currently building with the Microsoft Compiler to get analysis setup and see the features it has to offer.</p>
<h2 id="setup-github-action">Setup GitHub Action</h2>
<p>To get started using this experience you can find an entry for Microsoft C++ Code Analysis on the Security (tab) -&gt; Setup up code scanning page if C++ is detected in your repository.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/WorkflowSetup.gif"><img class="alignnone wp-image-29704 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/WorkflowSetup.gif" alt="Setting up Code Scanning workflow (GIF)" width="1002" height="592" /></a></p>
<p>Once you have the template installed you can customize it to adapt to the specific needs of your repository. You can configure options such as ignoring a set of targets used for testing or changing the Ruleset file. The Ruleset file allows you to customize which warnings will be run beyond the default behavior. You can select a predefined ruleset available in a Visual Studio install (inside the ‘Team ToolsStatic Analysis ToolsRule Sets’ directory) or reference a customized file checked-in to the source. For the best results create a custom ruleset that adds/removes warnings from official rulesets in VS. This will ensure you receive updated checks as more are developed. Refer to the <a href="https://docs.microsoft.com/cpp/code-quality/using-rule-sets-to-specify-the-cpp-rules-to-run?view=msvc-160">documentation on rulesets</a> for more information.</p>
<h3 id="example-ruleset">Example Ruleset</h3>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;RuleSet Name="Example" Description="Enable Warnings" ToolsVersion="10.0"&gt; 
  &lt;!-- Default rules available in Visual Studio --&gt;
  &lt;Include Path="NativeRecommendedRules.ruleset" Action="Default" /&gt; 
  &lt;Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis"     
         RuleNamespace="Microsoft.Rules.Native"&gt; 
    &lt;Rule Id="C26440" Action="None" /&gt; &lt;!-- Exclude: Declare noexcept --&gt;
    &lt;Rule Id="C26492" Action="None" /&gt; &lt;!-- Include: No const_cast&lt;&gt; --&gt; 
  &lt;/Rules&gt; 
&lt;/RuleSet&gt; </code></pre>
<h2 id="feedback">Feedback</h2>
<p>The action is published under a pre-release status as it is tested on additional GitHub repositories and more features are added. We would love to hear feedback from you on how we can improve the Action to make it compatible with your GitHub projects. If you have a need for Native MSBuild support, please express your interest on the following <a href="https://developercommunity.visualstudio.com/t/Add-Native-MSBuild-support-for-GitHub-Ac/1563225">feature request ticket</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">Microsoft C++ Code Analysis with GitHub Actions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</title>
		<link>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/</link>
					<comments>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/#comments</comments>
		
		<dc:creator><![CDATA[David Li]]></dc:creator>
		<pubDate>Mon, 25 Oct 2021 13:53:40 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[gamedev]]></category>
		<category><![CDATA[Intellisense]]></category>
		<category><![CDATA[unreal engine]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29655</guid>

					<description><![CDATA[<p>With Visual Studio, we want to build the best tools to empower game developers. We joined forces with Epic Games to bring faster semantic highlighting and IntelliSense ready to Visual Studio 2022 for Unreal Engine developers. In this blog post, we will detail how we worked with the Unreal Engine team to significantly speed up the time it takes IntelliSense to start when a new file is opened in the editor by an order of 18x.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>With Visual Studio, we want to build the best tools to empower game developers. We joined forces with Epic Games to bring faster semantic highlighting and IntelliSense ready to Visual Studio 2022 for Unreal Engine developers. In this blog post, we will detail how we worked with the Unreal Engine team to significantly speed up the time it takes IntelliSense to start when a new file is opened in the editor by an order of <strong>18x</strong>.</p>
<p><strong><em>&#8220;We&#8217;ve always struggled with Intellisense performance in the Unreal Engine solution, but these changes are a night-and-day improvement. Faster feedback and less waiting help devs stay focused on making amazing games.&#8221;</em></strong> – Ben Marsh, Lead Programmer at Epic Games</p>
<p><strong>The changes are available for Unreal Engine 4.27.1 projects using the latest Visual Studio 2022 Preview. The changes will be available for Unreal Engine 5 at a later date.</strong></p>
<h1 id=""><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHOld30s.gif"><img class="aligncenter size-full wp-image-29684" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHOld30s.gif" alt="Image UnrealPCHOld30s" width="1200" height="675" /></a></h1>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHNew15s.gif"><img class="aligncenter size-full wp-image-29685" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCHNew15s.gif" alt="Image UnrealPCHNew15s" width="1200" height="675" /></a></p>
<h2 id="testing-methodology">Testing Methodology</h2>
<p>We tested using an Unreal Engine 4.27.1 sample project on a desktop with Intel Core i7-9700 @ 3Ghz, 64GB RAM, and an SSD. The tests took place on Visual Studio 2019 16.11.5 and Visual Studio 2022 Preview 6. The results were averaged over 4 runs.</p>
<h2 id="results">Results</h2>
<p>When opening a file on Visual Studio 2019, it took <strong>11.0</strong> seconds for IntelliSense to be ready and semantic code colorization to show up. Opening a different file took the same amount of time to get to the same state. Closing and reopening the same file took <strong>1.0</strong> seconds for the ready state.</p>
<p>In comparison, Visual Studio 2022 took <strong>7.2</strong> seconds for the first file to be ready and <strong>0.4</strong> seconds for any subsequent files.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png"><img class="aligncenter size-full wp-image-29671" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png" alt="Image UnrealPCH" width="2273" height="1393" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH.png 2273w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-300x184.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-1024x628.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-768x471.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-1536x941.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/10/UnrealPCH-2048x1255.png 2048w" sizes="(max-width: 2273px) 100vw, 2273px" /></a></p>
<h2 id="analysis">Analysis</h2>
<p>Prior to the change, each translation unit, the C++ and header files in your project, started from scratch with no state reuse between them. Reopening the same file took 1 second; however, because PCHs were not shared between files, opening any file for the first time took the same amount of time for semantic highlighting to show up and IntelliSense to be ready.</p>
<p>In Unreal Engine 4.27.1 projects using Visual Studio 2022, the generated project files are updated to configure IntelliSense to share compilation state across translation units. As a result, the semantic code colorization and IntelliSense completion will be available drastically quicker (<strong>0.4 seconds</strong>) when switching files in Visual Studio.</p>
<p>In addition, C++ IntelliSense improvements in VS2022 were able to bring down ready time by a factor of <strong>1.5x</strong> from 11 seconds to 7.4 seconds. This change will benefit all C++ developers using IntelliSense, not only Unreal Engine developers.</p>
<h2 id="applying-the-change-to-your-project">Applying The Change to Your Project</h2>
<p>Currently, you will need to manually make an update in the Unreal Engine Editor to apply the changes.</p>
<ol>
<li>Click Edit -&gt; Editor Preferences -&gt; Source Code</li>
<li>Change Source Code Editor to “Visual Studio 2022”</li>
<li>Click File -&gt; Refresh Visual Studio 2022 Project</li>
<li>Click File -&gt; Open Visual Studio 2022 to open the project in Visual Studio</li>
</ol>
<p><em>If you use GenerateProjectFiles.bat when working with Unreal Engine source code, use “GenerateProjectFiles.bat -2022” to generate project files with changes.</em></p>
<h2 id="feedback-wanted">Feedback Wanted!</h2>
<p>We received feedback about various ways of making the game developer experiences even better in Visual Studio. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like the one detailed in this blogpost.</p>
<p>How will these productivity enhancements impact you as a game developer? What other enhancements do you wish to see in Visual Studio? Talk to us in the comments below, on Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h2 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h2>
<p><strong><a href="https://visualstudio.microsoft.com/launch/">Visual Studio 2022</a> is now available! </strong></p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/">18x Faster IntelliSense for Unreal Engine Projects in Visual Studio 2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/18x-faster-intellisense-for-unreal-engine-projects-in-visual-studio-2022/feed/</wfw:commentRss>
			<slash:comments>15</slash:comments>
		
		
			</item>
	</channel>
</rss>
