<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>The latest in C++, Visual Studio, VS Code, and vcpkg from the MSFT C++ team</description>
	<lastBuildDate>Tue, 06 Aug 2024 22:26:56 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>GitHub Copilot Extensions for C++ developers and beyond now available in VS Code</title>
		<link>https://devblogs.microsoft.com/cppblog/github-copilot-extensions-for-c-developers-and-beyond-now-available-in-vs-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/github-copilot-extensions-for-c-developers-and-beyond-now-available-in-vs-code/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Wed, 07 Aug 2024 09:00:57 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Copilot]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34409</guid>

					<description><![CDATA[<p>GitHub Copilot is now more extensible than ever for extension authors in VS Code.<br />
At the Microsoft Build conference, we announced that VS Code extensions can now leverage APIs for Copilot to build custom chat participants that users can interact with in the GitHub Copilot Chat view in VS Code.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/github-copilot-extensions-for-c-developers-and-beyond-now-available-in-vs-code/">GitHub Copilot Extensions for C++ developers and beyond now available in VS Code</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>GitHub Copilot is now more extensible than ever for extension authors in VS Code.</p>
<p>At the Microsoft Build conference, we announced that VS Code extensions can now leverage APIs for Copilot to build custom <strong>chat participants</strong> that users can interact with in the GitHub Copilot Chat view in VS Code. To learn more, please watch <a href="https://www.youtube.com/watch?v=YI7kjWzIiTM">the Build session on the new extensibility</a> and read more on the <a href="https://code.visualstudio.com/blogs/2024/06/24/extensions-are-all-you-need">VS Code blog</a>.  Some notable extensions that have developed chat participants for public consumption include <a href="https://marketplace.visualstudio.com/items?itemName=DevCenter.ms-devbox">Microsoft Dev Box</a> and <a href="https://marketplace.visualstudio.com/items?itemName=ParallelsDesktop.parallels-desktop">Parallels</a>.</p>
<p>Another API that extensions can leverage LLMs with is the <strong>language model API</strong>. It enables you to integrate AI-powered features and natural language processing in your Visual Studio Code extension. To learn more about this API, please visit <a href="https://code.visualstudio.com/api/extension-guides/language-model">our VS Code docs</a>.</p>
<h3 id="what-are-chat-participants">What are chat participants?</h3>
<p>You can read more in <a href="https://code.visualstudio.com/api/extension-guides/chat">the VS Code docs for</a> more specifics on how chat participants work. These are specified by the user in the Copilot chat window, with queries using <code>@&lt;participant&gt;</code>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/cat-pointers.png"><img decoding="async" class=" wp-image-34410 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/cat-pointers.png" alt="@Cat chat participant providing a description of pointers in C++ in cat speak" width="863" height="682" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/cat-pointers.png 1023w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/cat-pointers-300x237.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/cat-pointers-768x607.png 768w" sizes="(max-width: 863px) 100vw, 863px" /></a></p>
<p>Some existing chat participants available in VS Code Copilot Chat that you may be familiar with include <code>@workspace</code> and <code>@vscode</code>.</p>
<p>For example, <code>@workspace</code> dynamically looks at all the code in your open workspace to provide relevant code snippets as context to Copilot Chat.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/tests-chat.png"><img decoding="async" class="size-full wp-image-34481 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/tests-chat.png" alt="Invoking @workspace to query a codebase for where the tests are located" width="459" height="555" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/tests-chat.png 459w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/tests-chat-248x300.png 248w" sizes="(max-width: 459px) 100vw, 459px" /></a></p>
<p>On the other hand, <code>@vscode</code> dynamically indexes VS Code settings to provide an answer.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/cmake-vscode-copilot.png"><img decoding="async" class="size-full wp-image-34482 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/cmake-vscode-copilot.png" alt="Using @vscode to ask VS code how to specify a specific cmake executable to use in project" width="402" height="446" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/cmake-vscode-copilot.png 402w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/cmake-vscode-copilot-270x300.png 270w" sizes="(max-width: 402px) 100vw, 402px" /></a></p>
<p>With the latest release, you now have access to build your own chat participant for your VS Code extensions, allowing you to provide domain knowledge to Copilot that would be relevant to your users.</p>
<p>As a consumer, there are some chat participants to look forward to that utilized this API and are in the pipeline. For example, for users who have containerized development, there is <a href="https://www.docker.com/blog/preview-docker-extension-for-github-copilot/">a Docker Copilot extension that is currently in limited public beta</a> that allows users to learn more about containerization with regards to their app.</p>
<h3 id="what-are-language-models">What are language models?</h3>
<p>With the <a href="https://code.visualstudio.com/api/extension-guides/language-model">Language Model API</a>, you can directly access and take advantage of LLMs contributed by GitHub Copilot in your own extensions, by specifying prompts, relevant context, and how requests should be sent to the model. You can utilize this API to enhance developer experiences beyond the Copilot Chat view.</p>
<p>For example, one feature that utilizes the Language Model API is AI-powered rename suggestions, that allow you to dynamically rename symbols in your C++ code. These will automatically invoke suggestions when you go to rename a symbol in VS code when you have the Copilot Chat extension installed.<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/rename-suggestions-vsc.png"><img decoding="async" class="size-full wp-image-34411 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/rename-suggestions-vsc.png" alt="AI-generated rename suggestions for a variable named &quot;property&quot;" width="787" height="339" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/rename-suggestions-vsc.png 787w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/rename-suggestions-vsc-300x129.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/rename-suggestions-vsc-768x331.png 768w" sizes="(max-width: 787px) 100vw, 787px" /></a></p>
<p>Additionally, the source control view utilizes the Language Model API to prompt how to automatically generate commit messages using AI for users that invoke it, based on the source code changes.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/ai-commit-messages.png"><img decoding="async" class="size-full wp-image-34412 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/ai-commit-messages.png" alt="AI-generated commit message detailing updates to main.cpp in the soure control view in VS Code" width="612" height="392" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/ai-commit-messages.png 612w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/ai-commit-messages-300x192.png 300w" sizes="(max-width: 612px) 100vw, 612px" /></a></p>
<h3 id="whats-next-in-vs-code-copilot-chat">What&#8217;s next in VS Code Copilot Chat?</h3>
<p>We are committed to enhancing the extensibility, quality, and customizability of Copilot Chat in VS Code. Stay tuned for exciting updates to make your experience with Chat.</p>
<p>Some things coming up to look forward to in VS Code, which can be found in <a href="https://code.visualstudio.com/blogs/2024/06/24/extensions-are-all-you-need#_next-steps">the original blog post announcement from the VS Code team</a>, include the <strong>variable resolving API</strong>, which allows extensions to contribute chat variables (via # sign) which provide context from the extension’s domain. Additionally, VS Code expects improvements to intent detection, so that these chat participants are automatically invoked, and to provide GPT-4o language model support.</p>
<p>Please file any issues or feedback in the <a href="https://github.com/microsoft/vscode-copilot-release">VS Code Copilot repo</a>, try out building your own developments using Copilot for your extensions, or let us know any VS Code extensions you’d like to see leveraging these APIs.</p>
<p>To learn more about using GitHub Copilot in VS Code with C++, watch <a href="https://www.youtube.com/watch?v=ZfT2CXY5-Dc">our introduction YouTube video</a> and <a href="https://www.youtube.com/@code/playlists">others on the VS Code Channel</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/github-copilot-extensions-for-c-developers-and-beyond-now-available-in-vs-code/">GitHub Copilot Extensions for C++ developers and beyond now available in VS Code</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/github-copilot-extensions-for-c-developers-and-beyond-now-available-in-vs-code/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New in vcpkg (July 2024)</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2024/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2024/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 01 Aug 2024 19:15:40 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34467</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2024.07.12 release, 2024-07-10 tool release, as well as changes to vcpkg documentation throughout July. This month’s release includes some minor changes to output, bug fixes, and documentation improvements.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2024/">What’s New in vcpkg (July 2024)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.07.12">2024.07.12 release</a>, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2024-07-10">2024-07-10 tool release</a>, as well as changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout July. This month’s release includes some minor changes to output, bug fixes, and documentation improvements.</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,457 total ports </strong>available in the vcpkg public registry. A <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>17 new ports</strong> were added to the open-source registry.</li>
<li><strong>315 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our 13 main <a href="https://learn.microsoft.com/en-us/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>28 contributors</strong> submitted PRs, issues, or participated in discussions in the main repo.</li>
<li>The main vcpkg repo has over <strong>6,200 forks</strong> and <strong>22,400 stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="vcpkg-changelog-2024-07-12-release">vcpkg changelog (2024.07.12 release)</h3>
<p>The following notable changes were made in this release:</p>
<ul>
<li>Added VxWorks as a platform expression (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1427">Microsoft/vcpkg-tool#1427</a>, thanks @Neumann-A!).</li>
<li>vcpkg now uses curl to download on Windows when proxy authentication is required (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1434">Microsoft/vcpkg-tool#1434</a>, thanks @sylvlecl!).</li>
<li>vcpkg now raises errors for certain invalid overlay port manifests: malformed JSON, missing “name” field, and missing “version:” field (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1435">Microsoft/vcpkg-tool#1435</a>, thanks @dg0yt!).</li>
<li>Made error message clearer when attempting to download sources from an invalid URL when installing a port (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1411">Microsoft/vcpkg-tool#1411</a>, thanks @autoantwort!).</li>
<li>Improved asset caching output to make it clear if it is enabled and what specific actions vcpkg is taking (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1409">Microsoft/vcpkg-tool#1409</a>).</li>
<li>Bug fixes:
<ul>
<li>Fixed x-update-baseline incorrectly updating the baseline field when the registry is configured with a reference. The correct behavior is to use the latest commit of the reference branch when set (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1414">Microsoft/vcpkg-tool#1414</a>).</li>
<li>Fixed post-build check that forbids putting absolute paths in installed packages to also check .csh and .pl files for these paths (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1426">Microsoft/vcpkg-tool#1426</a>, thanks @dg0yt!).</li>
<li>Fixed incorrect vcpkg export help message when specifying an output directory (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1450">Microsoft/vcpkg-tool#1450</a>, thanks @myd7349!).</li>
<li>Fixed vcpkg.exe sometimes failing to determine the version of a downloaded nuget.exe (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1451">Microsoft/vcpkg-tool#1451</a>, thanks @kazssym!).</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<h3 id="documentation-changes">Documentation changes</h3>
<ul>
<li>Added docs for <code>AUTHORIZATION_TOKEN</code> in <a href="https://learn.microsoft.com/vcpkg/maintainers/functions/vcpkg_from_gitlab">vcpkg_from_gitlab</a> (PR: <a href="https://github.com/microsoft/vcpkg-docs/pull/328">Microsoft/vcpkg-docs#328</a>, thanks, @autoantwort!).</li>
<li>Documented <code>STRIP_TRAILING_WHITESPACE</code> for the <a href="https://learn.microsoft.com/vcpkg/maintainers/functions/vcpkg_execute_required_process">vcpkg_execute_required_process</a> function (PR: <a href="https://github.com/microsoft/vcpkg-docs/pull/348/">Microsoft/vcpkg-docs#348</a>).</li>
<li>Documented <code>VCPKG_USE_HOST_TOOLS</code> CMake option in <a href="https://learn.microsoft.com/vcpkg/users/host-dependencies">Host dependencies</a> article (PR: <a href="https://github.com/microsoft/vcpkg-docs/pull/306">Microsoft/vcpkg-docs#306</a>).</li>
<li>Clarified level of support for different Unix/Linux distros in <a href="https://learn.microsoft.com/vcpkg/concepts/supported-hosts">Supported hosts</a> article (PRs: <a href="https://github.com/microsoft/vcpkg-docs/pull/339">Microsoft/vcpkg-docs#339</a>, <a href="https://github.com/microsoft/vcpkg-docs/pull/345">Microsoft/vcpkg-docs#345</a>, <a href="https://github.com/microsoft/vcpkg-docs/pull/341">Microsoft/vcpkg-docs#341</a>, thanks @SchaichAlonso!).</li>
<li>Other typo and bug fixes (thanks @autoantwort, @Suisse00, and @kwsp!).</li>
</ul>
<p>If you have any suggestions for our documentation, please <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a> or see the box at the bottom of a particular article.</p>
<p><img decoding="async" class="wp-image-34469" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/word-image-34467-1.png" width="686" height="202" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/word-image-34467-1.png 1508w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/word-image-34467-1-300x88.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/word-image-34467-1-1024x301.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/08/word-image-34467-1-768x226.png 768w" sizes="(max-width: 686px) 100vw, 686px" /></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total ports available for tested triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x64-windows</td>
<td>2,323</td>
</tr>
<tr>
<td>x86-windows</td>
<td>2,231</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2,203</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2,237</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,915</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1,285</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1,252</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2,293</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2,170</td>
</tr>
<tr>
<td>arm64-osx</td>
<td>2,090</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1,593</td>
</tr>
<tr>
<td>x64-android</td>
<td>1,665</td>
</tr>
<tr>
<td>arm64-android</td>
<td>1,641</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a>, or <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs</a> repos in this release:</p>
<ul>
<li>dg0yt (26 commits)</li>
<li>c8ef (21 commits)</li>
<li>autoantwort (19 commits)</li>
<li>Neumann-A (7 commits)</li>
<li>miyanyan (6 commits)</li>
<li>nlogozzo (5 commits)</li>
<li>m-kuhn (4 commits)</li>
<li>talregev (4 commits)</li>
<li>xiaozhuai (4 commits)</li>
<li>waywardmonkeys (3 commits)</li>
<li>RT2Code (2 commits)</li>
<li>myd7349 (3 commits)</li>
<li>MehdiChinoune (1 commit)</li>
<li>omarhogni (1 commit)</li>
<li>moritz-h (1 commit)</li>
<li>alagoutte (1 commit)</li>
<li>Tradias (1 commit)</li>
<li>past-due (1 commit)</li>
<li>AenBleidd (1 commit)</li>
<li>coryan (1 commit)</li>
<li>SchaichAlonso (1 commit)</li>
<li>Suisse00 (1 commit)</li>
<li>kwsp (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn more</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.07.12">full 2024.07.12 release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to vcpkg documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2024/">What’s New in vcpkg (July 2024)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-july-2024/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MSVC Backend Updates in Visual Studio 2022 version 17.10</title>
		<link>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-10/</link>
					<comments>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-10/#comments</comments>
		
		<dc:creator><![CDATA[Sarthak Tamboli]]></dc:creator>
		<pubDate>Mon, 29 Jul 2024 19:10:48 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34439</guid>

					<description><![CDATA[<p>Visual Studio 2022 17.10 brings new optimizations, intrinsics, features, and improvements to the MSVC backend. Check out the highlights below:</p>
<p>Performance improvements and additional functionality for all architectures:</p>
<p>Improved SLP vectorizer. Now it runs on more functions, recognizes more operations, and may choose to use larger vector widths if allowed by the appropriate /arch flag.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-10/">MSVC Backend Updates in Visual Studio 2022 version 17.10</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://visualstudio.microsoft.com/vs/features/cplusplus/">Visual Studio 2022</a> 17.10 brings new optimizations, intrinsics, features, and improvements to the MSVC backend. Check out the highlights below:</p>
<ul>
<li>Performance improvements and additional functionality for all architectures:
<ul>
<li>Improved SLP vectorizer. Now it runs on more functions, recognizes more operations, and may choose to use larger vector widths if allowed by the appropriate <code>/arch</code> flag. Add the <code><a href="https://learn.microsoft.com/en-us/cpp/build/reference/qvec-report-auto-vectorizer-reporting-level?view=msvc-170">/Qvec-report:1</a></code> switch and look for info <em>C5003: block vectorized</em> for more SLP vectorization.</li>
<li>Support <code>__declspec(guard(overflow))</code> with signed operations for add/mul.</li>
<li><a href="https://devblogs.microsoft.com/cppblog/improvements-in-variable-visibility-when-debugging/">Improvements in Variable Visibility when Debugging.</a></li>
<li>Enabled code coverage of managed C++ binaries targeting .NET Core.</li>
<li>Increase debug information for symbol removal during <a href="https://devblogs.microsoft.com/cppblog/improvements-in-variable-visibility-when-debugging/"><code>/LTCG</code>.</a></li>
<li>Significant improvements to ASAN code generation, fixing codegen bugs, and reducing false negatives. ASAN now emits more checks in the presence of inlining.</li>
<li>Made security improvements to the PDB handling code.</li>
</ul>
</li>
<li>New functionality and performance improvements on ARM64:
<ul>
<li>The new <a href="https://learn.microsoft.com/en-us/cpp/build/reference/feature-arm64?view=msvc-170"><code>/feature</code> (ARM64)</a> flag allows you to enable one or more optional Arm A-Profile architecture features for a specified ARM64 extension. You can also enable ARM64 features by specifying them in the updated <a href="https://learn.microsoft.com/en-us/cpp/build/reference/arch-arm64?view=msvc-170"><code>/arch</code></a> ARM64 option. For example, if you’d like to enable feature <code>FEAT_LSE</code> (Large System Extensions), you can use both <code>/feature:lse</code> and <code>/arch:armv8.0</code> or only use <code>/arch:armv8.0+lse</code>. Note that only certain ARM64 features are currently supported by MSVC. Along with adding the option to enable Arm A-Profile architecture features, the <code>/arch</code> ARM64 option now has the additional arguments for Armv8-A architecture extension version armv8.9 and Armv9-A architecture extensions armv9.0, armv9.1, armv9.2, armv9.3, and armv9.4. For more information about both options, please refer to our documentation for <a href="https://learn.microsoft.com/en-us/cpp/build/reference/arch-arm64?view=msvc-170"><code>/feature</code> (ARM64)</a> and <a href="https://learn.microsoft.com/en-us/cpp/build/reference/arch-arm64?view=msvc-170"><code>/arch</code> (ARM64)</a>.</li>
<li>Added Arm64 intrinsics, and variants, for exclusive load/store and load/store for unprivileged registers, <code>ldtr</code> and <code>sttr</code><em>.</em> Thanks to our friends at ARM.</li>
<li>Optimized Arm64 CRT functions to run faster and take less space
<ul>
<li><code>strstr</code>/<code>wcschr</code>/<code>wcsrchr</code>/<code>wcsstr</code></li>
<li><code>strchr</code><em>, </em><code>strrchr</code>, and <code>memchr</code>, thanks to our friends at ARM.</li>
</ul>
</li>
<li>Speed up intrinsic expansion by reducing intermediate steps</li>
<li>Support SVE2 instructions in the assembler and disassembler, thanks to our friends at ARM.
<ul>
<li>bit permutation</li>
<li>element move and broadcasting</li>
<li>constructive multiplication</li>
<li>polynomial and complex integer arithmetic/dot product/matrix multiplication/comparison</li>
<li>uniform/widening/narrowing/unary DSP operations</li>
<li>cryptography support</li>
<li>extended table lookup</li>
<li>non-temporal gather/scatter</li>
<li>floating-point extra conversion and floating-point widening multiply-accumulate</li>
</ul>
</li>
</ul>
</li>
<li>Improvements to ARM64EC:
<ul>
<li>No longer generate mismatched thunks with different call signatures</li>
<li>Now considers x64 functions during long-branch optimizations <a href="https://learn.microsoft.com/en-us/cpp/build/reference/opt-optimizations?view=msvc-170"><code>/OPT:LBR</code></a></li>
<li><code><a href="https://learn.microsoft.com/en-us/cpp/build/reference/map-generate-mapfile?view=msvc-170">/map</a></code> now contains Arm64 native symbols</li>
</ul>
</li>
<li>Performance improvements and additional functionality for x86 and x64:
<ul>
<li>Vectorizer optimized to run in additional scenarios, thanks to our friends at AMD.</li>
<li>Optimize FMA generation with <code>/favor:ATOM</code>, thanks to our friends at Intel.</li>
<li>New functionality on x64:
<ul>
<li>Support the vectorization of the multiplication of 8-bit types for AVX512, thanks to our friends at Intel.</li>
<li>Support AVX2 and AVX512 variable bit shift instructions, thanks to our friends at AMD.</li>
<li>Our friends at Intel added intrinsics for Intel Lion Cove to enable:
<ul>
<li>AVX-VNNI-INT16
<ul>
<li><code>VPDPW[SU,US,UU]D[,S]</code></li>
</ul>
</li>
<li>TSE
<ul>
<li><code>PBNDKB</code></li>
</ul>
</li>
<li>SHA512
<ul>
<li><code>VSHA512MSG1</code><em>, </em><code>VSHA512MSG2</code><em>, </em><code>VSHA512RNDS2</code></li>
</ul>
</li>
<li>SM3
<ul>
<li><code>VSM3MSG1</code><em>, </em><code>VMS3MSG2</code><em>, </em><code>VSM3RNDS2</code></li>
</ul>
</li>
<li>SM4
<ul>
<li><code>VSM4KEY4</code><em>, </em><code>VSM4RNDS4</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Do you want to experience the new improvements in the C++ backend? Please <a href="https://visualstudio.microsoft.com/vs/features/cplusplus/">download the latest Visual Studio 2022</a> and give it a try! Any feedback is welcome. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/cpp">Developer Community</a>, X (<a href="https://twitter.com/visualc">@VisualC</a>), or email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>Stay tuned for more information on updates to the latest Visual Studio.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-10/">MSVC Backend Updates in Visual Studio 2022 version 17.10</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/msvc-backend-updates-in-visual-studio-2022-version-17-10/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Genetec uses Visual Studio, CMake, vcpkg, and Docker for remote Linux C++ development</title>
		<link>https://devblogs.microsoft.com/cppblog/genetec-uses-visual-studio-for-cmake-and-remote-container-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/genetec-uses-visual-studio-for-cmake-and-remote-container-development/#respond</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 23 Jul 2024 14:54:52 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Containers]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34406</guid>

					<description><![CDATA[<p>Over the past couple of months, the Microsoft C++ team reached out to a series of customers voting on a suggestion ticket asking for Remote Linux Unit Testing support to understand their full set of interactions and needs with CMake and remote Linux scenarios in Visual Studio.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/genetec-uses-visual-studio-for-cmake-and-remote-container-development/">Genetec uses Visual Studio, CMake, vcpkg, and Docker for remote Linux C++ development</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Over the past couple of months, the Microsoft C++ team reached out to a series of customers voting on <a href="https://developercommunity.visualstudio.com/t/ctest-support-for-remote-linux-targets/431771">a suggestion ticket asking for Remote Linux Unit Testing support</a> to understand their full set of interactions and needs with CMake and remote Linux scenarios in Visual Studio. After these discussions, we built out a backlog of work items to deliver on any pain points in their experiences.</p>
<p>One of the customers we interviewed and worked closely with during the process was Georg Zankl, a software developer for Genetec. Georg manages a project that uses dev containers and CMake. Our team helped Georg to bridge the gap in his developer workflows between Visual Studio and VS Code, so that his team can use Visual Studio and benefit from this more powerful IDE, while having a reproducible dev environment in VS Code.</p>
<p>Specifically, he previously could not use CMake Presets with his Docker environment in Visual Studio, and his CTests were not discoverable in the Test Explorer UI. However, after working with the Microsoft C++ team, his CMake builds are now enabled in dev containers in Visual Studio, allowing him to utilize Visual Studio’s powerful IntelliSense and features.</p>
<p>Below is an interview with Georg on his overall experience. <em>Thank you, Georg, for working with us!</em></p>
<hr />
<h3 id="what-does-your-team-do">What does your team do?</h3>
<p>We develop and deploy algorithms based on Deep Learning and Computer Vision for real-time video processing.</p>
<p>We use very large open-source libraries for video processing, Computer Vision, and Deep Learning. Usually, we require customized configurations and builds of those all while continuously updating them. <strong>We rely on docker and vcpkg (with nuget caching) to get reproducible, efficient builds</strong>. The builds of our C++ code are generally integrated in containerized C# applications.</p>
<h3 id="what-was-your-prior-development-environment-for-managing-your-projects">What was your prior development environment for managing your projects?</h3>
<p>We use Windows workstations but deploy on Linux. We’ve used VS Code as it has very good support for this kind of development across programming languages, due to the dev container support. On the other hand, Visual Studio is more powerful with its IntelliSense and extensions for C++. Visual Studio had support for dev containers, which was a step for us to utilize the powerful IDE features with our workflow. However, it had some issues which were preventing us from utilizing this IDE. Most notably, CTest tests running from the UI did not work in the container, and the CMake Presets that included a path in our docker image were not properly recognized by Visual Studio and instead reverted to a default configuration.</p>
<h3 id="what-was-your-experience-working-with-the-microsoft-c-team-how-did-it-enable-you-to-adopt-visual-studio">What was your experience working with the Microsoft C++ team? How did it enable you to adopt Visual Studio?</h3>
<p>The Microsoft C++ team was very proactive in enabling our workflows and addressed the dev container issues for us step-by-step.</p>
<p>CMake Presets including paths in the docker image and CTests now work for our environments in Visual Studio. The Visual Studio team worked diligently to ensure dev container support was available for these scenarios.</p>
<p>We can now use Visual Studio with pretty much the same setup that we use in VS Code, while benefiting from the more powerful IDE. With the fixes applied, <strong>VS CMake builds in dev containers work very well for us. </strong>All our tooling (gcc, ninja, cmake, vcpkg, ..) is now validated and versioned through our baseline docker container and developers can get started right away with Visual Studio or VS Code, simply by opening the project with devcontainers.</p>
<hr />
<p>Now, Genetec (and you) has first-class VS support available for using dev containers with their CMake project. Visual Studio is now more versatile than ever for remote Linux C++ developers who are looking to have reproducible developer environments across their IDEs.</p>
<p>Please try out <a href="aka.ms/vs">Visual Studio 17.11 Preview 2</a> for this latest dev container support.</p>
<p>The Microsoft C++ team would love to hear from any teams that work with our IDE and would like to see improvements with their remote Linux and/or CMake scenarios. Please reach out to us at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/genetec-uses-visual-studio-for-cmake-and-remote-container-development/">Genetec uses Visual Studio, CMake, vcpkg, and Docker for remote Linux C++ development</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/genetec-uses-visual-studio-for-cmake-and-remote-container-development/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Improving GitHub Copilot Completions in VS Code for C++ Developers</title>
		<link>https://devblogs.microsoft.com/cppblog/improving-github-copilot-completions-in-vs-code-for-c-developers/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improving-github-copilot-completions-in-vs-code-for-c-developers/#comments</comments>
		
		<dc:creator><![CDATA[Erika Sweet]]></dc:creator>
		<pubDate>Mon, 22 Jul 2024 14:43:56 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Copilot]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34429</guid>

					<description><![CDATA[<p>GitHub Copilot code completions are autocomplete-stye suggestions that appear inline as you code. Until today, they have used context from your active file and other tabs open in the editor to inform the suggestion that is returned. However, we know that more contextually relevant input leads to better suggestions.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/improving-github-copilot-completions-in-vs-code-for-c-developers/">Improving GitHub Copilot Completions in VS Code for C++ Developers</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>GitHub Copilot code completions are autocomplete-stye suggestions that appear inline as you code. Until today, they have used context from your <a href="https://code.visualstudio.com/docs/copilot/ai-powered-suggestions#_context">active file and other tabs open in the editor</a> to inform the suggestion that is returned. However, we know that more contextually relevant input leads to better suggestions. Our team has made changes to the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ extension</a> and the <a href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot">GitHub Copilot extension</a> in VS Code to ensure that other relevant C++ context — like available types and methods — are also provided to Copilot completions.</p>
<p>When you use the latest version of the C/C++ extension and the GitHub Copilot extension together in VS Code, directly-referenced header files will be automatically considered when gathering additional context for Copilot completions, even if they’re not open in the editor. This helps to reduce hallucinations and provide more relevant suggestions. Let’s look at an example.</p>
<h5 id="before-directly-referenced-header-files-are-not-considered-as-context-for-github-copilot-code-completions">Before: Directly-referenced header files are not considered as context for GitHub Copilot code completions</h5>
<p>In this example, I want to create a new function in the OSS <a href="https://github.com/dolphin-emu/dolphin/tree/321c4649a5c9d185ea163707d0ee9f296df1ecd6">Dolphin codebase</a> to find text files. When directly-referenced header files are not considered as context, GitHub Copilot hallucinates a <a href="https://github.com/search?q=repo%3Adolphin-emu%2Fdolphin%20FindFiles&amp;type=code">non-existent FindFiles() function</a>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/headers-context-off-blog.gif"><img decoding="async" class="aligncenter size-full wp-image-34432" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/headers-context-off-blog.gif" alt="A snippet of C++ code in VS Code. A user types a function name (FindAllTextFiles), and Copilot hallucinates a non-existent function (FindFiles()) in the function body." width="1440" height="379" /></a></p>
<h5 id="after-directly-referenced-header-files-are-considered-as-context-for-github-copilot-code-completions">After: Directly-referenced header files are considered as context for Github Copilot code completions</h5>
<p>Now, when directly-referenced header files are considered as context, Copilot correctly suggests an <a href="https://github.com/dolphin-emu/dolphin/blob/321c4649a5c9d185ea163707d0ee9f296df1ecd6/Source/Core/Common/FileSearch.h#L13-L15">existing DoFileSearch()</a> utility function declared in FileSearch.h.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/headers-context-on-blog.gif"><img decoding="async" class="aligncenter size-full wp-image-34433" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/07/headers-context-on-blog.gif" alt="A snippet of C++ code in VS Code. A user types a function name (FindAllTextFiles), and Copilot suggests an existing utility function (DoFileSearch) in the function body." width="1440" height="379" /></a></p>
<p>To get started, make sure you’re using the <a href="https://marketplace.visualstudio.com/items?itemName=GitHub.copilot">GitHub Copilot extension</a> version 1.205 or later and have an active <a href="https://github.com/features/copilot?utm_source=vscom&amp;utm_medium=hero&amp;utm_campaign=cta-get#pricing">GitHub Copilot subscription</a>. You’ll also need the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack">C/C++ extension</a> version 1.21 or later with <a href="https://code.visualstudio.com/docs/cpp/configure-intellisense">IntelliSense configured correctly</a>. Version 1.21 of the C/C++ extension is currently in pre-release. Our team is committed to C++ Copilot support in both Visual Studio and VS Code, and similar support is coming to Visual Studio in Visual Studio 2022 version 17.12.</p>
<h3 id="contacts-us">Contacts Us</h3>
<p>Your feedback helps inform our work to improve the Copilot experience for C++ developers in Visual Studio and VS Code. You can provide feedback on GitHub Copilot by opening a <a href="https://github.com/orgs/community/discussions/categories/copilot">GitHub discussion</a>. You can also reach our team via email (<a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>), X (<a href="https://x.com/visualc">@VisualC</a>), or through the comments below.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/improving-github-copilot-completions-in-vs-code-for-c-developers/">Improving GitHub Copilot Completions in VS Code for C++ Developers</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improving-github-copilot-completions-in-vs-code-for-c-developers/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>What&#8217;s New in vcpkg (June 2024)</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2024/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2024/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 27 Jun 2024 00:35:53 +0000</pubDate>
				<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34374</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2024.06.15 release, 2024-06-10 tool release, as well as changes to vcpkg documentation throughout June. This month’s release includes some error message improvements and bug fixes.<br />
Some stats for this period:</p>
<p>There are now 2,441 total ports available in the vcpkg public registry.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2024/">What&#8217;s New in vcpkg (June 2024)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.06.15">2024.06.15 release</a>, <a href="https://github.com/microsoft/vcpkg-tool/releases/tag/2024-06-10">2024-06-10 tool release</a>, as well as changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout June. This month’s release includes some error message improvements and bug fixes.</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,441 total ports </strong>available in the vcpkg public registry. A <a href="https://learn.microsoft.com/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>9 new ports</strong> were added to the open-source registry.</li>
<li><strong>442 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our 13 main <a href="https://learn.microsoft.com/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>26 contributors</strong> submitted PRs, issues, or participated in discussions in the main repo.</li>
<li>The main vcpkg repo has over <strong>6,100 forks</strong> and <strong>22,000 stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="vcpkg-changelog-2024-06-15-release">vcpkg changelog (2024.06.15 release)</h3>
<p>The following meaningful changes were made in this release:</p>
<ul>
<li>Fixed version export in SPDX module (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1400">Microsoft/vcpkg-tool#1400</a>, thanks @xvitaly!).</li>
<li>Added missing <code>--keep-going</code> switch to <code>x-set-installed</code> (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1407">Microsoft/vcpkg-tool#1407</a>, thanks @Neumann-A!).</li>
<li>Fixed misleading/incorrect error message triggering on an AWS S3 binary cache miss (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1404">Microsoft/vcpkg-tool#1404</a>, thanks @petamas!).</li>
<li>All post-build checks now have skip policies. Also made some error messages more consistent in format, improved their output, and removed some duplicate messages (PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/1405">Microsoft/vcpkg-tool#1405</a>).</li>
</ul>
<p>&nbsp;</p>
<h3 id="documentation-changes">Documentation changes</h3>
<ul>
<li>Made references to the vcpkg curated registry more consistent throughout the docs. The curated registry is the main registry that ships with vcpkg and consists of 2400+ open-source ports (PR: <a href="https://github.com/microsoft/vcpkg-docs/pull/333">Microsoft/vcpkg-docs#333</a>).</li>
<li>Added clarification about why ports in the curated registry need to work simultaneously in the <a href="https://learn.microsoft.com/vcpkg/contributing/maintainer-guide">Maintainer guide</a> (PR: <a href="https://github.com/microsoft/vcpkg-docs/pull/332">Microsoft/vcpkg-docs#332</a>).</li>
<li>Added mentions of IDEs/editors that officially support vcpkg in the <a href="https://learn.microsoft.com/vcpkg/concepts/build-system-integration">Build system integration</a> article (thanks @UnixY2K for providing the initial PR <a href="https://github.com/microsoft/vcpkg-docs/pull/325">Microsoft/vcpkg-docs#325</a> for this effort!).</li>
<li>Added some recommended packages for pacman-based Linux distros (Article: <a href="https://learn.microsoft.com/vcpkg/concepts/supported-hosts">Supported hosts</a>; PR: <a href="https://github.com/microsoft/vcpkg-docs/pull/326">Microsoft/vcpkg-docs#326</a>, thanks @UnixY2K!).</li>
<li>Added some clarifications for binary caching ABI hashing (Article: <a href="https://learn.microsoft.com/vcpkg/reference/binarycaching">Binary caching reference</a>; PR: <a href="https://github.com/microsoft/vcpkg-docs/pull/330">Microsoft/vcpkg-docs#330</a>, thanks @Thomas1664!)</li>
<li>Removed some duplicate deprecation notices about CONTROL files in certain articles.</li>
<li>Fixed some typos (thanks @Thomas1664, @c8ef, and @pzychotic!).</li>
</ul>
<p>If you have any suggestions for our documentation, please <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a> or see the box at the bottom of a particular article.</p>
<p><img decoding="async" class="wp-image-34376" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/word-image-34374-1.png" width="672" height="198" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/word-image-34374-1.png 1508w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/word-image-34374-1-300x88.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/word-image-34374-1-1024x301.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/word-image-34374-1-768x226.png 768w" sizes="(max-width: 672px) 100vw, 672px" /></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total ports available for tested triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x64-windows</td>
<td>2,306</td>
</tr>
<tr>
<td>x86-windows</td>
<td>2,215</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2,190</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2,223</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,873</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1,274</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1,240</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2,273</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2,155</td>
</tr>
<tr>
<td>arm64-osx</td>
<td>2,074</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1,578</td>
</tr>
<tr>
<td>x64-android</td>
<td>1,651</td>
</tr>
<tr>
<td>arm64-android</td>
<td>1,625</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a>, or <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs</a> repos in this release:</p>
<ul>
<li>dg0yt (35 commits)</li>
<li>Neumann-A (8 commits)</li>
<li>RT2Code (5 commits)</li>
<li>AenBleidd (4 commits)</li>
<li>Thomas1664 (4 commits)</li>
<li>xiaozhuai (3 commits)</li>
<li>MehdiChinoune (2 commits)</li>
<li>UnixY2K (2 commits)</li>
<li>kafeg (1 commit)</li>
<li>omarhogni (1 commit)</li>
<li>alagoutte (1 commit)</li>
<li>miyanyan (1 commit)</li>
<li>danielaparker (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>talregev (1 commit)</li>
<li>Osyotr (1 commit)</li>
<li>traversaro (1 commit)</li>
<li>chausner (1 commit)</li>
<li>c8ef (1 commit)</li>
<li>pzychotic (1 commit)</li>
<li>xvitaly (1 commit)</li>
<li>autoantwort (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn more</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.06.15">full 2024.06.15 release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to vcpkg documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a> or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>&nbsp;</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2024/">What&#8217;s New in vcpkg (June 2024)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-june-2024/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Understand your C++ symbols using Copilot in Visual Studio&#8217;s Quick Info</title>
		<link>https://devblogs.microsoft.com/cppblog/understand-your-c-symbols-using-copilot-in-visual-studios-quick-info/</link>
					<comments>https://devblogs.microsoft.com/cppblog/understand-your-c-symbols-using-copilot-in-visual-studios-quick-info/#comments</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 18 Jun 2024 09:00:30 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Copilot]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34348</guid>

					<description><![CDATA[<p>Navigating your codebase and forget what exactly that method does? Looking for quick, easy-to-digest information on your code at any point in your development journey?<br />
We are excited to announce that now when you hover over symbols in your codebase, you&#8217;ll have the ability to invoke Copilot conveniently within the Quick Info dialog to learn more about a given symbol and enhance existing or lacking code documentation.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/understand-your-c-symbols-using-copilot-in-visual-studios-quick-info/">Understand your C++ symbols using Copilot in Visual Studio&#8217;s Quick Info</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Navigating your codebase and forget what exactly that method does? Looking for quick, easy-to-digest information on your code at any point in your development journey?</p>
<p>We are excited to announce that now when you hover over symbols in your codebase, you&#8217;ll have the ability to invoke Copilot conveniently within the Quick Info dialog to learn more about a given symbol and enhance existing or lacking code documentation.</p>
<h3 id="how-it-works">How it works</h3>
<p>Normally, in the Quick info window, you would see comments or xml documentation if it was generated by your team in the code, which can sometimes be unrelated to what the given symbol does. Copilot can help augment existing documentation or lacking documentation.</p>
<p>Just hover over your symbol of interest and click on the link to learn more about what it does in natural language, rather than having to go to the definition and parse through all the code.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2.png"><img decoding="async" class="alignnone size-full wp-image-34350" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2.png" alt="A symbol called Outfit Choices, that has a link to Tell Me More over it" width="2185" height="370" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2.png 2185w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2-300x51.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2-1024x173.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2-768x130.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2-1536x260.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/tellmemore-v2-2048x347.png 2048w" sizes="(max-width: 2185px) 100vw, 2185px" /></a></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info.png"><img decoding="async" class="alignnone size-full wp-image-34351" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info.png" alt="Copilot provided a definition of what OutfitChoices function does in Visual Studio's quick info" width="2149" height="457" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info.png 2149w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info-300x64.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info-1024x218.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info-768x163.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info-1536x327.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/outfit-choices-info-2048x436.png 2048w" sizes="(max-width: 2149px) 100vw, 2149px" /></a></p>
<p>Copilot uses the declaration and definition of the given symbol to provide you an understanding of it at any invocation.</p>
<p>For example, when working with unfamiliar library code, there is often context from the source code of the symbol definition to infer the purpose of the symbol.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-tell-me-more.png"><img decoding="async" class="alignnone size-full wp-image-34352" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-tell-me-more.png" alt="Tell me more link over an unfamiliar section of library code called &quot;enable_bsl_summary_mode&quot;" width="1753" height="399" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-tell-me-more.png 1753w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-tell-me-more-300x68.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-tell-me-more-1024x233.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-tell-me-more-768x175.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-tell-me-more-1536x350.png 1536w" sizes="(max-width: 1753px) 100vw, 1753px" /></a></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-more-info.png"><img decoding="async" class="alignnone wp-image-34353 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-more-info-e1718642657451.png" alt="The &quot;enable_bsl_summar_mode&quot; function with some Copilot-generated info" width="1556" height="219" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-more-info-e1718642657451.png 1556w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-more-info-e1718642657451-300x42.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-more-info-e1718642657451-1024x144.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-more-info-e1718642657451-768x108.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/library-code-more-info-e1718642657451-1536x216.png 1536w" sizes="(max-width: 1556px) 100vw, 1556px" /></a></p>
<h3 id="try-it-out">Try it out</h3>
<p>Stay tuned for upcoming support for other languages and please let us know anything you&#8217;d like to see added to this feature. You&#8217;ll need an active <a href="https://github.com/features/copilot?utm_source=vscom&amp;utm_medium=hero&amp;utm_campaign=cta-get#pricing">GitHub Copilot</a> subscription. Download the <a href="http://aka.ms/vs">latest version of Visual Studio</a> and give it a try.</p>
<p>In addition, our team is working hard on improving C++ integrations with Copilot Chat, so please let us know any other enhancements you&#8217;d like to see to your C++ workflows and content you&#8217;d like to see.</p>
<p>We welcome all types of feedback on your experience with the product. Comment below, or you can find us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or via X at <a href="https://x.com/visualc">@VisualC</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/understand-your-c-symbols-using-copilot-in-visual-studios-quick-info/">Understand your C++ symbols using Copilot in Visual Studio&#8217;s Quick Info</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/understand-your-c-symbols-using-copilot-in-visual-studios-quick-info/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Bosch widely adopts Visual Studio 2022 after experiencing performance improvements for C++ Linux cross-compilation</title>
		<link>https://devblogs.microsoft.com/cppblog/bosch-widely-adopts-visual-studio-2022-after-experiencing-performance-improvements-for-c-linux-cross-compilation/</link>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Mon, 10 Jun 2024 16:00:55 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34323</guid>

					<description><![CDATA[<p>Introduction</p>
<p>The Bosch security camera team had been evaluating Visual Studio as a unified development setup for their team’s C++ development, which includes remote Linux C++ development for cross-compiling. <br />
While evaluating Visual Studio 2022, the team had a positive experience of using Visual Studio for their C++ development due to notable improvements over the years.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/bosch-widely-adopts-visual-studio-2022-after-experiencing-performance-improvements-for-c-linux-cross-compilation/">Bosch widely adopts Visual Studio 2022 after experiencing performance improvements for C++ Linux cross-compilation</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h3 id="introduction">Introduction</h3>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/Bosch_symbol_logo_black_red.png"><img decoding="async" class="alignnone wp-image-34324" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/Bosch_symbol_logo_black_red.png" alt="Bosch symbol logo black red" width="1172" height="468" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/Bosch_symbol_logo_black_red.png 1920w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/Bosch_symbol_logo_black_red-300x120.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/Bosch_symbol_logo_black_red-1024x409.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/Bosch_symbol_logo_black_red-768x307.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/Bosch_symbol_logo_black_red-1536x614.png 1536w" sizes="(max-width: 1172px) 100vw, 1172px" /></a></p>
<p><span class="TextRun SCXW69896041 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW69896041 BCX8">The </span><span class="NormalTextRun CommentStart SCXW69896041 BCX8">Bosch</span><span class="NormalTextRun SCXW69896041 BCX8"> security camera</span><span class="NormalTextRun SCXW69896041 BCX8"> team</span><span class="NormalTextRun SCXW69896041 BCX8"> ha</span><span class="NormalTextRun SCXW69896041 BCX8">d been evaluating Visual Studio as a</span><span class="NormalTextRun SCXW69896041 BCX8"> unified development setup</span><span class="NormalTextRun SCXW69896041 BCX8"> for their </span><span class="NormalTextRun SCXW69896041 BCX8">team’s </span><span class="NormalTextRun SCXW69896041 BCX8">C++ development, </span><span class="NormalTextRun SCXW69896041 BCX8">which includes</span><span class="NormalTextRun SCXW69896041 BCX8"> remote Linux</span><span class="NormalTextRun SCXW69896041 BCX8"> C++</span><span class="NormalTextRun SCXW69896041 BCX8"> development for cross-compiling.</span> </span></p>
<p><span data-contrast="auto">While evaluating Visual Studio 2022, the team had a positive experience of using Visual Studio for their C++ development due to notable improvements over the years. Specifically, compared to their experience with Visual Studio 2019, they noticed improvements such as:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<ol>
<li data-leveltext="%1." data-font="" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559683&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0,46],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">More seamless integration with GDB and a quicker debug experience within the inner-dev-loop </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></li>
<li data-leveltext="%1." data-font="" data-listid="1" data-list-defn-props="{&quot;335552541&quot;:0,&quot;335559683&quot;:0,&quot;335559684&quot;:-1,&quot;335559685&quot;:720,&quot;335559991&quot;:360,&quot;469769242&quot;:[65533,0,46],&quot;469777803&quot;:&quot;left&quot;,&quot;469777804&quot;:&quot;%1.&quot;,&quot;469777815&quot;:&quot;hybridMultilevel&quot;}" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Better integration with CMake and WSL2 to allow for stabilized build environments and easily transferrable dev environments. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></li>
</ol>
<p><span data-contrast="auto">In Visual Studio 2022, they migrated their project from CMake settings to </span><a href="https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html"><span data-contrast="none">CMake presets</span></a><span data-contrast="auto"> to improve portability between Visual Studio and VS Code, compilation performance, and ease of maintaining multiple different configurations.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span class="TextRun SCXW262439761 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW262439761 BCX8">However, </span><span class="NormalTextRun SCXW262439761 BCX8">th</span><span class="NormalTextRun SCXW262439761 BCX8">e</span><span class="NormalTextRun SCXW262439761 BCX8"> Bosch team was still </span><span class="NormalTextRun SCXW262439761 BCX8">impacted</span><span class="NormalTextRun SCXW262439761 BCX8"> by</span> <span class="NormalTextRun SCXW262439761 BCX8">one issue with their Linux development</span><span class="NormalTextRun SCXW262439761 BCX8"> which was that there was a </span><span class="NormalTextRun SCXW262439761 BCX8">gap in the current </span><span class="NormalTextRun SCXW262439761 BCX8">sync mechanism when switching between code branches.</span><span class="NormalTextRun SCXW262439761 BCX8"> They had reached out to the </span><span class="NormalTextRun SCXW262439761 BCX8">Microsoft </span><span class="NormalTextRun SCXW262439761 BCX8">C++ team, who promptly resolved their issues</span><span class="NormalTextRun SCXW262439761 BCX8"> in </span><span class="NormalTextRun SCXW262439761 BCX8">Visual Studio 2022 version 17.10</span><span class="NormalTextRun SCXW262439761 BCX8">.</span></span> <span class="TextRun SCXW262439761 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW262439761 BCX8">As a result of this collaboration, the </span><span class="NormalTextRun CommentStart SCXW262439761 BCX8">C++</span><span class="NormalTextRun SCXW262439761 BCX8"> workload</span><span class="NormalTextRun SCXW262439761 BCX8"> has added new capabilities, which enable</span><span class="NormalTextRun SCXW262439761 BCX8"> finer grain</span><span class="NormalTextRun SCXW262439761 BCX8"> control of </span><span class="NormalTextRun SpellingErrorV2Themed SCXW262439761 BCX8">rsync</span><span class="NormalTextRun SCXW262439761 BCX8"> settings</span><span class="NormalTextRun SCXW262439761 BCX8"> when used with a remote </span><span class="NormalTextRun SpellingErrorV2Themed SCXW262439761 BCX8">rsync</span><span class="NormalTextRun SCXW262439761 BCX8"> daemon. This is </span><span class="NormalTextRun SCXW262439761 BCX8">accomplished</span><span class="NormalTextRun SCXW262439761 BCX8"> via a new </span><span class="NormalTextRun SCXW262439761 BCX8">CMake</span><span class="NormalTextRun SCXW262439761 BCX8"> presets property for the user specification of </span><span class="NormalTextRun SpellingErrorV2Themed SCXW262439761 BCX8">rsync</span><span class="NormalTextRun SCXW262439761 BCX8"> daemon parameters. The property supports explicit control over the copy. For example, the user can now explicitly turn on/off </span><span class="NormalTextRun SpellingErrorV2Themed SCXW262439761 BCX8">rsync’s</span> <span class="NormalTextRun SpellingErrorV2Themed SCXW262439761 BCX8">s</span><span class="NormalTextRun SpellingErrorV2Themed SCXW262439761 BCX8">ymlink</span><span class="NormalTextRun SCXW262439761 BCX8"> “munging” feature when copying.</span></span><span class="EOP SCXW262439761 BCX8" data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<blockquote><p><span data-contrast="auto">“This step significantly decreased our issues during CMake configure and the average time needed for a configure-compiler-debug- cycle, not only because of the omitted additional step, but also there is less effort in doing syncing as well, as the copy keeps untouched. </span><b><span data-contrast="auto">This overall increased our productivity and reduced the pain in cross-compiling for multiple targets.</span></b><span data-contrast="auto">” &#8211; Bosch</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p></blockquote>
<p><span data-contrast="auto">This blog post was written in collaboration with Philipp Jeske and Rainer Bauereiss, a software engineer and a software engineering lead we worked with to deliver on these improvements, who shared their story and experience with C++ development while adopting Visual Studio 2022. Thank you both for your continued partnership over the years!</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<hr />
<h5 id="what-does-your-team-do-what-technical-challenges-come-from-your-work"><strong>What does your team do? What technical challenges come from your work?</strong></h5>
<p><span data-contrast="auto">We are developing the OS and the applications for the Bosch security cameras. Involved is an international team with multiple locations which are contributing software modules for those cameras on multiple layers. Scaling this firmware to multiple types of cameras is key. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span data-contrast="auto">Our OS is based on Linux in different variants, that differ depending on the target. Each OS variant comes with its own SDK and toolchain for cross-compiling on a Linux host.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span data-contrast="auto">For embedded application development, we must work with different SDKs and toolchains. Most development is Windows based, but we also have Linux based machines. The toolchain is either locally installed or inside a WSL2 or other virtual machines tools. For limitations of some SDKs, the SDKs files are checked in as part of our application repository, and there come the symbolic links from our issue in play. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<h5 id="what-was-the-process-of-re-evaluating-and-adopting-visual-studio-as-a-unified-ide-for-the-team-like"><strong>What was the process of re-evaluating and adopting Visual Studio as a unified IDE for the team like?</strong></h5>
<p><span data-contrast="auto">Some months ago, there wasn’t anything such as a unified development setup, but we were striving for a unified way of building our code. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span data-contrast="auto">We started a proof of concept using Visual Studio 2022 for cross-development on Windows Hosts, after previously evaluating Visual Studio 2019.  We started with WSL2 integration and CMakeSettings.json.  We noticed substantial improvements in how working with VS2022 looks and feels like after the substantial changes made in the year before. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559685&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span class="NormalTextRun SCXW195228984 BCX8">During the evaluation phase of Visual Studio 2019 we had good contact with the </span><span class="NormalTextRun CommentStart SCXW195228984 BCX8">Microsoft </span><span class="NormalTextRun SCXW195228984 BCX8">C++</span><span class="NormalTextRun SCXW195228984 BCX8"> team, but sadly the tooling did not provide the functionality we needed. The main issue with Visual Studio 2019 before was the unsatisfying debug experience (due to lack of performance while compiling), when working remotely on a Linux-based system. The seamless integration from GDB into Visual Studio makes it nowadays one of the <strong>best debugging experiences we have encountered so far</strong>. The Visual Studio and Visual Studio Code remote development experience, especially for Linux and CMake-based projects, has clearly increased a lot since the last evaluation.</span></p>
<p><span data-contrast="auto">This setup already had some benefits by using Visual Studio as IDE and debugger interface, but it had its drawbacks, especially the lack of performance whilst compiling and the not-portable CMakeSettings.json configuration. Nevertheless, this setup has already convinced some of us and we have started out using this setup for our daily business.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span data-contrast="auto">In parallel, we experimented a bit and finally encountered that </span><b><span data-contrast="auto">when we use CMake Presets, most of the drawbacks would be resolved.</span></b><span data-contrast="auto"> Therefore, we migrated from CMakeSettings.json to CMakePresets.json and with that setup our performance problem was gone, thanks to the rsync mechanism that removes the performance penalty that comes from compiling on a network share. Another advantage was that </span><b><span data-contrast="auto">the configuration made in CMakePresets is compatible between Visual Studio and VS Code.</span></b><span data-contrast="auto"> Additionally, it makes it easier for us to maintain multiple different build configurations.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<h5 id="after-migrating-to-cmake-presets-what-were-your-challenges-with-using-visual-studio"><strong>After migrating to CMake presets, what were your challenges with using Visual Studio?</strong></h5>
<p><span class="TextRun SCXW231873589 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW231873589 BCX8">We were so positive about the overall experience of using Visual Studio</span><span class="NormalTextRun SCXW231873589 BCX8">. However, there was </span><span class="NormalTextRun SCXW231873589 BCX8">a flaw present in the </span><span class="NormalTextRun SpellingErrorV2Themed SCXW231873589 BCX8">rsync</span><span class="NormalTextRun SCXW231873589 BCX8"> mechanism</span><span class="NormalTextRun SCXW231873589 BCX8"> preventing us from increasing the acceptance of the VS2022 solution widely across the team</span><span class="NormalTextRun SCXW231873589 BCX8">. </span><span class="NormalTextRun SpellingErrorV2Themed SCXW231873589 BCX8">Symlinks</span> <span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW231873589 BCX8">were getting</span><span class="NormalTextRun SCXW231873589 BCX8"> munged when using </span><span class="NormalTextRun SpellingErrorV2Themed SCXW231873589 BCX8">rsync</span><span class="NormalTextRun SCXW231873589 BCX8"> for </span><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2Themed SCXW231873589 BCX8">cross-compiling</span><span class="NormalTextRun SCXW231873589 BCX8"> our WSL targets</span><span class="NormalTextRun SCXW231873589 BCX8">.</span><span class="NormalTextRun SCXW231873589 BCX8"> Because this was an issue for us and severity increased with the number of developers working with the new </span><span class="NormalTextRun SCXW231873589 BCX8">tool</span><span class="NormalTextRun SCXW231873589 BCX8">, we reached out to the Visual Studio C++ team </span><span class="NormalTextRun SCXW231873589 BCX8">with the hope of getting some </span><span class="NormalTextRun SCXW231873589 BCX8">additional</span><span class="NormalTextRun SCXW231873589 BCX8"> information. </span></span><span class="EOP SCXW231873589 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<h5 id="what-is-your-current-experience-with-visual-studio-now-that-the-fix-has-been-implemented"><strong>What is your current experience with Visual Studio now that the fix has been implemented?</strong></h5>
<p><span class="NormalTextRun SCXW79827107 BCX8">Since the fix for our </span><span class="NormalTextRun SpellingErrorV2Themed SCXW79827107 BCX8">rsync</span><span class="NormalTextRun SCXW79827107 BCX8"> issue is available in the preview for the upcoming release, most of us switched to the prerelease version. This step significantly decreased our issues during </span><span class="NormalTextRun SCXW79827107 BCX8">CMake</span><span class="NormalTextRun SCXW79827107 BCX8"> configure and the average time needed for a configure-compile-debug-cycle decreased, not only because of the omitted </span><span class="NormalTextRun SCXW79827107 BCX8">additional</span><span class="NormalTextRun SCXW79827107 BCX8"> step,but also because there is less effort in doing the syncing as well, as the copy keeps the file names untouched. This overall increased our productivity and reduced the pain in cross-compiling for multiple targets.</span></p>
<p><span data-contrast="auto">We are on the verge of migrating to MSVC as a mandatory toolchain for all our development. The portability between Visual Studio and Visual Studio Code makes both in our case a good tooling, because of our diverse environment. Furthermore, it enables the developers to choose the development environment that works for them. </span><b><span data-contrast="auto">This increases productivity and satisfaction across the team. </span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span data-contrast="auto">The experience working with the Microsoft C++ team was very pleasant and solution oriented. We hope that we were able to share our appreciation for the tooling with the team that develops it.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<hr />
<p>You can adjust the value of munging symlinks via new rsync settings in the vendor block remote settings in CMake presets, as of Visual Studio 2022 version 17.10:</p>
<p><code>"rsyncCommandArgs": ["-t", "--delete", <strong>"--no-munge-links"</strong>]</code></p>
<p><code></code>
<code>"rsyncDaemonOptions": ["read only = no", "list = True", <strong>"munge symlinks = no"</strong>]</code></p>
<p>For example:</p>
<pre>"configurePresets": [
{
"name": "windows-base",
...
"vendor": {
"microsoft.com/VisualStudioRemoteSettings/CMake/1.0": {
"rsyncCommandArgs": ["--no-munge-links"],
"rsyncDaemonOptions": ["list = True"]
}
}
]</pre>
<hr />
<h3 id="conclusion">Conclusion</h3>
<p><span data-contrast="auto">Bosch has successfully adopted Visual Studio 2022 as a unified IDE for their C++ Linux cross-compilation projects, thanks to migrating to CMake presets, overall improvements to the Linux experience in Visual Studio over the years and collaborating with the Microsoft C++ team to improve rsync mechanism issues. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><span data-contrast="auto">Any developer targeting Linux with their CMake projects can try out the updates to the remote Linux experience with Visual Studio, including improvements to the CMake presets support and added rsync settings.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:278}"> </span></p>
<p><div style="text-align:center"><a class="cta_button_link" href="aka.ms/vs" style="text-transform: titlecase; display: inline-block; background-color: #0078D4; color: white; padding: 10px; margin:10px 0; text-decoration: none;" target="_blank">Download Visual Studio</a></div></p>
<p><span data-contrast="auto">The Microsoft C++ team is continuously looking to improve the remote Linux experience with the IDE and would love to hear from any enterprises that work with Visual Studio. Please reach out to us via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com.</a></span></p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/bosch-widely-adopts-visual-studio-2022-after-experiencing-performance-improvements-for-c-linux-cross-compilation/">Bosch widely adopts Visual Studio 2022 after experiencing performance improvements for C++ Linux cross-compilation</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Integrating C++ header units into Office using MSVC (3/n)</title>
		<link>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-3-n/</link>
					<comments>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-3-n/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Wed, 05 Jun 2024 16:30:47 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[build throughput]]></category>
		<category><![CDATA[C++ language]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[modernization]]></category>
		<category><![CDATA[modules]]></category>
		<category><![CDATA[Office]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34284</guid>

					<description><![CDATA[<p>Overview</p>
<p>Recap: Where we were, what we&#8217;re doing now.<br />
Changes adopted in Word: Composing headers for reuse.<br />
Testing Details: The setup of the performance experiment.<br />
Opportunity for Improvement: Identifying a potential performance bottleneck.<br />
Upcoming Improvements to MSVC.<br />
What&#8217;s next for Office?</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-3-n/">Integrating C++ header units into Office using MSVC (3/n)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<ul>
<li><a href="#recap">Recap: Where we were, what we&#8217;re doing now.</a></li>
<li><a href="#changes">Changes adopted in Word: Composing headers for reuse.</a></li>
<li><a href="#details">Testing Details: The setup of the performance experiment.</a></li>
<li><a href="#opportunity">Opportunity for Improvement: Identifying a potential performance bottleneck.</a></li>
<li><a href="#upcoming">Upcoming Improvements to MSVC.</a></li>
<li><a href="#what-next">What&#8217;s next for Office?</a></li>
<li><a href="#final-thoughts">Closing thoughts.</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>In our previous two (<a href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-1-n/">part 1</a>, <a href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-2-n/">part 2</a>) blog posts we discussed how Office was thinking holistically about header units. In this installment we’d like to share the concrete steps taken to integrate header units into the build of Microsoft Word, and their effect on build throughput. Throughout the post we&#8217;ll use the term &#8220;build throughput&#8221; as opposed to &#8220;build performance&#8221; to avoid potential confusion with application runtime performance. This blog is primarily a recap of the <a href="https://www.youtube.com/watch?v=RvliLGtaQ0c">presentation</a> that Zachary gave at Pure Virtual C++ 2024.</p>
<p>Remember that precompiled headers are an established technology, dating back 30 years, compared to header units, which are a newer feature, only 5 years old. There are still a lot of opportunities for optimization!</p>
<p>In the best case migrating from a precompiled header (PCH) to header units produced a <em>21.3% build throughput improvement</em>. In the worst case the migration yielded a <em>0.9% build throughput regression</em>.</p>
<h2><span id="changes">Changes adopted in Word</span></h2>
<p>There are two precompiled headers that Word code can select between. The first of these, minpch, is extremely lightweight. It contains things like the C++ standard library, windows.h, some common Word internal helpers, and a very small set of low-level Office shared headers. In total it includes about 250 files if you count all transitive includes. Minpch is not widely used; it&#8217;s the PCH chosen by only 2% of the files in Word.</p>
<p>On the other extreme is the word_shared precompiled header. It captures nearly every upstream header, with only some minimal holdbacks for test headers. It contains around 2500 transitive includes. This makes word_shared a challenging test for header units, both in terms of the breadth of C++ compiled into a header unit and what effect it will have on build throughput. As previously mentioned, Word used <a href="https://learn.microsoft.com/en-us/cpp/build-insights/get-started-with-cpp-build-insights?view=msvc-170">C++ Build Insights</a> to measure each individual file&#8217;s contribution as justification for its inclusion in word_shared.</p>
<p>At a high level the conversion we performed was:</p>
<ol>
<li>Switch <code>/Yc</code> to <a href="https://learn.microsoft.com/en-us/cpp/build/reference/module-exportheader?view=msvc-170"><code>/exportHeader</code></a></li>
<li>Switch <code>/Yu</code> to <a href="https://learn.microsoft.com/en-us/cpp/build/reference/headerunit?view=msvc-170"><code>/headerUnit:quoteword_shared.h=path/to/word_shared.ifc</code></a></li>
<li>Measure!</li>
</ol>
<h2><span id="details">Testing Details</span></h2>
<h3 id="process">Process</h3>
<p>These were the steps to gather measurements:</p>
<ol>
<li>Set the configuration to PCH or Header Units</li>
<li>Perform a full build of Word</li>
<li>Disable build caching</li>
<li>Run all compiler invocations, excluding PCH or HU creation (repeat 7x)</li>
<li>Record CPU time spent by the compiler, excluding highest and lowest results</li>
<li>Repeat every night, on 3 unique boxes, for 3 weeks</li>
</ol>
<p>In step 4, 3 unique sets of files were chosen to compile and measure. In the first case all C++ files (roughly 6000) in Word were compiled. In addition, two active areas of investment were chosen to measure. The first of these, henceforth referred to as &#8220;Folder A&#8221;, consisted of approximately 300 files. The second, which will be termed &#8220;Folder B&#8221;, consisted of around 200 files.</p>
<h3 id="test-equipment">Test Equipment</h3>
<table>
<tbody>
<tr>
<td></td>
<td><b>Build the World (BTW)</b></td>
<td><b>Physical Workstation (PDW)</b></td>
<td><b>Microsoft DevBox (MDB)</b></td>
</tr>
<tr>
<td><b>Threads</b></td>
<td>64</td>
<td>32</td>
<td>16</td>
</tr>
<tr>
<td><b>Max Clock</b></td>
<td>4.2 GHz</td>
<td>4.3 GHz</td>
<td>3.5 GHz</td>
</tr>
<tr>
<td><b>RAM</b></td>
<td>256 GB</td>
<td>128 GB</td>
<td>64 GB</td>
</tr>
<tr>
<td><b>Storage</b></td>
<td>Boot SSD + Software RAID data drive</td>
<td>Boot SSD + Software RAID data drive</td>
<td>Single Azure Premium SSD (P30)</td>
</tr>
</tbody>
</table>
<p>The Build the World machines are server-class machines, generally reserved for the limited number of developers that need to make changes that span all of Office at once. The physical workstations are more common and reflect what a developer working on an application team, such as Word, would have for their box. The Microsoft Dev Box is a publicly available product; a virtual machine running in Azure. Other MDB options are available from the service—these specifications are merely the specifications chosen for an internal pilot program.</p>
<h3 id="results">Results</h3>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/office-modules-throughput.png"><img decoding="async" class="alignnone wp-image-34295 size-large" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/office-modules-throughput-1024x532.png" alt="Image office modules throughput" width="640" height="333" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/office-modules-throughput-1024x532.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/office-modules-throughput-300x156.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/office-modules-throughput-768x399.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/office-modules-throughput-1536x798.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/06/office-modules-throughput-2048x1065.png 2048w" sizes="(max-width: 640px) 100vw, 640px" /></a></p>
<h3 id="additional-advantages">Additional Advantages</h3>
<p>Beyond build speed, header units have additional advantages. The IFC files produced by header units are portable. Precompiled headers produced by MSVC must be created and consumed locally. Header units don&#8217;t have this limitation.</p>
<p>It would be possible for a separate project upstream of Word to create the minpch and word_shared header units. Most Word developers would not need to build the files locally; the IFC files could simply be downloaded from the cloud.
Second, the IFC produced for a header unit follows a <a href="https://github.com/microsoft/ifc-spec">fully documented specification</a> and <a href="https://github.com/microsoft/ifc">corresponding SDK</a>. Cameron&#8217;s presentation on the IFC SDK from Pure Virtual C++ is <a href="https://www.youtube.com/watch?v=t6QCzVXrwIw">available on YouTube</a>.</p>
<p>Finally, header units are significantly smaller on disk than their corresponding PCH. The comparison between a single PCH file and a corresponding header unit may not be an unbiased comparison because of how well header units compose with their dependencies. To create a fairer picture, we&#8217;ve also included data on the disk size of Word&#8217;s header units plus all its upstream dependencies.</p>
<table>
<tbody>
<tr>
<td></td>
<td><b>PCH</b></td>
<td><b>Header Unit</b></td>
<td><b>% Reduction</b></td>
<td><b>Full header unit chain</b></td>
<td><b>% Reduction</b></td>
</tr>
<tr>
<td><b>minpch</b></td>
<td>174 MB</td>
<td>8.78 MB</td>
<td>95%</td>
<td>42.8 MB</td>
<td>77%</td>
</tr>
<tr>
<td><b>word_shared</b></td>
<td>1.16 GB</td>
<td>111 MB</td>
<td>90%</td>
<td>150 MB</td>
<td>88%</td>
</tr>
</tbody>
</table>
<h2><span id="opportunity">Uncovering an Opportunity for Improvement</span></h2>
<p>We were surprised to discover that storage system performance was the best predictor of build compile time improvement. We measured the size of the object files on disk, and found a sizable increase. The total disk space of all object files created for Word under header units was 1.22x the size on disk vs the total size of object files when consuming a PCH. The median increase per obj file was 1.25x and the largest was 8000x larger under header units.</p>
<p>This was due to the compiler duplicating debug information into each of the object files due to Office&#8217;s use of the <a href="https://learn.microsoft.com/en-us/cpp/build/reference/z7-zi-zi-debug-information-format?view=msvc-170"><code>/Z7</code> compiler flag</a>. This is a change from the toolchain&#8217;s ability to look up many kinds of debug information directly from the PCH file. The biggest offenders in Word were a pair of large enums with 10,000 and 30,000 entries. The first is an enum of all command IDs for all Office applications. The other is to idenitfy performance data scenarios. Even when only one enum value was used, all values of corresponding enum was recorded in the obj file.</p>
<p>After removing the include files that brought two enums into Word&#8217;s word_shared header, the object sizes on disk dropped by a measurable amount.</p>
<table>
<tbody>
<tr>
<td><b>PCH vs Header Units</b></td>
<td><b>Default</b></td>
<td><b>Large Enums Omitted</b></td>
</tr>
<tr>
<td><b>Total .obj file size increase</b></td>
<td>1.22x</td>
<td>1.18x</td>
</tr>
<tr>
<td><b>Median size increase</b></td>
<td>1.25x</td>
<td>1.22x</td>
</tr>
<tr>
<td><b>Greatest obj size increase</b></td>
<td>8000x</td>
<td>1700x</td>
</tr>
</tbody>
</table>
<p>As the table demonstrates, removing the large enums improved the size of binaries on disk but also made us anxious for the upcoming work in the MSVC toolchain that would eliminate this duplicate data.</p>
<h2><span id="upcoming">Upcoming improvements in MSVC</span></h2>
<p>Office hit a recent bug where the linker can fail to perform an incremental link and it falls back to performing a full link. If you run into the same issue in your projects, please update to compiler version 17.8.10 or 17.10.0 for the fix.</p>
<p>The other big item is to update the toolchain so that debug information can be gathered directly from an IFC file, and avoid creating huge obj files. Notably, this optimization benefits both named modules as well as header units.</p>
<p>This is a more invasive change than fixes Office has needed for header units in the past as it will require changes to the compiler, linker, and PDB writer—essentially requiring the entire toolset to cooperate. We don&#8217;t have a release date for this work, but please stay tuned for an announcement when it&#8217;s ready for testing.</p>
<h2><span id="what-next">What&#8217;s next for Office?</span></h2>
<p>In Office we want to continue making low-level libraries into header units. As a prerequisite we need to remove Office&#8217;s global &#8216;inc&#8217; folder, our collection of headers that don&#8217;t share a single logical responsibility. Once all these headers are moved to new homes their component libraries can each have a header unit created for them.</p>
<p>Once that&#8217;s done, we can migrate our shared PCH to become a header unit in the same way that was done for Word. The shared PCH is consumed by a huge percentage of our shared code, so we expect header unit creation and consumption to greatly accelerate once we reach this milestone.</p>
<p>In addition, we have ongoing work to do to continue striving for consistent build flags, the same issue we&#8217;ve highlighted in each of these blog posts. We&#8217;ve done a lot of prep work to mark where there are deviations from the global defaults, but the work remains to perform the migration to the common settings. Once we achieve continuity, downstream libraries can also become header units.</p>
<h2><span id="final-thoughts">Final Thoughts</span></h2>
<p>Moving a part of the Office codebase to utilize header units has been an excellent learning experience and collaborative effort between the compiler team and the Office engineering team. Without a doubt, this experience has shown that not only can header units (and therefore C++ modules) scale to a multi-million-line codebase, but the technology is flexible enough to match that of preexisting technology with 30+ years of improvements and improve upon it for even more throughput.</p>
<p>The MSVC implementation of modules is continuing to improve with each release and the more exposure the compiler gets to community feedback/usage the better the team can improve the overall quality and robustness. We recommend you go out and try to integrate C++ modules or header units into your code and tell us about your experiences. We’re eager to learn from and work with the community to elevate the implementation into something we are all happy to use!</p>
<h4 id="closing">Closing</h4>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow Cameron DaCamara on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report
a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us
know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-3-n/">Integrating C++ header units into Office using MSVC (3/n)</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/integrating-c-header-units-into-office-using-msvc-3-n/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New in vcpkg (May 2024): Dedicated Pages for Each Package on vcpkg.io</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-may-2024-dedicated-pages-for-each-package-on-vcpkg-io/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-may-2024-dedicated-pages-for-each-package-on-vcpkg-io/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Fri, 31 May 2024 19:53:46 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<category><![CDATA[vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=34273</guid>

					<description><![CDATA[<p>This blog post summarizes changes to the vcpkg package manager as part of the 2024.05.24 release as well as changes to vcpkg documentation throughout May. This month’s update also includes individual pages for each package on the vcpkg website as well as several new documentation articles.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-may-2024-dedicated-pages-for-each-package-on-vcpkg-io/">What’s New in vcpkg (May 2024): Dedicated Pages for Each Package on vcpkg.io</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>This blog post summarizes changes to the <a href="https://vcpkg.io/">vcpkg package manager</a> as part of the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.05.24">2024.05.24</a> release as well as changes to <a href="https://learn.microsoft.com/vcpkg/">vcpkg documentation</a> throughout May. This month’s update also includes individual pages for each package on the vcpkg website as well as several new documentation articles.</p>
<p>Some stats for this period:</p>
<ul>
<li>There are now <strong>2,434 total ports </strong>available in the vcpkg public registry. A <a href="https://learn.microsoft.com/vcpkg/concepts/ports">port is a versioned recipe</a> for building a package from source, such as a C or C++ library.</li>
<li><strong>11 new ports</strong> were added to the open-source registry.</li>
<li><strong>387 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our 13 main <a href="https://learn.microsoft.com/vcpkg/concepts/triplets">triplets</a>.</li>
<li><strong>20 contributors</strong> submitted PRs, issues, or participated in discussions in the main repo.</li>
<li>The main vcpkg repo has over <strong>6,100 forks</strong> and <strong>21,900 stars</strong> on GitHub.</li>
</ul>
<p>There was no update this month to the vcpkg tool binary itself. However, we have made an important update to our website, <a href="https://vcpkg.io/">vcpkg.io</a>.</p>
<p>&nbsp;</p>
<h3 id="individual-pages-for-each-port">Individual pages for each port</h3>
<p>Each one of the 2,434 ports available in the vcpkg open-source registry now has a dedicated page on vcpkg.io with more information about them. You can access these pages by using the search features accessible under <em>Packages</em> at the top right of the site. Below are some example screenshots of the openssl port. You can also review it for yourself at <a href="https://vcpkg.io/en/package/openssl">vcpkg.io/en/package/openssl</a>.</p>
<p><img decoding="async" class="wp-image-34275" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-2.png" alt="A screenshot of a computer Description automatically generated" width="999" height="566" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-2.png 1428w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-2-300x170.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-2-1024x580.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-2-768x435.png 768w" sizes="(max-width: 999px) 100vw, 999px" /></p>
<p>Each port page contains the following elements:</p>
<ol>
<li>The name of the port.</li>
<li>The most recently available version.</li>
<li>A description of the port.</li>
<li>The license for the port.</li>
<li>The last updated date for the port.</li>
<li>The “Supports” expression for the port which lists which triplets are explicitly supported or not supported. If blank, all triplets are assumed to be supported.</li>
<li>A link to documentation for the port, if available.</li>
<li>A link to the homepage for the port, if available.</li>
<li>Installation instructions for both classic and manifest mode.</li>
<li>Four tabs with additional information:
<ol>
<li>Dependencies: Lists the port’s dependencies.</li>
<li>Features: Lists the port’s optional features.</li>
<li>Versions: Lists all available versions of the port in the vcpkg registry.</li>
<li>Port Content: Lists all the files that comprise the port.</li>
</ol>
</li>
</ol>
<p>A view of the Features tab for openssl:</p>
<p><img decoding="async" class="wp-image-34276" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-3.png" alt="A screenshot of a computer Description automatically generated" width="999" height="555" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-3.png 1427w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-3-300x167.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-3-1024x569.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-3-768x427.png 768w" sizes="(max-width: 999px) 100vw, 999px" /></p>
<p>A view of the Versions tab for openssl:</p>
<p><img decoding="async" class="wp-image-34277" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-4.png" alt="A screenshot of a computer Description automatically generated" width="999" height="561" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-4.png 1428w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-4-300x168.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-4-1024x575.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-4-768x431.png 768w" sizes="(max-width: 999px) 100vw, 999px" /></p>
<p>A view of the Port Content tab for openssl:</p>
<p><img decoding="async" class="wp-image-34278" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-5.png" alt="A screenshot of a computer Description automatically generated" width="999" height="556" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-5.png 1426w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-5-300x167.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-5-1024x570.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/a-screenshot-of-a-computer-description-automatica-5-768x428.png 768w" sizes="(max-width: 999px) 100vw, 999px" /></p>
<p>We hope these new pages make it easier for anyone interested in vcpkg to learn more about libraries they can install out of the box from the open-source registry. And we would love your feedback on how we can make our website better!</p>
<p>&nbsp;</p>
<h3 id="documentation-changes">Documentation changes</h3>
<ul>
<li>Separated previous binary caching article into separate <a href="https://learn.microsoft.com/vcpkg/users/binarycaching">concepts</a> and <a href="https://learn.microsoft.com/vcpkg/reference/binarycaching">reference</a> articles. The concepts article is a good place to start if you are new to binary caching or want to learn best practices. The reference article lists all the interaction points of the feature and is useful when you are actually implementing or updating binary caching support for your libraries.</li>
<li>Added <a href="https://learn.microsoft.com/vcpkg/reference/policies">Port policies reference</a> article. Documents various ways to change and customize vcpkg’s behavior, such as post-build checks, and how certain ports are categorized based on their intended functionality.</li>
<li>Added <a href="https://learn.microsoft.com/vcpkg/concepts/continuous-integration">Continuous integration concepts</a> article. Provides guidance for using vcpkg in continuous integration environments.</li>
</ul>
<p>If you have any suggestions for our documentation, please <a href="https://github.com/microsoft/vcpkg-docs/issues">submit an issue in our GitHub repo</a> or see the box at the bottom of a particular article.</p>
<p><img decoding="async" class="wp-image-34279" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/word-image-34273-5.png" width="700" height="206" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/word-image-34273-5.png 1508w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/word-image-34273-5-300x88.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/word-image-34273-5-1024x301.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2024/05/word-image-34273-5-768x226.png 768w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total ports available for tested triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x64-windows</td>
<td>2,298</td>
</tr>
<tr>
<td>x86-windows</td>
<td>2,208</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>2,184</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>2,216</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,873</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>1,267</td>
</tr>
<tr>
<td>arm64-uwp</td>
<td>1,233</td>
</tr>
<tr>
<td>x64-linux</td>
<td>2,256</td>
</tr>
<tr>
<td>x64-osx</td>
<td>2,144</td>
</tr>
<tr>
<td>arm64-osx</td>
<td>2,067</td>
</tr>
<tr>
<td>arm-neon-android</td>
<td>1,565</td>
</tr>
<tr>
<td>x64-android</td>
<td>1,620</td>
</tr>
<tr>
<td>arm64-android</td>
<td>1,594</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures (as <a href="https://github.com/microsoft/vcpkg/tree/master/triplets/community">community triplets</a>), the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, <a href="https://github.com/microsoft/vcpkg-tool">vcpkg-tool</a>, or <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs</a> repos in this release:</p>
<ul>
<li>dg0yt (18 commits)</li>
<li>Neumann-A (7 commits)</li>
<li>miyanyan (5 commits)</li>
<li>AenBleidd (4 commits)</li>
<li>alagoutte (3 commits)</li>
<li>talregev (3 commits)</li>
<li>Thomas1664 (3 commits)</li>
<li>waywardmonkeys (2 commits)</li>
<li>cenit (2 commits)</li>
<li>RT2Code (2 commits)</li>
<li>MehdiChinoune (1 commit)</li>
<li>HappySeaFox (1 commit)</li>
<li>RealTimeChris (1 commit)</li>
<li>moritz-h (1 commit)</li>
<li>danielaparker (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>SchaichAlonso (1 commit)</li>
<li>Osyotr (1 commit)</li>
<li>coryan (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn more</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2024.05.24">full 2024.05.24 release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. To contribute to vcpkg documentation, visit the <a href="https://github.com/microsoft/vcpkg-docs">vcpkg-docs repo</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>.</p>
<p>The post <a href="https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-may-2024-dedicated-pages-for-each-package-on-vcpkg-io/">What’s New in vcpkg (May 2024): Dedicated Pages for Each Package on vcpkg.io</a> appeared first on <a href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-in-vcpkg-may-2024-dedicated-pages-for-each-package-on-vcpkg-io/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
	</channel>
</rss>
