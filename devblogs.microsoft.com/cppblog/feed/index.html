<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Thu, 27 May 2021 00:37:47 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Preview of using CMake Presets for Azure Sphere development</title>
		<link>https://devblogs.microsoft.com/cppblog/preview-of-using-cmake-presets-for-azure-sphere-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/preview-of-using-cmake-presets-for-azure-sphere-development/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Thu, 27 May 2021 15:00:53 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Containers]]></category>
		<category><![CDATA[IoT]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28128</guid>

					<description><![CDATA[<p>We are happy to announce that CMake Presets preview support is available in the Visual Studio 16.10 release as well as CMake Tools version 1.7 for Visual Studio Code.<br />
Erika introduced CMake Presets and why you should use them, this post will focus on how they can be used for Azure Sphere development across Visual Studio,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/preview-of-using-cmake-presets-for-azure-sphere-development/">Preview of using CMake Presets for Azure Sphere development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that CMake Presets preview support is available in the Visual Studio 16.10 release as well as CMake Tools version 1.7 for Visual Studio Code.</p>
<p>Erika introduced <a class='myclass'href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">CMake Presets and why you should use them</a>, this post will focus on how they can be used for Azure Sphere development across Visual Studio, VS Code, and GitHub Actions for consistent build settings across your development team and CI system.</p>
<p><a class='myclass'href="https://azure.microsoft.com/en-us/services/azure-sphere/">Azure Sphere</a> is a comprehensive IoT security solution that is beyond the scope of this article. Azure Sphere projects are CMake based, and application development is in C (<a class='myclass'href="https://azure.microsoft.com/en-us/services/azure-sphere/get-started/">get started</a> here).</p>
<p>As CMake Presets are still in preview in VS and VS Code they are not yet part of the Azure Sphere projects created by Visual Studio or VS Code. In the future they will be, as well as part of the official Azure Sphere samples. To collect early feedback on using CMake Presets for Azure Sphere I have prepared <a class='myclass'href="https://github.com/robotdad/AzureSphereBlink">a GitHub template repository of the Azure Sphere blink project</a> configured with CMake Presets you can use to follow this post.</p>
<h3 id="example-from-a-github-template">Example from a GitHub Template</h3>
<p><a class='myclass'href="https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/creating-a-repository-on-github/creating-a-repository-from-a-template">GitHub template repositories</a> are a way you can create a new project from an existing repo as opposed to starting a fork. This is great for providing samples to start a new project from where there is no intention in cloning to send changes upstream. You can create your own repo on GitHub directly by selecting “Use this template” and then clone it locally. Or you can use <a class='myclass'href="https://cli.github.com/manual/">the GitHub cli</a> to create your own repo from the template locally and on GitHub in one step.</p>
<pre class="Code">gh repo create azblink --template https://github.com/robotdad/AzureSphereBlink</pre>
<p>Follow the prompts from the above command and it will create a repo in your GitHub account named azblink and create a local copy of it.</p>
<h3 id="cmake-presets-file">CMake Presets file</h3>
<p>The CMakePresets.json file in this project has presets for debug and release builds on Windows and Linux. Both of these presets inherit from a common base configuration.</p>
<pre>"name": "Base",
"description": "Base configuration using Ninja generator",
"hidden": true,
"generator": "Ninja",
"binaryDir": "${sourceDir}/build/${presetName}",
"architecture": {
    "value": "arm",
    "strategy": "external"
},
"cacheVariables": {
    "AZURE_SPHERE_TARGET_API_SET": "latest-lts"
}</pre>
<p>This configuration is tagged as hidden which means it is not available to use directly, it is only for use to provide common settings to other presets. We can see that it is set to use Ninja as the build tool, and the output directory is configured here to derive from the configuration that is used. We can also see that the variable set for which Azure Sphere API set the project is configured for.</p>
<p>There are two other hidden presets: Windows-Base and Linux-Base. These inherit from the above Base configuration and each respectively set the CMake cache variable for the Azure Sphere toolchain file. That variable uses an environment variable that is set in each of these respective sections for the default Azure Sphere SDK installation location. You will also notice a vendor section that specifies a host OS. This is used by Visual Studio and VS Code to only surface that configuration option when it is on that OS. That reduces the possibility of selecting an invalid configuration.</p>
<h3 id="visual-studio">Visual Studio</h3>
<p>If you open this project in Visual Studio it will automatically select the Windows debug configuration and is ready to build with the implicit default build configuration. The launch configuration for Visual Studio in launch.vs.json is checked in as an exception under the .vs folder so debugging is preconfigured. You should not need to modify this file.</p>
<p>See our documentation for more information on how to <a class='myclass'href="https://docs.microsoft.com/en-us/cpp/build/cmake-presets-vs?view=msvc-160">configure and build with CMake Presets with Visual Studio</a>.</p>
<h3 id="vs-code">VS Code</h3>
<p>If you open this project in VS Code you will be prompted for which configuration to use. Select Debug. This occurs as settings.json is preconfigured to use the CMake Tools extension. When you build the project, you will be prompted for a build configuration, select default which is implicit from the selected configuration. To debug you need to have an Azure Sphere board attached.</p>
<p>This project does contain a devcontainer definition so you may be prompted to open in a devcontainer. This is supported so feel free to try that, it will work exactly as above including debugging.</p>
<p>Since there is a devcontainer definition this project can also be opened in GitHub Codespaces. Navigate to the repo you created and select the drop down on the Code button and then Open in Codespaces. In the web interface you can build the project. If you connect to the Codespace from VS Code you can also debug to a locally attached device.</p>
<p>See our documentation for more information on <a class='myclass'href="https://github.com/microsoft/vscode-cmake-tools/blob/develop/docs/cmake-presets.md">how to configure and build with CMake Presets with VS Code</a>.</p>
<h3 id="github-actions">GitHub Actions</h3>
<p>This project is preconfigured to use GitHub Actions. You <a class='myclass'href="https://docs.microsoft.com/en-us/azure-sphere/app-development/continuous-integration">can learn more about how to use GitHub Actions with Azure Sphere projects here</a>. As CMake Presets are new the thing that varies from other samples and current guidance is the invocation of CMake. If you look in the .devcontainer/Dockerfile you will see it is a multistage definition with three targets, dev, debug-build, and release-build. The dev stage is simply the official Azure Sphere container image.  This is used for the interactive devcontainer. The other two stages inherit the dev stage as a base. Each of these stages copies the repo into the container, then run CMake with either the debug or release preset, and then set the appropriate entry point to the generated cache to start the build.</p>
<p>Look in the .github\workflows\ci.yml file and you will see minor changes from the official guidance to use the paths created in the build output through using CMake Presets.</p>
<p>If you followed along from the beginning and created your own repo from the template repository you should already have a successful build. Go to your repo on GitHub and navigate to the Actions tab. You should see a completed workflow for the initial commit. If you select that there will be an artifact with the Azure Sphere image package that can be deployed to a device directly or as part of a <a class='myclass'href="https://docs.microsoft.com/en-us/azure-sphere/deployment/create-a-deployment?tabs=cliv2beta">deployment to a device group</a>.</p>
<h3 id="whats-next">What’s next?</h3>
<p>CMake Presets integration in Visual Studio and Visual Studio Code is still in preview. We’ll continue to add to our integration and address your feedback in future release of Visual Studio and the CMake Tools extension for VS Code.</p>
<p>In Visual Studio, the best way to file a bug or suggest a feature is with the <strong>Send Feedback</strong> button in the upper right-hand corner of the IDE. See <a class='myclass'href="https://docs.microsoft.com/en-us/visualstudio/ide/feedback-options?view=vs-2019#:~:text=In%20Visual%20Studio%2C%20choose%20the%20feedback%20icon%20in,information%2C%20see%20Suggest%20a%20feature%20for%20Visual%20Studio.">Visual Studio feedback options</a> for more information.</p>
<p>In VS Code, the best way to file a bug or suggest a feature is by creating (or upvoting) an issue in the <a class='myclass'href="https://github.com/microsoft/vscode-cmake-tools/issues">extension’s GitHub repository</a>.</p>
<p>We’d love to learn how your team is adopting CMake Presets, for Azure Sphere or otherwise. If you have feedback or a success story to share, you can contact us at <a class='myclass'href="mailto:cmake@microsoft.com">cmake@microsoft.com</a>. You can also reach us on Twitter (<a class='myclass'href="https://twitter.com/visualc">@VisualC</a>).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/preview-of-using-cmake-presets-for-azure-sphere-development/">Preview of using CMake Presets for Azure Sphere development</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/preview-of-using-cmake-presets-for-azure-sphere-development/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>C++20 Ranges are complete in Visual Studio 2019 version 16.10</title>
		<link>https://devblogs.microsoft.com/cppblog/c20-ranges-are-complete-in-visual-studio-2019-version-16-10/</link>
					<comments>https://devblogs.microsoft.com/cppblog/c20-ranges-are-complete-in-visual-studio-2019-version-16-10/#respond</comments>
		
		<dc:creator><![CDATA[Casey Carter]]></dc:creator>
		<pubDate>Wed, 26 May 2021 17:21:00 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=26348</guid>

					<description><![CDATA[<p>We are proud to announce completion of our implementation of C++20 Ranges in the Standard Library in the VS2019 v16.10 release under/std:c++latest. We announced the first useful user-visible parts of Ranges in VS 2019 v16.6 in mid 2020, the trickle accelerated into a gushing stream,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/c20-ranges-are-complete-in-visual-studio-2019-version-16-10/">C++20 Ranges are complete in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are proud to announce completion of our implementation of C++20 Ranges in the Standard Library in the VS2019 v16.10 release under<code>/std:c++latest</code>. We <a class='myclass'href="https://devblogs.microsoft.com/cppblog/initial-support-for-c20-ranges/">announced the first useful user-visible parts of Ranges in VS 2019 v16.6 in mid 2020</a>, the trickle accelerated into a gushing stream, and the final parts are now in place. This represents a huge body of work with input from multiple open-source contributors over the last two years.</p>
<p>Ironically enough, ranges are nothing new to the Standard Library. STL algorithms have always operated on ranges of elements whose bounds are denoted by an iterator that denotes the first element and an iterator pointing past the end of the sequence of elements subject to a computation. The novelty in C++20 Ranges is that we recognize the expressive power that comes from passing ranges around directly as abstractions instead of passing iterator pairs – eliminating passing iterators into different ranges as a source of errors – and that operations on ranges can compose more easily than operations on their elements.</p>
<h2 id="what-components-comprise-the-c20-ranges-design">What components comprise the C++20 Ranges design?</h2>
<p>Ranges first relaxes the old C++ iterator-pair design by allowing the sentinel that denotes the end of a sequence of elements to have a different type than the iterator that denotes the beginning. This enables expression of simple notions like a range bounded by a pointer-to-character and a delimiter sentinel that compares equal to a pointer-to-character when the pointer points to <code>'\0'</code>. A Range is then any expression <code>meow</code> such that <code>std::ranges::begin(meow)</code> and <code>std::ranges::end(meow)</code> return an iterator and a sentinel.</p>
<p>The Ranges library expresses predicates over types (“is this a bidirectional iterator?”) and relationships between types (“is this a valid iterator-and-sentinel pair?”) using C++ Concepts. Ranges is the first use – and quite an extensive use, at that – of the new Concepts language feature in the C++ Standard Library. Concepts are nicely expressive in that they allow the specification of type requirements, and to a lesser extent preconditions on the values of arguments, to appear directly in code as syntax instead of appearing in documentation as English prose. (See <a class='myclass'href="https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/">“C++20 Concepts Are Here in Visual Studio 2019 version 16.3”</a> for more discussion of C++ Concepts.)</p>
<p>Ranges adds a set of algorithms – mirrors of the algorithms defined in namespace <code>std</code> – in namespace <code>std::ranges</code>. These algorithms are constrained with Concepts, and unlike their siblings in <code>std</code> accept both range arguments, and iterator-sentinel pair arguments where the sentinel and iterator types differ.</p>
<p>Ranges also unsurprisingly adds a slew of ranges to the Standard Library. The Standard splits these out into factories that create ranges:</p>
<ul>
<li><code>std::views::iota(0, 42)</code> is the range of integers from 0 up to but not including 42,</li>
<li><code>std::views::istream_view&lt;int&gt;(std::cin)</code> is a range of whitespace-delimited integers read from <code>std::cin</code>,</li>
</ul>
<p>and adaptors that transform the elements of an underlying range into a new range:</p>
<ul>
<li><code>std::views::filter(my_vec, [](const auto&amp; x) { return x % 2 == 0; })</code> is a range of only the even elements of <code>my_vec</code>,</li>
<li><code>std::views::transform(my_vec, [](const auto&amp; x) { return 3 * x; })</code> is a range of elements with value 3k where k is the value of the corresponding element of <code>my_vec</code>.</li>
</ul>
<p>The range adaptors are often best thought of as lazy, composable algorithms since they do no work until you begin to iterate over them and they are functions from ranges to ranges. We could compose the above two examples into:</p>
<pre class="prettyprint">auto r1 = std::views::filter(my_vec, [](const auto&amp; x) { return x % 2 == 0; });
auto r2 = std::views::transform(r1, [](const auto&amp; x) { return 3 * x; });
</pre>
<p>for example, to get a range consisting of elements whose value is three times the value of the even elements of <code>my_vec</code>. The design even provides a pipeline syntax to facilitate this composition, using <code>|</code> to provide a left-hand range as input to a right-hand range adaptor:</p>
<pre class="prettyprint">auto r = my_vec
       | std::views::filter([](const auto&amp; x) { return x % 2 == 0; })
       | std::views::transform([](const auto&amp; x) { return 3 * x; });
</pre>
<p>Doing the equivalent work with algorithms would require storing intermediate and final results in some kind of container, which an adaptor composition like this avoids by working element-at-a-time.</p>
<h2 id="where-did-this-implementation-come-from">Where did this implementation come from?</h2>
<p>A typical STL feature is described by a 10-20 page proposal that WG21 polishes into a specification to merge into the C++ Standard. <a class='myclass'href="https://wg21.link/p0896r4">P0896R4 “The One Ranges Proposal”</a> was around 230 pages. As if that weren’t enough, <a class='myclass'href="https://github.com/microsoft/STL/issues/39">our tracking issue for Ranges implementation</a> documents a litany of 22 follow-up proposals (design changes) and 35 LWG issues (bug fixes) that are covered in the Ranges implementation. <a class='myclass'href="https://github.com/microsoft/STL/issues/39#issuecomment-599807825">Our implementation plan</a> broke the work down into bitesize pieces starting with “Implement common_reference and common_type change” from May 13 2019, one of four internal PRs from before the STL became open-source, through another <a class='myclass'href="https://github.com/microsoft/STL/pulls?q=is%3Apr+label%3Aranges">99 GitHub pull requests</a> ending in <a class='myclass'href="https://github.com/microsoft/STL/pull/1748">“Define __cpp_lib_ranges [feature-test macro]” on Mar 18 2021</a>. While we certainly drew from experience prototyping the library for the Ranges Technical Specification to provide guidance, the STL implementation was almost entirely a full rewrite reusing only some test cases.</p>
<p>This is certainly the largest single Standard Library feature to-date, and we can’t express enough how much we appreciate all the work from the many members of the C++ community that helped bring it to life. We’d like to personally thank <a class='myclass'href="https://github.com/AdamBucior/">AdamBucior</a>, <a class='myclass'href="https://github.com/ahanamuk/">ahanamuk</a>, <a class='myclass'href="https://github.com/barcharcraz/">barcharcraz</a>, <a class='myclass'href="https://github.com/BillyONeal/">BillyONeal</a>, <a class='myclass'href="https://github.com/bkentel/">bkentel</a>, <a class='myclass'href="https://github.com/CaseyCarter/">CaseyCarter</a>, <a class='myclass'href="https://github.com/cbezault/">cbezault</a>, <a class='myclass'href="https://github.com/cpplearner/">cpplearner</a>, <a class='myclass'href="https://github.com/fsb4000/">fsb4000</a>, <a class='myclass'href="https://github.com/futuarmo/">futuarmo</a>, <a class='myclass'href="https://github.com/MahmoudGSaleh/">MahmoudGSaleh</a>, <a class='myclass'href="https://github.com/miscco/">miscco</a>, <a class='myclass'href="https://github.com/mnatsuhara/">mnatsuhara</a>, <a class='myclass'href="https://github.com/statementreply/">statementreply</a>, <a class='myclass'href="https://github.com/StephanTLavavej/">StephanTLavavej</a>, <a class='myclass'href="https://github.com/SuperWig/">SuperWig</a>, and <a class='myclass'href="https://github.com/timsong-cpp/">timsong-cpp</a>, each of whom contributed either code, code review comments, or issue reports for MSVC Ranges. On a personal note, my Ranges journey started six years ago this month at the WG21 meeting in Lenexa, Kansas. As an unemployed enthusiast C++ aficionado very excited about the design in <a class='myclass'href="https://wg21.link/n4128">Eric Niebler’s N4128 “Ranges for the Standard Library,”</a> I never would have believed that I’d spend the next six years working on that design through the standardization process right up through today’s shipping product.</p>
<h2 id="can-i-try-it-today">Can I try it today?</h2>
<p>Yes, that’s the point! Please give the available components a try, and we’ll keep them coming. Don’t forget to download (or update to) <a class='myclass'href="https://visualstudio.microsoft.com/vs/">Visual Studio 2019 version 16.10</a>; some but not all of the Ranges design is present in earlier releases. Be aware that WG21 is <a class='myclass'href="https://github.com/cplusplus/LEWG/wiki/Backports">processing some breaking changes for C++20</a>, three of which have bearing directly on Ranges. You can expect changes to (1)<code> std::ranges::split_view</code> / <code>std::views::split</code>, which WG21 has largely redesigned since publishing C++20, (2) <code>std::ranges::join_view</code> / <code>std::views::join</code>, which has been tweaked to be usable in more cases, and (3) the <code>std::ranges::view</code> concept itself will lose its requirement for default construction allowing range adaptors to more efficiently adapt underlying ranges that aren’t default constructible by producing a result view that is not default constructible.</p>
<p>We love to hear your feedback and suggestions. We can be reached via the comments below, <a class='myclass'href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a>, and Twitter (<a class='myclass'href="https://twitter.com/visualc">@VisualC</a>). For issues and questions specific to the STL or our Ranges implementation, the best way to reach is by <a class='myclass'href="https://github.com/microsoft/STL/issues">filing an issue on GitHub</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/c20-ranges-are-complete-in-visual-studio-2019-version-16-10/">C++20 Ranges are complete in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/c20-ranges-are-complete-in-visual-studio-2019-version-16-10/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>How to start using registries with vcpkg</title>
		<link>https://devblogs.microsoft.com/cppblog/how-to-start-using-registries-with-vcpkg/</link>
					<comments>https://devblogs.microsoft.com/cppblog/how-to-start-using-registries-with-vcpkg/#respond</comments>
		
		<dc:creator><![CDATA[Nicole Mazzuca]]></dc:creator>
		<pubDate>Mon, 24 May 2021 18:46:41 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28108</guid>

					<description><![CDATA[<p>For many users of vcpkg, the built-in repository of packages is completely sufficient. If you only need public, non-experimental libraries, the default vcpkg registry is completely fine. However, once you go outside of this world &#8211; once you have company-internal libraries,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/how-to-start-using-registries-with-vcpkg/">How to start using registries with vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>For many users of vcpkg, the built-in repository of packages is completely sufficient. If you only need public, non-experimental libraries, the default vcpkg registry is completely fine. However, once you go outside of this world &#8211; once you have company-internal libraries, or you want to use experimental libraries, the recommended solution is to use a registry.</p>
<p>Quite a few people have already set up their own registries, and if you want to learn to set up your own, you can check out the <a class='myclass'href="https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/">last blogpost</a>. However, if you want to use an existing registry, this tutorial is for you.</p>
<p>We also have <a class='myclass'href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">reference documentation in the vcpkg repository</a>.</p>
<p>&nbsp;</p>
<h3 id="getting-started">Getting Started</h3>
<p>Before anything else, you&#8217;ll need a vcpkg installation, and you&#8217;ll need to decide whether you&#8217;re using manifest mode or classic mode (in other words, installing packages manually using the command line). The use of registries is the same either way.</p>
<p>You&#8217;ll want to create a <code>vcpkg-configuration.json</code> file; in manifest mode, you&#8217;d place it alongside your <code>vcpkg.json</code> file, while in classic mode you&#8217;d place it in the vcpkg root directory. There are two important keys in this file: <code>"default-registry"</code>, and <code>"registries"</code>.</p>
<p><code>"default-registry"</code> allows you to set the fallback registry, for packages that aren&#8217;t covered by any of the registries in the <code>"registries"</code> array. <code>"registries"</code> allows you to set up registries for specific packages.</p>
<p>&nbsp;</p>
<h3 id="example-north-wind-traders">Example: North Wind Traders</h3>
<p>Your company, North Wind Traders, has decided to mirror the default vcpkg registry (from <a class='myclass'href="https://github.com/microsoft/vcpkg">https://github.com/microsoft/vcpkg</a>) in order to ensure business continuity and control of sources for purposes of security, and you&#8217;ve set it up as your default registry so that it&#8217;s used for every package that isn&#8217;t explicitly listed in a package registry. Your <code>vcpkg-configuration.json</code> file should look like this:</p>
<pre><code>{
  "default-registry": {
    "kind": "git",
    "repository": "https://github.com/northwindtraders/vcpkg-mirror",
    "baseline": "eefee7408133f3a0fef711ef9c6a3677b7e06fd7"
  },
  "registries": [
    {
      "kind": "git",
      "repository": "https://github.com/northwindtraders/vcpkg-registry",
      "baseline": "dacf4de488094a384ca2c202b923ccc097956e0c",
      "packages": [ "beison", "beicode" ]
    }
  ]
}
</code></pre>
<p>You also depend on your private registry for two of your internal libraries: beison and beicode. These libraries are neither open source nor public, but they are still managed via vcpkg, and you don&#8217;t have to be concerned about different processes for different libraries (at least at the consumption side). With manifests, you write your dependencies down, and the CMake or MSBuild integration will install all of those dependencies into your project, whether from the default, built-in registry, or from third-party registries. Private dependencies are exactly the same as public dependencies, as far as vcpkg is concerned. For classic mode, you tell vcpkg to install the packages you need from the command line. vcpkg will install them into the vcpkg git repository you’ve cloned, and you can access them either via direct usage or via the CMake and MSBuild integration. These existing use cases all &#8220;just work&#8221;, without any extra work from you on top of existing workflows. All you need is a configuration file.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback!</h3>
<p>Try out vcpkg by visiting our <a class='myclass'href="https://github.com/microsoft/vcpkg">GitHub repo</a>.</p>
<p>This is a relatively new feature, and the user experience is still being actively worked on. We want to create the best and simplest experience possible for our users, and so we welcome your feedback on this new feature in our <a class='myclass'href="https://github.com/microsoft/vcpkg/issues/new">issue tracker</a>!</p>
<p>The current up-to-date documentation on using registries can be found in <a class='myclass'href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">our GitHub repository</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/how-to-start-using-registries-with-vcpkg/">How to start using registries with vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/how-to-start-using-registries-with-vcpkg/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>All vcpkg enterprise features now generally available: versioning, binary caching, manifests and registries</title>
		<link>https://devblogs.microsoft.com/cppblog/all-vcpkg-enterprise-features-now-generally-available-versioning-binary-caching-manifests-and-registries/</link>
					<comments>https://devblogs.microsoft.com/cppblog/all-vcpkg-enterprise-features-now-generally-available-versioning-binary-caching-manifests-and-registries/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 19 May 2021 23:38:07 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28092</guid>

					<description><![CDATA[<p>We are announcing today that all major vcpkg enterprise features are no longer experimental. The latest vcpkg release makes versioning, binary caching, manifests and registries generally available to any developer, team or enterprise.<br />
We have steadily been adding to vcpkg over the years.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/all-vcpkg-enterprise-features-now-generally-available-versioning-binary-caching-manifests-and-registries/">All vcpkg enterprise features now generally available: versioning, binary caching, manifests and registries</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><!--StartFragment --></p>
<p><span class="cf0">We are announcing today that <strong>all major vcpkg enterprise features are no longer experimental</strong>. The latest vcpkg release makes versioning, binary caching, manifests and registries generally available to any developer, team or enterprise. </span></p>
<p>We have steadily been adding to vcpkg over the years. What started as a small open source project to migrate developers to newer versions of Visual Studio has expanded into a cross-platform C/C++ library manager with over 1600 libraries that can be used in a wide variety of environments to serve the entire C/C++ ecosystem.</p>
<p>In this blog post, we go over the latest vcpkg product announcements, particularly for those of you who missed them at the <a class='myclass'href="https://www.youtube.com/watch?v=tiWYy2EsSNU">Pure Virtual C++ conference</a> earlier this month. We are <strong>announcing the general availability of vcpkg versioning and registries</strong>, which, combined with our earlier release of manifests and binary caching, comprise our solution for <strong>vcpkg in the enterprise space</strong>. These features are free and are now on by default in the tool, no longer requiring feature flags to be manually turned on to opt in.</p>
<p>While we believe all developers can benefit from these four features, we believe they will be especially useful to professional developers who previously would have avoided adopting vcpkg without them.</p>
<p>Lastly, we are happy to announce that vcpkg has a new website and mark!</p>
<p>&nbsp;</p>
<h3 id="versioning-and-registries-no-longer-experimental">Versioning and Registries No Longer Experimental</h3>
<p>The vcpkg team has also been expanding the capabilities of the tool in response to popular user feedback. Most recently, we announced four new features:</p>
<ol>
<li><a class='myclass'href="https://github.com/microsoft/vcpkg/blob/master/docs/users/binarycaching.md"><strong>Binary caching</strong></a>, to save copies of prebuilt library binaries that can be restored on demand from a network file share, NuGet feed, or cloud binary storage solution. With this feature, you can build your dependencies once, and only once, then cache them for faster subsequent acquisition on other machines, containers, or continuous integration runs.</li>
<li><a class='myclass'href="https://github.com/microsoft/vcpkg/blob/master/docs/users/manifests.md"><strong>Manifests</strong></a>, making it possible to declare dependencies in a vcpkg.json file that can be maintained in source control and that automatically integrates with MSBuild and CMake projects. Simply run an MSBuild compilation or generate a CMake cache to automatically restore missing dependencies.</li>
<li><a class='myclass'href="https://github.com/microsoft/vcpkg/blob/master/docs/users/versioning.md"><strong>Versioning</strong></a>, to set libraries to be acquired at specific versions and lock them there.</li>
<li><a class='myclass'href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md"><strong>Registries</strong></a>, to bring your own libraries to vcpkg, whether they are forks of open source libraries available in the public catalog or other custom libraries (including private organization-only dependencies).</li>
</ol>
<p>When we announced versioning and registries, we pointed out that the features were considered experimental, as we wanted to take some more time to check the quality and listen to user feedback. Now, we are ready to state that <strong>versioning and registries are no longer experimental</strong>. While we will continue improving the features described above, we are confident enough to recommend using them in production environments. Please continue to submit feedback to us in the form of bug reports as <a class='myclass'href="https://github.com/microsoft/vcpkg/issues">GitHub Issues</a> and feature suggestions by starting a <a class='myclass'href="https://github.com/microsoft/vcpkg/discussions">GitHub Discussion</a>.</p>
<p>&nbsp;</p>
<h3 id="new-vcpkg-website-and-mark">New vcpkg Website and Mark</h3>
<p>We are proud to <strong>announce </strong><a class='myclass'href="https://vcpkg.io/"><strong>vcpkg.io</strong></a><strong>, our new website</strong>!</p>
<p><a class='myclass'href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-website.png"><img class="alignnone size-full wp-image-28094" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-website.png" alt="vcpkg.io website homepage" width="936" height="570" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-website.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-website-300x183.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-website-768x468.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>You can use the website to learn about vcpkg and how to get started, browse our documentation, and even explore available packages on our package search page:</p>
<p><a class='myclass'href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-browse-packages-page.png"><img class="alignnone size-full wp-image-28095" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-browse-packages-page.png" alt="vcpkg.io browse packages page" width="936" height="450" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-browse-packages-page.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-browse-packages-page-300x144.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg.io-browse-packages-page-768x369.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>On the website, you will notice our new, freshly-designed <strong>vcpkg product mark</strong>!</p>
<p><a class='myclass'href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg-product-mark.png"><img class="size-full wp-image-28096 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg-product-mark.png" alt="Image vcpkg product mark" width="278" height="278" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg-product-mark.png 278w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/vcpkg-product-mark-150x150.png 150w" sizes="(max-width: 278px) 100vw, 278px" /></a></p>
<p>Lovingly referred to by our team as the “potato chip logo”, this mark will be used to identify vcpkg wherever it goes on the web.</p>
<p>&nbsp;</p>
<h3 id="vcpkg-2021-04-30-and-2021-05-12-releases">vcpkg 2021.04.30 and 2021.05.12 Releases</h3>
<p>We completed <a class='myclass'href="https://github.com/microsoft/vcpkg/releases">two releases on GitHub for vcpkg</a> in the past few weeks. Our overall port count increased to 1,667, and we updated over 800 ports since our last release. We also added substantial new documentation, including for versioning, registries, manifests, and binary caching. We also <strong>turned registries and versioning on by default</strong>, so you no longer need to specify a feature flag to use them.</p>
<p>&nbsp;</p>
<h3 id="we-want-your-feedback">We Want Your Feedback!</h3>
<p>If you depend on C or C++ libraries for your project, you should give vcpkg a try by visiting our website, <a class='myclass'href="https://vcpkg.io/">vcpkg.io</a>. You can use vcpkg to install libraries from source, whether they are your own or popular open source projects You can follow the project and engage with us on the <a class='myclass'href="https://github.com/microsoft/vcpkg/releases">vcpkg GitHub repo</a>. The features discussed in this post were made possible thanks to your feedback, and we are always interested to hear what you think!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/all-vcpkg-enterprise-features-now-generally-available-versioning-binary-caching-manifests-and-registries/">All vcpkg enterprise features now generally available: versioning, binary caching, manifests and registries</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/all-vcpkg-enterprise-features-now-generally-available-versioning-binary-caching-manifests-and-registries/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Code Analysis supports SARIF 2.1</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/#respond</comments>
		
		<dc:creator><![CDATA[Hwi-sung Im]]></dc:creator>
		<pubDate>Thu, 13 May 2021 19:40:53 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[Rule Action]]></category>
		<category><![CDATA[Ruleset]]></category>
		<category><![CDATA[SARIF]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28068</guid>

					<description><![CDATA[<p>Starting with Visual Studio 16.8, MSVC Code Analysis officially supports SARIF 2.1.0 standard. SARIF is an industry standard for representing static analysis logs and we&#8217;ve been one of the earliest collaborators with the SARIF Technical Committee. Behind the scenes, analysis log files in the SARIF format powers Visual Studio IDE to provide a richer experience that was not possible with the legacy XML logs.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/">Microsoft C++ Code Analysis supports SARIF 2.1</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="none">Starting with Visual Studio 16.8, MSVC Code Analysis officially supports SARIF 2.1.0 standard. SARIF is an industry standard for representing static analysis logs and we&#8217;ve been one of the earliest collaborators with the SARIF Technical Committee.</span><span data-contrast="auto"> Behind the scenes, analysis log files in the SARIF format powers Visual Studio IDE to provide a richer experience that was not possible with the legacy XML logs. In this blog post we will present one of those enhanced experiences – </span><span data-contrast="auto">code analysis defects with different severity levels </span><span data-contrast="auto">in Error List and </span><span data-contrast="auto">color-coded squiggles </span><span data-contrast="auto">for offending code segments.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:240}"> </span></p>
<h1 aria-level="1" aria-level="1" id="what-is-sarif"><span data-contrast="none">What is SARIF?</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">SARIF is an acronym for the Static Analysis Results Interchange Format, which is a standard, JSON-based format for the output of static analysis tools. SARIF provides a rich format intended to meet the needs of a wide range of analysis tools, both sophisticated and simple ones. It also provides an extensibility mechanism to allow tool authors to store custom data that the SARIF format doesn&#8217;t directly support.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">You can find more information on SARIF at </span><a class='myclass'href="https://sarifweb.azurewebsites.net/#:~:text=The%20Static%20Analysis%20Results%20Interchange,approved%20as%20an%20OASIS%20standard"><span data-contrast="none">this</span></a><span data-contrast="auto"> introductory page. The latest SARIF standard is available at </span><a class='myclass'href="https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=sarif"><span data-contrast="none">this</span></a><span data-contrast="auto"> page.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="c-code-analysis-and-sarif"><span data-contrast="none">C++ Code Analysis and SARIF</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">MSVC Code Analysis has been using a custom XML log format to report defects it finds during code analysis. While this has served customers well for the last decade, we decided to support SARIF for richer capability such as logging list of files analyzed, configuration overrides for analysis, location where defects are suppressed if logging suppressed warnings, etc.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="none">We have been supporting SARIF in VS for quite some time, even the earliest drafts of the specification. 16.8 is the release that MSVC Code Analysis supports SARIF 2.1 standard.</span><span data-contrast="auto"> With this update, MSVC Code Analysis provided some enhanced experience that many readers may already know, including but not limited to:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="4" aria-setsize="-1" data-aria-posinset="16" data-aria-level="1"><span data-contrast="auto">Background code analysis</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="4" aria-setsize="-1" data-aria-posinset="16" data-aria-level="1"><span data-contrast="auto">Green squiggles for code analysis defects</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="4" aria-setsize="-1" data-aria-posinset="16" data-aria-level="1"><span data-contrast="auto">Fix-it for automatic recommendations to fix defects</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ul>
<p><span data-contrast="auto">To add more improvements to code analysis, we have updated MSVC Code Analysis to support the latest SARIF 2.1.0 standard. At the same time, it has been updated to provide options to record more information to the SARIF log file:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="2" aria-setsize="-1" data-aria-posinset="16" data-aria-level="1"><span data-contrast="auto">List of files analyzed </span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="2" aria-setsize="-1" data-aria-posinset="16" data-aria-level="1"><span data-contrast="auto">Configurations used for code analysis, including command-line options</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
<li data-leveltext="" data-font="Symbol" data-listid="2" aria-setsize="-1" data-aria-posinset="16" data-aria-level="1"><span data-contrast="auto">Rule actions for each of the active rules for which defects are reported</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ul>
<p><span data-contrast="auto">While we were updating MSVC Code Analysis to add more information to SARIF log files, we also added new capabilities to it:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="3" aria-setsize="-1" data-aria-posinset="17" data-aria-level="1"><span data-contrast="auto">Ability to log compiler warnings in addition to code analysis warnings</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="3" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">Ability to log suppressed warnings with location of suppression</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:720,&quot;335559737&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259,&quot;335559991&quot;:360}"> </span></li>
</ul>
<h1 aria-level="1" aria-level="1" id="rule-actions-in-visual-studio"><span data-contrast="none">Rule Actions in Visual Studio</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="auto">As we update MSVC Code Analysis with support of the latest SARIF standard and additional information on analysis and defects, we also updated Visual Studio to enhance the code analysis experience. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">In the following sections, let’s look at an enhanced code analysis experience in Visual Studio IDE.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h2 aria-level="1" aria-level="1" id="ruleset-and-rule-actions"><span data-contrast="none">Ruleset and Rule Actions</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">MSVC Code Analysis can be used with one or more ruleset files that can enable or disable selected rules. Rules that are enabled in the ruleset are checked and reported by the analysis tools. Rules that are disabled in a ruleset will be ignored by MSVC Code Analysis and will not be checked or reported. More information on rulesets can be found </span><a class='myclass'href="https://docs.microsoft.com/en-us/visualstudio/code-quality/using-rule-sets-to-group-code-analysis-rules"><span data-contrast="none">here</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Each of the rules in the ruleset file can be assigned with one of the following “Rule Action” values:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<table data-tablestyle="MsoTableGrid" data-tablelook="1184" aria-rowcount="7">
<tbody>
<tr aria-rowindex="1">
<td data-celllook="65536"><b><span data-contrast="auto">Rule Action</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="65536"><b><span data-contrast="auto">Description</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="2">
<td data-celllook="0"><span data-contrast="auto">None</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">Do not check or report</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="3">
<td data-celllook="0"><span data-contrast="auto">Hidden</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">May check, but do not report</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="4">
<td data-celllook="0"><span data-contrast="auto">Default</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">Inherit default action from &lt;Include&gt; or &lt;IncludeAll&gt;</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="5">
<td data-celllook="0"><span data-contrast="auto">Info</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">Report as Informational</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="6">
<td data-celllook="0"><span data-contrast="auto">Warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">Report as Warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="7">
<td data-celllook="0"><span data-contrast="auto">Error</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">Report as Error</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
</tbody>
</table>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Until we added support for SARIF, MSVC Code Analysis could only map these rule actions simply to “enabled” or “disabled” states, and either reported or ignored until it was added with the support for SARIF. Visual Studio build used ruleset files directly and could differentiate rules with “Error” Rule Action from the reset of the enabled rules, which were considered as “Warning” regardless of their Rule Action values. Visual Studio IDE did not honor the Rule Action values, and treated everything as “Warning”.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">With the support of SARIF, MSVC Code Analysis now maps these rule actions to the SARIF’s level property in the log file as follows:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<table data-tablestyle="MsoTableGrid" data-tablelook="1184" aria-rowcount="6">
<tbody>
<tr aria-rowindex="1">
<td data-celllook="65536"><b><span data-contrast="auto">Rule Action</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="65536"><b><span data-contrast="auto">SARIF level property</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="2">
<td data-celllook="0"><span data-contrast="auto">None</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">none</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="3">
<td data-celllook="0"><span data-contrast="auto">Hidden</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">none</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="4">
<td data-celllook="0"><span data-contrast="auto">Info</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">note</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="5">
<td data-celllook="0"><span data-contrast="auto">Warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
<tr aria-rowindex="6">
<td data-celllook="0"><span data-contrast="auto">Error</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
<td data-celllook="0"><span data-contrast="auto">error</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:259}"> </span></td>
</tr>
</tbody>
</table>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">A rule with Rule Action value of “default” will be assigned with one of the other Rule Action values before mapped to the SARIF’s level.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h2 aria-level="1" aria-level="1" id="rule-actions-in-action"><span data-contrast="none">Rule Actions in Action</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h2>
<p><span data-contrast="auto">Let’s look at how Visual Studio now uses the Rule Action values in the ruleset to improve the code analysis experience. As an example, let’s consider a custom ruleset with the following content:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint">&lt;?xml version="1.0" encoding="utf-8"?&gt; 
&lt;RuleSet Name="Copy of Microsoft Native Recommended Rules" Description="My custom rules" ToolsVersion="16.0"&gt; 
  &lt;Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis" RuleNamespace="Microsoft.Rules.Native"&gt; 
    &lt;Rule Id="C6001" Action="Warning" /&gt; 
    &lt;Rule Id="C6011" Action="Error" /&gt; 
    &lt;Rule Id="C6201" Action="None" /&gt; 
    &lt;Rule Id="C6385" Action="Info" /&gt; 
    &lt;Rule Id="C6386" Action="Info" /&gt; 
  &lt;/Rules&gt; 
&lt;/RuleSet&gt;</pre>
<p><span data-contrast="auto">And a *.cpp file with following test code:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></p>
<pre class="prettyprint">#pragma warning(disable:4700)
  
void foo()
{ 
    int arr[4]{}; 
    int v = arr[4]; // C6201, C6385 
    arr[4] = 2;     // C6201, C6386 

    int x; 
    int* py = nullptr; 
    int y = *py;    // C6011 
    y += x;         // C6001 
}</pre>
<p><span data-contrast="auto">When configured to use the above custom ruleset for analysis, analyzing the test code in Visual Studio produces results as shown in below screenshot:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a class='myclass'href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Untitled-1.png"><img class="alignnone wp-image-28070" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Untitled-1-300x173.png" alt="Image Untitled" width="791" height="456" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Untitled-1-300x173.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Untitled-1-1024x592.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Untitled-1-768x444.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Untitled-1.png 1293w" sizes="(max-width: 791px) 100vw, 791px" /></a></p>
<p><span data-contrast="auto">Please note how the defects are listed in the Error List window, and how their corresponding code segments are highlighted in the text editor window:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="3" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">In the Error List window, C6011 is listed as an Error, C6001 as a Warning,  and C6385 and C6386 as Messages.</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ul>
<ul>
<li data-leveltext="" data-font="Symbol" data-listid="3" aria-setsize="-1" data-aria-posinset="1" data-aria-level="1"><span data-contrast="auto">In the text editor window, code segment for C6011 is highlighted with red squiggle, C6001 with green squiggle, and C6385 and C6386 with gray squiggles (dots)</span><span data-ccp-props="{&quot;134233279&quot;:true,&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></li>
</ul>
<p><span data-contrast="auto">As you can see in the above example, rule actions in the ruleset maps to Visual Studio build output, Error List, and text editor display through the level property of SARIF as follows:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<table data-tablestyle="MsoNormalTable" data-tablelook="1184" aria-rowcount="7">
<tbody>
<tr aria-rowindex="1">
<td data-celllook="69905"><b><span data-contrast="auto">Rule Action</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335551550&quot;:2,&quot;335551620&quot;:2,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="69905"><b><span data-contrast="auto">SARIF level</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335551550&quot;:2,&quot;335551620&quot;:2,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="69905"><b><span data-contrast="auto">Build Output</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335551550&quot;:2,&quot;335551620&quot;:2,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="69905"><b><span data-contrast="auto">Error List</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335551550&quot;:2,&quot;335551620&quot;:2,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="69905"><b><span data-contrast="auto">Editor Display</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335551550&quot;:2,&quot;335551620&quot;:2,&quot;335559740&quot;:240}"> </span></td>
</tr>
<tr aria-rowindex="2">
<td data-celllook="4369"><span data-contrast="auto">Error</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">error</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Appear as </span><i><span data-contrast="auto">Errors</span></i><span data-contrast="auto"> in the output window. These cause the build to fail.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Appear as </span><i><span data-contrast="auto">Errors</span></i><span data-contrast="auto"> in the Error List.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Offending code is underlined with a red squiggle and marked by a small red box in the scroll bar.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
</tr>
<tr aria-rowindex="3">
<td data-celllook="4369"><span data-contrast="auto">Warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">warning</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Appear as </span><i><span data-contrast="auto">Warnings</span></i><span data-contrast="auto"> in the output window. These do not cause the build to fail.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Appear as </span><i><span data-contrast="auto">Warnings</span></i><span data-contrast="auto"> in the Error List.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Offending code is underlined with a green squiggle and marked by a small green box in the scroll bar.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
</tr>
<tr aria-rowindex="4">
<td data-celllook="4369"><span data-contrast="auto">Info</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">note</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Appear as </span><i><span data-contrast="auto">Warnings</span></i><span data-contrast="auto"> in the build output. These do not cause the build to fail.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Appear as </span><i><span data-contrast="auto">Messages</span></i><span data-contrast="auto"> in the Error List.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Offending code is underlined with a gray squiggle and marked by a small gray box in the scroll bar.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
</tr>
<tr aria-rowindex="5">
<td data-celllook="4369"><span data-contrast="auto">Hidden</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">none</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Not reported</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Not reported</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Not reported</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
</tr>
<tr aria-rowindex="6">
<td data-celllook="4369"><span data-contrast="auto">None</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">none</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Not reported</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Not reported</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-contrast="auto">Not reported</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
</tr>
<tr aria-rowindex="7">
<td data-celllook="4369"><span data-contrast="auto">Default</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td data-celllook="4369"><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
<td colspan="3" data-celllook="4369"><span data-contrast="auto">Corresponds to the default action of the rule.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559740&quot;:240}"> </span></td>
</tr>
</tbody>
</table>
<p><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Please note that rules with Rule Action value of “Info” is also reported as “Warning” in the Visual Studio build output window. This has been the behavior before the adoption of SARIF log format. Following our guiding principle of keeping minimal friction for our customers during Visual Studio upgrades, we kept this behavior as is to not change the build behavior of existing projects. Please share your feedback on this for future improvements – whether it should be updated to honor the Rule Action value of “Info” and reported as “Note” or something like that.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h1 aria-level="1" aria-level="1" id="send-us-feedback"><span data-contrast="none">Send Us Feedback</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:240,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h1>
<p><span data-contrast="none">Please download </span><a class='myclass'href="https://visualstudio.microsoft.com/vs/preview/"><span data-contrast="none">the latest Visual Studio 2019</span></a><span data-contrast="none"> and give it a try! Any feedback is welcome. We can be reached via the comments below, </span><a class='myclass'href="https://developercommunity.visualstudio.com/spaces/8/index.html"><span data-contrast="none">Developer Community</span></a><span data-contrast="none">, email (</span><a class='myclass'href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="none">), and Twitter (</span><a class='myclass'href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span data-contrast="none">).</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/">Microsoft C++ Code Analysis supports SARIF 2.1</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-c-code-analysis-supports-sarif-2-1/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>OpenMP Updates and Fixes for C++ in Visual Studio 2019 version 16.10</title>
		<link>https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/</link>
					<comments>https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/#comments</comments>
		
		<dc:creator><![CDATA[Chris Pulido]]></dc:creator>
		<pubDate>Wed, 12 May 2021 18:12:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27978</guid>

					<description><![CDATA[<p>In our previous blog post about improved OpenMP support in Visual Studio, we announced the addition of the -openmp:llvm switch in Visual Studio 2019 version 16.9 to enable compiled programs to target LLVM’s OpenMP runtime library for the x64 architecture. This switch supports all the OpenMP 2.0 directives that -openmp supports,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/">OpenMP Updates and Fixes for C++ in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>In our <a class='myclass'href="https://devblogs.microsoft.com/cppblog/improved-openmp-support-for-cpp-in-visual-studio/">previous blog post</a> about improved OpenMP support in Visual Studio, we announced the addition of the <strong>-openmp:llvm</strong> switch in Visual Studio 2019 version 16.9 to enable compiled programs to target LLVM’s OpenMP runtime library for the x64 architecture. This switch supports all the OpenMP 2.0 directives that <strong>-openmp</strong> supports, as well as unsigned integer indices in parallel for loops, and a subset of the SIMD directives that are supported under <strong>-openmp:experimental</strong>. It also enabled a few correctness fixes. Starting in <a class='myclass'href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 version 16.10 Preview 2</a>, the <strong>-openmp:llvm </strong>switch now works for x86 and arm64. We have also fixed a couple of bugs in 16.10 Preview 3.</p>
<h1 id="openmpllvm-now-available-for-x86-and-arm64">-openmp:llvm Now Available for x86 and arm64</h1>
<p>Starting in Visual Studio 2019 version 16.10 Preview 2, in addition to X64 support, we have added support for targeting LLVM’s OpenMP runtime library with <strong>-openmp:llvm </strong>for the x86 and ARM64 architectures. Compiling with <strong>-openmp:llvm </strong>will automatically add a dynamic link to libomp140.i386.dll (or libomp140d.i386.dll under <strong>/DEBUG</strong>) when targeting x86, or libomp140.aarch64.dll (or libomp140d.aarch64.dll under <strong>/DEBUG</strong>) when targeting ARM64. You can find these libraries under the Visual Studio installation directory at <code>VC\Redist\MSVC\&lt;version&gt;\debug_nonredist\&lt;arch&gt;\Microsoft.VC142.OpenMP.LLVM</code>.</p>
<p>As a reminder, the <strong>-openmp:llvm</strong> switch is experimental, and features from OpenMP 3.0 that were added with the <strong>-openmp:llvm</strong> switch in Visual Studio version 16.9 are still only supported with the additional
<strong>-openmp:experimental</strong> flag in Visual Studio version 16.10, and thus are provided with certain limitations in 16.10. In particular, <strong>#pragma omp task </strong>is not yet available on x86 or arm64, and there is only limited functionality on x64 in 16.10. Lastly, future versions of the LLVM OpenMP runtime DLLs may not be backwards compatible and the current version of these DLLs is not redistributable.</p>
<h1 id="bug-fixes-in-16-10-preview-3">Bug Fixes in 16.10 Preview 3</h1>
<ul>
<li><strong>return</strong> statements inside parallel regions now issue a helpful error message since they are non-conforming. The snippet below would previously crash the compiler with an <a class='myclass'href="https://developercommunity2.visualstudio.com/t/Return-in-OpenMP-loop-causes-internal-co/908052">internal compiler error</a>.</li>
</ul>
<pre class="prettyprint">#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "Hello World!\n";

#pragma omp parallel for schedule(dynamic)
    for (auto i = 0; i &lt; 100; ++i)
    {
        // should issue error C3010: 'return': jump out of OpenMP structured block not allowed
        return -1;  
    }

    return 0;
}</pre>
<ul>
<li>The <strong>if</strong> clause now chooses the correct scope for a variable. In the snippet below, the inner <strong>if </strong>clause was referencing the outer shared variable <strong>i</strong> which has a value of 1, rather than the inner private variable <strong>i</strong> which has the value of 0, causing the program to print “nested” four times instead of one. A similar fix was also applied to the <strong>num_threads</strong> clause.</li>
</ul>
<pre class="prettyprint">#include &lt;stdio.h&gt;
#include &lt;omp.h&gt;
int main(void)
{
  int i = 1;
  int retVal = 0;
  #pragma omp parallel if(retVal) default(none) private(i)
  {
    printf("hello\n");
    i = 0;
    #pragma omp parallel if(i) default(none) num_threads(4)
    {
      printf("nested\n");
    }
  }
  return 0;
}</pre>
<h1 id="our-openmp-plans">Our OpenMP Plans</h1>
<p>As of 16.10, the currently supported standard is still OpenMP 2.0, though we have made some improvements and fixed some long-standing bugs. We have started the long process to support newer versions of the OpenMP standard. Our goal is to support the most recent OpenMP standard, and this will be done step-by-step, with new features leveraging LLVM’s OpenMP runtime. Our next step for OpenMP will be to support the additional features added in the OpenMP 3.1 standard. Then we will add support for the pragmas and clauses added in the OpenMP 4.5 standard that do not involve offloading. Which features are added first after that will depend on your feedback. We would love to hear from you which specific OpenMP features you would like to see first.</p>
<h1 id="feedback">Feedback</h1>
<p>We encourage you to try out this update in the latest <a class='myclass'href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 version 16.10 Preview</a>. If you encounter a correctness issue in code generated with the <strong>-openmp:llvm</strong> switch or bugs in the libomp140 DLLs shipped with Visual Studio, please let us know. We can be reached via the comments below, via twitter (<a class='myclass'href="https://twitter.com/visualc">@visualc</a>), or via <a class='myclass'href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/">OpenMP Updates and Fixes for C++ in Visual Studio 2019 version 16.10</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/openmp-updates-and-fixes-for-cpp-in-visual-studio-2019-16-10/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
		<item>
		<title>New Static Analysis Rule for Bounds Checking</title>
		<link>https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/</link>
					<comments>https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/#comments</comments>
		
		<dc:creator><![CDATA[Jordan Maples]]></dc:creator>
		<pubDate>Tue, 11 May 2021 17:32:50 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[Writing Code]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[static analysis]]></category>
		<category><![CDATA[warning]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28054</guid>

					<description><![CDATA[<p>We have added a new experimental static analysis rule in Visual Studio 16.10 version Preview 3 &#8211; C26458, WARNING_PATH_SENSITIVE_USE_GSL_AT. The new warning is a more precise and less noisy version of warning C26446, WARNING_USE_GSL_AT. Both warnings analyse standard containers for unchecked element access and they both share the warning message: “Prefer to use gsl::at() instead of unchecked subscript operator (bounds.4).” This new warning,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/">New Static Analysis Rule for Bounds Checking</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We have added a new experimental static analysis rule in Visual Studio 16.10 version Preview 3 &#8211; C26458, <code>WARNING_PATH_SENSITIVE_USE_GSL_AT</code>. The new warning is a more precise and less noisy version of warning C26446, <code>WARNING_USE_GSL_AT</code>. Both warnings analyse standard containers for unchecked element access and they both share the warning message: “Prefer to use <code>gsl::at()</code> instead of unchecked subscript operator (bounds.4).” This new warning, however, uses path sensitive analysis to track buffer size validation calls to provide a less noisy, more targeted warning compared to C26446.</p>
<p>Path sensitive analysis is not an inexpensive operation: the complexity and time required to analyze each function depends on the length, number of branching operations, and individual properties that are tracked in each function. The path simulation walks the function and emulates each branch and loop that it encounters, updating an internal state based on various assumptions made in the code. Consider the following code segment:</p>
<pre class="prettyprint">    int i{};
    // ...
    if (i &lt; v.size()) {
        // ...
    }
    // ...
</pre>
<p>As the simulation reaches the branch, the analysis forks its state. In one fork it tracks that <code>i</code> is less than <code>v.size()</code>, and in the other <code>i</code> is greater than or equal to <code>v.size()</code>. The analysis does not necessarily know the value of <code>i</code> or the number of elements in <code>v</code>. It will only know the relation between these two due to the comparison. The same branching happens when the analysis encounters a loop.</p>
<h3 id="example-and-comparison-to-c26446">Example and comparison to C26446:</h3>
<pre class="prettyprint">void function(std::vector&lt;int&gt;&amp; v)
{
    if(v.size())
        v[0]; // C26446
    v[0]; // C26446 and C26458
}
</pre>
<p>In the path sensitive check, one branch simulated knows that <code>v</code> is not empty proving that it is safe to access the first element, but in the other, <code>v</code> is empty, which is why the second access issues the warning. C26446, on the other hand, will warn on any <code>operator[]</code> call not made by a <code>gsl::span</code>.</p>
<h3 id="why-is-this-check-in-experimental-and-what-can-it-not-do">Why is this check in experimental and what can it not do?</h3>
<p>Currently, C26458 does not track expansion of the container. Meaning that calls to <code>push_back</code>, <code>emplace</code>, <code>insert</code>, etc. are not yet supported. Nor does it track removal of elements. However, unlike the expansion of the container, reduction requires full revalidation of the containers bounds. Support for expansion/reduction of containers will be added in a future update.</p>
<pre class="prettyprint">void function(std::vector&lt;int&gt;&amp; v)
{
    if (v.size() &gt; 2)
    {
        v[2]; // C26446

        v.push_back(0);
        v[2]; // C26446
        v[3]; // C26446 &amp; C26458

        v.erase(v.begin()); // element removal currently removes all assumptions for the container
        v[2]; // 26446 &amp; C26458
    }
}
</pre>
<h2 id="how-to-enable-c26458">How to enable C26458</h2>
<h3 id="enabling-the-rule-in-visual-studio">Enabling the rule in Visual Studio:</h3>
<p>In the Project Properties page: Navigate to Configuration Properties -&gt; Code Analysis -&gt; Microsoft and select C++ Core Guidelines Experimental Rules.</p>
<p><a class='myclass'href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1.png"><img class="alignnone wp-image-28055 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1.png" alt="Image Picture1" width="624" height="389" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/Picture1-300x187.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>Alternatively, you can configure your current ruleset to include C26458.</p>
<p>We recommend that users disable C26446 when using C26458 to avoid duplicate warnings.</p>
<h2 id="feedback-and-follow-up">Feedback and follow up:</h2>
<p>Let us know your experience with the new checker, we are eager to hear back from all of you. Also, let us know if you would like to see more path sensitive rules like this in the future. Please download the latest <a class='myclass'href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2019</a> and give it a try! Any feedback is welcome. We can be reached via the comments below, <a class='myclass'href="https://developercommunity.visualstudio.com/search?space=62">Developer Community</a>, <a class='myclass'href="mailto:visualcpp@microsoft.com">email</a>, and <a class='myclass'href="https://twitter.com/visualc">Twitter</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/">New Static Analysis Rule for Bounds Checking</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/new-static-analysis-rule-for-bounds-checking/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Finding Bugs with AddressSanitizer: Patterns from Open Source Projects</title>
		<link>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/</link>
					<comments>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/#comments</comments>
		
		<dc:creator><![CDATA[Kevin Cadieux]]></dc:creator>
		<pubDate>Mon, 10 May 2021 19:05:14 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Diagnostics]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=28026</guid>

					<description><![CDATA[<p>AddressSanitizer (ASan) was officially released in Visual Studio 2019 version 16.9. We recently used this feature to find and fix a bug in the MSVC compiler itself. To further validate the usefulness of our ASan implementation, we also used it on a collection of widely used open source projects where it found bugs in Boost,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/">Finding Bugs with AddressSanitizer: Patterns from Open Source Projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>AddressSanitizer (ASan) was <a class='myclass'href="https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/">officially released in Visual Studio 2019 version 16.9</a>. We recently used this feature to <a class='myclass'href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-msvc-compiler/">find and fix a bug in the MSVC compiler itself</a>. To further validate the usefulness of our ASan implementation, we also used it on a collection of widely used open source projects where it found bugs in Boost, Azure IoT C SDK, and OpenSSL. In this article, we present our findings by describing the type of bugs that we found and how they presented themselves in these projects. We provide links to the GitHub commits where these bugs were fixed so you can get a helpful look at what code changes were involved. If you are unfamiliar with what ASan is and how to use it, you may want to take a look at the <a class='myclass'href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-160">AddressSanitizer documentation</a> prior to delving into this article.</p>
<p>&nbsp;</p>
<h3 id="boost-and-the-eager-iterator"><span style="font-size: 18pt;">Boost and the Eager Iterator</span></h3>
<p>An <em>eager iterator</em> is one that points to an element outside the bounds of a container and is then dereferenced. The following code sample shows an example of this buggy memory access pattern:</p>
<pre class="prettyprint">template &lt;typename Iter&gt;
int ComputeSum(Iter b, Iter e)
{
    int sum = 0;

    for (; b &lt;= e; ++b) {
        // ERROR: will dereference the 'end' iterator
        // due to the use of the '&lt;=' operator above.
        sum += *b;
    }

    return sum;
}</pre>
<p>Sometimes, eager iterators can appear by mistake in loops that are more complex, such as in the <code>do_length</code> function from Boost&#8217;s UTF-8 conversion facet implementation, shown below:</p>
<pre class="prettyprint">int utf8_codecvt_facet::do_length(
    std::mbstate_t &amp;,
    const char * from,
    const char * from_end, 
    std::size_t max_limit
) const
#if BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(600))
        throw()
#endif
{ 
    int last_octet_count=0;
    std::size_t char_count = 0;
    const char* from_next = from;

    while (from_next+last_octet_count &lt;= from_end &amp;&amp; char_count &lt;= max_limit) {
        from_next += last_octet_count;
        last_octet_count = (get_octet_count(*from_next));
        ++char_count;
    }
    return static_cast&lt;int&gt;(from_next-from);
}</pre>
<p>Here, the less-or-equal operator is used to correctly set <code>from_next</code> to <code>from_end</code> when the latter points at a UTF-8 character boundary. However, this also causes a bug where the end iterator is dereferenced. Building this code with ASan and debugging it in Visual Studio results in an ASan break at the expected location:</p>
<p><img class="alignnone wp-image-28029" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-2.png" alt="Screenshot of a debugging session in Visual Studio showing an AddressSanitizer global buffer overflow error in the 'do_length' function at line 'last_octet_count = (get_octet_count(*from_next));'" width="700" height="456" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-2.png 700w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-2-300x195.png 300w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>We let the Boost team know about this issue and they promptly <a class='myclass'href="https://github.com/boostorg/detail/commit/131208d8ccd82ef69afb9cf0bad1a314bd931d88">committed a fix on GitHub</a>.</p>
<p>&nbsp;</p>
<h3 id="azure-iot-c-sdk-an-array-and-its-length-constant-disagree"><span style="font-size: 18pt;">Azure IoT C SDK: An Array and Its Length Constant Disagree</span></h3>
<p>A disagreement between an array and its length constant happens when a constant is used to keep track of the length of an array but has the incorrect length. This can result in memory access bugs when the length constant is used in memory copy operations. The simple example below illustrates the problem:</p>
<pre class="prettyprint">#include &lt;cstring&gt;

unsigned char GLOBAL_BUFFER[] = { 1,2,3,4,5 };
constexpr size_t BUF_SIZE = 6;

void CopyGlobalBuffer(unsigned char* dst)
{
    // ERROR: AddressSanitizer: global-buffer-overflow
    std::memcpy(dst, GLOBAL_BUFFER, BUF_SIZE);
}</pre>
<p>We found an instance of this bug in the Azure IoT C SDK, where the length constant for a string did not match the actual length:</p>
<pre class="prettyprint">static const unsigned char* TWIN_REPORTED_PROPERTIES = 
    (const unsigned char*)
    "{ \"reportedStateProperty0\": \"reportedStateProperty0\", "
    "\"reportedStateProperty1\": \"reportedStateProperty1\" }";

static int TWIN_REPORTED_PROPERTIES_LENGTH = 117;</pre>
<p>The value of the <code>TWIN_REPORTED_PROPERTIES_LENGTH</code> constant is 117 while the actual size of the <code>TWIN_REPORTED_PROPERTIES</code> string is 107, resulting in a global buffer overflow when copying the string with <code>memcpy</code>. Building this code with ASan and debugging with Visual Studio shows an error during a call to <code>memcpy</code>, in a deep internal function named <code>CONSTBUFFER_Create_Internal</code>:</p>
<p><img class="alignnone wp-image-28032" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-5.png" alt="Screenshot of a debugging session in Visual Studio showing an AddressSanitizer error in the 'CONSTBUFFER_Create_Internal' function on line '(void)memcpy(temp, source, size);'" width="700" height="456" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-5.png 700w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-5-300x195.png 300w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>This didn’t immediately tell us what the origin of the bug was, but thanks to the ASan integration within Visual Studio, it was possible to use the Call Stack window to walk up the stack and find the function that passed the incorrect size value:</p>
<p><img class="alignnone wp-image-28033" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-6.png" alt="Screenshot of the Call Stack window from a debugging session in Visual Studio. The call stack contains the following functions: CONSTBUFFER_Create_Internal, real_CONSTBUFFER_Create, send_one_report_patch, twin_msgr_do_work_started_with_EXPIRED_in_progress_patches_success, RunTests, and main." width="698" height="205" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-6.png 698w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-6-300x88.png 300w" sizes="(max-width: 698px) 100vw, 698px" /></p>
<p>The culprit in this case was the <code>send_one_report_patch</code> function, which passed <code>TWIN_REPORTED_PROPERTIES</code> and <code>TWIN_REPORTED_PROPERTIES_LENGTH</code> to a function that indirectly calls <code>CONSTBUFFER_Create_Internal</code>:</p>
<pre class="prettyprint">static void send_one_report_patch(TWIN_MESSENGER_HANDLE handle, time_t current_time)
{
    const unsigned char* buffer = (unsigned char*)TWIN_REPORTED_PROPERTIES;
    size_t size = TWIN_REPORTED_PROPERTIES_LENGTH;
    CONSTBUFFER_HANDLE report = real_CONSTBUFFER_Create(buffer, size);

    umock_c_reset_all_calls();
    set_twin_messenger_report_state_async_expected_calls(report, current_time);
    (void)twin_messenger_report_state_async(handle, report, 
        TEST_on_report_state_complete_callback, NULL);

    real_CONSTBUFFER_DecRef(report);
}</pre>
<p>We fixed this issue by using the <code>sizeof</code> operator to set the length constant to a value that always reflects the actual size of the string. You can find our <a class='myclass'href="https://github.com/Azure/azure-iot-sdk-c/commit/79f6983b2ed86541bbdd943dbee59390efdd0ca9#diff-3c98bfc52b3211e281a71ec49c4ad26d5d0bb632f26795d33982d5e04abe2c31">bug fix commit on GitHub</a>.</p>
<p>&nbsp;</p>
<h3 id="openssl-and-the-shapeshifting-type"><span style="font-size: 18pt;">OpenSSL and the Shapeshifting Type</span></h3>
<p>A shapeshifting type is born when a type’s size varies depending on a preprocessor definition. If the type is then assumed to have a specific size, memory access bugs can occur. A simple example is shown below:</p>
<pre class="prettyprint">#include &lt;cstdint&gt;
#include &lt;cstring&gt;
#include &lt;array&gt;

#ifdef BIGGER_INT
typedef int64_t MyInt;
#else
typedef int32_t MyInt;
#endif

MyInt GLOBAL_BUFFER[] = { 1,2,3,4,5 };

void SizeTypeExample()
{
    int localBuffer[std::size(GLOBAL_BUFFER)];

    // ERROR: AddressSanitizer: stack-buffer-overflow
    std::memcpy(localBuffer, GLOBAL_BUFFER, sizeof(GLOBAL_BUFFER));
}</pre>
<p>If <code>BIGGER_INT</code> is defined, the <code>memcpy</code> operation might trigger a stack buffer overflow due to the <code>localBuffer</code> variable assuming <code>MyInt</code> has a size identical to <code>int</code>. An instance of this bug was found in the <code>test_param_time_t</code> OpenSSL test:</p>
<pre class="prettyprint">static int test_param_time_t(int n)
{
    time_t in, out;
    unsigned char buf[MAX_LEN], cmp[sizeof(size_t)];
    const size_t len = raw_values[n].len &gt;= sizeof(size_t)
                       ? sizeof(time_t) : raw_values[n].len;
    OSSL_PARAM param = OSSL_PARAM_time_t("a", NULL);

    memset(buf, 0, sizeof(buf));
    le_copy(buf, raw_values[n].value, sizeof(in));
    memcpy(&amp;in, buf, sizeof(in));
    param.data = &amp;out;
    if (!TEST_true(OSSL_PARAM_set_time_t(&amp;param, in)))
        return 0;
    le_copy(cmp, &amp;out, sizeof(out));
    if (!TEST_mem_eq(cmp, len, raw_values[n].value, len))
        return 0;
    in = 0;
    if (!TEST_true(OSSL_PARAM_get_time_t(&amp;param, &amp;in)))
        return 0;
    le_copy(cmp, &amp;in, sizeof(in));
    if (!TEST_mem_eq(cmp, sizeof(in), raw_values[n].value, sizeof(in)))
        return 0;
    param.data = &amp;out;
    return test_param_type_extra(&amp;param, raw_values[n].value, sizeof(size_t));
}</pre>
<p>Here, <code>size_t</code> is assumed to be the same type as <code>time_t</code>, but this is not always the case depending on the architecture being compiled for. When copying <code>out</code> to <code>cmp</code> using the <code>le_copy</code> function, the size of the copying operation is <code>sizeof(time_t)</code> but the <code>cmp</code> buffer was initialized with size <code>size_t</code>. When building the OpenSSL tests with ASan and debugging with Visual Studio, the debugger breaks with an ASan error inside <code>le_copy</code>:</p>
<p><img class="alignnone wp-image-28037" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-10.png" alt="Screenshot of a debugging session in Visual Studio, showing an AddressSanitizer error in the 'le_copy' function on line 'memcpy(out, in, len)'." width="700" height="445" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-10.png 700w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-10-300x191.png 300w" sizes="(max-width: 700px) 100vw, 700px" /></p>
<p>Again, thanks to the ASan integration in VS, we were able to use the call stack window to walk up to the actual source of the bug: the <code>test_param_time_t</code> function:</p>
<p><img class="alignnone wp-image-28038" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-11.png" alt="Screenshot of the Call Stack window from a Visual Studio debugging session. The call stack contains the following functions: le_copy, test_param_time_t, run_tests, and main." width="696" height="182" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-11.png 696w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/word-image-11-300x78.png 300w" sizes="(max-width: 696px) 100vw, 696px" /></p>
<p>We let the OpenSSL team know about this bug and a fix was <a class='myclass'href="https://github.com/openssl/openssl/commit/628d2d3a7f2318b6a6a1c36f9d8d12032c69a9dd">committed on GitHub</a>.</p>
<p>&nbsp;</p>
<h3 id="try-addresssanitizer-today"><span style="font-size: 18pt;">Try AddressSanitizer Today!</span></h3>
<p>In this article, we shared how we were able to use AddressSanitizer to find bugs in various open source projects. We hope this will motivate you to try out this feature on your own code base. Have you found eager iterators, shapeshifting types, or array / length constant disagreements in your projects? Let us know in the comments below, on Twitter <a class='myclass'href="https://twitter.com/visualc">(@VisualC</a>), or via email at <a class='myclass'href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p><em>This article contains code snippets from the following sources:</em></p>
<p><em><a class='myclass'href="https://github.com/boostorg/detail/blob/b29edf18cb94b01076c2cca1d72b32dc684ee575/include/boost/detail/utf8_codecvt_facet.ipp">utf8_codecvt_facet.ipp</a> file, <a class='myclass'href="https://github.com/boostorg/boost">Boost C++ Libraries</a>, Copyright (c) 2001 Ronald Garcia and Andrew Lumsdaine, distributed under the <a class='myclass'href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</em></p>
<p><em><a class='myclass'href="https://github.com/Azure/azure-iot-sdk-c">Azure IoT C SDKs and Libraries</a>, Copyright (c) Microsoft Corporation, distributed under the <a class='myclass'href="https://github.com/Azure/azure-iot-sdk-c/blob/116d971f17a64d79ca745b46d707c8210dbe3437/LICENSE">MIT License</a>.</em></p>
<p><em><a class='myclass'href="https://github.com/Azure/azure-c-shared-utility">Azure C Shared Utility</a>, Copyright (c) Microsoft Corporation, distributed under the <a class='myclass'href="https://github.com/Azure/azure-c-shared-utility/blob/c4e4d472679958b595a06c58849e3e2faf0074b7/LICENSE">MIT License</a>.</em></p>
<p><em><a class='myclass'href="https://github.com/openssl/openssl/blob/8020d79b4033400d0ef659a361c05b6902944042/test/params_api_test.c">params_api_test.c</a> file, <a class='myclass'href="https://github.com/openssl/openssl">OpenSSL</a>, Copyright 2019-2021 The OpenSSL Project Authors, Copyright (c) 2019 Oracle and/or its affiliates, distributed under the <a class='myclass'href="https://www.apache.org/licenses/LICENSE-2.0.txt">Apache License 2.0</a>.</em></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/">Finding Bugs with AddressSanitizer: Patterns from Open Source Projects</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/finding-bugs-with-addresssanitizer-patterns-from-open-source-projects/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>2x-3x Performance Improvements for Debug Builds</title>
		<link>https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/</link>
					<comments>https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/#comments</comments>
		
		<dc:creator><![CDATA[Pranav Kant]]></dc:creator>
		<pubDate>Fri, 07 May 2021 12:38:13 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[faster]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[debug builds]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27969</guid>

					<description><![CDATA[<p>We have made substantial runtime performance improvements in the x86/x64 C++ compiler for Visual Studio&#8217;s default debug configuration. For Visual Studio 2019 version 16.10 Preview 2, we measure 2x &#8211; 3x speedup for programs compiled in debug mode. These improvements come from reducing the overhead introduced by runtime checks (/RTCs) which are enabled by default. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/">2x-3x Performance Improvements for Debug Builds</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">We have made substantial runtime performance improvements in the x86/x64 C++ compiler for Visual Studio&#8217;s default debug configuration. For </span><a class='myclass'href="https://visualstudio.microsoft.com/vs/preview/%22%20/"><span data-contrast="none">Visual Studio 2019</span><span data-contrast="auto"> version 16.10 Preview 2</span></a><span data-contrast="auto">, we measure 2x &#8211; 3x speedup for programs compiled in debug mode. These improvements come from reducing the overhead introduced by runtime checks (/RTCs) which are enabled by default.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h3 id="default-debug-configuration"><b><span data-contrast="auto">Default debug configuration</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h3>
<p><span data-contrast="auto">When you compile your code in debug configuration in Visual Studio, there are some flags that are passed to the C++ compiler by default. Most relevant to this blog post are </span><a class='myclass'href="https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks?view=msvc-160"><span data-contrast="none">/RTC1</span></a><span data-contrast="auto">, </span><a class='myclass'href="https://docs.microsoft.com/en-us/cpp/build/reference/jmc?view=msvc-160"><span data-contrast="none">/JMC</span></a><span data-contrast="auto"> and </span><a class='myclass'href="https://docs.microsoft.com/en-us/cpp/build/reference/z7-zi-zi-debug-information-format?view=msvc-160"><span data-contrast="none">/ZI</span></a><span data-contrast="auto">. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">While all of these flags add useful debugging functionality, their interactions, particularly when /RTC1 is involved, add significant overhead. In this release, we removed the unnecessary overhead while making sure they keep helping you find bugs and make your debugging experience smoother.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Consider the following simple function:</span></p>
<div>
<div>
<pre>1    int foo() {
2        return 32;
3    }</pre>
</div>
</div>
<p>and <span data-contrast="auto">the x64 assembly generated by the 16.9 compiler when compiled with /RTC1 /JMC /ZI (<a class='myclass'href="https://godbolt.org/z/MnWehTso7">Godbolt link</a>):</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<div>
<pre>1    int foo(void) PROC                  
2    $LN3:
3            push rbp
4            push rdi
5            sub rsp, 232                ; extra space allocated due to /ZI, /JMC
6            lea rbp, QWORD PTR [rsp+32]
7            mov rdi, rsp
8            mov ecx, 58                 ; (= x)
9            mov eax, -858993460         ; 0xCCCCCCCC
10           rep stosd                   ; write 0xCC on stack for x DWORDs
11           lea rcx, OFFSET FLAT:__977E49D0_example@cpp
12           ; call due to /JMC
13           call __CheckForDebuggerJustMyCode
14           mov eax, 32
15           lea rsp, QWORD PTR [rbp+200]
16           pop rdi
17           pop rbp
18           ret 0
19    int foo(void) ENDP</pre>
</div>
<p><span data-contrast="auto">In the assembly shown above, the /JMC and /ZI flags add a total of 232 additional bytes on the stack (line 5). This stack space is not always necessary. When combined with the /RTC1 flag, which initializes the allocated stack space (line 10), it consumes a lot of CPU cycles. In this specific example, even though the stack space we allocated is necessary for proper functioning of /JMC and /ZI, its initialization is not. We can prove at compile time that these checks are unnecessary. There are plenty of such functions in any real-world C++ codebase, and that’s where the performance benefit comes from.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">Keep reading to get a deeper dive into each of these flags, their interactions with /RTC1, and how we avoid its unnecessary overhead.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="rtc1"><b><span data-contrast="auto">/RTC1</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><span data-contrast="auto">Using </span><a class='myclass'href="https://docs.microsoft.com/en-us/cpp/build/reference/rtc-run-time-error-checks?view=msvc-160"><span data-contrast="none">/RTC1</span></a><span data-contrast="auto"> flag is equivalent to using both /RTCs and /RTCu flags. /RTCs initializes the stack frame of functions by 0xCC to do various runtime checks namely, detecting uninitialized local variables, detecting array overrun and underruns, and stack pointer verification (for x86). You can see the code bloat with /RTCs </span><a class='myclass'href="https://godbolt.org/z/fEo9sYGTG"><span data-contrast="none">here</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">As seen in the above assembly code (line 10), the </span><code><i><span data-contrast="auto">rep stosd</span></i></code><span data-contrast="auto"> instruction, introduced by /RTCs, is the main reason for the slowdown. The situation is exacerbated when /RTCs (or /RTC1) is used in conjunction with /JMC, /ZI, or both.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="interactions-with-jmc"><b><span data-contrast="auto">Interactions with /JMC</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><a class='myclass'href="https://docs.microsoft.com/en-us/cpp/build/reference/jmc?view=msvc-160"><span data-contrast="none">/JMC</span></a><span data-contrast="auto"> stands for </span><i><span data-contrast="auto">Just My Code Debugging</span></i><span data-contrast="auto"> functionality</span><span data-contrast="auto">,</span><span data-contrast="auto"> and during debugging, it automatically skips over functions that are not written by you (such as framework, library, and other non-user code). It works by inserting a function call in the prologue that calls into the runtime library. This helps the debugger to distinguish between user and non-user code. The problem here is that inserting a function call into the prologue of every function in your project means that there are no leaf functions anymore in your whole project. If the function doesn&#8217;t need any stack frame originally, now it will, because as per </span><a class='myclass'href="https://docs.microsoft.com/en-us/cpp/build/stack-usage?view=msvc-160#stack-allocation"><span data-contrast="none">AMD64 ABI</span></a> for Windows platforms<span data-contrast="auto">, we need to have at least four stack slots available for function parameters (called <em>P</em></span><i><span data-contrast="auto">aram Home area</span></i><span data-contrast="auto">). This means all the functions that were not being initialized earlier by /RTCs, because they were leaf functions and had no stack frame, will now be initialized. It&#8217;s normal to have lots and lots of leaf functions in your program</span><span data-contrast="auto">,</span><span data-contrast="auto"> especially if you are using a heavily templated code library like C++ STL. /JMC will happily eat some of your CPU cycles in this case. This doesn&#8217;t apply for x86 (32 bit) because we don&#8217;t have any param home area there. You can see the effects of /JMC </span><a class='myclass'href="https://godbolt.org/z/v9qE3e7f5"><span data-contrast="none">here</span></a><span data-contrast="auto">.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="interaction-with-zi"><b><span data-contrast="auto">Interaction with /ZI</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><span data-contrast="auto">The next interaction we are going to talk about is with /ZI. It enables your code for </span><a class='myclass'href="https://docs.microsoft.com/en-us/visualstudio/debugger/edit-and-continue-visual-cpp?view=vs-2019"><span data-contrast="none">Edit and Continue</span></a><span data-contrast="auto"> support, which means you don&#8217;t need to recompile the whole program during debugging for small changes.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">In order to add such support, we add some padding bytes to the stack (the actual number of padding bytes depends on how big a function is). This way</span><span data-contrast="auto">,</span><span data-contrast="auto"> all the new variables you add during your debugging session can be allocated on the padding area without changing the total stack frame size, and you can continue your debugging without having to recompile your code.  See </span><a class='myclass'href="https://godbolt.org/z/oef3Pjn4G"><span data-contrast="none">here</span></a><span data-contrast="auto"> how enabling this flag adds an extra 64 bytes to the generated code.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">As you may have guessed, more stack area means more things to initialize by /RTCs, leading to more overhead.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h3 id="solution"><b><span data-contrast="auto">Solution</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h3>
<p><span data-contrast="auto">The root of all these problems is unnecessary initialization. Do we really need to initialize the stack area every time? No. One can safely prove within the compiler when stack initialization is really needed. For example, you need it when there is at least one address-taken variable, an array declared in your function or uninitialized variables. For every other case, we can safely skip over the initialization, as we are not going to find anything useful through runtime checks anyway.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">The situation gets a bit more complicated when you compile with edit-and-continue because now you may add uninitialized variables in the debugging session that can only be detected if we initialize the stack area. And we may not have done that. To solve this problem, we included the necessary bits in debugging info and exposed it via <a class='myclass'href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/debug-interface-access-sdk?view=vs-2019">Debug Interface Access SDK</a>. This information tells the debugger where the padding area introduced by /ZI </span><a class='myclass'href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiasymbol-get-framepadoffset?view=vs-2019"><span data-contrast="none">starts</span></a><span data-contrast="auto"> and </span><a class='myclass'href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiasymbol-get-framepadsize?view=vs-2019"><span data-contrast="none">ends</span></a><span data-contrast="auto">. It also tells the debugger if the function </span><a class='myclass'href="https://docs.microsoft.com/en-us/visualstudio/debugger/debug-interface-access/idiasymbol-get-isrtcs?view=vs-2019"><span data-contrast="none">needed any stack initialization</span></a><span data-contrast="auto">. If so, the debugger then unconditionally initializes the stack area in this memory range for the functions that you have edited during your debugging session. The new variables are always allocated on top of this initialized area and our runtime checks can now detect if your newly added code is safe or not.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h3 id="results"><b><span data-contrast="auto">Results</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h3>
<p><span data-contrast="auto">We compiled following projects in default debug configuration and then used the generated executables to run tests. We noticed 2x – 3x improvements in all the projects we tried. More STL-heavy projects may see larger improvements. Let us know in the comments any improvements you noticed in your projects. Project 1 and </span><a class='myclass'href="https://zeux.io/2019/01/17/is-c-fast/"><span data-contrast="none">Project 2</span></a><span data-contrast="auto"> are customer provided samples.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><a class='myclass'href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5.png"><img class="size-full wp-image-28007 aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5.png" alt="Image results" width="1024" height="570" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5-300x167.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/05/results-5-768x428.png 768w" sizes="(max-width: 1024px) 100vw, 1024px" /></a></p>
<p>&nbsp;</p>
<h4 id="tell-us-what-you-think"><b><span data-contrast="auto">Tell us what you think!</span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></h4>
<p><span data-contrast="auto">We hope this speedup makes your debugging workflow efficient and enjoyable. We are continuously listening to your feedback and working towards improving your inner loop experience. We’d love to hear about your experience in the comments below. You can also get in touch with us at </span><a class='myclass'href="https://developercommunity.visualstudio.com/spaces/8/index.html"><span data-contrast="none">Developer Community</span></a><span data-contrast="none">, email (</span><a class='myclass'href="mailto:visualcpp@microsoft.com"><span data-contrast="none">visualcpp@microsoft.com</span></a><span data-contrast="none">), and Twitter (</span><a class='myclass'href="https://twitter.com/visualc"><span data-contrast="none">@VisualC</span></a><span data-contrast="none">).</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/">2x-3x Performance Improvements for Debug Builds</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/2x-3x-performance-improvements-for-debug-builds/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Ignoring Automatic Initialization for Code Analysis</title>
		<link>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/</link>
					<comments>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/#comments</comments>
		
		<dc:creator><![CDATA[Gabor Horvath]]></dc:creator>
		<pubDate>Thu, 06 May 2021 15:00:15 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27927</guid>

					<description><![CDATA[<p>Reading uninitialized memory is one of the major sources of security vulnerabilities in C and C++ programs. Microsoft developed many tools to find such errors including compiler warnings, static analysis checks, and more recently: code instrumentation.  For a more detailed overview of uninitialized memory related vulnerabilities and mitigations please refer to Microsoft Security Response Center’s great blog post.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/">Ignoring Automatic Initialization for Code Analysis</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span data-contrast="auto">Reading uninitialized memory is one of the major sources of security vulnerabilities in C and C++ programs. Microsoft developed many tools to find such errors including compiler warnings, static analysis checks, and more recently: code instrumentation.  For a more detailed overview of uninitialized memory related vulnerabilities and mitigations please refer to <a class='myclass'href="https://msrc-blog.microsoft.com/2020/05/13/solving-uninitialized-stack-memory-on-windows/">Microsoft Security Response Center’s great blog post</a></span><span data-contrast="auto">. This blog post summarizes the potential interactions between code analysis and code instrumentation and improvements we&#8217;ve made in Visual Studio 2019 version 16.9.1.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">When we turn on the automatic initialization features of MSVC it will initialize certain constructs on the stack with a pattern. This solution can help mitigate the risks of reading uninitialized memory. However, to keep the performance costs of this mitigation minimal, the compiler will not initialize everything. It is a best effort method that tries to hit a good balance in mitigating security risks and avoiding noticeable performance regressions. Moreover, this is a non-standard feature that might not be available (or might behave differently) in other compilers, or in other versions of the same compiler. As a result, users should never rely on such an instrumentation. The proper fix is to explicitly initialize memory in the source code and only use instrumentation as a mitigation for any error that slipped through the code reviews, static analysis or any other tools of the QA process.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="auto">As a result, we want the compiler to warn on the following code regardless of the options used to compile the code:</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<pre class="prettyprint">void g(int); 
void f() { 
    int l; 
    g(l); // Warning C6001 expected regardless of the build configuration. 
}</pre>
<p><span data-contrast="auto">Starting from Visual Studio 2019 version 16.9.1, and 16.10 Preview 2 we ensured that the code analysis always sees the code as written as opposed to the instrumented version.  This behavior is in line with other toolchains and encourages developers to not rely on the automatic initialization feature.</span></p>
<p>Download the latest <a class='myclass'href="https://visualstudio.microsoft.com/vs/preview/" target="_blank" rel="noopener">Visual Studio 2019 Preview</a> today and give it a try. We’d love to hear from you to help us prioritize and build the right features for you. We can be reached via the comments below, <a class='myclass'href="https://developercommunity.visualstudio.com/spaces/8/index.html" target="_blank" rel="noopener">Developer Community</a>, and Twitter (<a class='myclass'href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>). The best way to file a bug or suggest a feature is via Developer Community.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/">Ignoring Automatic Initialization for Code Analysis</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/ignoring-automatic-initialization-for-code-analysis/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
	</channel>
</rss>
