<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Thu, 10 Mar 2022 00:01:39 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Embedded Software Development in Visual Studio Code</title>
		<link>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Thu, 10 Mar 2022 00:01:39 +0000</pubDate>
				<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30142</guid>

					<description><![CDATA[<p>We are happy to announce that we have released the Embedded Tools extension for Visual Studio Code. These capabilities are the same as what we recently announced for Visual Studio 2022. Used in conjunction with the new vcpkg artifact capabilities you can quickly bootstrap an embedded development machine and get started.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Embedded Software Development in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that we have released the Embedded Tools extension for Visual Studio Code. These capabilities are the same as what we recently announced for <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Visual Studio 2022</a>. Used in conjunction with the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifact capabilities</a> you can quickly bootstrap an embedded development machine and get started.</p>
<p>In this post we will walk you through how to acquire embedded tool dependencies with vcpkg, then demonstrate edit, build, deploy, and debugging directly in VS Code with new peripheral register and RTOS object views. We will demonstrate all of this with an Azure RTOS ThreadX project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png"><img class="alignnone size-full wp-image-30146" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png" alt="VS Code embedded development screenshot" width="1671" height="1044" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded.png 1671w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-1024x640.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-768x480.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vscode_embedded-1536x960.png 1536w" sizes="(max-width: 1671px) 100vw, 1671px" /></a></p>
<p>Azure RTOS ThreadX is a widely used Real Time Operating System (RTOS) used on billions of microcontrollers (MCUs) in products around the world. We have dedicated pages for VS Code usage in the getting started guides for the <a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/vscode.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/blob/master/NXP/MIMXRT1060-EVK/vscode.md">NXP 1060</a>, and STMicro STM32L4_L4+ IOT01A boards (<a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L475E-IOT01A/vscode.md">L475E</a> or <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L4S5I-IOT01A/vscode.md">L4S5I</a>). The techniques used for interacting with these boards should be applicable to other targets by changing configuration information we’ll highlight throughout.</p>
<h4 id="installation">Installation</h4>
<p>To get started install VS Code, then in the extensions side bar search for Embedded Tools and install it.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png"><img class="alignnone size-full wp-image-30147" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png" alt="Embedded Tools extension page screenshot" width="624" height="167" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_embedded_tools-300x80.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<h4 id="using-vcpkg-to-acquire-embedded-tools">Using vcpkg to acquire embedded tools</h4>
<p>One of the challenges in embedded development is getting the tools necessary installed and configured. It is not uncommon to have different compilers used for different projects, custom debug tools, etc. This is where the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">artifact capabilities in vcpkg</a>  can help us. Today we’ll demonstrate using vcpkg from a PowerShell prompt to activate our embedded development environment, but you can use the shell you prefer on your platform. In a future release this will be integrated into a Visual Studio Code extension for a more seamless experience.</p>
<p>From a PowerShell prompt, clone the Azure RTOS getting started repo. This sample will serve as our example project for the remainder of this post.</p>
<pre>git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Navigate to the subfolder for the board you are using, here I’m using the Azure IoT DevKit.</p>
<pre>cd ./getting-started/MXChip/AZ3166</pre>
<p>If you haven’t already, install vcpkg.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre>iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>CMD Shell</p>
<pre>curl -LO https://aka.ms/vcpkg-init.cmd &amp;&amp; .\vcpkg-init.cmd</pre>
<p>In the project folder, there is a file vcpkg_configuration.json. This manifest file was created with vcpkg and has recorded the tools you need to build and debug this project. See the <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifacts post</a> for details on how to create your own manifest. Running the vcpkg activate command will use this file to determine if I have those tools, install them if I do not, then activate them in my environment for use.</p>
<pre>vcpkg activate</pre>
<p>So, in three commands we have cloned our embedded project, installed vcpkg, acquired and activated the necessary tools for building the project.</p>
<h4 id="using-vs-code-for-embedded-development">Using VS Code for embedded development</h4>
<p>In the previous section we used vcpkg to acquire the tools for our embedded project. Today vcpkg is not integrated in Visual Studio Code. So, at present we need to launch VS Code from the environment we activated at the command line so those tools are available for its use as well.</p>
<pre>code .</pre>
<p>Now that we have the project open in VS Code it is ready to go as any other CMake project. <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">VS Code can run the CMake build using the preconfigured CMakePresets file</a> with the compilers vcpkg acquired. Select the preset arm-gcc-cortex-m4 when prompted on opening the folder.</p>
<p>All the editing power of VS Code is now available for use with the embedded project. With this Azure RTOS project we’ll cover code navigation, IntelliSense, build, deploy, debugging. We’ll also cover new diagnostic capabilities around peripheral registers and RTOS object views.</p>
<h5 id="code-navigation-and-intellisense">Code Navigation and IntelliSense</h5>
<p>Use Ctrl + T to open symbol search and type button_a_callback, select the button_a_callback function to navigate to it. Note on hover that this function expands to TIM3-&gt;CCR1 which is a peripheral register on the board which we’ll inspect while we are debugging.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png"><img class="alignnone size-full wp-image-30148" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png" alt="IntelliSense function expansion screenshot" width="538" height="327" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef.png 538w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_inspectregdef-300x182.png 300w" sizes="(max-width: 538px) 100vw, 538px" /></a></p>
<h5 id="build-deploy-and-debug-on-hardware">Build, Deploy, and Debug on hardware</h5>
<p>Set a breakpoint on RGB_LED_SET_R().</p>
<p>To see how the launch is controlled in the sidebar open .vscode/launch.json and look at the launch configuration. You can see the miDebuggerPath set to use arm-none-eabi-gdb while the debugServerPath is set to invoke openocd with the configuration script in debugServerArgs. The information for describing peripheral registers is provided by the MCU manufacturer in an SVD file that we point to with svdPath. This project is configured to break on entry with the property stopAtConnect.</p>
<p>Now, with your board plugged into the PC with <a href="https://www.st.com/en/development-tools/stsw-link009.html">ST-LINK drivers installed</a>, select the debug icon in the activity bar and make sure Run and Debug is set to Launch. Now F5 will work using openocd acquired by vcpkg to flash and debug the attached board. Execution stops at the entry function, so here we see the assembly code for that. We can also view the disassembly by right clicking the function in the call stack window, Open Disassembly View.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png"><img class="alignnone size-full wp-image-30149" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png" alt="Assembly source and disassembly screenshot" width="1047" height="177" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry.png 1047w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-300x51.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-1024x173.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_assemblyonentry-768x130.png 768w" sizes="(max-width: 1047px) 100vw, 1047px" /></a></p>
<p>Press continue to let execution continue.</p>
<h5 id="peripheral-registers">Peripheral Registers</h5>
<p>Now press the A button on the board. This has triggered our breakpoint. We can now go to the command palette Ctrl + Shift + P  and enter “peripheral”, select Focus on Peripheral View View. This opens the peripheral register view using the information from our SVD file specified in the launch configuration. We can now scroll through this list to find the register we are interested in, here TIM3-&gt;CCR1 which will update when we step over the RGB_LED_SET_R function.</p>
<p>On break</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png"><img class="alignnone wp-image-30259 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png" alt="Register before stepping" width="847" height="405" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new.png 847w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new-300x143.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regbefore_new-768x367.png 768w" sizes="(max-width: 847px) 100vw, 847px" /></a></p>
<p>After stepping</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png"><img class="alignnone wp-image-30260 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png" alt="Register after stepping" width="898" height="410" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new.png 898w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new-300x137.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_regafter_new-768x351.png 768w" sizes="(max-width: 898px) 100vw, 898px" /></a></p>
<h5 id="rtos-object-views">RTOS Object Views</h5>
<p>VS Code threads view won’t show you the threads in our Azure RTOS application. Why not? A good explanation can be found in this <a href="https://azure.microsoft.com/resources/real-time-operating-system">white paper on Real Time Operating Systems</a>.</p>
<p>“A Real-Time Operating System is system software that provides services and manages processor resources for applications. These resources include processor cycles, memory, peripherals, and interrupts. The main purpose of a Real-Time Operating System is to allocate processing time among various duties the embedded software must perform. This typically involves a division of the software into pieces, commonly called “tasks” or “threads,” and creating a run-time environment that provides each thread with its own virtual microprocessor (“Multithreading”). Basically, a virtual microprocessor consists of a virtual set of microprocessor resources, e.g., register set, program counter, stack memory area, and a stack pointer. Only while executing does a thread use the physical microprocessor resources, but each thread retains its own copy of the contents of these resources as if they were its own private resources (the thread”s “context”).”</p>
<p>So for embedded development ideally you would have views that could show you information about these RTOS objects. To see the new available RTOS objects views, go to the command palate Ctrl + Shift + P  and enter “rtos” then select Focus on RTOS viewer view</p>
<p>This will open the threads view that shows at a glance much of the information you would commonly need during embedded development, thread ids and names, how many times they have run, where the stack starts, ends, and its size as well as the maximum stack usage.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png"><img class="alignnone size-full wp-image-30153" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png" alt="RTOS threads window" width="1277" height="167" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads.png 1277w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-300x39.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-1024x134.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_RTOSthreads-768x100.png 768w" sizes="(max-width: 1277px) 100vw, 1277px" /></a></p>
<p>There are other views for additional ThreadX objects like block and byte pools, events, mutexes, queues, and timers. You can find these by selecting the three dots in the RTOS Viewer panel.</p>
<p>We also have RTOS object views for FreeRTOS though the available objects there differ based on what it supports.</p>
<h5 id="hardware-breakpoint-limits">Hardware breakpoint limits</h5>
<p>One last debugging capability to call out is that embedded hardware targets commonly have a limited set of hardware breakpoints available. Setting too many can corrupt the debugger state. As such we have added hardwareBreakpoints to launch.json. For this board that is set to what it supports which is 6. If we set more than that we will see the breakpoint is not set but will show as a gray empty circle.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png"><img class="alignnone size-full wp-image-30154" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png" alt="Hardware breakpoint example screenshot" width="328" height="66" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint.png 328w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/vsc_hwbreakpoint-300x60.png 300w" sizes="(max-width: 328px) 100vw, 328px" /></a></p>
<p>If you mouse over the breakpoint in the breakpoints view you will see a warning that it won’t be hit. This prevents corrupting the connection to the board and allows us the opportunity to unset some other breakpoints and continue debugging uninterrupted.</p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose VS Code for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vscode-embedded-development/">Embedded Software Development in Visual Studio Code</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vscode-embedded-development/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Execution and Static Analysis Support for MSVC on Compiler Explorer</title>
		<link>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/</link>
					<comments>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/#comments</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 01 Mar 2022 18:41:11 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30113</guid>

					<description><![CDATA[<p>Compiler Explorer is a popular resource for visualizing the assembly output of various compilers, trying out different compiler versions and flags, and testing many popular libraries.<br />
We&#8217;re pleased to announce that, as of today, code execution and static analysis are now available for MSVC on Compiler Explorer.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/">Execution and Static Analysis Support for MSVC on Compiler Explorer</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://godbolt.org/">Compiler Explorer</a> is a popular resource for visualizing the assembly output of various compilers, trying out different compiler versions and flags, and testing many popular libraries.</p>
<p>We&#8217;re pleased to announce that, as of today, code execution and static analysis are now available for MSVC on Compiler Explorer. Execution on CE has been one of our <a href="https://developercommunity.visualstudio.com/t/allow-code-execution-on-godboltorg-for-msvc-compil/663829">highest voted tickets on Developer Community</a>, so we hope many of you will find it useful. The static analysis tool provided is the same as offered in <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-with-github-actions/">GitHub Actions</a> and in the IDE as <a href="https://devblogs.microsoft.com/cppblog/in-editor-code-analysis-in-visual-studio-2019-preview-2/">background code analysis</a>.</p>
<p>To enable code execution, tick the &#8220;Execute the code&#8221; box in the &#8220;Output…&#8221; menu. Now, every time the code is compiled, it will be run and the output will be displayed in the Output window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png"><img class="aligncenter wp-image-30121 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png" alt="Execute the code and compile to binary options highlighted in the output menu" width="866" height="308" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1.png 866w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-300x107.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-768x273.png 768w" sizes="(max-width: 866px) 100vw, 866px" /></a></p>
<p>To enable static analysis, select &#8220;Static Analysis&#8221; from the &#8220;Add tool…&#8221; menu. Output from the tool will be written to a new Static Analysis window. You can find out more about our toolchain&#8217;s static analysis capabilities in our <a href="https://docs.microsoft.com/en-us/cpp/code-quality/code-analysis-for-c-cpp-overview?view=msvc-170">code analysis documentation</a>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png"><img class="aligncenter wp-image-30122 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png" alt="Static analysis highlighted in the add tool menu" width="849" height="311" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1.png 849w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1-300x110.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce1-1-768x281.png 768w" sizes="(max-width: 849px) 100vw, 849px" /></a></p>
<p>You can see the static analysis in action below.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png"><img class="aligncenter wp-image-30128 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png" alt="Static analysis finding an issue with the code" width="3838" height="874" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2.png 3838w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-300x68.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-1024x233.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-768x175.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-1536x350.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/03/ce2-2048x466.png 2048w" sizes="(max-width: 3838px) 100vw, 3838px" /></a></p>
<p>A huge thanks to Matt Godbolt and Patrick Quist from the Compiler Explorer team for their support. On the Microsoft side, much of this work was done by Tim Myers and Dale Hirt.</p>
<p>You can let us know what you think of the new support on Twitter <a href="https://twitter.com/visualc">@visualc</a> or in the comments below.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/">Execution and Static Analysis Support for MSVC on Compiler Explorer</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/execution-and-static-analysis-support-for-msvc-on-compiler-explorer/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>GSL 4.0.0 is Available Now</title>
		<link>https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/</link>
					<comments>https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/#respond</comments>
		
		<dc:creator><![CDATA[Dmitry Kobets]]></dc:creator>
		<pubDate>Tue, 01 Feb 2022 15:45:22 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[Writing Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30051</guid>

					<description><![CDATA[<p>Version 4.0.0 of Microsoft’s implementation of the C++ Core Guidelines Support Library (GSL) is now available for you to download on the releases page. This release maintains the safety guarantees that we have always offered and adds improvements to various parts of the library.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/">GSL 4.0.0 is Available Now</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Version 4.0.0 of Microsoft’s implementation of the <a href="https://github.com/microsoft/GSL">C++ Core Guidelines Support Library</a> (GSL) is now available for you to download on the <a href="https://github.com/microsoft/gsl/releases">releases page</a>. This release maintains the safety guarantees that we have always offered and adds improvements to various parts of the library.</p>
<h2 id="what-changed-in-this-release">What changed in this release?</h2>
<ul>
<li><a href="#deprecation-of-gslstring_span">Deprecation of <code>gsl::string_span</code></a></li>
<li><a href="#removal-of-gsl-multi_span">Removal of <code>&lt;gsl/multi_span&gt;</code></a></li>
<li><a href="#header-files-dropped-the-gsl_-prefix">Header files dropped the <code>gsl_</code> prefix</a></li>
<li><a href="#changes-to-not_null">Changes to <code>not_null</code></a></li>
<li><a href="#gslspan-and-stdspan-now-use-the-correct-specialization-of-gslat"><code>gsl::span</code> and <code>std::span</code> now use the correct specialization of <code>gsl::at</code></a></li>
<li>The <code>zstring</code> family no longer requires empty brackets to be used: <a href="https://github.com/microsoft/GSL/issues/992">issue#992</a>
<ul>
<li>for example, <code>void foo(zstring&lt;&gt; str);</code> should now be <code>void foo(zstring str);</code></li>
</ul>
</li>
<li><code>gsl::narrowing_error</code> now has a helpful <code>what()</code> message</li>
<li><code>finally</code> and <code>final_action</code> are now <code>[[nodiscard]]</code></li>
<li><a href="#gsl-will-work-in-environments-where-exceptions-are-disabled-with-some-caveats">GSL will work in environments where exceptions are disabled, with some caveats</a></li>
<li>GSL will work in environments which do not support iostreams, via the addition of the <code>GSL_NO_IOSTREAMS</code> flag: <a href="https://github.com/microsoft/GSL/pull/935">#953</a></li>
<li><a href="#C-compilers">Updated compiler support</a></li>
<li><a href="#cmake-and-build-improvements">CMake and build improvements</a></li>
</ul>
<h2 id="deprecation-of-gslstring_span">Deprecation of <code>gsl::string_span</code></h2>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/pull/1680">isocpp/CppCoreGuidelines#1680</a> removed <code>string_span</code> from the C++ Core Guidelines. The recommendation is to use <code>std::string_view</code>, <code>std::span&lt;char&gt;</code> or <code>gsl::span&lt;char&gt;</code> instead. To more closely align Microsoft’s GSL with the C++ Core Guidelines, we deprecated our implementation of <code>string_span</code> and <code>zstring_span</code>, including <code>basic_string_span</code>, <code>basic_zstring_span</code>, and all related types. For the time being, we will continue to provide the <code>&lt;gsl/string_span&gt;</code> header, but it will not be actively worked on or maintained. A table of all supported and unsupported types/features can be found in the <a href="https://github.com/microsoft/GSL/blob/main/README.md">README.md</a>.</p>
<h2 id="removal-of-gsl-multi_span">Removal of <code>&lt;gsl/multi_span&gt;</code></h2>
<p><code>multi_span</code>, <code>strided_span</code>, and everything else in <code>&lt;gsl/multi_span&gt;</code> were deprecated over a year ago in <a href="https://github.com/microsoft/GSL/releases/tag/v3.0.0">GSL 3.0.0</a>, and it is time for them and their associated tests to be removed from the library.</p>
<h2 id="header-files-dropped-the-gsl_-prefix">Header files dropped the <code>gsl_</code> prefix</h2>
<p>All headers which previously contained a <code>gsl_</code> prefix in their name have had this prefix removed. For example, <code>&lt;gsl/gsl_algorithm&gt;</code> is now <code>&lt;gsl/algorithm&gt;</code>. The <code>gsl_</code> prefixed files still exist and pass through to the updated files, but will be removed in a future release.</p>
<h2 id="changes-to-not_null">Changes to <code>not_null</code></h2>
<p>To more closely align Microsoft’s GSL with the C++ Core Guidelines, <code>gsl::not_null</code> now accepts only types which are <em>comparable</em> to <code>nullptr</code>. Previously, it accepted only types which are <em>assignable</em> from <code>nullptr</code>, but this was stricter than what was intended by the <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#gslview-views">Core Guidelines</a>.</p>
<p>The functions <code>make_not_null</code> and <code>make_strict_not_null</code>, and the <code>not_null</code> comparison operators, are now all <code>noexcept</code>.</p>
<h2 id="gslspan-and-stdspan-now-use-the-correct-specialization-of-gslat"><code>gsl::span</code> and <code>std::span</code> now use the correct specialization of <code>gsl::at</code></h2>
<p><code>gsl::span</code> and <code>std::span</code> now have their own separate specializations of <code>gsl::at</code>, to ensure consistent behavior between the two versions of span. Both overloads are included when importing <code>&lt;gsl/span&gt;</code>. The <code>std::span</code> overload can be separately included from <code>&lt;gsl/util&gt;</code>.</p>
<h2 id="gsl-will-work-in-environments-where-exceptions-are-disabled-with-some-caveats">GSL will work in environments where exceptions are disabled, with some caveats</h2>
<p><code>gsl::narrow</code> is the only part of the library which may throw exceptions and has been moved into its own header <code>&lt;gsl/narrow&gt;</code>. This header is included in <code>&lt;gsl/gsl&gt;</code> only if exceptions are enabled. This allows users of the library who are working in environments without exceptions to use all of the other components of the library.</p>
<p>Note: <code>gsl::narrow_cast</code> is still in <code>&lt;gsl/util&gt;</code>, since it does not throw exceptions.</p>
<h2 id="updated-compiler-support">Updated compiler support</h2>
<p>The list of supported compilers/toolsets has been updated with newer versions. More info on compiler support can be found in the <a href="https://github.com/microsoft/GSL/blob/main/README.md#supported-compilers--toolsets">README.md</a>.</p>
<table>
<thead>
<tr>
<th>Compiler/Toolset</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>XCode</td>
<td>13.2.1 &amp; 12.5.1</td>
</tr>
<tr>
<td>GCC</td>
<td>11.1.0 &amp; 10.3.0</td>
</tr>
<tr>
<td>Clang</td>
<td>12.0.0 &amp; 11.0.0</td>
</tr>
<tr>
<td>Visual Studio with MSVC</td>
<td>VS2022 (17.0) &amp; VS2019 (16.11)</td>
</tr>
<tr>
<td>Visual Studio with LLVM</td>
<td>VS2022 (17.0) &amp; VS2019 (16.11)</td>
</tr>
</tbody>
</table>
<h2 id="cmake-and-build-improvements">CMake and build improvements</h2>
<ul>
<li>GSL Install logic is now guarded by a cmake option <code>GSL_INSTALL</code>: <a href="https://github.com/microsoft/GSL/pull/964">#964</a></li>
<li>Fix bug which prevented the library from being built on a 32-bit host and then being used on a 64-bit machine: <a href="https://github.com/microsoft/GSL/pull/893">#893</a></li>
<li>Build will now use <code>CMAKE_CXX_STANDARD</code> if it&#8217;s provided <a href="https://github.com/microsoft/GSL/pull/953">#953</a></li>
<li>Clean up <code>GSL_SUPPRESS</code> warning for intel compilers: <a href="https://github.com/microsoft/GSL/pull/906">#906</a></li>
<li>Fix build failure for C++20 compilers which don&#8217;t have <code>std::span</code>: <a href="https://github.com/microsoft/GSL/pull/993">#993</a></li>
<li>Cleaned up some static analysis warnings</li>
<li>The cmake cache variable <code>VS_ADD_NATIVE_VISUALIZERS</code> has been renamed to <code>GSL_VS_ADD_NATIVE_VISUALIZERS</code>: <a href="https://github.com/microsoft/GSL/pull/941">#941</a></li>
</ul>
<h2 id="summary">Summary</h2>
<p>This has been a list of the changes in the GSL 4.0.0 release. You can download the code at the <a href="https://github.com/microsoft/GSL">GSL GitHub page</a>. Please stay tuned for future releases!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/">GSL 4.0.0 is Available Now</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/gsl-4-0-0-is-available-now/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>How we used C++20 to eliminate an entire class of runtime bugs</title>
		<link>https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/</link>
					<comments>https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/#comments</comments>
		
		<dc:creator><![CDATA[Cameron DaCamara]]></dc:creator>
		<pubDate>Thu, 13 Jan 2022 17:52:08 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++20]]></category>
		<category><![CDATA[compiler]]></category>
		<category><![CDATA[constexpr]]></category>
		<category><![CDATA[safety]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29981</guid>

					<description><![CDATA[<p>C++20 is here and has been supported in MSVC since 16.11, but today&#8217;s post is not about how you can use it, but rather how we used it to effectively eliminate an entire class of runtime bugs by hoisting a check into compile-time.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/">How we used C++20 to eliminate an entire class of runtime bugs</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>C++20 is here and has been supported in MSVC since <a href="https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/">16.11</a>, but today&#8217;s post is not about how you can use it, but rather how <em>we</em> used it to effectively eliminate an entire class of runtime bugs by hoisting a check into compile-time. Let&#8217;s get right into it!</p>
<h4><span id="humble-beginnings">Humble beginnings</span></h4>
<p>In compiler design one of the very first things you need is a way to convey to the programmer that their source code has an error or warn them if their code might not behave as expected. In MSVC our error infrastructure looks something like this:</p>
<pre>enum ErrorNumber {
    C2000,
    C2001,
    C2002,
    ...
};
void error(ErrorNumber, ...);</pre>
<p>The way <code>error</code> works is that each <code>ErrorNumber</code> has a corresponding string entry which represents the text we want to display to the user. These text strings can be anything from: <code>C2056 -&gt; "illegal expression"</code> to: <code>C7627 -&gt; "'%1$T': is not a valid template argument for '%2$S'"</code>, but what are these <code>%1$T</code> and <code>%2$S</code> things? These are some of the compiler&#8217;s format-specifiers to display certain types of structures in the compiler to the user in a readable way.</p>
<h4><span id="double-edged-sword">The double-edged sword of format-specifiers</span></h4>
<p>Format-specifiers provide a lot of flexibility and power to us as compiler developers. Format-specifiers can more clearly illustrate why a diagnostic was issued and provide the user with more context into the problem. The problem with format-specifiers is that they are not type checked in the call to <code>error</code>, so if we happen to get an argument type wrong or did not pass an argument at all it will almost certainly end up in a runtime error later for the user. Other problems arise when you want to refactor a diagnostic message into something clearer, but to do that you need to query every caller of that diagnostic message and ensure that the refactor agrees with the arguments being passed to <code>error</code>.</p>
<p>We have three high-level goals when designing a system that can check our format-specifiers:</p>
<ol>
<li>Validate that argument types passed into our diagnostic APIs at compile-time so authoring a mistake is caught as early as possible.</li>
<li>Minimize changes made to callers of diagnostic APIs. This is to ensure well-formed calls retain their original structure (no disruption to future calls as well).</li>
<li>Minimize changes made to implementation details of the callee. We should not change the behavior of the diagnostic routines at runtime.</li>
</ol>
<p>There are, of course, some solutions introduced with later C++ standards which could aid in trying to remedy this problem. For one, once variadic templates were introduced into the language we could have tried some template metaprogramming to try and type check the calls to <code>error</code>, but that would require a separate lookup table since constexpr and templates were limited in what they could do. C++14/17 both introduced a lot of improvements to constexpr and non-type template arguments. Something like this would work great:</p>
<pre>constexpr ErrorToMessage error_to_message[] = {
    { C2000, fetch_message(C2000) },
    { C2001, fetch_message(C2001) },
    ...
};

template &lt;typename... Ts&gt;
constexpr bool are_arguments_valid(ErrorNumber n) {
    /* 1. fetch message
       2. parse specifiers
       3. check each specifier against the parameter pack Ts... */
    return result;
}</pre>
<p>So we finally had the tools to try and check the format-specifiers at compile-time. But there was still a problem: we still did not have a way to silently check all the existing calls to <code>error</code> meaning that we would have to add an extra layer of indirection between the call sites of <code>error</code> to ensure that the <code>ErrorNumber</code> could fetch the string at compile-time and check the argument types against it. In C++17 this will not work:</p>
<pre>template &lt;typename... Ts&gt;
void error(ErrorNumber n, Ts&amp;&amp;... ts) {
    assert(are_arguments_valid&lt;Ts...&gt;(n));
    /* do error stuff */
}</pre>
<p>And we cannot make <code>error</code> itself constexpr because it does a lot of constexpr-unfriendly things. Additionally, adjusting all the call sites to something like: <code>error&lt;C2000&gt;(a, b, c)</code> so that we can check the error number as a compile-time expression is unsavory and would cause a lot of unnecessary churn in the compiler.</p>
<h4><span id="cpp20">C++20 to the rescue!</span></h4>
<p>C++20 introduced an important tool for us to enable compile-time checking, <code>consteval</code>. <code>consteval</code> is in the family of constexpr but the language guarantees that a function adorned with <code>consteval</code> will be evaluated at compile-time. A well-known library by the name of <a href="https://github.com/fmtlib/fmt">fmtlib</a> introduced compile-time checking as part of the <a href="https://fmt.dev/latest/api.html#core-api">core API</a> and it did so without changing any call sites, assuming the call site was well-formed according to the library. Imagine a simplified version of <code>fmt</code>:</p>
<pre>template &lt;typename T&gt;
void fmt(const char* format, T);

int main() {
    fmt("valid", 10);    // compiles
    fmt("oops", 10);     // compiles?
    fmt("valid", "foo"); // compiles?
}</pre>
<p>Where the intent is that <code>format</code> should always be equal to <code>"valid"</code> and <code>T</code> should always be an <code>int</code>. The code in <code>main</code> is ill-formed according to the library in this case, but nothing validates that at compile-time. fmtlib accomplished compile-time checking using a little trick with user-defined types:</p>
<pre>#include &lt;string_view&gt;
#include &lt;type_traits&gt;

// Exposition only
#define FAIL_CONSTEVAL throw

template &lt;typename T&gt;
struct Checker {
    consteval Checker(const char* fmt) {
        if (fmt != std::string_view{ "valid" }) // #1
            FAIL_CONSTEVAL;
        // T must be an int
        if (!std::is_same_v&lt;T, int&gt;)            // #2
            FAIL_CONSTEVAL;
    }
};

template &lt;typename T&gt;
void fmt(std::type_identity_t&lt;Checker&lt;T&gt;&gt; checked, T);

int main() {
    fmt("valid", 10);    // compiles
    fmt("oops", 10);     // fails at #1
    fmt("valid", "foo"); // fails at #2
}</pre>
<p>Note: you need to use the <code>std::type_identity_t</code> trick to keep <code>checked</code> from participating in type deduction. We only want it to deduce the rest of the arguments and use their deduced types as template arguments to <code>Checker</code>.</p>
<p>You can fiddle with the example for yourself using <a href="https://godbolt.org/z/baPvojah1">Compiler Explorer</a>.</p>
<h4><span id="tying-it-together">Tying it all together</span></h4>
<p>The code above is powerful in that it gives us a tool which can perform additional safety checking without changing any caller which is well-formed. Using the technique above we applied compile-time checking to all our <code>error</code>, <code>warning</code>, and <code>note</code> message routines. The code used in the compiler is nearly identical to the <code>fmt</code> above except that the argument to <code>Checker</code> is an <code>ErrorNumber</code>.</p>
<p>In total we identified <b>~120</b> instances where we were either passing the incorrect number of arguments to a diagnostic API or where we passed the wrong type for a particular format-specifier. Over the years we have received bugs regarding strange compiler behavior when emitting a diagnostic or a straight-up ICE (Internal Compiler Error) because the format-specifiers were looking for arguments which were incorrect or did not exist. Using C++20 we have largely eliminated possibility of such bugs happening in the future and while offering the ability for us to safely refactor diagnostic messages, made possible by one little keyword: <code>consteval</code>.</p>
<h4 id="closing">Closing</h4>
<p>As always, we welcome your feedback. Feel free to send any comments through e-mail at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a> or through <a href="https://twitter.com/visualc">Twitter @visualc</a>. Also, feel free to follow me on Twitter <a href="https://twitter.com/starfreakclone">@starfreakclone</a>.</p>
<p>If you encounter other problems with MSVC in VS 2019/2022 please let us know via the <a href="https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report a Problem</a> option, either from the installer or the Visual Studio IDE itself. For suggestions or bug reports, let us know through <a href="https://developercommunity.visualstudio.com/">DevComm.</a></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/">How we used C++20 to eliminate an entire class of runtime bugs</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/how-we-used-cpp20-to-eliminate-an-entire-class-of-runtime-bugs/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ December 2021 Update: clang-tidy</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Tue, 14 Dec 2021 19:26:50 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++ extension]]></category>
		<category><![CDATA[clang]]></category>
		<category><![CDATA[clang-tidy]]></category>
		<category><![CDATA[code analysis]]></category>
		<category><![CDATA[CPP]]></category>
		<category><![CDATA[cpptools]]></category>
		<category><![CDATA[linter]]></category>
		<category><![CDATA[static analysis]]></category>
		<category><![CDATA[tidy]]></category>
		<category><![CDATA[vs code]]></category>
		<category><![CDATA[VSCode]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29926</guid>

					<description><![CDATA[<p>The latest insiders release of the C++ extension is here, bringing clang-tidy support to VS Code! Clang-tidy is a clang-based C++ linter tool that detects common errors in your code, like style violations and bugs that can be deduced via static analysis.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/">Visual Studio Code C++ December 2021 Update: clang-tidy</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The latest <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.8.0-insiders2">insiders release</a> of the C++ extension is here, bringing clang-tidy support to VS Code! <a href="https://clang.llvm.org/extra/clang-tidy/">Clang-tidy</a> is a clang-based C++ linter tool that detects common errors in your code, like style violations and bugs that can be deduced via static analysis. <a href="https://github.com/microsoft/vscode-cpptools/issues/2908">Clang-tidy integration</a> was one of our top asks on GitHub, so we’re excited to announce that it’s ready for you to try!</p>
<h1 id="getting-started">Getting started</h1>
<h2 id="do-i-need-to-install-clang-tidy">Do I need to install clang-tidy?</h2>
<p>Nope! Clang-tidy now comes bundled with the C++ extension. But if you already have clang-tidy installed (and it’s on your environment’s path), the C++ extension will use that one instead. You can point the C++ extension to any clang-tidy binary by editing the C++ extension’s <strong>Clang Tidy: Path</strong> setting.</p>
<h2 id="how-do-i-run-clang-tidy-in-vs-code">How do I run clang-tidy in VS Code?</h2>
<p>To manually run clang-tidy, open the <strong>Command Palette (Ctrl + Shift + P)</strong> and type <strong>“Run Code Analysis.” </strong>You can run clang-tidy on the active file, on all open files, or on the entire workspace.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png"><img class="alignnone size-full wp-image-29937" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png" alt="Screenshot showing how to manually run clang-tidy from the Command Palette" width="2024" height="380" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis.png 2024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-300x56.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-1024x192.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-768x144.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/run-code-analysis-1536x288.png 1536w" sizes="(max-width: 2024px) 100vw, 2024px" /></a></p>
<p>If there are certain workspace files or folders that you <em>don’t</em> want to run clang-tidy on, add them to the <strong>Clang Tidy: Exclude</strong> setting (C_Cpp.codeAnalysis.exclude in settings.json).</p>
<p>You can also set clang-tidy to run automatically whenever you open or save a file. To turn on automatic code analysis, open your project settings by selecting <strong>“Preferences: Open Settings (UI)”</strong> from the <strong>Command Palette (Ctrl + Shift + P).</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png"><img class="alignnone size-full wp-image-29936" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png" alt="Screenshot showing how to open VS Code settings from the Command Palette" width="1742" height="184" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui.png 1742w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-300x32.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-1024x108.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-768x81.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/open-settings-ui-1536x162.png 1536w" sizes="(max-width: 1742px) 100vw, 1742px" /></a></p>
<p>Then search for <strong>“code analysis” </strong>to find all the clang-tidy settings and set <strong>Clang Tidy: Enabled</strong> to true.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png"><img class="alignnone size-full wp-image-29929" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png" alt="Screenshot of the Clang Tidy: Enabled setting in VS Code, which must be set to true in order for code analysis to run automatically in the background" width="1770" height="284" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting.png 1770w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-300x48.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-1024x164.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-768x123.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-enable-setting-1536x246.png 1536w" sizes="(max-width: 1770px) 100vw, 1770px" /></a></p>
<p><strong>Note:</strong> You can set clang-tidy settings globally (in the User tab) or at the workspace level.</p>
<p>You can check if clang-tidy is running by looking for the fire icon in the blue status bar at the bottom of the window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png"><img class="alignnone size-full wp-image-29935" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png" alt="Screenshot of the fire icon in the status bar. Users can hover over this icon to see the status of clang-tidy." width="590" height="192" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover.png 590w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/fire-icon-hover-300x98.png 300w" sizes="(max-width: 590px) 100vw, 590px" /></a></p>
<p>To pause or cancel clang-tidy, click on the fire icon and then choose an option from the drop down.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png"><img class="alignnone size-full wp-image-29927" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png" alt="Screenshot showing the Cancel and Pause options for clang-tidy from a dropdown in VS Code" width="1746" height="242" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy.png 1746w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-300x42.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-1024x142.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-768x106.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/cancel-pause-clang-tidy-1536x213.png 1536w" sizes="(max-width: 1746px) 100vw, 1746px" /></a></p>
<h2 id="how-do-i-configure-clang-tidy-checks-and-check-options">How do I configure clang-tidy checks and check options?</h2>
<p>If you have a .clang-tidy configuration file in your project directory, the C++ extension will honor the checks and options defined in that file. If you have multiple .clang-tidy configuration files in your workspace, clang-tidy will use the configuration file closest to the source file by searching up the path in its parent directories. Alternatively, you can specify a clang-tidy configuration with the <strong>Clang Tidy: Config</strong> setting. <strong>Clang Tidy: Config</strong> accepts checks and check options as a YAML/JSON-formatted string.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png"><img class="alignnone size-full wp-image-29928" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png" alt="Screenshot of the Clang Tidy: Config setting in VS Code, where users can pass a string in YAML/JSON format to specify clang-tidy checks and options" width="1860" height="376" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config.png 1860w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-300x61.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-1024x207.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-768x155.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-config-1536x311.png 1536w" sizes="(max-width: 1860px) 100vw, 1860px" /></a></p>
<p>If a source file doesn’t have a .clang-tidy configuration file in any of its parent directories, and the <strong>Clang Tidy: Config</strong> property is left empty, then the fallback configuration (defined in C_Cpp.codeAnalysis.clangTidy.fallbackConfig) will be used for that file.</p>
<p>You can enable and disable more checks by using the <strong>Clang Tidy &gt; Checks: Enabled</strong> and <strong>Clang Tidy &gt; Checks: Disabled</strong> settings. The checks defined in these settings are run in addition to the checks in the .clang-tidy file.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png"><img class="alignnone size-full wp-image-29934" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png" alt="Screenshot of the Clang Tidy &gt; Checks: Enabled setting in VS Code, where users pick which clang-tidy settings to run on their project" width="1558" height="504" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting.png 1558w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-300x97.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-1024x331.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-768x248.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-checks-setting-1536x497.png 1536w" sizes="(max-width: 1558px) 100vw, 1558px" /></a></p>
<p>Selecting <strong>Add Item</strong> shows a list of all clang-tidy checks.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png"><img class="alignnone size-full wp-image-29940" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png" alt="Screenshot showing the list of available clang-tidy checks after selecting Add Item in the Clang Tidy &gt; Checks: Enabled settings" width="1630" height="1162" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-300x214.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-1024x730.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-768x547.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/list-of-clang-tidy-checks-1536x1095.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></a></p>
<p>You can add as many checks as you’d like to both the <strong>Clang Tidy &gt; Checks: Enabled</strong> and <strong>Clang Tidy &gt; Checks: Disabled</strong> settings.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png"><img class="alignnone size-full wp-image-29933" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png" alt="Screenshot of the Clang Tidy &gt; Checks: Disabled and Clang Tidy &gt; Checks: Disabled settings in VS Code, where users can choose which clang-tidy checks to run or not run for their workspace" width="1602" height="1244" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks.png 1602w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-300x233.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-1024x795.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-768x596.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/enabled-and-disabled-checks-1536x1193.png 1536w" sizes="(max-width: 1602px) 100vw, 1602px" /></a></p>
<h2 id="how-do-i-pass-command-line-args-to-clang-tidy">How do I pass command line args to clang-tidy?</h2>
<p>If you typically pass <a href="https://clang.llvm.org/extra/clang-tidy/">command line options</a> to clang-tidy, you can specify those in the <strong>Clang Tidy: Args</strong> property. The <strong>Clang Tidy: Args</strong> setting takes precedence over the equivalent Clang Tidy settings in the editor (such as Clang Tidy &gt; Checks: Enabled and Clang Tidy &gt; Checks: Disabled).</p>
<h1 id="viewing-check-results-in-the-editor">Viewing check results in the editor</h1>
<p>The results of clang-tidy checks (warnings and errors) are displayed in the <strong>Problems panel</strong> and as squiggles beneath relevant sections of code.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png"><img class="alignnone size-full wp-image-29930" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png" alt="Screenshot of the results of clang-tidy checks showing up in the Problems pane in VS Code" width="1646" height="1312" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane.png 1646w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-300x239.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-1024x816.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-768x612.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clang-tidy-problems-pane-1536x1224.png 1536w" sizes="(max-width: 1646px) 100vw, 1646px" /></a></p>
<p>Clicking on the problem in the Problems panel takes you to the issue in your source file. To clear the code analysis squiggles, click on the Quick Actions lightbulb, and then select <strong>Clear code analysis squiggles.</strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png"><img class="alignnone size-full wp-image-29931" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png" alt="Screenshot of the &quot;Clear Code Analysis Squiggles&quot; Quick Action, which is visible when selecting the lightbulb next to underlined code " width="1172" height="388" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles.png 1172w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-300x99.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-1024x339.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/clear-code-analysis-squiggles-768x254.png 768w" sizes="(max-width: 1172px) 100vw, 1172px" /></a></p>
<h1 id="clang-tidy-settings">Clang-tidy settings</h1>
<p>Here’s a list of new VS Code settings to help you configure clang-tidy for your workspace.</p>
<table>
<tbody>
<tr>
<td width="282"><strong>Setting name</strong></td>
<td width="60"><strong>Type</strong></td>
<td width="84"><strong>Default value</strong></td>
<td width="198"><strong>Description</strong></td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.enabled</p>
<p>&nbsp;</td>
<td width="60">Boolean</td>
<td width="84">False</td>
<td width="198">When true, clang-tidy will be enabled and run automatically if C_Cpp.codeAnalysis.runAutomatically is set to true</p>
<p>&nbsp;</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.runAutomatically</td>
<td width="60">Boolean</td>
<td width="84">True</td>
<td width="198">When true, runs clang-tidy on file open and file save.</p>
<p>&nbsp;</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.path</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">The full path to the clang-tidy executable.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.checks.enabled</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">List of enabled clang-tidy checks. The values are appended to the Checks in a .clang-tidy file or C_Cpp › Code Analysis › Clang Tidy: Config.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.checks.disabled</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">List of disabled clang-tidy checks. The values are appended to the Checks in a .clang-tidy file or C_Cpp › Code Analysis › Clang Tidy: Config, if any.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.config</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Specifies a clang-tidy configuration in YAML/JSON format: {Checks: &#8216;-*,clang-analyzer-*&#8217;, CheckOptions: [{key: x, value: y}]}. When empty, any found .clang-tidy files will be used.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.fallbackConfig</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Specifies a clang-tidy configuration in YAML/JSON format to be used as a fallback when C_Cpp › Code Analysis › Clang Tidy: Config is not set and no .clang-tidy file is found.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.args</td>
<td width="60">Array of strings</td>
<td width="84">Null (empty)</td>
<td width="198">Command line arguments to pass to clang-tidy. These take precedence over the equivalent C_Cpp.codeAnalysis.clangTidy.* settings.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.exclude</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">Configure glob patterns for excluding folders and files for code analysis.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.clangTidy.headerFilter</td>
<td width="60">String</td>
<td width="84">Null (empty)</td>
<td width="198">A POSIX extended regular expression (ERE) matching the names of the headers to output diagnostics from. It overrides the HeaderFilterRegex option in a .clang-tidy file, if any.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.maxConcurrentThreads</p>
<p>(User level only)</td>
<td width="60">Int</td>
<td width="84">Null (empty)</td>
<td width="198">The maximum number of concurrent threads to use for code analysis. The default of null (empty) uses half the value inherited from C_Cpp: Max Concurrent Threads.</td>
</tr>
<tr>
<td width="282">C_Cpp.codeAnalysis.maxMemory</p>
<p>(User level only)</td>
<td width="60">Int</td>
<td width="84">Null (empty)</td>
<td width="198">Fewer code analysis processes will run concurrently after this memory usage (in MB) is exceeded. The default of null (empty) uses the value inherited from C_Cpp: Max Memory.</td>
</tr>
</tbody>
</table>
<h1 id="coming-soon">Coming soon</h1>
<p>Hang tight! Applying suggested fixes in the editor is coming soon.</p>
<h1 id="what-do-you-think">What do you think?</h1>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today and join our Insiders program to access this initial release of clang-tidy integration. To join our Insiders program, go to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/">Visual Studio Code C++ December 2021 Update: clang-tidy</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-december-2021-update-clang-tidy/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>The /fp:contract flag and changes to FP modes in VS2022</title>
		<link>https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/</link>
		
		<dc:creator><![CDATA[Gautham Beeraka (Intel Americas Inc)]]></dc:creator>
		<pubDate>Tue, 14 Dec 2021 00:25:13 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<category><![CDATA[Floating Point]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29915</guid>

					<description><![CDATA[<p>The /fp:contract flag and changes to FP modes in VS2022<br />
In this blog we will cover a new feature we have added to the MSVC version 17.0 compiler in VS2022 that impacts the generation of Floating-Point contractions such as Fused Multiply Add (FMA) instructions.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022">The /fp:contract flag and changes to FP modes in VS2022</h1>
<p>In this blog we will cover a new feature we have added to the MSVC version 17.0 compiler in VS2022 that impacts the generation of Floating-Point contractions such as Fused Multiply Add (FMA) instructions. We will cover how FMA contractions are supported in pre-VS2022 MSVC compiler releases, a new /fp:contract flag and changes to existing Floating-Point pragmas in VS2022 MSVC compiler allowing explicit control over generation of contractions</p>
<p>A contraction, as used here, is where two operations in the source code are performed by a single instruction in the executable code. Examples are Fused Multiply-Add (FMA) and reciprocal square root. The former computes ((a * b) + c), while the later computes (1/sqrt(a)). The advantages of contractions are increased speed of calculations involved and decrease in the code size of your application. The reason you might not want to use a contraction is because the intermediate result isn’t rounded, so the result might differ slightly from what you would get from separate instructions. That is often not a problem, but we’re particular about what we mean by “precise” and don’t want to promise something we’re not delivering. Giving you control over whether contractions are used or not gives the best of both worlds, where you can get consistent results when you need them and can use contractions when you don’t.</p>
<h2 id="pre-vs2022-behavior-for-contractions">Pre-VS2022 behavior for contractions</h2>
<p>In the versions of Visual Studio prior to VS2022, under the default FP mode of /fp:precise, the generation of contractions was inconsistent. This inconsistency was between different platforms and between scalar and vector versions of FMAs. The compiler could generate both scalar and vector versions of FMAs on the ARM and ARM64 platforms. On x86 and x64 platforms supporting FMA instructions, the compiler could only generate vector FMA instructions. We are addressing this inconsistency and updating the documentation on FP modes in VS2022.</p>
<h2 id="vs2022-behavior-for-contractions">VS2022 behavior for contractions</h2>
<p>Although contractions tend to improve the performance of your application, they can produce inconsistent results between debug and release builds and ISA targeting (example: SSE2 vs AVX2) and may result in breaking existing assumptions in test coverage. To account for this and address the aforementioned inconsistency, contractions will not be generated by default under the /fp:precise mode on all platforms starting from VS2022 version 17.0. We have introduced a new /fp:contract flag which can be used along with /fp:precise to enable contractions. The /fp:contract flag will enable both vector and scalar contractions on all platforms. The /fp:contract flag and the updated behavior for /fp:precise is documented <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fp-specify-floating-point-behavior?view=msvc-170">here</a>. The table below summarizes the behavior for VS2022.</p>
<table>
<tbody>
<tr>
<td><strong>Compiler FP-mode flag</strong></td>
<td><strong>VS2022 17.0 default behavior</strong></td>
<td><strong>VS2022 17.0 behavior with /fp:contract</strong></td>
</tr>
<tr>
<td>/fp:strict</td>
<td>No contractions</td>
<td>Incompatible (compiler error)</td>
</tr>
<tr>
<td>/fp:precise</td>
<td>No contractions</td>
<td>Allow contractions</td>
</tr>
<tr>
<td>/fp:fast</td>
<td>Allow contractions</td>
<td>Allow contractions</td>
</tr>
</tbody>
</table>
<p>The behavior of Floating-Point pragmas was also modified to agree with the behavior of the Floating-Point flags. The float_control pragmas will now disable contractions when turned on and will restore the previous setting for contractions when turned off. This new behavior is documented for <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/float-control?view=msvc-170">float_control</a>, <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/fenv-access?view=msvc-170">fenv_access</a> and <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/fp-contract?view=msvc-170">fp_contract</a> pragmas.</p>
<p>With this new behavior, there can be performance regressions since contractions are no longer generated by default. Adding the /fp:contract flag should mitigate this. The behavior of contractions can be further controlled at a function level using the Floating-Point pragmas.</p>
<p>Note that intrinsic functions such as: fma<em>, </em>fmaf<em> and </em>fmal can still be used to generate FMA machine instructions if the target architecture supports them.</p>
<h2 id="how-to-enable-fpcontract-in-vs2022">How to enable /fp:contract in VS2022</h2>
<p>To enable /fp:contract for your project:</p>
<p>In Visual Studio, add the /fp:contract option in the Additional Options box (Project|Properties|Configuration Properties|C/C++|Command Line|Additional Options)</p>
<p><img width="796" height="553" class="wp-image-29916" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1.png" alt="Graphical user interface, text, application, email Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1.png 796w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/graphical-user-interface-text-application-email-1-768x534.png 768w" sizes="(max-width: 796px) 100vw, 796px" /></p>
<p>Figure 1. Add the /fp:contract compiler option for each desired configuration.</p>
<p>Since generation of contractions is an optimization, adding the /fp:contract flag may not produce contractions for debug builds.</p>
<p>If you are upgrading your project from VS2019 to VS2022 and see different floating-point results, these are the things you should check:</p>
<ul>
<li>If your code is built with /fp:fast, this can be the expected behavior. /fp:fast allows the compiler to optimize things more aggressively with some loss in FP precision. More optimizations are likely firing in this case.</li>
<li>If your code is built with /fp:precise (or no /fp model is specified), try throwing /fp:contract to confirm if contractions were the cause of the FP changes. If it was, see if that makes sense for your scenario to continue to throw /fp:contract.</li>
<li>If your code is built with /fp:strict then <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">let us know</a>, there may be a compiler bug.</li>
</ul>
<h2 id="closing-notes">Closing Notes</h2>
<p>We’d love for you to download <a href="https://visualstudio.microsoft.com/vs/">Visual Studio 2022</a> and give it a try to see how the changes described above affect your applications. Your feedback is key to deliver the best experience. If you have any questions, please feel free to ask us below. You can also send us your comments through <a href="mailto:visualcpp@microsoft.com">e-mail</a>. If you encounter problems with the experience or have suggestions for improvement, please <a href="mailto:https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report A Problem</a> or reach out via <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">Developer Community</a>. You can also find us on Twitter <a href="mailto:https://twitter.com/visualc">@VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/the-fpcontract-flag-and-changes-to-fp-modes-in-vs2022/">The /fp:contract flag and changes to FP modes in VS2022</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/#comments</comments>
		
		<dc:creator><![CDATA[John Morgan (Intel Corporation)]]></dc:creator>
		<pubDate>Mon, 13 Dec 2021 22:48:48 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Compatibility]]></category>
		<category><![CDATA[conformance]]></category>
		<category><![CDATA[Conversion]]></category>
		<category><![CDATA[Floating Point]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29902</guid>

					<description><![CDATA[<p>Microsoft Visual Studio 2022 and Floating-point to Integer Conversions<br />
Quick Summary:</p>
<p>/QIfist is going away<br />
MSVC is compatible with Standard C++ for all floating-point to integer conversions<br />
For floating-point to signed integer conversions nothing changed<br />
VS2022 is compatible with VS2017 and earlier by default for all floating-point to integer conversions<br />
For floating-point to unsigned integer conversions in VS2019:</p>
<p>When targeting x64,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/">Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<h1 id="microsoft-visual-studio-2022-and-floating-point-to-integer-conversions">Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</h1>
<h2 id="quick-summary">Quick Summary:</h2>
<ul>
<li>/QIfist is going away</li>
<li>MSVC is compatible with Standard C++ for all floating-point to integer conversions</li>
<li>For floating-point to signed integer conversions nothing changed</li>
<li>VS2022 is compatible with VS2017 and earlier by default for all floating-point to integer conversions</li>
<li>For floating-point to unsigned integer conversions in VS2019:
<ul>
<li>When targeting x64, it is usually compatible with VS2017</li>
<li><span style="font-size: 1rem;">When targeting x86, it is usually compatible with AVX-512</span></li>
<li>Version 16.7 and later can use /fpcvt:BC for VS2017 compatibility and /fpcvt:IA for AVX-512 compatibility</li>
</ul>
</li>
<li><span style="font-size: 1rem;">Intrinsic functions give you more options and better control</span></li>
</ul>
<p>See also the MSDN documentation on /fpcvt <a href="https://docs.microsoft.com/en-us/cpp/build/reference/fpcvt?view=msvc-170">here</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>As some of you may be aware, Microsoft Visual Studio 2019 changed some floating-point to integer conversions for Intel Architecture (IA). When targeting 32-bit IA (x86), most conversions match the Intel AVX-512 conversion instructions. For signed integers this is the same as Visual Studio 2017. With unsigned integers the results of invalid conversions can be different, as I will explain later. With 64-bit IA (x64), the AVX-512 instructions are used when /arch:AVX512 is selected, but otherwise there was no change from VS2017. Unfortunately, we did not announce this change and we didn’t provide an option for backward compatibility until version 16.7.</p>
<p>By default, Visual Studio 2022 reverts back to the way Visual Studio 2017 handled these conversions. It also keeps the option of using conversions compatible with AVX-512. This post tells you more about this, including other options you might want to use.</p>
<h2 id="background">Background</h2>
<p>Standard C++ specifies how valid conversions work, but invalid conversions can do anything at all. Valid conversions start by truncating the floating-point value, which discards any fractional part and leaves only the integer value. This is also known as &#8220;rounding toward zero&#8221;. The conversion is valid if the truncated value can be represented in the result type, and the result must be that value. MSVC has been compatible with this for well over a decade, and only invalid conversions to unsigned types have changed.</p>
<p>Most floating-point operations indicate an invalid operation by returning a special &#8220;Not-a-Number&#8221; (NaN) value, but conversion to integer doesn&#8217;t allow that option. Any result value can come from a valid conversion, and t<span style="font-size: 1rem;">here is no single “correct” result for an invalid conversion. </span>Of course, completely random results for such conversions aren&#8217;t useful, so two different approaches are commonly used. Intel Architecture (IA) uses the result value farthest from zero as a substitute for NaN, so that any invalid conversion returns this <em>sentinel</em> value. (The specific value returned depends on the result type.) The sentinel value is easy to test for, and it will often cause distinctive behavior during testing and debugging.</p>
<p>The other common approach is called <em>saturation</em>, where any floating-point value too high to fit in the destination type gives the highest possible destination value, and any value too low to fit gives the lowest possible value. If the source value is NaN, zero will be returned for the result. Even if the result is wrong, it is as close as possible to the correct result and may be less likely to cause failures. ARM uses saturation for its conversion instructions.</p>
<h2 id="conversions-with-visual-studio-2017">Conversions with Visual Studio 2017</h2>
<p>Intel Architecture has had instructions to convert from floating-point to signed integer types since before the first IBM PC, but instructions to convert to unsigned integer types were first introduced in AVX-512.  Up through Visual Studio 2017, conversions to unsigned integer types are based on conversion to type <em>long long</em>. Converting to <em>unsigned</em> first converts to <em>long long</em> and then truncates to 32 bits. When converting to <em>unsigned long long</em>, valid source values that are too high for <em>long long</em> are handled as a special case. All other values are simply converted to <em>long long</em> and recast. This gets around the lack of unsigned conversion instructions, but the values returned for invalid conversions aren’t especially useful.</p>
<h2 id="conversions-with-visual-studio-2019">Conversions with Visual Studio 2019</h2>
<p>For VS2019, we intended to make all FP to integer conversions compatible with the corresponding Intel Architecture conversion instructions. That allows using VCVTTSD2USI and VCVTTSS2USI when /arch:AVX512 is selected with no change in behavior. Unfortunately, this change was a bit more difficult than we expected and some cases were not completed. It is only enabled on x64 when /arch:AVX512 is selected. On x86 it was not enabled when /arch:IA32 or /arch:SSE is selected. In addition, on x86 the behavior of a conversion of a floating-point value returned from a function call could be either way. Although this was still compatible with Standard C++, it was obviously undesirable, and we introduced the /fpcvt option to allow developers to select which behavior they want.</p>
<h2 id="the-fpcvt-compilation-option">The /fpcvt Compilation Option</h2>
<p>Starting with Visual Studio 2019 version 16.7, the <em>/fpcvt</em> compilation option controls the results of floating-point to unsigned integer conversions. There are two selections: <em>/fpcvt:BC</em> which specifies the backward compatible VS2017 behavior, and <em>/fpcvt:IA</em> which specifies the new AVX-512 instruction behavior. This option works with either x86 or x64 targets, and it applies whether or not <em>/arch:AVX512</em> is specified. With VS2022 the default has changed to be the same as <em>/fpcvt:BC</em>, but the <em>/fpcvt:IA</em> selection is still available for both x86 and x64.</p>
<h2 id="intrinsic-functions-for-conversion">Intrinsic Functions for Conversion</h2>
<p>There are three problems that the <em>/fpcvt</em> option does not address:</p>
<ul>
<li>It applies to all compiled conversions, even where that isn’t the best option.</li>
<li>It applies to headers and source code modules that may have been written to expect other behavior.</li>
<li>Neither <em>/fpcvt</em> option generates saturating conversions. Saturation provides compatibility with languages such as Rust and WebAssembly, as well as code compiled to target ARM.</li>
</ul>
<p>Visual Studio 2022 provides intrinsic functions to address these issues. These sentinel and saturating conversion functions are fully defined on IA, so the behavior doesn’t change due to compilation settings or context.</p>
<p>In addition to these functions, there are fast conversion functions which execute as quickly as possible for valid conversions. Unlike the saturating and sentinel conversions, these are not fully defined, and may generate different values or exceptions for invalid conversions depending on target platform, compilation settings and context. They are useful for handling values that have already been range-checked or values that are generated in a manner that can never cause an invalid conversion.</p>
<table style="width: 99.2273%;">
<tbody>
<tr>
<td style="width: 33.2273%;">Fast conversion functions</td>
<td style="width: 33.3863%;">Saturating conversion functions</td>
<td style="width: 136.363%;">Sentinel conversion functions</td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>int </code>
<code><strong>_cvt_ftoi_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>int </code>
<code><strong>_cvt_ftoi_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>int </code>
<code><strong>_cvt_ftoi_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>long long </code>
<code><strong>_cvt_ftoll_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>long long </code>
<code><strong>_cvt_ftoll_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>long long </code>
<code><strong>_cvt_ftoll_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned </code>
<code><strong>_cvt_ftoui_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned </code>
<code><strong>_cvt_ftoui_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned </code>
<code><strong>_cvt_ftoui_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_ftoull_fast</strong> (float a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_ftoull_sat</strong> (float a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_ftoull_sent</strong> (float a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>int </code>
<code><strong>_cvt_dtoi_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>int </code>
<code><strong>_cvt_dtoi_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>int </code>
<code><strong>_cvt_dtoi_sent</strong> (double a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>long long </code>
<code><strong>_cvt_dtoll_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>long long </code>
<code><strong>_cvt_dtoll_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>long long </code>
<code><strong>_cvt_dtoll_sent</strong> (double a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned </code>
<code><strong>_cvt_dtoui_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned </code>
<code><strong>_cvt_dtoui_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned </code>
<code><strong>_cvt_dtoui_sent</strong> (double a);</code></td>
</tr>
<tr>
<td style="width: 33.2273%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_dtoull_fast</strong> (double a);</code></td>
<td style="width: 33.3863%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_dtoull_sat</strong> (double a);</code></td>
<td style="width: 136.363%;" width="208"><code>unsigned long long </code>
<code><strong>_cvt_dtoull_sent</strong> (double a);</code></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2 id="termination-of-qifist-support">Termination of /QIfist Support</h2>
<p>Visual Studio 2022 version 17.0 still supports the deprecated <em>/QIfist</em> option on x86, but we will remove it in an update. This option allowed floating-point to <strong>int</strong> conversions to round according to the current rounding mode (usually <em>round-to-nearest with ties to even</em>) instead of always truncating as specified in Standard C++. This option supports legacy code written on x86 before truncation was adopted as standard. It has never been supported on other target platforms and has been marked <em>deprecated</em> for many releases. Use intrinsic functions to round floating-point values before converting to integer, since this is clearer, faster, and more portable.</p>
<h2 id="closing-notes">Closing Notes</h2>
<p>We’d love for you to download <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2022</a> and see how these options can be used in your applications. Your feedback is key to deliver the best experience. If you have questions, please feel free to ask us below. You can also send us your comments through <a href="mailto:visualcpp@microsoft.com">email</a>. If you encounter problems with the experience or have suggestions for improvement, please <a href="mailto:https://docs.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2019">Report A Problem</a> or reach out via <a href="mailto:https://developercommunity.visualstudio.com/spaces/62/index.html">Developer Community</a>. We are also found on Twitter <a href="mailto:https://twitter.com/visualc">@VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/">Microsoft Visual Studio 2022 and Floating-point to Integer Conversions</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-visual-studio-2022-and-floating-point-to-integer-conversions/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
		<item>
		<title>Embedded Software Development in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 16:29:06 +0000</pubDate>
				<category><![CDATA[embedded]]></category>
		<category><![CDATA[IoT]]></category>
		<category><![CDATA[New Feature]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29828</guid>

					<description><![CDATA[<p>We are happy to announce that we have added new embedded development capabilities to Visual Studio 2022 Preview. Used in conjunction with the new vcpkg artifact capabilities you can quickly bootstrap an embedded development machine and get started.<br />
In this post we will walk you through Visual Studio installation of the embedded workload,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Software Development in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that we have added new embedded development capabilities to <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2022 Preview</a>. Used in conjunction with the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">vcpkg artifact capabilities</a> you can quickly bootstrap an embedded development machine and get started.</p>
<p>In this post we will walk you through Visual Studio installation of the embedded workload, how to acquire embedded tool dependencies with vcpkg, then demonstrate edit, build, deploy, and debugging directly in Visual Studio with new peripheral register and RTOS object views. We will demonstrate all of this with an Azure RTOS ThreadX project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png"><img class="alignnone wp-image-29829 size-full" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png" alt="VS embedded development screenshot" width="1712" height="1122" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded.png 1712w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-300x197.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-1024x671.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-768x503.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/VS-embedded-1536x1007.png 1536w" sizes="(max-width: 1712px) 100vw, 1712px" /></a></p>
<p>Azure RTOS ThreadX is a widely used Real Time Operating System (RTOS) used on billions of microcontrollers (MCUs) in products around the world. We have dedicated pages for Visual Studio usage in the getting started guides for the <a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/VS.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/blob/master/NXP/MIMXRT1060-EVK/VS.md">NXP 1060</a>, and <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L4S5I-IOT01A/VS.md">STMicro STM32L4_L4+</a> boards. The techniques used for interacting with these boards should be applicable to other targets by changing configuration information.</p>
<h4 id="installation">Installation</h4>
<p>To get started install the latest preview release of Visual Studio 2022 and select the Linux and embedded development with C++ workload. The components you need are selected by default.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png"><img class="alignnone size-full wp-image-29830" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png" alt="Installation screen for embedded workload" width="910" height="460" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded.png 910w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded-300x152.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Install-embedded-768x388.png 768w" sizes="(max-width: 910px) 100vw, 910px" /></a></p>
<p>One of the challenges in embedded development is getting the tools necessary installed and configured. It is not uncommon to have different compilers used for different projects, custom debug tools, etc. This is where the new <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts">artifact capabilities in vcpkg</a> can help us. Today we’ll demonstrate using vcpkg from a PowerShell prompt to activate our embedded development environment. In a future release this will be integrated into Visual Studio for a more seamless experience.</p>
<p>From a PowerShell prompt, clone the Azure RTOS getting started repo. This sample will serve as our example project for the remainder of this post.</p>
<pre class="prettyprint">git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>Navigate to the subfolder for the board you are using, here I’m using the Azure IoT DevKit.</p>
<pre class="prettyprint">cd .\getting-started\MXChip\AZ3166\</pre>
<p>If you haven’t already, install vcpkg.</p>
<pre class="prettyprint">iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>In the project folder, there is a file vcpkg_configuration.json. This manifest file was created with vcpkg and has recorded the tools you need to build and debug this project. See <a href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts">the vcpkg artifacts post</a> for details on how to create your own manifest. Running the vcpkg activate command will use this file to determine if I have those tools, install them if I do not, then activate them in my environment for use.</p>
<pre class="prettyprint">vcpkg activate</pre>
<p>So, in three commands we have cloned our embedded project, installed vcpkg, acquired and activated the necessary tools for building the project.</p>
<h4 id="using-visual-studio-for-embedded-development">Using Visual Studio for embedded development</h4>
<p>In the previous section we used vcpkg to acquire the tools for our embedded project. Today vcpkg is not integrated in Visual Studio. So, at present we need to launch Visual Studio from the environment we activated at the command line so those tools are available for its use as well.</p>
<pre class="prettyprint">Start-Process devenv .</pre>
<p>Note that if you have more than one version of Visual Studio installed this may not launch the current preview, in that case you will need to use the full path to your preview installation, for example</p>
<pre class="prettyprint">C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\IDE\devenv</pre>
<p>Now that we have the project open in Visual Studio it is ready to go as any other CMake project. <a href="https://devblogs.microsoft.com/cppblog/cmake-presets-integration-in-visual-studio-and-visual-studio-code/">Visual Studio can run the CMake build using the preconfigured CMakePresets file</a> with the compilers vcpkg acquired.</p>
<p>All the editing power of Visual Studio is now available for use with the embedded project. With this Azure RTOS project we’ll cover code navigation, IntelliSense, build, deploy, debugging. We will also cover new diagnostic capabilities around peripheral registers and RTOS object views.</p>
<h5 id="code-navigation-and-intellisense">Code Navigation and IntelliSense</h5>
<p>Use Ctrl + T to open Go to All and type button, select the button_a_callback function to navigate to it. Note on hover that this function expands to TIM3-&gt;CCR1 which is a peripheral register on the board which we’ll inspect while we are debugging.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png"><img class="alignnone size-full wp-image-29831" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png" alt="IntelliSense function expansion screenshot" width="763" height="471" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd.png 763w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/isense-func-expnd-300x185.png 300w" sizes="(max-width: 763px) 100vw, 763px" /></a></p>
<h5 id="build-deploy-and-debug-on-hardware">Build, Deploy, and Debug on hardware</h5>
<p>Set a breakpoint on RGB_LED_SET_R().</p>
<p>To see how the launch is controlled select view all files in the solution explorer and open <a href="https://docs.microsoft.com/cpp/build/launch-vs-schema-reference-cpp?view=msvc-170">.vs\launch.vs.json</a>. You can see the miDebuggerPath set to use arm-none-eabi-gdb while the debugServerPath is set to invoke openocd with the configuration script in debugServerArgs. The information for describing peripheral registers is provided by the MCU manufacturer in an SVD file that we point to with svdPath. This project is configured to break on entry with the property stopAtConnect.</p>
<p>Now, with your board plugged into the PC (and <a href="https://www.st.com/en/development-tools/stsw-link009.html">ST-LINK drivers</a> installed), set the debug target to Launch and F5 will work using openocd acquired by vcpkg to flash and debug the attached board. Execution stops at the entry function, so here we see the assembly code for that. We can also view the disassembly by going to the menu Debug &gt; Windows &gt; Disassembly.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png"><img class="alignnone size-full wp-image-29832" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png" alt="Assembly source and disassembly screenshot" width="936" height="164" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly-300x53.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/assembly-disassembly-768x135.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>Press continue to let execution continue.</p>
<h5 id="peripheral-registers">Peripheral Registers</h5>
<p>Now press the A button on the board. This has triggered our breakpoint. We can now go to the menu Debug &gt; Windows &gt; Embedded Registers. This opens the peripheral register view using the information from our SVD file specified in the launch configuration. We can now scroll through this list to find the register we are interested in, here TIM3-&gt;CCR1 which will update when we step over the RGB_LED_SET_R function.</p>
<p>On break</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png"><img class="alignnone size-full wp-image-29833" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png" alt="Register on break screenshot" width="936" height="349" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak-300x112.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-onbreak-768x286.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>After stepping</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png"><img class="alignnone size-full wp-image-29834" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png" alt="Register after stepping" width="936" height="395" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep-300x127.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/register-afterstep-768x324.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<h5 id="rtos-object-views">RTOS Object Views</h5>
<p>The application in the getting started project has several threads, but you won’t see them with the existing threads window.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png"><img class="alignnone size-full wp-image-29839" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png" alt="Threads window screenshot" width="1348" height="223" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window.png 1348w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-300x50.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-1024x169.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/threads-window-768x127.png 768w" sizes="(max-width: 1348px) 100vw, 1348px" /></a></p>
<p>Why not? A good explanation can be found in this <a href="https://azure.microsoft.com/resources/real-time-operating-system">white paper on Real Time Operating Systems</a>.</p>
<p>&#8220;A Real-Time Operating System is system software that provides services and manages processor resources for applications. These resources include processor cycles, memory, peripherals, and interrupts. The main purpose of a Real-Time Operating System is to allocate processing time among various duties the embedded software must perform. This typically involves a division of the software into pieces, commonly called “tasks” or “threads,” and creating a run-time environment that provides each thread with its own virtual microprocessor (“Multithreading”). Basically, a virtual microprocessor consists of a virtual set of microprocessor resources, e.g., register set, program counter, stack memory area, and a stack pointer. Only while executing does a thread use the physical microprocessor resources, but each thread retains its own copy of the contents of these resources as if they were its own private resources (the thread”s “context”).&#8221;</p>
<p>So for embedded development ideally you would have views that could show you information about these RTOS objects. To see the new available RTOS objects views, go to the menu Debug &gt; Windows &gt; RTOS Objects. Here you will see options for the objects that ThreadX provides, here we’ll select Threads.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png"><img class="alignnone size-full wp-image-29840" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png" alt="Debug RTOS menu options" width="325" height="297" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu.png 325w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/Debug-RTOS-menu-300x274.png 300w" sizes="(max-width: 325px) 100vw, 325px" /></a></p>
<p>The threads view shows at a glance much of the information you would commonly need during embedded development, thread ids and names, how many times they have run, where the stack starts, ends, and its size as well as the maximum stack usage.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png"><img class="alignnone size-full wp-image-29842" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png" alt="RTOS threads window" width="1440" height="177" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1.png 1440w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-300x37.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-1024x126.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/RTOS-threads-window-1-768x94.png 768w" sizes="(max-width: 1440px) 100vw, 1440px" /></a></p>
<p>There are other views for additional ThreadX objects like block and byte pools, events, mutexes, queues, and timers. We also have RTOS object views for FreeRTOS though the available objects there differ based on what it supports.</p>
<h5 id="hardware-breakpoint-limits">Hardware breakpoint limits</h5>
<p>One last debugging capability to call out is that embedded hardware targets commonly have a limited set of hardware breakpoints available. Setting too many can corrupt the debugger state. As such we have added hardwareBreakpoints to launch.vs.json. For this board that is set to what it supports which is 6. If we set more than that we will see the breakpoint is not set and we get a warning that it won’t be hit. This prevents corrupting the connection to the board and allows us the opportunity to unset some other breakpoints and continue debugging uninterrupted.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png"><img class="alignnone size-full wp-image-29843" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png" alt="hardware breakpoint exceeded warning" width="667" height="124" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning.png 667w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/hardware-breakpoint-exceeded-warning-300x56.png 300w" sizes="(max-width: 667px) 100vw, 667px" /></a></p>
<h4 id="send-us-your-feedback">Send us your feedback</h4>
<p>We hope that these new capabilities will enable you to choose Visual Studio for your embedded development needs and make you more productive. We are very interested in your feedback to continue to improve this experience. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>If you are on Linux or Mac and looking for similar capabilities, yes, we will be bringing embedded development capabilities to VS Code soon as well. We have provided VS Code getting started guides for Azure RTOS the same boards as VS (<a href="https://github.com/azure-rtos/getting-started/blob/master/MXChip/AZ3166/vscode.md">Azure IoT DevKit</a>, <a href="https://github.com/azure-rtos/getting-started/tree/master/NXP/MIMXRT1060-EVK">NXP 1060</a>, and <a href="https://github.com/azure-rtos/getting-started/blob/master/STMicroelectronics/B-L475E-IOT01A/VS.md">STMicro STM32L4_L4+</a>), though today the capabilities are limited to acquisition with vcpkg, edit, build, deploy, and debug. Similar embedded specific views will be coming in a future extension.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Software Development in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/feed/</wfw:commentRss>
			<slash:comments>15</slash:comments>
		
		
			</item>
		<item>
		<title>Bootstrap your dev environment with vcpkg artifacts</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/#comments</comments>
		
		<dc:creator><![CDATA[Marc Goodner]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 16:27:55 +0000</pubDate>
				<category><![CDATA[New Feature]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29826</guid>

					<description><![CDATA[<p>We are happy to announce a new experience for acquiring artifacts using vcpkg. We define an artifact as a set of packages required for a working development environment. Examples of relevant packages include compilers, linkers, debuggers, build systems, and platform SDKs.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">Bootstrap your dev environment with vcpkg artifacts</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce a new experience for acquiring artifacts using vcpkg. We define an artifact as a set of packages required for a working development environment. Examples of relevant packages include compilers, linkers, debuggers, build systems, and platform SDKs. With this important change, vcpkg can not only download and build your libraries from source, it can also bootstrap the rest of your environment, acquiring pre-built binary dependencies for your projects.</p>
<p>The experience is in preview and currently focused on embedded developers. We will expand the scope in the future to include any developers targeting Linux, macOS, or Windows.</p>
<p>This post focuses on using vcpkg artifacts at the command line. Check out the <a href="https://devblogs.microsoft.com/cppblog/visual-studio-embedded-development/">Embedded Development in Visual Studio blogpost</a> for how the capabilities are used there.</p>
<p>Here we are going to show how to acquire vcpkg, then activate artifacts for building an embedded project. Following that we’ll cover specific vcpkg capabilities for finding and using artifacts, then how to create a manifest and add artifacts to it. We will also cover how you can use artifacts of your own that are not part of the default artifact registry.</p>
<h4 id="using-vcpkg-artifacts">Using vcpkg artifacts</h4>
<p>We’ll look at some embedded development scenarios to understand the new artifact capabilities in vcpkg. Embedded development is particularly known for being difficult to get a new developer machine started. Projects often have specific compiler requirements, special debug tools needed, etc. What we will show here is how through using vcpkg with a manifest you can capture these requirements and easily restore an environment for an embedded project. You do not need a device to follow along as we will not show any device interactivity. These steps except where noted are consistent cross platform.</p>
<h5 id="acquire-vcpkg">Acquire vcpkg</h5>
<p>We have also added a new way to acquire vcpkg in a single step without a git clone of the repo. Depending on your platform use one of the following commands to get vcpkg.</p>
<p>Linux/macOS</p>
<pre>. &lt;(curl https://aka.ms/vcpkg-init.sh -L)</pre>
<p>PowerShell</p>
<pre class="prettyprint">iex (iwr -useb https://aka.ms/vcpkg-init.ps1)</pre>
<p>CMD Shell</p>
<pre class="prettyprint">curl -LO https://aka.ms/vcpkg-init.cmd &amp;&amp; .\vcpkg-init.cmd</pre>
<h5 id="clone-the-example-project">Clone the example project</h5>
<p>The example project is the Azure RTOS getting started repo, so start by cloning that with this command.</p>
<pre class="prettyprint">git clone --recursive https://github.com/azure-rtos/getting-started.git</pre>
<p>This repo has many projects within is, each for a specific board. Use the Azure IoT DevKit by switching to that directory.</p>
<pre class="prettyprint">cd .\getting-started\MXChip\AZ3166\</pre>
<h5 id="vcpkg-activate">vcpkg activate</h5>
<p>In the project folder, there is a file vcpkg-configuration.json. This manifest file has recorded the tools you need to build and debug this project. Running the vcpkg activate command will use this file to determine if those tools have been acquired before, acquire them not, then activate them in your environment for use.</p>
<pre class="prettyprint">vcpkg activate</pre>
<p>This is a new vcpkg command that works with artifacts. As this is the first time you are using vcpkg for artifacts it acquires the new vcpkg-ce component on demand. The ce in this component name stands for configure environment. This name was chosen as vcpkg will modify your current environment to use the artifacts in the manifest with your C++ projects.</p>
<p>To demonstrate that build the project. To do so generate the CMake configuration, then build the project using the preset provided by CMakePresets.json in the project with the following two commands.</p>
<pre class="prettyprint">cmake --preset arm-gcc-cortex-m4
cmake --build --preset arm-gcc-cortex-m4</pre>
<p>So, in just a few commands you have installed vcpkg, cloned an embedded project, acquired and activated the necessary tools for building the project, and successfully compiled it.</p>
<h5 id="finding-artifacts">Finding artifacts</h5>
<p>There is a vcpkg search command already that finds ports of libraries in the vcpkg registry. We needed a way to distinguish between the existing vcpkg port concept and the new artifacts concept in areas where the commands could mean either. As such we have introduced a new find command that can be used as find port name, or find artifact name. The existing search command is still present with its existing behavior that only returns ports.</p>
<p>Try finding an artifact, like CMake, with the following command.</p>
<pre class="prettyprint">vcpkg find artifact cmake</pre>
<p>This will output anything that matches the short name used, currently the below.</p>
<pre class="prettyprint">vcpkg-ce ('configure environment') is experimental and may change at any time.
 Artifact                       Version  Summary
 microsoft:tools/kitware/cmake  3.20.1   Kitware's cmake tool
</pre>
<h5 id="using-artifacts">Using artifacts</h5>
<p>Now that you have found an artifact you want to use, you can with the vcpkg use command. Try this command to use CMake.</p>
<pre class="prettyprint">vcpkg use cmake 
vcpkg-ce ('configure environment') is experimental and may change at any time.
 Artifact                           Version    Status     Dependency  Summary

 microsoft:tools/kitware/cmake      3.20.1     installed              Kitware's cmake tool

Activating individual artifacts
</pre>
<p>Yes, you can activate more than one artifact at a time. The following command activates gcc, cmake, and ninja, a complete C++ build system in one command. Note this is the Arm GCC compiler as that is the only one presently in the registry.</p>
<pre class="prettyprint">vcpkg use gcc cmake ninja</pre>
<h5 id="creating-your-own-manifest">Creating your own manifest</h5>
<p>The manifest, vcpkg-configuration.json, in the example above was also created with vcpkg. To create a manifest with tools needed for your own use vcpkg new. Make sure to run the subsequent commands in a new directory that is not a subfolder of an existing project.</p>
<pre class="prettyprint">vcpkg new</pre>
<h5 id="adding-artifacts-to-your-manifest">Adding artifacts to your manifest</h5>
<p>Now that we have a manifest and found artifacts we want to use with our project it is simple to add them. Note that the add command requires us to specify an artifact as it can also be used to add ports to a manifest.</p>
<pre class="prettyprint">vcpkg add artifact cmake

vcpkg-ce ('configure environment') is experimental and may change at any time.

 Artifact                       Version  Status     Dependency  Summary

 microsoft:tools/kitware/cmake  3.20.1   installed  *           Kitware's cmake tool

Project c:\source\newprj activated</pre>
<p>Now you can check in vcpkg-configuration.json with your source. Anyone else who uses your project can install vcpkg with a single command, then activate the artifacts in your manifest and reproduce the same results locally.</p>
<h4 id="subsequent-use-of-vcpkg">Subsequent use of vcpkg</h4>
<p>In the above examples vcpkg was available on the command line after installation. There is a quick way to get it back in new instances of your favorite terminal.</p>
<p>Linux/macOS</p>
<pre class="prettyprint">. ~/.vcpkg/vcpkg-init.sh</pre>
<p>PowerShell</p>
<pre class="prettyprint">. ~/.vcpkg/vcpkg-init.ps1</pre>
<p>CMD Shell</p>
<pre class="prettyprint">%USERPROFILE%\.vcpkg\vcpkg-init.cmd</pre>
<h4 id="removing-vcpkg">Removing vcpkg</h4>
<p>That was fun, how do you remove vcpkg installed from your system using the instructions above? Simply delete the .vcpkg folder in your home directory. No other changes have been made to your system through installing or using it.</p>
<h4 id="using-your-own-registry">Using your own registry</h4>
<p>The current artifacts in the default registry are limited to the embedded scenarios we have been developing the tool around which focus on Azure RTOS. In the future this set will expand to desktop development scenarios. The default registry can be found here: <a href="https://github.com/microsoft/vcpkg-ce-catalog">https://github.com/microsoft/vcpkg-ce-catalog</a>. Note that we are not taking pull requests of artifact additions to the default registries at this time.</p>
<p>We fully expect people to have their own artifacts they would like to use, or to provide for others to use.</p>
<p>As an example, what if you want to use a newer Arm compiler? Our example uses the one set by the example Azure RTOS project so that is the only one we put into the registry. In the steps below I will show how I added a new Arm compiler to my own registry. You can follow the same steps, modified for the artifact you need, to create your own registry of artifacts for use with vcpkg.</p>
<p>To create a new Arm gcc artifact metadata file I looked at the existing artifact metadata for the gcc compiler in the vcpkg-ce-catalog repo, <a href="https://github.com/microsoft/vcpkg-ce-catalog/blob/main/compilers/arm/gcc/gcc-2020.10.0.yaml">compilers/arm/gcc/ gcc-2020.10.0.yaml</a>.</p>
<p>On my local machine I copied that file into a folder, myregistry, under the same path for consistency. I then went to Arm’s website to find the latest compilers they provide. I then renamed the metadata file to match, gcc-2021.10.0.yaml. I updated the fields in the file for the version, the artifact urls under install &gt; unzip, and added the sha256 information. Note that Arm only provides md5 sums for their artifacts, this meant I had to download the artifacts manually first to generate my own sha256 sums to use. You can find this file in my personal GitHub repository here, <a href="https://github.com/robotdad/myregistry/blob/main/compilers/arm/gcc/gcc-2021.10.0.yaml">gcc-2021.10.0.yaml</a>.</p>
<p>Now, to test this I created a test folder and created a manifest with vcpkg new. I then opened this manifest and added a registry section pointing to my local folder with the artifact metadata.</p>
<pre class="prettyprint">{
    "registries": [
      {
        "name": "myregistry",
        "location": "c:/source/myregistry",
        "kind": "artifact"
      }
    ]
}</pre>
<p>Note that I specified the full path, alias like ~ are not supported.  Now, to find this entry I specified the name as part of the search query.</p>
<pre class="prettyprint">vcpkg find artifact myregistry:gcc

vcpkg-ce ('configure environment') is experimental and may change at any time.
Artifact                 Version    Summary
myregistry:compilers/arm/gcc  2021.10.0  GCC compiler for ARM CPUs.</pre>
<p>Once verified I added it to the manifest in the same way.</p>
<pre class="prettyprint">vcpkg add artifact local:gcc

vcpkg-ce ('configure environment') is experimental and may change at any time.
Artifact                      Version    Status     Dependency Summary
myregistry:compilers/arm/gcc  2021.10.0  installed  *          GCC compiler for ARM CPUs.

Project c:\source\test activated
</pre>
<p>Now my manifest looks like this:</p>
<pre class="prettyprint">{
  "registries": [
    {
      "name": "myregistry",
      "location": "c:/source/myregistry",
      "kind": "artifact"
    }
  ],
  "requires": {
    "myregistry:compilers/arm/gcc": "* 2021.10.0"
  }
}</pre>
<p>I wouldn’t want to share a manifest with others where a local path was used for a registry. Network paths are supported which works if I am only sharing internally. Note I had to escape the path in the location field.</p>
<pre class="prettyprint">"location": "\\\\myshare\\folder\\myregistry",</pre>
<p>I wanted to share my registry on GitHub to support this post which requires a couple of extra steps. The first extra step is to generate an index file. To do so I ran the following experimental command (this is likely to change in the future).</p>
<pre class="prettyprint">vcpkg z-ce regenerate c:/source/myregistry</pre>
<p>This generated an index.yaml for all of the artifact metadata files in the specified location.</p>
<p>To use a registry published in a GitHub repo I needed to specify the endpoint that provides an archive of the repository. This allows vcpkg to acquire all the artifact metadata in a single request. For a GitHub repo this is available at the path /archive/refs/heads/main.zip under the repository. For this example, I published my registry in my personal GitHub account here, <a href="https://github.com/robotdad/myregistry">https://github.com/robotdad/myregistry</a>, the location for that is specified as below in the manifest.</p>
<pre class="prettyprint">"location": "https://github.com/robotdad/myregistry/archive/refs/heads/main.zip",</pre>
<h4 id="give-us-your-feedback">Give us your feedback!</h4>
<p>We are very interested in hearing your thoughts on the new artifact capabilities in vcpkg. We have a separate repo for the component that provides those, <a href="https://github.com/microsoft/vcpkg-ce">vcpkg-ce</a>, where you can file any issues you encounter. The comments below are open, or you can find us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. As capabilities around artifacts in vcpkg evolve, your thoughts are critical to us for creating an excellent developer experience.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/">Bootstrap your dev environment with vcpkg artifacts</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-artifacts/feed/</wfw:commentRss>
			<slash:comments>14</slash:comments>
		
		
			</item>
		<item>
		<title>Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</title>
		<link>https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/</link>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Mon, 06 Dec 2021 15:20:01 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[C++ extension]]></category>
		<category><![CDATA[compilation database]]></category>
		<category><![CDATA[compile commands]]></category>
		<category><![CDATA[compile_commands.json]]></category>
		<category><![CDATA[CPP]]></category>
		<category><![CDATA[make]]></category>
		<category><![CDATA[makefile]]></category>
		<category><![CDATA[makefile tools]]></category>
		<category><![CDATA[problem matcher]]></category>
		<category><![CDATA[vs code]]></category>
		<category><![CDATA[VSCode]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=29854</guid>

					<description><![CDATA[<p>The December 2021 update of the Makefile Tools extension for Visual Studio Code is here, bringing you support for problem matchers (to easily view errors and warnings in the editor), the ability to generate a compile_commands.json file for your project, and a bunch of other enhancements and bug fixes!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/">Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The December 2021 update of <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">the Makefile Tools extension for Visual Studio Code</a> is here, bringing you <a href="https://github.com/microsoft/vscode-makefile-tools/issues/7">support for problem matchers</a> (to easily view errors and warnings in the editor), the ability to <a href="https://github.com/microsoft/vscode-makefile-tools/issues/104">generate a compile_commands.json file</a> for your project, and a bunch of other enhancements and bug fixes! To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-makefile-tools/releases/tag/v0.3.0">release notes on GitHub.</a></p>
<h1 id="problem-matchers">Problem matchers</h1>
<p>If you’ve used the C++ extension for VS Code, you’re probably familiar with the <strong>Problems</strong> panel, where you can navigate through a list of compiler errors and warnings found in your project. VS Code uses a <a href="https://code.visualstudio.com/Docs/editor/tasks#_processing-task-output-with-problem-matchers">problem matcher</a> to display the errors and warnings in the Problems panel.</p>
<p>For example, if you’re missing a semi-colon in your source file, you’ll see the compiler error in the <strong>Problems</strong> panel. Selecting the problem brings you to the line of code generating the error or warning. To fix the problem, click on the lightbulb and choose from a list of Quick Actions.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png"><img class="alignnone size-full wp-image-29856" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png" alt="A screenshot of the Problems Pane in VS Code, showing errors and warnings found by GCC and make in the project" width="3036" height="2054" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2.png 3036w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-300x203.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-1024x693.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-768x520.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-1536x1039.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-problem-selected-2-2048x1386.png 2048w" sizes="(max-width: 3036px) 100vw, 3036px" /></a></p>
<p>Now, let’s say you don’t have any compiler errors, but make displays a bunch of warnings when you build your project. Until now, there wasn’t a way to see those warnings in the Problems panel. With this latest release of the Makefile Tools extension, you’ll see all of make’s errors and warnings in the Problems panel after you build your program.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png"><img class="alignnone size-full wp-image-29857" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png" alt="A screenshot showing make's warnings in the Problems Pane in VS Code after building a project with Makefile Tools." width="3036" height="2062" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings.png 3036w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-300x204.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-1024x695.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-768x522.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-1536x1043.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-warnings-2048x1391.png 2048w" sizes="(max-width: 3036px) 100vw, 3036px" /></a></p>
<p>To enable make errors and warnings in the Problems panel, add <strong>&#8220;problemMatchers&#8221;: [&#8220;$gcc&#8221;]</strong> to your makefile configuration in settings.json, like this:</p>
<pre class="prettyprint">"makefile.configurations": [

        {

            "name": "MyConfiguration",

            "problemMatchers": [

                "$gcc"

            ],

            "makeArgs": ["any", "other", "args", "you", "want"]

        },

]</pre>
<p>If you’re on Windows using MSVC, set the problemMatcher to <strong>&#8220;$msCompile&#8221;</strong> instead of <strong>&#8220;$gcc&#8221;</strong>. Contributions from the community to support additional problem matchers are welcome! Problem matchers are defined in the extension’s <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/package.json#L198">package.json</a> file.</p>
<h1 id="generate-compile_commands-json">Generate compile_commands.json</h1>
<p>As a C++ developer, you might find yourself wanting a compilation database, which is a file that stores compilation instructions for the source files in your project. Compilation databases are used by many <a href="https://clang.llvm.org/docs/ClangTools.html">Clang tools</a> and editors/IDEs. A common compilation database format is compile_commands.json, which contains command objects, one for each translation unit in the project. Each command object specifies the translation unit’s main file, the compile command, and the working directory where the compile command is run.</p>
<p>With this latest release of the Makefile Tools extension, you can generate a compile_commands.json file for your project. All you have to do is specify the path to the target compile_commands.json file in settings.json, like this:</p>
<pre class="prettyprint">"makefile.compileCommandsPath": ".vscode/compile_commands.json"</pre>
<p>Then configure your project to generate compile_commands.json at the specified location.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png"><img class="alignnone size-full wp-image-29855" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png" alt="A screenshot of the contents of a compile_commands.json file generated by the Makefile Tools extension" width="3088" height="1888" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands.png 3088w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-300x183.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-1024x626.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-768x470.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-1536x939.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/12/makefile-tools-compile-commands-2048x1252.png 2048w" sizes="(max-width: 3088px) 100vw, 3088px" /></a></p>
<p>Thank you <a href="https://github.com/rapgenic">rapgenic</a> for the request and for contributing to this feature!</p>
<h1 id="give-it-a-try">Give it a try</h1>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Download the Makefile Tools extension for Visual Studio Code</a> today, give it a try, and let us know what you think. Check out <a href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/">this blog post</a> to learn how to get started with Makefile Tools.</p>
<p>If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-makefile-tools/issues">Issues section of our GitHub repository</a>. Be sure to check out the <a href="https://github.com/microsoft/vscode-makefile-tools/tree/main/docs">Makefile Tools documentation</a> for troubleshooting tips and a list of tested repositories and their configuration instructions.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:makefiletools@microsoft.com">makefiletools@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/makefile-tools-december-2021-update-problem-matchers-and-compilation-database-generation/">Makefile Tools December 2021 Update: Problem Matchers and Compilation Database Generation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
