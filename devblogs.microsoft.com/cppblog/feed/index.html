<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Wed, 16 Nov 2022 01:29:51 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>vcpkg 2022.11.14 and 2022.10.19 Releases: Localization for 14 Languages, Overlay Ports/Triplets in Manifests, acquire-project Command, and More…</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 16 Nov 2022 01:29:51 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31329</guid>

					<description><![CDATA[<p>The 2022.11.14 release of the vcpkg package manager is available. This blog post summarizes changes from September 27th, 2022 to November 13th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
Some stats for this period:</p>
<p>47 new ports were added to the open-source registry.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/">vcpkg 2022.11.14 and 2022.10.19 Releases: Localization for 14 Languages, Overlay Ports/Triplets in Manifests, acquire-project Command, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.11.14">2022.11.14 release of the vcpkg package manager is available</a>. This blog post summarizes changes from September 27<sup>th</sup>, 2022 to November 13<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>47 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>519 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>2,069 total libraries</strong> available in the vcpkg public registry. There are a total of <strong>10,964</strong> ports if each library version is counted uniquely.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.11.14">2022.11.14 release of the main vcpkg repo</a> includes <strong>65 commits</strong>.</li>
<li><strong>68 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has over <strong>4,900 forks</strong> and <strong>17,100 stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<p>Notable changes for this release are summarized below:</p>
<p>&nbsp;</p>
<h4 id="localized-vcpkg-output-is-now-available">Localized vcpkg output is now available</h4>
<p>One of the steps required for us to ship vcpkg in Visual Studio was to localize its output to a variety of languages. This experience is now enabled in the tool for 14 languages – the same languages available for Visual Studio. You can change the language of vcpkg’s output (even if you’re not using Visual Studio) by setting an environment variable called VSLANG to a 4-digit LCID (locale identifier) code. For example, setting this variable to 1033 sets the language to English. For more details, including a list of available LCIDs, <a href="https://github.com/microsoft/vcpkg-tool/blob/main/docs/localization.md">see our documentation</a> on this.</p>
<p>&nbsp;</p>
<h4 id="configuring-overlay-ports-and-triplets-in-a-manifest-file">Configuring overlay ports and triplets in a manifest file</h4>
<p><strong>Overlay ports</strong> is a feature of vcpkg that allows the user to override the default port vcpkg would have installed with a custom one. This can be useful when the user needs to patch a library and deviate from the default experience. Note: this is very different from installing a different version of a library, which does not require creating a custom port.</p>
<p><strong>Overlay triplets</strong> work similarly by overriding default vcpkg triplets with customized ones. A use case for this can be if you require additional compile flags for your build over what vcpkg would run by default.</p>
<p>Historically, it was only possible to set overlay ports and triplets on the command line, via environment variables, or through the build system. Now, it is possible to configure these in a vcpkg-configuration.json file by enabling an optional object to the schema which receives a path or list of paths. This provides a better experience when a user wants to provide multiple additional paths for one install. Ports are resolved from top to bottom. Here is an example:</p>
<pre class="prettyprint">{
    "default-registry": {
    "kind": "git",
    "repository": "&lt;https://internal/mirror/of/github.com/Microsoft/vcpkg&gt;",
    "baseline": "eefee7408133f3a0fef711ef9c6a3677b7e06fd7"
    },
    "registries": [{
        "kind": "git",
        "repository": "&lt;https://github.com/my-repository/vcpkg-registry&gt;",
        "baseline": "xxxxxxx000000000000000000000000000000000",
        "packages": [ "my", "packages" ]
    }],
    "overlay-ports": [
    "./my-ports/fmt",
    "custom-ports",
    "../share/team-ports"
    ],
    "overlay-triplets" : [ "./my-triplets" ]
}</pre>
<p><strong>Note:</strong> if overlay ports are configured in multiple ways, we prioritize them in the following order:</p>
<ol>
<li>Command line</li>
<li>Manifest (vcpkg-configuration.json)</li>
<li>Environment variables</li>
</ol>
<p>In other words, a port configured in the command line will always override the same port being configured in a manifest or an environment variable, and ports configured in the manifest override the same ports being configured as environment variables.</p>
<p>See our <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">article on registries</a> for additional documentation on this feature.</p>
<p>&nbsp;</p>
<h4 id="new-artifact-command-acquire-project">New artifact command: acquire-project</h4>
<p>A new command for managing vcpkg artifacts has been added: acquire-project. Like the activate command, it affects all artifact dependencies listed in the manifest, but it only downloads and extracts them without activating them in the environment. Functionally like running vcpkg acquire once for each dependency.</p>
<p>&nbsp;</p>
<h4 id="console-output-less-verbose-in-manifest-mode">Console output less verbose in manifest mode</h4>
<p>The option &#8211;no-print-usage now supports manifest mode (by @demianmnave-pti in <a href="https://github.com/microsoft/vcpkg-tool/pull/721">Microsoft/vcpkg-tool#721</a>). This switch suppresses the printing of usage text at the end of a port installation.</p>
<p>&nbsp;</p>
<h4 id="get-current-port-version-in-portfile-cmake">Get current port version in portfile.cmake</h4>
<p>It is now possible to reference a port’s current version when authoring ports in their portfile.cmake using a variable called VERSION. Implemented by @autoantwort.</p>
<p>&nbsp;</p>
<h4 id="ignore-the-vcpkg_root-environment-variable-when-we-already-detected-a-vcpkg-root">Ignore the VCPKG_ROOT environment variable when we already detected a vcpkg root</h4>
<p>The VCPKG_ROOT environment variable can be used to point to the location of a vcpkg instance. This is useful for example in pre-configured CI systems so the user can run vcpkg commands without having to go looking for vcpkg first. However, this can be problematic if the user is consuming vcpkg as a git submodule and doesn’t want to use the default machine-wide instance. Now, if a vcpkg root directory is detected, we will no longer override it with the VCPKG_ROOT environment variable. vcpkg will output a warning when the environment variable is ignored.</p>
<p>&nbsp;</p>
<h4 id="documentation-changes">Documentation Changes</h4>
<p>We are continuing to improve our vcpkg documentation:</p>
<ol>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/list.md">Added reference documentation for vcpkg list command</a>.</li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/commands/version.md">Added reference documentation for vcpkg version command</a>.</li>
<li>Added reference documentation for three topics:
<ol>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/manifests.md">Embedding vcpkg-configuration.json contents in vcpkg.json</a></li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">Overlay ports in vcpkg-configuration.json</a></li>
<li><a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/registries.md">Overlay triplets in vcpkg-configuration.json</a></li>
</ol>
</li>
</ol>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,860</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,924</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,826</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,839</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>971</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,497</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>924</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,791</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,867</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank You to Our Contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>autoantwort (54 commits)</li>
<li>dg0yt (35 commits)</li>
<li>Neumann-A (17 commits)</li>
<li>AtariDreams (10 commits)</li>
<li>Honeybunch (9 commits)</li>
<li>Thomas1664 (9 commits)</li>
<li>SchaichAlonso (8 commits)</li>
<li>Tradias (7 commits)</li>
<li>RT222 (6 commits)</li>
<li>Osyotr (3 commits)</li>
<li>m-kuhn (4 commits)</li>
<li>chausner (4 commits)</li>
<li>luncliff (4 commits)</li>
<li>gjasny (3 commits)</li>
<li>past-due (3 commit)</li>
<li>AenBleidd (3 commits)</li>
<li>coryan (2 commit)</li>
<li>wrobelda (1 commit)</li>
<li>daschuer (1 commit)</li>
<li>longnguyen2004 (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>klalumiere (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.11.14">full 2022.11.14 release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue tracker</a>, or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<h3 id="interested-in-vcpkg-but-not-sure-where-to-start">Interested in vcpkg but not sure where to start?</h3>
<p>Is your company experiencing challenges managing C/C++ libraries? Perhaps you’re curious if a package manager is the right choice to you? Please reach out to <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a> and we’d be happy to help!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/">vcpkg 2022.11.14 and 2022.10.19 Releases: Localization for 14 Languages, Overlay Ports/Triplets in Manifests, acquire-project Command, and More…</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-2022-11-14-and-2022-10-19-releases-localization-for-14-languages-overlay-ports-triplets-in-manifests-acquire-project-command-and-more/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio 2022 Performance: Faster C++ Source Code Indexing</title>
		<link>https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/</link>
					<comments>https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/#respond</comments>
		
		<dc:creator><![CDATA[Victor Ciura]]></dc:creator>
		<pubDate>Tue, 15 Nov 2022 16:00:21 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[performance]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31318</guid>

					<description><![CDATA[<p>Building on top of our performance wins in Visual Studio 2022 version 17.3, we are excited to announce additional improvements in version 17.4.<br />
Whether you are a game developer, work with large codebases, or have solutions with many C++ projects, your development experience in Visual Studio 2022 17.4 will feel even faster.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/">Visual Studio 2022 Performance: Faster C++ Source Code Indexing</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Building on top of <a id="post-31318-_Int_H4uFQVnC"></a>our <a href="https://devblogs.microsoft.com/cppblog/vs2022-performance-enhancements-faster-c-development/">performance wins</a> in Visual Studio 2022 version 17.3, we are excited to announce additional improvements in version 17.4.</p>
<p>Whether you are a game developer, work with large codebases, or have solutions with many C++ projects, your development experience in Visual Studio 2022 17.4 will feel <em>even faster</em>.</p>
<p>In 17.4 we significantly reduced the time it takes to open a C++ project for the first time (cold load).</p>
<p>While working on these improvements, we constantly check our performance against real-life large projects, including some of our own, as well as several C++ codebases for popular games from our partner game studios.</p>
<p>Large C++ projects could see a 20-36% speed improvement over 17.3 when populating the source code database used for browsing and navigation.</p>
<p>When compared to VS 2019, the cumulative performance gains for this scenario should be between 2X-6X depending on the project structure and size.</p>
<p>In this post, we want to highlight the C++ project indexing scenario for the <a href="https://en.wikipedia.org/wiki/Gears_of_War">Gears of War</a> source code and a generic Unreal Engine 5 starter project.</p>
<h2 id="testing-methodology">Testing Methodology</h2>
<p>Hardware: AMD Ryzen PRO 3945WX 12/24, 128GB RAM, 2.5TB SSD, RTX 3080</p>
<p>Projects/source code: Gears of War, Unreal Engine 5 starter project, Chromium</p>
<p>Visual Studio: VS2019 v16.11 and VS2022 v17.4</p>
<p>For all scenarios, we used VS system events/logs to track the duration of the operations.</p>
<h3 id="results">Results</h3>
<p>Let’s see the cumulative effect of all the improvements we made in this area for C++ projects, for the past year.</p>
<p><img width="1431" height="1080" class="wp-image-31319" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1.png" alt="Chart, bar chart Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1.png 1431w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1-300x226.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1-1024x773.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/chart-bar-chart-description-automatically-genera-1-768x580.png 768w" sizes="(max-width: 1431px) 100vw, 1431px" /></p>
<p>In Visual Studio 2019 16.11, it takes roughly <a id="post-31318-OLE_LINK1"></a>6½ minutes for Gears of War to fully index. In Visual Studio 2022 17.4, waiting for indexing to finish will only take a bit over <a id="post-31318-OLE_LINK2"></a>2½ minutes, resulting in a <strong>2.5X</strong> speed up.</p>
<p><img width="1431" height="1080" class="wp-image-31320" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2.png 1431w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2-300x226.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2-1024x773.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-2-768x580.png 768w" sizes="(max-width: 1431px) 100vw, 1431px" /></p>
<p>When getting to code in a new Unreal Engine 5 solution, you will see a huge improvement in the latest version of VS2022 versus VS2019. In VS2019 16.11, fully indexing a brand-new C++ UE5 solution took a bit over 2½ minutes. When using VS2022 17.4, fully indexing the same UE5 solution is now <strong>2.7X</strong> faster at just 1 minute. Whether you are creating a new UE5 project or cloning from an existing repo, your code will index much faster in 17.4.</p>
<h3 id="pushing-the-limits">Pushing the limits</h3>
<p>Few open-source projects reach the scale of <a href="https://chromium.googlesource.com/chromium/src.git">Chromium</a> with over 12,000 projects in one single Visual Studio solution, so naturally it’s an irresistible target for stress testing the components we’re improving. Let’s see how we did.</p>
<p><img width="1431" height="1080" class="wp-image-31321" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3.png 1431w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3-300x226.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3-1024x773.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31318-3-768x580.png 768w" sizes="(max-width: 1431px) 100vw, 1431px" /></p>
<p>In Visual Studio 2019 16.11, it takes roughly 31 minutes for the Chromium repo to fully index. In Visual Studio 2022 17.4, waiting for indexing to finish will only take just 5 minutes, a <strong>6X</strong> speed up. When indexing a large solution like the Chromium repo for the first time, you will save up to 26 minutes with the latest version of Visual Studio.</p>
<h3 id="try-it-out">Try it out</h3>
<p>Although everyone should see considerable improvements for these scenarios, the magnitude of the gains is dependent on your source code, project layout, include graph, etc. So, try it out on your codebase and let us know about your project load/parsing gains for IntelliSense start-up.</p>
<h2 id="feedback-wanted">Feedback Wanted!</h2>
<p>Your feedback through <a href="https://developercommunity.visualstudio.com/" target="_blank" rel="noopener">Developer Community</a>, surveys, and social media channels has made these improvements possible. We thank you for your valuable comments. These enhancements are a continuation of our focus on improving productivity for game developers. Throughout the Visual Studio 2022 development cycle, we will continue to make improvements like ones detailed in this blogpost. If you are a game developer, <a href="http://aka.ms/VSGameDevSurvey" target="_blank" rel="noopener">let us know your thoughts in our 2022 Visual Studio Game Developer Survey</a>.</p>
<p>In addition, please continue to help shape the development of Visual Studio by talking to us in the comments below, on Twitter (<a href="https://twitter.com/visualc" target="_blank" rel="noopener">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a></p>
<h2 id="upgrade-to-visual-studio-2022">Upgrade to Visual Studio 2022</h2>
<p><a href="https://visualstudio.microsoft.com/downloads/" target="_blank" rel="noopener">Download the latest version of Visual Studio 2022</a> to take advantage of these productivity benefits today!</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/">Visual Studio 2022 Performance: Faster C++ Source Code Indexing</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/faster-cpp-source-code-indexing/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>What’s New for C++ Developers in Visual Studio 2022 17.4</title>
		<link>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/</link>
					<comments>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/#respond</comments>
		
		<dc:creator><![CDATA[Sy Brand]]></dc:creator>
		<pubDate>Tue, 08 Nov 2022 10:30:45 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31267</guid>

					<description><![CDATA[<p>We are happy to announce that Visual Studio 2022 version 17.4 is now generally available! This post summarizes the new features you can find in this release for C++. You can download Visual Studio 2022 from the Visual Studio downloads page or upgrade your existing installation by following the Update Visual Studio Learn page.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/">What’s New for C++ Developers in Visual Studio 2022 17.4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are happy to announce that Visual Studio 2022 version 17.4 is now generally available! This post summarizes the new features you can find in this release for C++. You can download Visual Studio 2022 from the <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio downloads page </a>or upgrade your existing installation by following the <a href="https://learn.microsoft.com/en-us/visualstudio/install/update-visual-studio?view=vs-2022">Update Visual Studio Learn page</a>.</p>
<h1 id="arm64">Arm64</h1>
<p>In 17.3, Visual Studio became available as a native Arm64 application. We have continued work on supporting more development scenarios and are pleased to announce that the native Arm64 toolchain is now ready for production use!</p>
<p>The “Desktop development with C++” and “Game development with C++” workloads are enabled for native Arm64 development. Please give them a try and let us know your feedback!</p>
<h1 id="msvc">MSVC</h1>
<p>One of our major investments for this release has been in improved compiler diagnostics. New C++ features like concepts and ranges present the opportunity for more expressive code and better-defined APIs. However, to make the most of them, better diagnostics are required from tooling so that constraint failures can be pinpointed and resolved. See Xiang Fan’s blog post on <a href="https://devblogs.microsoft.com/cppblog/the-future-of-c-compiler-diagnostics-in-msvc-and-visual-studio/">The Future of C++ Compiler Diagnostics in MSVC and Visual Studio</a> for all the details, but here’s a quick example of the improvement, showing more complete information on overload resolution failures, and information on why a given constraint failed:</p>
<pre class="prettyprint language-cpp"><code class="language-cpp">struct cat {};
struct dog {};

// can pet cats and dogs
void pet(cat);
void pet(dog);

template &lt;class T&gt;
concept has_member_pettable = requires (T t) { t.pet(); };

// allow calling as a non-member
template &lt;has_member_pettable T&gt;
void pet(T);

int main() {
    pet(0); //oh no
}</code></pre>
<p><strong>Error in 17.3</strong></p>
<pre class="prettyprint language-default"><code class="language-default">&lt;source&gt;(16,10): error C2665: 'pet': none of the 2 overloads could convert all the argument types
    pet(0); //oh no
         ^
&lt;source&gt;(6,6): note: could be 'void pet(dog)'
void pet(dog);
     ^
&lt;source&gt;(5,6): note: or 'void pet(cat)'
void pet(cat);
     ^
&lt;source&gt;(16,5): note: 'void pet(cat)': cannot convert argument 1 from 'int' to 'cat'
    pet(0); //oh no
    ^
&lt;source&gt;(16,10): note: No constructor could take the source type, or constructor overload resolution was ambiguous
    pet(0); //oh no
         ^
&lt;source&gt;(5,6): note: see declaration of 'pet'
void pet(cat);
     ^
&lt;source&gt;(16,10): note: while trying to match the argument list '(int)'
    pet(0); //oh no</code></pre>
<p><strong>Error in 17.4</strong></p>
<pre>&lt;source&gt;(16,5): error C2665: 'pet': no overloaded function could convert all the argument types
    pet(0); //oh no
    ^
&lt;source&gt;(6,6): note: could be 'void pet(dog)'
void pet(dog);
     ^
&lt;source&gt;(16,5): note: 'void pet(dog)': cannot convert argument 1 from 'int' to 'dog'
    pet(0); //oh no
    ^
&lt;source&gt;(16,9): note: No constructor could take the source type, or constructor overload resolution was ambiguous
    pet(0); //oh no
        ^
&lt;source&gt;(5,6): note: or 'void pet(cat)'
void pet(cat);
     ^
&lt;source&gt;(16,5): note: 'void pet(cat)': cannot convert argument 1 from 'int' to 'cat'
    pet(0); //oh no
    ^
&lt;source&gt;(16,9): note: No constructor could take the source type, or constructor overload resolution was ambiguous
    pet(0); //oh no
        ^
&lt;source&gt;(13,6): note: or 'void pet(T)'
void pet(T);
     ^
&lt;source&gt;(16,5): note: the associated constraints are not satisfied
    pet(0); //oh no
    ^
&lt;source&gt;(12,11): note: the concept 'has_member_pettable&lt;int&gt;' evaluated to false
template &lt;has_member_pettable T&gt;
          ^
&lt;source&gt;(9,48): note: the expression is invalid
concept has_member_pettable = requires (T t) { t.pet(); };
                                               ^
&lt;source&gt;(16,5): note: while trying to match the argument list '(int)'
    pet(0); //oh no
    ^</pre>
<p>Here is a <a href="https://godbolt.org/z/a85z9d5qd">Compiler Explorer link</a> to see the difference.</p>
<p>As part of this work, we’ve also added experimental support for outputting compiler diagnostics as <a href="https://sarifweb.azurewebsites.net/">SARIF</a>. This is accessible with the experimental flag /experimental:log&lt;directory&gt;.</p>
<p>In addition to improved diagnostics, we’ve expanded the compiler’s Named Return Value Optimization (NRVO) capabilities. See Bran Hagger’s blog post <a href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> for details. The main improvements are in enabling NRVO for cases which involve exception handling or loops. For example, in 17.3, the copy/move of result when returning it would not be elided, but now will be.</p>
<pre class="prettyprint language-cpp"><code class="language-cpp">Foo ReturnInALoop(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        Foo result;
        if (i == (iterations / 2)) {
            return result; //copy/move elided
        }
    }
}</code></pre>
<p>You can see the difference in generated assembly at <a href="https://godbolt.org/z/jrP4jcz3G">this Compiler Explorer link</a>.</p>
<h1 id="cmake-cross-platform">CMake &amp; Cross Platform</h1>
<p>Containers are a great way to package up everything for running an application. Through a Dockerfile, all prerequisites are captured so that there is a consistent runtime environment anywhere the container is deployed and run. Dev Containers expand this concept to capture everything necessary for developing and building an application in the container. You can now use Dev Containers for your C++ projects in Visual Studio. You can learn more about this feature in our <a href="https://devblogs.microsoft.com/cppblog/dev-containers-for-c-in-visual-studio/" target="_blank" rel="noopener">Dev Containers for C++ blog post</a>.</p>
<p><img class="alignnone wp-image-31268" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-1.png" alt="Alert box saying &quot;Folder contains a dev container configuration file&quot; Options are &quot;Reopen folder in container&quot;, &quot;Settings&quot;, and &quot;Learn more&quot;" width="744" height="40" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-1.png 744w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-1-300x16.png 300w" sizes="(max-width: 744px) 100vw, 744px" /></p>
<p>Connecting to remote systems with the <a href="https://learn.microsoft.com/en-us/cpp/linux/connect-to-your-remote-linux-computer?view=msvc-170" target="_blank" rel="noopener">Connection Manager</a> now supports SSH ProxyJump, which is used to access a SSH host via another SSH host (for example, to access a host behind a firewall).</p>
<p>Test Explorer used to expose internal prefixes of CTest tests, making the list harder to read and navigate. We’ve improved this, grouping all of them under a single header. Here is the before and after:</p>
<p><img class="alignnone wp-image-31269" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-2.png" alt="List from test explorer showing the weird prefixes " width="251" height="201" /> <img class="alignnone wp-image-31270" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-3.png" alt="Cleaner list under a ctest header" width="170" height="124" /></p>
<h2 id="bundled-tools">Bundled tools</h2>
<p>We made several updates to the additional tools which are shipped with Visual Studio in some workloads.</p>
<p>If you’re using Visual Studio on Arm64 machines, you will now get Arm64 builds of CMake and Ninja through the CMake components in the Visual Studio installer.</p>
<p>We’ve updated the version of CMake which we ship to version 3.24.1. This release comes with many new features, including a &#8211;fresh CLI flag for removing the CMake cache, path comparison in if expressions, and version 5 of CMakePresets.json. We’ll be adding support for CMakePresets.json version 5 in our 17.5 release of Visual Studio 2022, but 17.4 comes with added support for version 4. See the <a href="https://cmake.org/cmake/help/latest/release/3.24.html">CMake release notes</a> for all the new goodies.</p>
<p>We also updated the version of LLVM which we ship to version 15.0.1. See the <a href="https://releases.llvm.org/15.0.0/docs/ReleaseNotes.html" target="_blank" rel="noopener">LLVM</a> and <a href="https://releases.llvm.org/15.0.0/tools/clang/docs/ReleaseNotes.html" target="_blank" rel="noopener">Clang</a> release notes for what is available.</p>
<h1 id="productivity">Productivity</h1>
<p>When using the “Create Declaration/Definition” feature, it used to be that the new code would open up in a small window to give you a “peek”. This is now configurable: you can select between peeking (the default), or opening the document,, or no navigation. The setting is under Options &gt; Text Editor &gt; C/C++ &gt; Advanced &gt; Refactoring.</p>
<p><img class="alignnone wp-image-31271" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-4.png" alt="Options pane showing &quot;None&quot;, &quot;Peek document&quot;, and &quot;Open document&quot; as the options for the setting &quot;Navigation after create declaration/definition&quot;" width="749" height="161" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-4.png 749w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-4-300x64.png 300w" sizes="(max-width: 749px) 100vw, 749px" /></p>
<p>We fixed a consistency gap between IntelliSense and MSBuild for pre-compiled headers. It used to be that, when a PCH was used via /Yu and force-included via /FI, IntelliSense would always process it first, before any other headers included via /FI. This did not match the build behavior, so with this change /FI headers are processed in the order they are specified.</p>
<h1 id="ide-performance">IDE Performance</h1>
<p>We are also continuing to improve the performance of the IDE. In this release, we improved indexing performance when opening a new solution. Large projects could see a 20-35% improvement from 17.3.</p>
<h1 id="code-safety">Code Safety</h1>
<p>We enrich some of our code analysis warnings with “key events” information which describes how the result of the analysis was arrived at. We improved and expanded this feature by adding this information to more analyses and giving you new ways to visualize it in Visual Studio.</p>
<p>For example, when the <a href="https://marketplace.visualstudio.com/items?itemName=WDGIS.MicrosoftSarifViewer">SARIF Viewer extension</a> is installed, the key event information will now be used to annotate the source directly.</p>
<p><img class="alignnone wp-image-31272" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5.png" alt="Code annotated with reasoning behind an initialization code analysis warning" width="920" height="199" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5.png 920w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5-300x65.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-5-768x166.png 768w" sizes="(max-width: 920px) 100vw, 920px" /></p>
<p>See the <a href="https://devblogs.microsoft.com/cppblog/microsoft-cpp-code-analysis-warnings-with-key-events/">Microsoft C++ Code Analysis Warnings with Key Events </a>blog post for all the details.</p>
<h1 id="conformance">Conformance</h1>
<p>We’re continuing to track the latest developments in C++ standardization. You can see the latest and upcoming STL features in our <a href="https://github.com/microsoft/STL/wiki/Changelog">Changelog on GitHub</a>, but here are some of the ones I’m most excited about:</p>
<ul>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r7.html" target="_blank" rel="noopener">P0881R7</a>  &lt;stacktrace&gt;</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1328r1.html" target="_blank" rel="noopener">P1328R1</a>  constexpr type_info::operator==()</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2440r1.html" target="_blank" rel="noopener">P2440R1</a>  ranges::iota, ranges::shift_left, ranges::shift_right</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2441r2.html" target="_blank" rel="noopener">P2441R2</a>  views::join_with</li>
<li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2302r4.html">P2302R4</a>  ranges::contains, ranges::contains_subrange</li>
<li style="list-style-type: none;"></li>
</ul>
<p>Conformance work also extends to IntelliSense, which now has support for C23 attributes, and we are continuing to improve the support for C++20 modules.</p>
<h1 id="vcpkg">vcpkg</h1>
<p>vcpkg is now 6 years old and has over 2000 open-source libraries available!</p>
<p>We’re continuing to add new features both to vcpkg itself, and to Visual Studio to improve integration. For example, vcpkg artifacts is a feature which allows you to describe the tools and environment necessary to build your application. We have now added support to Visual Studio for vcpkg artifacts with CMake projects, such that if your project includes a vcpkg manifest, the environment will be activated automatically on project open. You can learn more about this in the <a href="https://devblogs.microsoft.com/cppblog/vcpkg-environment-activation-in-visual-studio/">vcpkg environment activation in Visual Studio blog post</a>.</p>
<p><img class="alignnone wp-image-31273" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/text-description-automatically-generated.png" alt="Popup saying &quot;vcpkg environment activation. vcpkg activated successfully. C/C++ development actions will now run in the vcpkg environment.&quot;" width="383" height="202" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/text-description-automatically-generated.png 383w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/text-description-automatically-generated-300x158.png 300w" sizes="(max-width: 383px) 100vw, 383px" /></p>
<p>Other notable improvements since the last release are making the “name” and “version” fields in vcpkg.json optional, adding schemata for all vcpkg json formats, and improving cross-compilation for macOS. You can read more details about these and more in our monthly blog posts from <a href="https://devblogs.microsoft.com/cppblog/vcpkg-august-2022-release-is-now-available-cmake-version-update-updated-faq-cross-compilation-fix-for-apple-silicon/">August</a> and <a href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">September</a>.</p>
<h1 id="game-development">Game Development</h1>
<p>We’re working hard on the Unreal Engine integration into Visual Studio. As of 17.4, you can now see which Unreal Engine Blueprints reference, use, and inherit from C++ classes, directly in the IDE. To enable this feature, ensure that the “IDE support for Unreal Engine” component is enabled in the VS Installer, and download <a href="https://www.unrealengine.com/marketplace/en-US/product/362651520df94e4fa65492dbcba44ae2">the Visual Studio Integration Tool</a> from the Unreal Marketplace.</p>
<p><img class="alignnone wp-image-31274" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7.png" alt="Popup showing the references to a given blueprint" width="837" height="271" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7.png 837w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7-300x97.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/11/word-image-31267-7-768x249.png 768w" sizes="(max-width: 837px) 100vw, 837px" /></p>
<p>Keep an eye out for more new features in 17.5, and please let us know what you think of the Blueprints integration!</p>
<h1 id="send-us-your-feedback">Send us your feedback</h1>
<p>We are very much interested in your feedback to continue to improve this experience. The comments below are open. Feedback can also be shared through the <a href="https://developercommunity.visualstudio.com/cpp">Developer Community</a>. You can also reach us on Twitter (<a href="https://twitter.com/visualc">@VisualC</a>), or via email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/">What’s New for C++ Developers in Visual Studio 2022 17.4</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/whats-new-for-cpp-developers-in-visual-studio-2022-17-4/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Fix for High Risk OpenSSL Security Vulnerabilities Announced – Guidance for vcpkg Users</title>
		<link>https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/</link>
					<comments>https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Wed, 02 Nov 2022 23:27:22 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31246</guid>

					<description><![CDATA[<p>OpenSSL.org announced the release of OpenSSL 3.0.7 to address two security vulnerabilities rated as high risk. This patch is now available, including via vcpkg. The vulnerabilities impact users of OpenSSL 3.0.0 &#8211; 3.0.6. If you are relying on a version of OpenSSL in this range,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/">Fix for High Risk OpenSSL Security Vulnerabilities Announced – Guidance for vcpkg Users</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a href="https://www.openssl.org/blog/blog/2022/11/01/email-address-overflows/">OpenSSL.org announced the release of OpenSSL 3.0.7</a> to address two security vulnerabilities rated as high risk. This patch is now available, including via vcpkg. The vulnerabilities impact users of OpenSSL 3.0.0 &#8211; 3.0.6. If you are relying on a version of OpenSSL in this range, it is <strong>strongly recommended</strong> to upgrade to 3.0.7 as soon as possible. We also recommend reviewing Microsoft Security Response Center&#8217;s central blog post on awareness and guidance related to these two CVEs: <a href="https://msrc-blog.microsoft.com/2022/11/02/microsoft-guidance-related-to-openssl-risk-cve-2022-3786-and-cve-2202-3602/">Awareness and guidance related to OpenSSL 3.0 – 3.0.6 risk (CVE-2022-3786 and CVE-2202-3602) – Microsoft Security Response Center</a>.</p>
<p>If you are a vcpkg user or port author depending on the OpenSSL vcpkg port, below are instructions on how to upgrade to the new version.</p>
<p>&nbsp;</p>
<h3 id="vcpkg-users-check-if-you-are-using-a-vulnerable-version-of-openssl">vcpkg users: check if you are using a vulnerable version of OpenSSL</h3>
<p><strong>WARNING: </strong>It is possible that OpenSSL is a part of your dependency graph even if your project does not directly depend on it. This is because other vcpkg ports may transitively depend on OpenSSL and thus vcpkg will install it for you. For example, users of the <a href="https://azure.github.io/azure-sdk-for-cpp/index.html">Azure C++ SDK</a> port transitively depend on OpenSSL and should verify the version of OpenSSL installed on their system.</p>
<p>There are several methods that can help you identify the version of OpenSSL installed by vcpkg (if it exists), depending on your scenario:</p>
<ol>
<li>If you install your libraries via the command line, use <code>vcpkg list openssl</code>​ to list all installed versions of OpenSSL.</li>
<li>If you use a <em>vcpkg.json</em> manifest that installs dependencies during your build, use <code>vcpkg install --dry-run</code>​ to list the versions of every library that will be installed.</li>
<li>Finally, you can also directly verify the installed version of OpenSSL from an installed tree by looking at the version macros in the header &#8220;<em>openssl/opensslv.h</em>&#8220;.
<ul>
<li>These are the macros, denoting the major, minor, and patch versions (3.0.5 in this case):</li>
<li><code># define OPENSSL_VERSION_MAJOR 3</code></li>
<li><code># define OPENSSL_VERSION_MINOR 0</code></li>
<li><code># define OPENSSL_VERSION_PATCH 5</code></li>
</ul>
</li>
</ol>
<p>If you find that you are using a vulnerable version of OpenSSL, read on to find out how to upgrade.</p>
<p>&nbsp;</p>
<h3 id="classic-mode-command-line-users">Classic Mode (Command Line) Users</h3>
<p>If you are consuming vcpkg dependencies and don’t use a <em>vcpkg.json</em> manifest, you are using classic mode, which involves running commands of the nature <code>vcpkg install &lt;library_name&gt;</code>. To get the latest version of OpenSSL, you have several options. Pick the one that works best for you:</p>
<p>&nbsp;</p>
<h4 id="classic-mode-option-1-upgrade-all-dependencies-at-once">Classic Mode Option 1: Upgrade all dependencies at once</h4>
<p>If you are using classic mode and are okay with updating all your vcpkg dependencies at once, the fastest solution is to update your local copy of the vcpkg git repo to a newer version. Just open a terminal to your copy of vcpkg and run the following commands:</p>
<pre class="prettyprint">git fetch https://github.com/microsoft/vcpkg 09adfdc8cdad76345b7cc7f3305899e1cbd66297
git checkout 09adfdc8cdad76345b7cc7f3305899e1cbd66297
vcpkg upgrade
vcpkg upgrade --no-dry-run</pre>
<p><strong>Notes: </strong></p>
<ul>
<li><code>09adfdc8cdad76345b7cc7f3305899e1cbd66297</code> is a vcpkg commit ID containing the patched version of OpenSSL. You can also use a newer commit ID than this.</li>
<li>After running the git checkout line with that commit ID, you should see <code>HEAD</code> is now at <code>09adfdc8c [OpenSSL] Update to 3.0.7. (#27594)</code></li>
<li>After running <code>vcpkg upgrade</code>, you should see that OpenSSL will be updated to 3.0.7, along with other affected dependencies.</li>
<li>The last line with <code>--no-dry-run</code> will update your dependencies for real.</li>
<li>If you are not bothered about which commit to update to, you can just run a general git pull to get the very latest version of vcpkg and skip having to provide a commit ID altogether. You will still need to run <code>vcpkg upgrade</code> after.</li>
</ul>
<p>&nbsp;</p>
<h4 id="classic-mode-option-2-update-your-local-openssl-port-files-to-the-new-version">Classic Mode Option 2: Update your local OpenSSL port files to the new version</h4>
<p>If you want to update just OpenSSL and nothing else, open a terminal to your copy of vcpkg and run the following commands:</p>
<pre class="prettyprint">git fetch https://github.com/microsoft/vcpkg 09adfdc8cdad76345b7cc7f3305899e1cbd66297
git checkout 09adfdc8cdad76345b7cc7f3305899e1cbd66297 -- ports/openssl
vcpkg upgrade
vcpkg upgrade --no-dry-run</pre>
<p><strong>Notes: </strong></p>
<ul>
<li><code>09adfdc8cdad76345b7cc7f3305899e1cbd66297</code> is a vcpkg commit ID containing the patched version of OpenSSL. You can also use a newer commit ID than this.</li>
<li>In contrast to the previous example, this approach lets you update just the OpenSSL portion of the vcpkg repo while leaving everything else alone.</li>
<li>After running <code>vcpkg upgrade</code>, you should see that OpenSSL will be updated to 3.0.7, along with other affected dependencies.</li>
<li>The last line with <code>--no-dry-run</code> will update your dependencies for real.</li>
</ul>
<p>This approach will only update the OpenSSL port, but keep in mind that future general git fetches on the repo will apply a new commit ID globally, so you’ll need to make sure you don’t accidentally pull a version of OpenSSL within the 3.0.0 &#8211; 3.0.6 range.</p>
<p>&nbsp;</p>
<h3 id="manifest-mode-users">Manifest Mode Users</h3>
<p>If you are consuming vcpkg dependencies via a manifest file (recommended for any advanced users and professional projects), you just need to update your <em>vcpkg.json</em> file to set a different OpenSSL version.</p>
<p>&nbsp;</p>
<h4 id="manifest-mode-option-1-upgrade-all-dependencies-at-once">Manifest Mode Option 1: Upgrade all dependencies at once</h4>
<p>In general, we recommend updating all open-source dependencies at once rather than one at a time since that allows you to benefit from vcpkg’s version conflict resolution to avoid things like diamond dependencies in your dependency graph.</p>
<p>If this works for you, open a terminal to your vcpkg install location and run the following command:</p>
<p><code>git pull origin 09adfdc8cdad76345b7cc7f3305899e1cbd66297</code></p>
<p>Then (still in your terminal), navigate to your project containing the vcpkg.json, and run:</p>
<p><code>vcpkg x-update-baseline</code></p>
<p>You can git pull to a newer commit ID if you prefer (or just not specify a commit ID and get the latest), but the commit ID in the example above is the earlier one with the patch applied.</p>
<p>The <a href="https://vcpkg.io/en/docs/commands/update-baseline.html">x-update-baseline</a> command moves your registry baseline forward to the baseline set for the vcpkg repo. This is why you must run git pull on the main repo to sync it to the baseline you need.</p>
<p>You can alternatively go into your <em>vcpkg.json</em> and <em>vcpkg-configuration.json</em> files to set baselines manually if you’re having trouble running <code>x-update-baseline</code>:</p>
<h5 id="example-with-baseline-field">Example with baseline field</h5>
<pre class="prettyprint"><strong>vcpkg.json:
</strong>{
    "name": "example",
    "version": "1.0.0",
    "dependencies": [
        "curl"
    ]
}

<strong>vcpkg-configuration.json:
</strong>{
    "default-registry": {
        "kind": "git",
        "baseline": "09adfdc8cdad76345b7cc7f3305899e1cbd66297",
        "repository": "https://github.com/microsoft/vcpkg"
    }
}</pre>
<p>The baseline field is used when the registry location is defined in a separate <em>vcpkg-configuration.json</em> file. This is common for custom registries, though you can configure the public registry this way as well. If you just want to use the default registry and don’t have it separately configured in <em>vcpkg-configuration.json</em>, follow the next example instead using the builtin-baseline field.</p>
<h5 id="example-with-builtin-baseline-field">Example with builtin-baseline field</h5>
<pre class="prettyprint"><strong>vcpkg.json:
</strong>{
    "name": "example",
    "version": "1.0.0",
    "builtin-baseline": "09adfdc8cdad76345b7cc7f3305899e1cbd66297",
    "dependencies": [
        "curl"
    ]
}</pre>
<p>See the <a href="https://vcpkg.io/en/docs/users/versioning.html&quot; \l &quot;baselines">vcpkg versioning documentation</a> for details on how baselines work.</p>
<p>&nbsp;</p>
<h4 id="manifest-mode-option-2-upgrade-openssl-using-an-override">Manifest Mode Option 2: Upgrade OpenSSL using an override</h4>
<p>If you need fine-grained control over the versions of your libraries, you can</p>
<p>set the version of OpenSSL to stay at exactly 3.0.7 using the overrides field. The limitations of this approach are that you won’t get the automatic version conflict resolution (as you would with baselines) and must manually track the package version. In addition, if your project that consumes OpenSSL will itself be packaged as a vcpkg port, your downstream consumers will <strong>not</strong> automatically get the version of OpenSSL you specify. Your downstream consumers must also update their version of OpenSSL.</p>
<h5 id="registries-example-with-overrides">Registries example with overrides</h5>
<pre class="prettyprint"><strong>vcpkg.json:
</strong>{
    "name": "example",
    "version": "1.0.0",
    "dependencies": [
        "curl"
    ],
    "overrides": [
    {
        "name": "openssl",
        "version": "3.0.7"
    }]
}
<strong>vcpkg-configuration.json:
</strong>{
    "default-registry": {
        "kind": "git",
        "baseline": "fcfda3c78c474aec7187299b684258855259a7a6",
        "repository": "https://github.com/microsoft/vcpkg"
    }
}</pre>
<p>Please see our <a href="https://vcpkg.io/en/docs/users/versioning.html">versioning documentation</a> if you need a refresher on these vcpkg features.</p>
<p>&nbsp;</p>
<h3 id="questions">Questions?</h3>
<p>We will monitor this blog post for comments in case there are any questions. Please also feel free to email us at <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a> if you need additional guidance.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/">Fix for High Risk OpenSSL Security Vulnerabilities Announced – Guidance for vcpkg Users</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/fix-for-high-risk-openssl-security-vulnerabilities-announced-guidance-for-vcpkg-users/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft Office team uses Remote MacOS Debugging Capability in Visual Studio</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/#comments</comments>
		
		<dc:creator><![CDATA[Sinem Akinci]]></dc:creator>
		<pubDate>Tue, 01 Nov 2022 18:18:54 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31240</guid>

					<description><![CDATA[<p>The Microsoft Office team approached the C++ team after seeing the Visual Studio announcement for support for debugging applications running on C++ from Windows through the Blizzard blog post. They had a need for a similar workflow, but for Macs instead of Linux.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/">Microsoft Office team uses Remote MacOS Debugging Capability in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW1907738 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW1907738 BCX8">The Microsoft Office team approached the </span><span class="NormalTextRun SCXW1907738 BCX8">C++ </span><span class="NormalTextRun SCXW1907738 BCX8">team after seeing the Visual Studio announcement for support for debugging applications running on </span><span class="NormalTextRun SCXW1907738 BCX8">C++ </span><span class="NormalTextRun SCXW1907738 BCX8">from Windows through </span></span><a class="Hyperlink SCXW1907738 BCX8" href="https://devblogs.microsoft.com/cppblog/blizzard-diablo-iv-debugs-linux-core-dumps-from-visual-studio/" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW1907738 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW1907738 BCX8" data-ccp-charstyle="Hyperlink">the Blizzard blog post</span></span></a><span class="TextRun SCXW1907738 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW1907738 BCX8">. They had a need for a similar workflow, but for Macs instead of Linux. The </span><span class="NormalTextRun SCXW1907738 BCX8">C++ </span><span class="NormalTextRun SCXW1907738 BCX8">team worked closely with the Office engineers to adapt</span><span class="NormalTextRun CommentStart SCXW1907738 BCX8"> the same underlying technology for Mac. </span></span><span class="EOP SCXW1907738 BCX8" data-ccp-props="{}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1.png"><img class="alignnone size-full wp-image-31241" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1.png" alt="Image Picture1" width="1100" height="687" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1.png 1100w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1-300x187.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1-1024x640.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/Picture1-768x480.png 768w" sizes="(max-width: 1100px) 100vw, 1100px" /></a></p>
<p>The following blog post is written in conjunction with Anthony Penniston, an Office engineer we worked closely with to deliver this capability. <em>Thank you, Anthony, for working with us!</em></p>
<h5 id="what-does-this-team-do"><strong><u>What does this team do?</u></strong></h5>
<p>Anthony’s team in Office works on delivering core productivity verticals such as document storage and syncing, collaboration, predictive intelligence, authentication, and single sign on. Due to the nature of working on Microsoft Office, the team is very much cross-platform oriented in the products they deliver and feels a lot of unique pains.</p>
<p>Specifically, since Office delivers scalable, robust, responsive, and cross-platform products, the team must build their products natively in C++, using several different compilers and build systems, while still operating on the same unified codebase. As a result, every change they make typically affects the same product on multiple platforms.</p>
<h5 id="how-does-this-team-accomplish-their-work"><strong><u>How does this team accomplish their work?</u></strong></h5>
<p>Before working with the C++ team on a remote debugging solution for Mac, Office engineers looking to investigate Apple-specific behavior really faced some challenges. They had to either attempt to guess the behavior from source code and logs or acquire a Mac system and learn how to use XCode to debug the behavior natively. Additionally, investigating platform-specific behavior ended up compounding in difficulty because much of the team primarily has expertise and experience in Windows. Neither of these workflows were practical for ad-hoc investigations by the engineers. As a result, a lot of investigations ended up being often delayed and Apple-specific issues were resolved by less-than-ideal workarounds and through many iterations of trial-and-error guesswork. This was by far an unproductive way to move forward in their work. For many Windows engineers who may only briefly need to investigate one-off issues for Apple-specific behavior, being able to use the familiar Windows tooling is a huge benefit and timesaver.</p>
<p>The team really wanted to stay developing in Visual Studio for all their needs because it has the reputation as an industry-standard and industry-leading tool for developing and debugging C++ applications on Windows. Visual Studio helps them make sense of their codebase and quickly turn around questions into answers and ideas into implementation through features they use like IntelliSense, code browsing and navigation, and auto-completion. Since the Microsoft Office organization primarily develops on Windows, alongside several other platforms, it takes a great deal of investment to build proficiency in any tool ecosystem. Being able to reuse the skills they’ve built with their Windows tooling and apply that across platforms is incredibly valuable to the engineers. So, when Anthony saw that the C++ team developed functionality to allow users to debug Linux from the comfort of Visual Studio, he was super excited to reach out to the team and learn more about how this functionality could possibly be adapted for Mac.</p>
<h5 id="adopting-the-mac-targeting-support"><strong><u>Adopting the Mac targeting support</u></strong></h5>
<p>Once Anthony contacted the C++ team with his request, the C++ engineers were able to engage and collaborate with the Office team to produce a prototype that would fit his needs for remote Mac development in Visual Studio. This was done pretty rapidly and within a few weeks. Since the C++ team was able to move quickly on this request, by the time a one-week hackathon was over, they had that they were able to demo to the Office team and raise awareness of this new product effort. At the demo, they were able to attract a lot of other Office engineers to this idea and these engineers were keen on seeing more, so over the course of the year, the C++ team continued to collaborate with the Office team to further refine the experience into the <a href="https://devblogs.microsoft.com/cppblog/visual-studio-for-remote-macos-c-development/">out-of-box remote debugging functionality for LLDB in Visual Studio 2022</a> present today, which not only met all of the team’s technical requirements, and addressed all the feedback given, but was also easy to onboard engineers unfamiliar with the workflow.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager.png"><img class="alignnone size-full wp-image-31242" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager.png" alt="Connection Manager in Visual Studio with remote Mac connections" width="720" height="388" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager.png 720w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/connectionmanager-300x162.png 300w" sizes="(max-width: 720px) 100vw, 720px" /></a></p>
<p>We spoke to Anthony after this experience, and he stated: “End-to-end it was an engaging and energizing experience to see an ambitious idea turned into reality.“ Also, Anthony pointed out that “[what stood out to me the most was] the engagement, responsiveness, and attention to user feedback of the VS team to improve and iterate on the design. The VS team had the polished feature ready-to-go in VS 2022 with all our asks in place and checked in with us to make sure our use cases were covered and our path to adoption was smooth and unblocked”</p>
<p>This concept not only improved their specific workflow but will also improve others’. This Office engineering team had some initial apprehension towards cross-platform development on Mac, specifically worries about encountering Mac-specific failures or behaviors, as this meant either investigation through guesswork or a considerable time investment into setting up a Mac system and learning the toolset, for what is often a one-off investigation. However, now, with VS 2022’s remote debugging capability for Mac, combined with being able to easily provision Mac systems in Office, the engineering team feels empowered to take on platform-specific investigations using the VS toolchain that they are already familiar and comfortable with.</p>
<h5 id="conclusion"><strong><u>Conclusion</u></strong>:</h5>
<p>A special thanks to Erika Sweet, Paul Maybee, Sinem Akinci, Ion Todirel, and the rest of the Visual Studio C++ team who, over the course of a several months to a year, helped make the Office team’s cross-platform ideal workflow a reality. The Office team left with an overwhelmingly positive experience and hopes for more collaboration in the future (and looking forward to soon leveraging this same VS technology to debug Mac core dumps on Windows).</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/">Microsoft Office team uses Remote MacOS Debugging Capability in Visual Studio</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-office-team-uses-remote-macos-debugging-capability-in-visual-studio/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Improving Copy and Move Elision</title>
		<link>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/</link>
					<comments>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/#comments</comments>
		
		<dc:creator><![CDATA[Bran Hagger]]></dc:creator>
		<pubDate>Mon, 24 Oct 2022 16:00:31 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31231</guid>

					<description><![CDATA[<p>With Visual Studio 2022 version 17.4 Preview 3, we&#8217;ve significantly increased the number of situations where we do copy or move elision and given users more control over whether these transformations are enabled.<br />
What are copy and move elision?<br />
When a return keyword in a C++ function is followed by an expression of non-primitive type,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>With Visual Studio 2022 version 17.4 Preview 3, we&#8217;ve significantly increased the number of situations where we do copy or move elision and given users more control over whether these transformations are enabled.</p>
<h2 id="what-are-copy-and-move-elision">What are copy and move elision?</h2>
<p>When a <code>return</code> keyword in a C++ function is followed by an expression of non-primitive type, the execution of that return statement copies the result of the expression into the return slot of the calling function. To do this, the copy or move constructor of the non-primitive type is called. Then, as part of exiting the function, destructors for function-local variables are called, likely including any variables named in the expression following the <code>return</code> keyword.</p>
<p>The C++ specification allows the compiler to construct the returned object directly in the return slot of the calling function, eliding the copy or move constructor executed as part of the return. Unlike most other optimizations, this transformation is allowed to have an observable effect on the program&#8217;s output &#8211; namely, the copy or move constructor and associated destructor are called one less time.</p>
<h2 id="mandatory-copy-move-elision-in-visual-studio">Mandatory copy/move elision in Visual Studio</h2>
<p>The C++ standard <em>requires</em> copy or move elision when the returned value is initialized as part of the <code>return</code> statement (such as when a function with return type <code>Foo</code> returns <code>return Foo()</code>). The Microsoft Visual C++ compiler always performs copy and move elision for return statements where it is required to do so, regardless of the flags passed to the compiler. This behavior is unchanged.</p>
<h2 id="changes-to-optional-copy-move-elision-in-visual-studio-17-4-preview-3">Changes to optional copy/move elision in Visual Studio 17.4 Preview 3</h2>
<p>When the returned value is a named variable, the compiler <em>may</em> elide the copy or move but is not required to do so. The standard still requires a copy or move constructor to be defined for the named return variable, even if the compiler elides the constructor in all cases. Prior to Visual Studio 2022 version 17.4 Preview 3, when optimizations were disabled (such as with the <code>/Od</code> compiler flag or for functions marked with <code>#pragma optimize("", off)</code>) the compiler would only perform mandatory copy and move elision. With the <code>/O2</code> flag, the compiler would perform optional copy or move elision for optimized functions with simple control flow.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, we are giving developers the option for consistency with the new <code>/Zc:nrvo</code> compiler flag. The <code>/Zc:nrvo</code> flag will be passed by default when code is compiled with the <code>/O2</code> flag, the <code>/permissive-</code> flag, or when compiling for <code>/std:c++20</code> or later. When this flag is passed, copy and move elision will be performed wherever possible. We would like to turn <code>/Zc:nrvo</code> on by default in a future release.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, optional copy/move elision can also be explicitly disabled with the <code>/Zc:nrvo-</code> flag. It is impossible to disable mandatory copy/move elision.</p>
<p>In Visual Studio 2022 version 17.4 Preview 3, we are also increasing the number of places where we do copy/move elision when optional copy/move elision is enabled with the <code>/Zc:nrvo</code>, <code>/O2</code>, <code>/permissive-</code>, or <code>/std:c++20</code> or later flags.</p>
<table>
<thead>
<tr>
<th></th>
<th>Earlier versions of Visual Studio</th>
<th>Visual Studio 17.4 Preview 3 and later</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mandatory copy/move elision</td>
<td>Always occurs.</td>
<td>Always occurs.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in function without loops or exception handling</td>
<td>Occurs under <code>/O2</code> unless the function has multiple returned symbols with overlapping lifetimes or the type&#8217;s copy or move constructor has default arguments.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in a loop</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable in functions with exception handling</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for return of named variable when the copy or move constructor has additional default arguments</td>
<td>Never occurs.</td>
<td>Does not occur under <code>/Zc:nrvo-</code>. Otherwise, occurs under <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> unless the function has multiple returned symbols with overlapping lifetimes.</td>
</tr>
<tr>
<td>Optional copy/move elision for throw of a named variable</td>
<td>Never occurs.</td>
<td>Never occurs.</td>
</tr>
</tbody>
</table>
<h2 id="examples-of-optional-copy-move-elision">Examples of optional copy/move elision</h2>
<p>The simplest example of optional copy or move elision is a function such as:</p>
<pre><code class="language-C++">Foo SimpleReturn() {
    Foo result;
    return result;
}</code></pre>
<p>Earlier versions of the MSVC compiler already elided the copy or move of <code>result</code> into the return slot in this case if the <code>/O2</code> flag was passed. In Visual Studio 2022 version 17.4 Preview 3, the copy or move is also elided if the <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed, and retained if the <code>/Zc:nrvo-</code> flag is passed.</p>
<p>Starting with Visual Studio 2022 version 17.4 Preview 3, we now perform copy/move elision in the following additional cases if the <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed to the compiler and the <code>/Zc:nrvo-</code> flag is not:</p>
<h3 id="return-inside-a-loop">Return inside a loop</h3>
<pre><code class="language-C++">Foo ReturnInALoop(int iterations) {
    for (int i = 0; i &lt; iterations; ++i) {
        Foo result;
        if (i == (iterations / 2)) {
            return result;
        }
    }
}</code></pre>
<p>The <code>result</code> object will be properly constructed at the start of each iteration of the loop and destructed at the end of each iteration. On the iteration where <code>result</code> is returned, its destructor will not be called on exit from the function. The function&#8217;s caller will destroy the returned object when it falls out of scope in that function.</p>
<h3 id="return-with-exception-handling">Return with exception-handling</h3>
<pre><code class="language-C++">Foo ReturnInTryCatch() {
    try {
        Foo result;
        return result;
    } catch (...) {}
}</code></pre>
<p>The copy or move of the <code>result</code> object will now be elided if the <code>/O2</code>, <code>/permissive-</code>, <code>/std:c++20</code> or later, or <code>/Zc:nrvo</code> flags are passed and the <code>/Zc:nrvo-</code> flag is not. We also now properly handle more complex cases such as:</p>
<pre><code class="language-C++">int n;

void throwFirstThreeIterations() {
    ++n;
    if (n &lt;= 3) throw n;
}

Foo ComplexTryCatch()
{
Label1:
    Foo result;

    try {
        throwFirstThreeIterations();
        return result;
    }
    catch(...) {
        goto Label1;    
    }
}</code></pre>
<p>The <code>result</code> object will be constructed in the return slot for the caller function and no copy/move constructor or destructor will be called for it on a successful return. When an exception is thrown, whether or not the <code>result</code> object is destructed is determined by which exception-handling flags are passed to the compiler. By default, no stack-unwinding will occur and therefore no destructors will be called. However, if stack-unwinding exception handling is enabled with the <code>/EHs</code>, <code>/EHa</code>, or <code>/EHr</code> flags, <code>goto Label1</code> will cause <code>result</code>&#8216;s destructor to be called because it jumps to before <code>result</code> is initialized. Either way, when the expression <code>Foo result</code> is reached again, the object will be constructed again in the return slot.</p>
<h3 id="copy-constructors-with-default-arguments">Copy constructors with default arguments</h3>
<p>We now properly detect that a copy or move constructor with default arguments is still a copy or move constructor, and therefore can be elided in the cases above. A copy constructor with default parameters will look something like the following:</p>
<pre><code class="language-C++">struct StructWithCopyConstructorDefaultParam {
   int X;

   StructWithCopyConstructorDefaultParam(int x) : X(x) {}
   StructWithCopyConstructorDefaultParam(StructWithCopyConstructorDefaultParam const&amp; original, int defaultParam = 0) :
      X(original.X + defaultParam) {
      printf("Copy constructor called.\n");
   }
};
</code></pre>
<h2 id="limitations-on-nrvo">Limitations on NRVO</h2>
<p>Although the MSVC compiler now performs copy and move elision in many more situations, it is not always possible to perform copy/move elision. To see why this is true, consider the following function:</p>
<pre><code class="language-C++">Foo WhichShouldIReturn(bool condition) {
    Foo resultA;
    if (condition) {
        Foo resultB;
        return resultB;
    }
    return resultA;
}</code></pre>
<p>Copy elision constructs the object to be returned in the return slot, but which object should be constructed in the return slot in this case? For the copy of <code>resultA</code> to be elided at <code>return resultA</code>, it must be constructed in the return slot. However, if <code>condition</code> is true, <code>resultB</code> will need to be constructed in the return slot before <code>resultA</code> is destroyed. There is no way to perform copy elision for both paths.</p>
<p>We currently choose to avoid doing optional copy/move elision on all paths in a function if copy/move elision is impossible on any path. However, changes to inlining decisions, dead code elimination, and other optimizations can change whether copy or move elision is possible. For this reason, it is never safe to write code that depends on certain behavior for copy/move elision of named variables unless all optional copy/move elision is disabled with <code>/Zc:nrvo-</code>.</p>
<p>As long as stack-unwinding exception handling is enabled or no exceptions are thrown, it is still safe to assume that every constructer call has a matching destructor call.</p>
<h2 id="feedback">Feedback</h2>
<p>We encourage you to try out this update in the latest Visual Studio 2022 version 17.4 Preview. Please let us know what you think or any issues you encounter. We can be reached via the comments below, via twitter (<a href="https://twitter.com/visualc">@visualC</a>) or via <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/">Improving Copy and Move Elision</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/improving-copy-and-move-elision/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/#respond</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 06 Oct 2022 18:02:05 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31188</guid>

					<description><![CDATA[<p>The September 2022 release of the vcpkg package manager is available. This blog post summarizes changes from August 15th, 2022 to September 27th, 2022 for the Microsoft/vcpkg and Microsoft/vcpkg-tool GitHub repos.<br />
&#160;<br />
vcpkg now has over 2,000 unique libraries in its open-source registry<br />
With this release,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">September 2022 release of the vcpkg package manager is available</a>. This blog post summarizes changes from August 15<sup>th</sup>, 2022 to September 27<sup>th</sup>, 2022 for the <a href="https://github.com/microsoft/vcpkg">Microsoft/vcpkg</a> and <a href="https://github.com/microsoft/vcpkg-tool/">Microsoft/vcpkg-tool</a> GitHub repos.</p>
<p>&nbsp;</p>
<h3 id="vcpkg-now-has-over-2000-unique-libraries-in-its-open-source-registry">vcpkg now has over 2,000 unique libraries in its open-source registry</h3>
<p>With this release, and the 6<sup>th</sup> anniversary of the launch of vcpkg, we are proud to hit a new milestone:<strong> over 2,000 unique open-source libraries</strong> are available in the vcpkg catalog! vcpkg continues to maintain the largest catalog of any C/C++ package manager with over 10,000 unique library versions with built-in support for many popular architectures, operating systems, and compilers, including x64, x86, arm, arm64, WebAssembly, Linux, macOS, Windows, iOS, Android, FreeBSD, UWP, MSVC, Clang, gcc, mingw, as well as static and shared (dynamic) libraries and more! And of course, since vcpkg is configured to build all these libraries from source, you can make further customizations as needed for your unique workflow.</p>
<p>From the beginning, we have invested extensively in building a large ecosystem of libraries supporting as many development workflows as possible, and we will continue to honor that commitment. While the C++ ecosystem is incredibly diverse, we will rise to the challenge and try to make as many developers as possible more productive. Managing libraries is well understood as a top C++ pain point in annual ISO C++ surveys, but we hope that will change over the next several years.</p>
<p>Some stats for this period:</p>
<ul>
<li><strong>48 new ports</strong> were added to the open-source registry. If you are unfamiliar with the term ‘port’, they are packages that are built from source and are typically C/C++ libraries.</li>
<li><strong>419 updates</strong> were made to existing ports. As always, we validate each change to a port by building all other ports that depend on or are depended by the library that is being updated for our nine main triplets.</li>
<li>There are now <strong>2,022 total libraries</strong> available in the vcpkg public registry. When including all available versions, there are over <strong>10,839 port versions</strong>.</li>
<li>The <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">September release of the main vcpkg repo</a> includes <strong>249 commits</strong>.</li>
<li><strong>95 contributors</strong> submitted PRs, issues, or participated in discussions in the repo.</li>
<li>The main vcpkg repo has <strong>4.8k forks</strong> and <strong>16.8k stars</strong> on GitHub.</li>
</ul>
<p>&nbsp;</p>
<h3 id="notable-changes">Notable Changes</h3>
<p>While last month was relatively quiet, this month’s update includes several vcpkg tool changes. See the full tool <a href="https://github.com/microsoft/vcpkg-tool/compare/2022-07-21...2022-09-20">commit changelog</a> for details. Notable changes are summarized below.</p>
<p>&nbsp;</p>
<h4 id="optional-name-and-version-fields-in-vcpkg-json">Optional name and version fields in vcpkg.json</h4>
<p><code>vcpkg.json</code> is the manifest file for specifying library dependencies, versions, optional features and other metadata required for acquiring ports. Previously, two fields were always mandatory for this file:</p>
<ul>
<li><code>name</code>: specifies a name for the project this manifest resides in.</li>
<li><code>version</code>: specifies a version for the project this manifest resides in.</li>
</ul>
<p>These fields are only really useful if your project is a library or other port that you want to package with vcpkg. However, we required the same schema for all projects consuming vcpkg ports (even if they themselves are not a port), which may be confusing for users. From now on, these fields are optional for projects that are only consuming ports, but not producing one. If you’re packaging a library for use in vcpkg however, you absolutely still need to specify these fields as they are critical for consumers to be able to consume your library via vcpkg.</p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/605">Microsoft/vcpkg-tool#605</a></p>
<p>&nbsp;</p>
<h4 id="vcpkg-artifacts-improvements">vcpkg artifacts improvements</h4>
<p>We are continuing to improve our preview experience for vcpkg artifacts, which enable acquisition of developer tools like compilers and debuggers from vcpkg. These are some changes in this release, especially for multiple registry scenarios:</p>
<ul>
<li>The <code>--registry</code>switch has been removed as registries are required to have a name.</li>
<li>Commands which take as input registry names or IDs now combine the set of registry names from the global set and the local project.</li>
<li>Console output now always displays registries using the following rules:
<ul>
<li>If the registry URI is in the project, the name of the project is used.</li>
<li>If the registry URI is not in the project, and the name of the registry in the global configuration does not conflict with the project, the global configuration’s name is used.</li>
<li>Otherwise, the URI enclosed in []s is used. This is a signal to vcpkg users that they will need to provide an appropriate registry name if they want something different.</li>
</ul>
</li>
<li>The command x-regenerate I now requires a local file path.</li>
<li>Several places that used to break when handling relative paths now tolerate the situation correctly, including x-regenerate.</li>
<li>If an artifact declares a dependency from a particular registry, and that registry’s name is not declared in the artifact itself, resolution fails. Vcpkg will no longer try to find the name in the project/global configuration.</li>
<li>Commands that need activation like add and remove no longer try to activate the project automatically.</li>
<li>Artifacts are now installed and enumerated in topological sorted order.</li>
<li>There is no longer a built-in registry named “default”.</li>
<li>Except for index.yaml, all remaining YAML files have been replaced with JSON. This may invalidate existing installed artifacts. This change was necessary in order to make the artifacts experience more consistent with our existing experience for managing ports.</li>
<li>Output messages have been cleaned up, including the removal of several newlines.</li>
<li>Bug fix: the console output no longer gets confused around registry names and no longer displays names using a “[URL]” format when it is unnecessary to do so.</li>
</ul>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/690">Microsoft/vcpkg-tool#690</a>, <a href="https://github.com/microsoft/vcpkg-tool/pull/693">Microsoft/vcpkg-tool#693</a></p>
<p>&nbsp;</p>
<h4 id="cleaned-up-console-output-when-not-connected-to-a-console">Cleaned up console output when not connected to a console</h4>
<p>We fixed some console output bugs when vcpkg is not connected to a console/TTY. Specifically:</p>
<ul>
<li>VT codes when showing tables should now be displayed correctly.</li>
<li>Progress bars are no longer displayed as the extra output may be undesirable in CI systems and also was not displaying correctly at times.</li>
</ul>
<p><strong>Before (non-TTY): </strong></p>
<p><img width="1489" height="191" class="wp-image-31202" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4.png" alt="Graphical user interface Description automatically generated with low confidence" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4.png 1489w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-300x38.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-1024x131.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-4-768x99.png 768w" sizes="(max-width: 1489px) 100vw, 1489px" /></p>
<p><strong>After (non-TTY): </strong></p>
<p><img width="1393" height="661" class="wp-image-31203" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2.png" alt="Text Description automatically generated" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2.png 1393w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-300x142.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-1024x486.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/text-description-automatically-generated-2-768x364.png 768w" sizes="(max-width: 1393px) 100vw, 1393px" /></p>
<p><strong>In TTY: </strong></p>
<p><img width="1630" height="412" class="wp-image-31204" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5.png" alt="Graphical user interface Description automatically generated with low confidence" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-300x76.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-1024x259.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-768x194.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/graphical-user-interface-description-automaticall-5-1536x388.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/702">Microsoft/vcpkg-tool#702</a></p>
<p>&nbsp;</p>
<h4 id="added-schemata-for-vcpkg-json-vcpkg-configuration-json-and-artifacts">Added schemata for vcpkg.json, vcpkg-configuration.json, and artifacts</h4>
<p>We added official schemas for our manifest files to make it easier to validate that files are authored correctly. In the future, we will also be using this experience to validate manifest files opened in Visual Studio and Visual Studio Code and notify users if errors are present using the IntelliSense experience.</p>
<p>You can try it yourself for the vcpkg.json and vcpkg-configuration.json manifests by</p>
<p>adding the following to the appropriate .json file:</p>
<p><code>"$schema": https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/vcpkg.schema.json</code></p>
<p><img width="1018" height="677" class="wp-image-31205" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2.png 1018w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2-300x200.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-4-2-768x511.png 768w" sizes="(max-width: 1018px) 100vw, 1018px" /></p>
<p>To try it out on JSON files describing artifacts,</p>
<p>add the following to the file:</p>
<p><code>"$schema": https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/artifact.schema.json</code></p>
<p><img width="1050" height="562" class="wp-image-31206" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2.png" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2.png 1050w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-300x161.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-1024x548.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/10/word-image-31188-5-2-768x411.png 768w" sizes="(max-width: 1050px) 100vw, 1050px" /></p>
<p>PR: <a href="https://github.com/microsoft/vcpkg-tool/pull/650">Microsoft/vcpkg-tool#650</a></p>
<p>&nbsp;</p>
<h3 id="total-ports-available-for-tested-triplets">Total Ports Available for Tested Triplets</h3>
<table>
<tbody>
<tr>
<td><strong>triplet</strong></td>
<td><strong>ports available</strong></td>
</tr>
<tr>
<td>x86-windows</td>
<td>1,823</td>
</tr>
<tr>
<td>x64-windows</td>
<td>1,879</td>
</tr>
<tr>
<td>x64-windows-static</td>
<td>1,784</td>
</tr>
<tr>
<td>x64-windows-static-md</td>
<td>1,795</td>
</tr>
<tr>
<td>x64-uwp</td>
<td>956</td>
</tr>
<tr>
<td>arm64-windows</td>
<td>1,444</td>
</tr>
<tr>
<td>arm-uwp</td>
<td>910</td>
</tr>
<tr>
<td>x64-osx</td>
<td>1,738</td>
</tr>
<tr>
<td>x64-linux</td>
<td>1,810</td>
</tr>
</tbody>
</table>
<p>While vcpkg supports a much larger variety of target platforms and architectures, the list above is validated exhaustively to ensure updated ports don’t break other ports in the catalog.</p>
<p>&nbsp;</p>
<h3 id="thank-you-to-our-contributors">Thank you to our contributors</h3>
<p>vcpkg couldn’t be where it is today without contributions from our open-source community. Thank you for your continued support! The following people contributed to the vcpkg and vcpkg-tool repos in this release:</p>
<ul>
<li>Thomas1664 (21 commits)</li>
<li>dg0yt (16 commits)</li>
<li>Neumann-A (14 commits)</li>
<li>wrobelda (5 commits)</li>
<li>autoantwort (4 commits)</li>
<li>m-kuhn (4 commits)</li>
<li>coryan (4 commits)</li>
<li>RT222 (2 commits)</li>
<li>eao197 (2 commits)</li>
<li>chausner (2 commits)</li>
<li>Osyotr (2 commits)</li>
<li>daschuer (1 commit)</li>
<li>ekilmer (1 commit)</li>
<li>yurybura (1 commit)</li>
<li>myd7349 (1 commit)</li>
<li>an-tao (1 commit)</li>
<li>past-due (1 commit)</li>
<li>DragonJoker (1 commit)</li>
<li>xvitaly (1 commit)</li>
</ul>
<p>&nbsp;</p>
<h3 id="learn-more">Learn More</h3>
<p>You can find the <a href="https://github.com/microsoft/vcpkg/releases/tag/2022.09.27">full September release notes on GitHub</a> for the main repo. Recent updates to the vcpkg tool can be viewed on the <a href="https://github.com/microsoft/vcpkg-tool/releases">vcpkg-tool Releases page</a>. If you’re new to vcpkg or curious about how a package manager can make your life easier as a C/C++ developer, check out the <a href="https://vcpkg.io/en/index.html">vcpkg website – vcpkg.io</a>.</p>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/releases">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues">issue </a><span style="color: #00a9e0;">tracker </span>or join more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap">roadmap page</a>.</p>
<p>&nbsp;</p>
<h3 id="interested-in-vcpkg-but-not-sure-where-to-start">Interested in vcpkg but not sure where to start?</h3>
<p>Is your company experiencing challenges managing C/C++ libraries? Perhaps you&#8217;re curious if a package manager is the right choice to you? Please reach out to vcpkg@microsoft.com and we&#8217;d be happy to help!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/">vcpkg September 2022 Release is Now Available: Celebrating 6 Years with Over 2000 Libraries!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-september-2022-release-is-now-available-celebrating-6-years-with-over-2000-libraries/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</title>
		<link>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/</link>
					<comments>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Mon, 03 Oct 2022 21:59:28 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31177</guid>

					<description><![CDATA[<p>One of the new features for C++ developers in Visual Studio 2022 version 17.3 is NuGet PackageReference support for C++/CLI MSBuild projects that target .NET Core and .NET 5 or higher. More specifically, this impacts CLR Class Library (.NET) and CLR Empty Project (.NET) project templates.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/">Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>One of the new features for C++ developers in Visual Studio 2022 version 17.3 is <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files">NuGet PackageReference</a> support for <strong>C++/CLI MSBuild projects that target .NET Core and .NET 5 or higher</strong>. More specifically, this impacts <em>CLR Class Library (.NET)</em> and <em>CLR Empty Project (.NET)</em> project templates. This functionality allows you to manage NuGet packages while bringing the <a href="https://docs.microsoft.com/en-us/nuget/consume-packages/migrate-packages-config-to-package-reference">benefits of PackageReference</a> support to your dependencies. This feature is on by default for new projects. To enable this feature for your existing projects, add the following property to your project file:</p>
<p><code>&lt;PropertyGroup Label="Globals"&gt;</code></p>
<p><code>&lt;EnableManagedPackageReferenceSupport&gt;true&lt;/EnableManagedPackageReferenceSupport&gt; &lt;/PropertyGroup&gt;</code></p>
<p>In most cases, you will want to enable this for the whole codebase. You can do this by setting the property in a <a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2022">Directory.Build.props file</a> instead.</p>
<p>When this property is set to <strong>true</strong>, NuGet will recognize on project load that the project is participating in the PackageReference experience and begin restoring packages just as it would for a .NET project.</p>
<p><strong>Note:</strong> in order to modify this setting in any way, it is required to unload the project file, make the change, then reload it for the change to take effect. This setting cannot be changed for an actively loaded project.</p>
<p>&nbsp;</p>
<h3 id="is-packagereference-support-limited-to-managed-c-cli-projects">Is PackageReference support limited to managed C++/CLI projects?</h3>
<p>In short, yes. It is important to support NuGet PackageReference for projects that touch .NET code since NuGet is the recommended dependency management solution for .NET. Furthermore, the C++ team will continue supporting C++/CLI projects as an interop story between C++ and .NET.</p>
<p>For native C++ projects, we recommend using vcpkg for both C++ open-source and closed source libraries. With compilation from source, binary caching, custom registries, version conflict resolution, and more, we believe this will provide the best experience for managing C/C++ dependencies. vcpkg can also target a large variety of platforms and architectures natively and works with any C++ build system.</p>
<p>With that said, we would love to hear your feedback on language interop scenarios with C++: <a href="https://developercommunity.visualstudio.com/report?space=8&amp;ftype=idea&amp;entry=suggestion">please file suggestion tickets</a> on Developer Community.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback</h3>
<p>We would love to hear from you! <a id="post-31177-_Hlk110857813"></a><a href="https://visualstudio.microsoft.com/">Download Visual Studio 2022</a>, give it a try, and file bugs or feature requests on <a href="https://developercommunity.visualstudio.com/home">Visual Studio Developer Community</a>. For new issues within NuGet, please report a <a href="https://github.com/NuGet/Home/issues/new/choose">GitHub Issue</a>. For general NuGet experience issues, let us know via the <a href="https://learn.microsoft.com/en-us/visualstudio/ide/how-to-report-a-problem-with-visual-studio?view=vs-2022">Report a Problem</a> option in Visual Studio found under the <em>Help &gt; Report A Problem </em>menu.</p>
<p>Feel free to leave comments in this blog post with your thoughts or reach out to us at <a href="mailto:visualc@microsoft.com">visualcpp@microsoft.com</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/">Announcing NuGet PackageReference support for C++/CLI MSBuild projects targeting .NET Core and .NET 5 or higher</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/announcing-nuget-packagereference-support-for-c-cli-msbuild-projects-targeting-net-core/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
			</item>
		<item>
		<title>Using system package manager dependencies with vcpkg</title>
		<link>https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/</link>
					<comments>https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/#comments</comments>
		
		<dc:creator><![CDATA[Daniel Shaw]]></dc:creator>
		<pubDate>Wed, 28 Sep 2022 21:55:20 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Vcpkg]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=31151</guid>

					<description><![CDATA[<p>According to C++ 2022 developer survey, the top 3 ways to manage C++ libraries were having the library source code as part of the build, compiling the library separately from instructions, and acquiring the library from a system package manager. Language package managers,</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/">Using system package manager dependencies with vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>According to C++ 2022 developer survey, the top 3 ways to manage C++ libraries were having the library source code as part of the build, compiling the library separately from instructions, and acquiring the library from a system package manager. Language package managers, such as vcpkg, simplify library management by offering the ease of use of a system package manager with the power, flexibility, and portability of building from source.</p>
<p>vcpkg brings several advantages to C++ library management. First, vcpkg supports a wide range of customizations for each library. vcpkg installs libraries with a specific version. For additional configuration, each library supports various features and flags. Second, the vcpkg catalog supports over 1900 libraries. Third, vcpkg brings finer control: once a library and feature set are selected, that library&#8217;s configuration will be consistent on any platform.</p>
<p>However, there are certain scenarios where using a system package manager is the better choice. You can deploy ABI compatible security and bug fixes without deploying the entire application. Multiple applications can use the same shared library, which reduces deployment size. And sometimes, company policy requires using a particular system package dependency. </p>
<p>In the first example, we will show what it will look like if we strictly use dependencies from vcpkg. In the second example, we will replace some dependencies with system package manager ones.</p>
<p>This blogpost is for advanced users of vcpkg. To get started with vcpkg instead, see <a href="https://github.com/microsoft/vcpkg">https://github.com/microsoft/vcpkg</a>.</p>
<h3 id="building-an-application-with-dependencies-from-the-vcpkg-catalog">Building an application with dependencies from the vcpkg catalog</h3>
<p>In this example, we are using Ubuntu 22.04 and the x64-linux triplet. First, create three files in an empty project directory: vcpkg.json, main.cpp, and CMakeLists.txt.</p>
<pre class="prettyprint">
//vcpkg.json
{
    "name": "test-project", 
    "version": "1.0.0",
    "dependencies": [
        "azure-core-cpp"
        "curl"
    ]
}</pre>
<pre class="prettyprint">
//main.cpp
#include &#60;curl/curl.h&#62;
#include &#60;azure/core/internal/strings.hpp&#62;
#include &#60;iostream&#62;

using namespace std;
using Azure::Core::_internal::StringExtensions;

int main() {
    cout &#60;&#60; curl_version() &#60;&#60; endl;
    cout &#60;&#60; StringExtensions::LocaleInvariantCaseInsensitiveEqual("aA", "aa") &#60;&#60; endl;
}</pre>
<pre class="prettyprint">
# CMakeLists.txt
cmake_minimum_required(VERSION 3.22)
project(test-project)
add_executable(main main.cpp)
find_package(CURL REQUIRED)
find_package(azure-core-cpp CONFIG REQUIRED)
target_link_libraries(main PUBLIC Azure::azure-core CURL::libcurl)</pre>
<p>Configuring the project:</p>
<pre class="prettyprint">cmake &#60;path to project&#62; -DCMAKE_TOOLCHAIN_FILE=&#60;path to vcpkg&#62;/scripts/buildsystems/vcpkg.cmake

... [build output]
Detecting compiler hash for triplet x64-linux...
The following packages will be built and installed:
azure-core-cpp[core,curl,http]:x64-linux -&#62; 1.7.1
curl[core,non-http,openssl,ssl]:x64-linux -&#62; 7.84.0#1
* openssl[core]:x64-linux -&#62; 3.0.5#4
* vcpkg-cmake[core]:x64-linux -&#62; 2022-07-18
* vcpkg-cmake-config[core]:x64-linux -&#62; 2022-02-06#1
* zlib[core]:x64-linux -&#62; 1.2.12#1
Additional packages (*) will be modified to complete this operation.
...</pre>
<p>Building and running main:</p>
<pre class="prettyprint">cmake --build . &#38;&#38; ./main

[ 50%] Building CXX object CMakeFiles/main.dir/main.cpp.o
[100%] Linking CXX executable main
[100%] Built target main
libcurl/7.82.0-DEV OpenSSL/3.0.2 zlib/1.2.12
1</pre>
<p>We can use ldd to list the shared libraries:</p>
<pre class="prettyprint">ldd main

linux-vdso.so.1 (0x00007ffc32bf1000)
libstdc++.so.6 =&#62; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f816357a000)
libm.so.6 =&#62; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f8163493000)
libgcc_s.so.1 =&#62; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f8163473000)
libc.so.6 =&#62; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f816324b000)
/lib64/ld-linux-x86-64.so.2 (0x00007f8163cf0000)</pre>
<h3 id="using-curl-and-openssl-from-the-system-package-manager">Using curl and OpenSSL from the system package manager</h3>
<p>You can use <a href="https://github.com/microsoft/vcpkg/blob/master/docs/specifications/ports-overlay.md" rel="noopener" target="_blank">port overlays</a> to configure vcpkg to use the system package manager dependencies. We will build the previous example and use curl and OpenSSL from the system package manager.</p>
<p>Install the developer dependencies for curl with an OpenSSL backend and OpenSSL:</p>
<pre class="prettyprint">sudo apt-get install libcurl4-openssl-dev libssl-dev</pre>
<p>Create the port overlay directory and file structure:</p>
<pre class="prettyprint">mkdir -p &#60;path to project&#62;/overlays/curl &#60;path to project&#62;/overlays/openssl</pre>
<pre class="prettyprint">//&#60;path to project&#62;/overlays/curl/vcpkg.json
{
    "name": "curl",
    "version": "1.0.0",
    "port-version": 0,
    "features": {
        "ssl": {
            "description": ""
        }
    }
}</pre>
<pre class="prettyprint"># &#60;path to project&#62;/overlays/curl/portfile.cmake
set(VCPKG_POLICY_EMPTY_PACKAGE enabled)</pre>
<pre class="prettyprint">//&#60;path to project&#62;/overlays/openssl/vcpkg.json
{
    "name": "openssl",
    "version": "3.0.5"
}</pre>
<pre class="prettyprint"># &#60;path to project&#62;/overlays/openssl/portfile.cmake
set(VCPKG_POLICY_EMPTY_PACKAGE enabled)</pre>
<p>Building with CMake (we’re using the same project in the previous example):</p>
<pre class="prettyprint">cmake &#60;path to project&#62; -DVCPKG_OVERLAY_PORTS=&#60;path to project&#62;/overlays -DCMAKE_TOOLCHAIN_FILE=&#60;path to vcpkg&#62;/scripts/buildsystems/vcpkg.cmake

-- Running vcpkg install
Detecting compiler hash for triplet x64-linux...
The following packages will be built and installed:
azure-core-cpp[core,curl,http]:x64-linux -&#62; 1.7.1
curl[core,non-http,openssl,ssl]:x64-linux -&#62; 7.84.0#1 -- &#60;path to project&#62;/overlays/curl
* openssl[core]:x64-linux -&#62; 3.0.5#4 -- &#60;path to project&#62;/overlays/openssl
* vcpkg-cmake[core]:x64-linux -&#62; 2022-07-18
* vcpkg-cmake-config[core]:x64-linux -&#62; 2022-02-06#1
Additional packages (*) will be modified to complete this operation.
...</pre>
<p>Building and running main:</p>
<pre class="prettyprint">cmake --build .
.\main

libcurl/7.81.0 OpenSSL/3.0.2 zlib/1.2.11 brotli/1.0.9 zstd/1.4.8 libidn2/2.3.2 libpsl/0.21.0 (+libidn2/2.3.2) libssh/0.9.6/openssl/zlib nghttp2/1.43.0 librtmp/2.3 OpenLDAP/2.5.11
1</pre>
<p>Checking whether we’ve linked the correct shared libraries (libssl and libcurl):</p>
<pre class="prettyprint">ldd main

libcurl.so.4 =&#62; /lib/x86_64-linux-gnu/libcurl.so.4 (0x00007f632c1c0000)
libssl.so.3 =&#62; /lib/x86_64-linux-gnu/libssl.so.3 (0x00007f632c11c000)
libcrypto.so.3 =&#62; /lib/x86_64-linux-gnu/libcrypto.so.3 (0x00007f632bcda000)
libstdc++.so.6 =&#62; /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f632baae000)
libm.so.6 =&#62; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f632b9c7000)
... (25+ more dependencies)</pre>
<p>You will notice curl and openssl from the system package manager have more dependencies than the curl and openssl from the vcpkg catalog. In the above example, we only added port overlays for the dependencies that we use. If you were to build a more complex application that would depend on other dependencies, you would need to add additional overlays.</p>
<p>Both the vcpkg and the system packager catalogs can contain the same library, and we need to make sure the application only links one copy of each library. Linking two different versions of the same library could lead to ODR violations.
In the example, curl from the system package manager pulls in OpenSSL as a dependency. We overlayed the OpenSSL dependency in vcpkg to prevent vcpkg from also acquiring OpenSSL from its catalog.</p>
<h4 id="how-did-cmake-find-curl"> How did CMake find curl?</h4>
<p>When find_package(CURL) is called, CMake searches for the CURL libraries in the vcpkg_installed directory. If the CURL libraries are not found on the CMake paths, it defaults to the FindCurl module which finds the system dependency.</p>
<h3 id="learn-more"> Learn More </h3>
<p>If you would like to contribute to vcpkg and its library catalog, or want to give us feedback on anything, check out our <a href="https://github.com/microsoft/vcpkg/" rel="noopener" target="_blank">GitHub repo</a>. Please report bugs or request updates to ports in our <a href="https://github.com/microsoft/vcpkg/issues" rel="noopener" target="_blank">issue tracker</a> or join a more general discussion in our <a href="https://github.com/microsoft/vcpkg/discussions" rel="noopener" target="_blank">discussion forum</a>. For an overview of our top priorities and backlog, take a look at our <a href="https://github.com/microsoft/vcpkg/wiki/Roadmap" rel="noopener" target="_blank">roadmap</a> page.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/">Using system package manager dependencies with vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/using-system-package-manager-dependencies-with-vcpkg/feed/</wfw:commentRss>
			<slash:comments>6</slash:comments>
		
		
			</item>
		<item>
		<title>A Visual Studio Debugger Extension for the Raspberry Pi Camera</title>
		<link>https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/</link>
					<comments>https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/#comments</comments>
		
		<dc:creator><![CDATA[Paul Maybee]]></dc:creator>
		<pubDate>Wed, 21 Sep 2022 15:04:55 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=30885</guid>

					<description><![CDATA[<p>While developing a sample application for a Raspberry Pi with a camera using the RaspiCam library, it occurred to me that it would be convenient and fun to be able to see the current camera input while debugging the application.  The Visual Studio debugger supports type-specific custom visualizers and end-user extensions that implement UI for these visualizers.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/">A Visual Studio Debugger Extension for the Raspberry Pi Camera</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>While developing a sample application for a Raspberry Pi with a camera using the <a href="https://github.com/rmsalinas/raspicam">RaspiCam</a> library, it occurred to me that it would be convenient and fun to be able to see the current camera input while debugging the application.  The Visual Studio debugger supports type-specific custom visualizers and end-user extensions that implement UI for these visualizers. I decided to make one for the RaspiCam camera types that would display the current image from the camera. The image below is the end result, showing Visual Studio debugging a program running on the Raspberry Pi and displaying the content of a Raspberry Pi camera object in a pop-up debugger visualizer.</p>
<p><img class="aligncenter" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2022/08/Picture1.png" alt="Picture of rasperry pi displaying camera" /></p>
<h5 id="build-a-raspicam-application">Build a RaspiCam Application</h5>
<p><span class="TextRun SCXW83782341 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentStart CommentHighlightPipeRest CommentHighlightRest SCXW83782341 BCX8">I needed a sample Raspberry Pi camera application.</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> I downloaded the <a href="https://gnutoolchains.com/raspberry/">Raspberry Pi SDK</a></span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> and a CM</span><span class="NormalTextRun SpellingErrorV2Themed CommentHighlightRest SCXW83782341 BCX8">ake</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> toolchain to my windows machine</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">. I downloaded </span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">the <a href="https://github.com/rmsalinas/raspicam">Raspiam cd camera library</a> </span></span><span class="TextRun SCXW83782341 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">and <a href="https://github.com/opencv/opencv">OpenCV</a></span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">. I used the Raspberry Pi toolchain to build </span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8">both these repositories. I then created a new CM</span><span class="NormalTextRun SpellingErrorV2Themed CommentHighlightRest SCXW83782341 BCX8">ake</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> project in Visual Studio, wrote a simple camera application and linked to these two libraries. My </span><span class="NormalTextRun SpellingErrorV2Themed CommentHighlightRest SCXW83782341 BCX8">CMakePresets.json</span><span class="NormalTextRun CommentHighlightRest SCXW83782341 BCX8"> file contains this configuration</span><span class="NormalTextRun CommentHighlightPipeRest SCXW83782341 BCX8">:</span></span><span class="EOP SCXW83782341 BCX8" data-ccp-props="{}"> </span></p>
<pre class="prettyprint">  "configurePresets": [
    {
      "name": "raspberrypi-Debug",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/out/build/${presetName}",
      "installDir": "${sourceDir}/out/install/${presetName}",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": "Debug",
        "CMAKE_TOOLCHAIN_FILE": "C:/temp/raspberry/toolchain-rpi.cmake",
        "OpenCV_DIR": "D:\\opencv-4.5.5\\opencv-4.5.5\\out\\install\\RaspberryPi-Debug\\lib\\cmake\\opencv4",
        "raspicam_DIR": "D:\\raspicam\\out\\install\\raspberrypi-Debug\\lib\\cmake"
      },
      "environment": {
        "RASPBIAN_ROOTFS": "c:/temp/raspberry/arm-linux-gnueabihf/sysroot",
        "PATH": "c:/temp/raspberry/bin;$env{Path}"
      }
    }
  ],
  "buildPresets": [
   {
      "name": "cross-build",
      "environment": {
        "PATH": "c:/temp/raspberry/bin;$penv{PATH}"
      },
      "configurePreset": "raspberrypi-Debug"
    }
  ]
</pre>
<p>My Raspberry Pi application uses the OpenCV library and the <code>RaspiCam_Still_Cv</code> camera type for capturing and manipulating the camera image.</p>
<pre>    raspicam::RaspiCam_Still_Cv Camera;
    cv::Mat image;

    Camera.open();
    Camera.grab();
    Camera.retrieve(image);
    cv::imwrite("raspicam_cv_image.jpg", image);</pre>
<p>I wanted to debug this application on the Pi so I added the launch configuration below. This instructs the debugger to first deploy the application to my RaspberryPi device in directory ~/camera. I copied all the shared OpenCV and RaspiCam libraries I needed to this directory too.</p>
<pre>    {
      "type": "cppgdb",
      "name": "DebugOnPi",
      "project": "CMakeLists.txt",
      "projectTarget": "simpletest_raspicam",
      "debuggerConfiguration": "gdb",
      "MIMode": "gdb",
      "args": [],
      "env": {},
      "deployDirectory": "~/camera",
      "remoteMachineName": "<em>&lt;your-connection-name-here&gt;</em>",
      "preDebugCommand": "export LD_LIBRARY_PATH=~/camera"
    }</pre>
<p>I could now debug on the Raspberry Pi.</p>
<h5 id="add-visualizers-to-the-linux-debugger">Add Visualizers to the Linux Debugger</h5>
<p>Although the Visual Studio Windows debugger supports UI visualizers, it turned out that the Visual Studio Linux debugger did not have this feature implemented.  Since the Raspberry Pi runs Raspian, a Debian Linux variant, the first thing I had to do was fix that. The Linux debugger is an open source project called <a href="https://github.com/Microsoft/MIEngine">MIEngine</a>. The MIEngine runs as a Visual Studio debugger “engine” that controls a gdb process running remotely on a Linux host. The MIEngine already supported custom variable visualization using <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2022">natvis</a> files (example below). However, it did not support the <code>UIVizualizer</code> tag in natvis files which is necessary to open a new visualization window containing, for example, a camera image. The work described here is now part of the MIEngine and in Visual Studio. The completed PR with the changes is <a href="https://github.com/microsoft/MIEngine/pull/1281">here</a>. Remember it’s open source, so you too can contribute in this way!</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010"&gt;
     &lt;UIVisualizer ServiceId="{0A73397B-D550-4BFE-94C9-C0E5122DC06F}" Id="1"
             MenuName="Raspberry Still Camera (OpenCV) Visualizer"/&gt;

      &lt;Type Name="raspicam::RaspiCam_Still_Cv"&gt;
         &lt;UIVisualizer ServiceId="{0A73397B-D550-4BFE-94C9-C0E5122DC06F}" Id="1" /&gt;
      &lt;/Type&gt;            
&lt;/AutoVisualizer&gt;</pre>
<p>There were two changes I needed to make to the MIEngine: First was to recognize and process the <code>UIVisualizer</code> element in natvis files and second was to automatically load natvis files for registered Visual Studio extensions.</p>
<ul>
<li>Recognizing the element was simple. The MIEngine already parsed natvis files, it was just ignoring the <code>UIVisualizer</code> element. I simply changed the natvis lookup code to return not just the visualized string value for an expression, but also a list of any <code>UIVisualizers</code> that were present for the expression type. The MIEngine returns an expression value to the Visual Studio debugger as an <code><a href="https://github.com/microsoft/MIEngine/blob/main/src/MIDebugEngine/AD7.Impl/AD7Property.cs">AD7Property</a></code>. I updated the <code>AD7Property</code> class to also return the list of <code>UIVisualizers</code> found.</li>
<li>The MIEngine makes requests of Visual Studio via its <code><a href="https://github.com/microsoft/MIEngine/tree/main/src/DebugEngineHost">DebugEngineHost</a></code>. In order to support visualization, I needed to call into Visual Studio from the <code>DebugEngineHost</code> and ask it for an <code>IVsExtensionManagerPrivate</code> service reference. I then called into the resulting service asking for a list of all resources tagged as “<code>NativeCrossPlatformVisualizer</code>”. It returned a list of file names for resources that have this tag. These are given to the MIEngine natvis processor for parsing.</li>
</ul>
<p>Finally, there was an additional feature that was missing from the MIEngine. It didn’t have a convenient way for a caller holding an <code>AD7Property</code> object to determine the execution context (that is, stack frame) where the expression that generated that property was evaluated. So, I extended the <code>AD7Property</code> class to implement a new interface <code><a href="https://github.com/microsoft/MIEngine/blob/main/src/DebugEngineHost.Stub/Shared/Microsoft.VisualStudio.Debugger.Interop.MI.cs">IDebugMIEngineProperty</a></code> that contains a method for returning the properties <code>IDebugExpressionContext2</code>. Now all the parts are in place for developing a <code>UIVisualizer</code> for Linux applications.</p>
<h5 id="create-a-visualizer-vsix-project">Create a Visualizer VSIX Project</h5>
<p>The <code>UIVisualizer</code> for a data type is identified in natvis by a GUID <em>ServiceId</em> and an integer <em>Id</em>. These are the values the debugger will use to find and open the associated visualizer. The <em>ServiceId</em> identifies a type that implements <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.debugger.interop.ivscppdebuguivisualizer?view=visualstudiosdk-2022"><code>VsCppDebugUIVisualizer</code></a>. The Id identified which of its visualizers to open – in the case that more than one visualizer is supported by the service. I needed to author a service for my camera picture viewer as a visual studio extension.</p>
<p>To start, I created a VSIX (Visual Studio extension project) called PictureViewer (you need to have the “Visual Studio extension development” workload installed). Then I defined an interface for my visualizer tagged with my viewer’s <em>ServiceId</em> and attributed the VSIX Package object with this interface. I now had to define the relationship between the <code>UIVisualizer</code> element in the natvis file with this VSIX package.</p>
<pre>[Guid("0A73397B-D550-4BFE-94C9-C0E5122DC06F")]
public interface IPictureViewerService
{
}
…
[PackageRegistration(UseManagedResourcesOnly = true, AllowsBackgroundLoading = true)]
[ProvideService(typeof(IPictureViewerService), ServiceName = "PictureViewerService", IsAsyncQueryable = true)]
[Guid(PictureViewerPackage.PackageGuidString)]
public sealed class PictureViewerPackage : AsyncPackage
{
…
}</pre>
<p>I then added a new <code>PictureViewerService</code> that implements both <code>IPictureViewerService</code> and <code>IVsCppDebugUIVisualizer</code>. The only method it implements is <code>IVsCppDebugUIVisualizer.DisplayValue</code>.</p>
<pre>int DisplayValue(uint ownerHwnd, uint visualizerId, IDebugProperty3 debugProperty)

</pre>
<p>This is the API called by the debugger to display a value using a custom <code>UIVisualizer</code>. The already evaluated expression value is passed to the visualizer in the <code>debugProperty</code> object.</p>
<p>I implemented my UI in class <code>PictureViewerViewModel</code>. The UI in this example is very simple, just an Image and a Button in a pop-up window. When the service activates the UI the view model object fires off a task to load the image from the application being debugged and then invokes <code><a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.window.showdialog?view=netframework-4.7.2">ShowDialog</a></code>. The XAML snippet below defines the content of the dialog.</p>
<pre>&lt;Grid Margin="4"&gt;
    &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="*" /&gt;
        &lt;RowDefinition Height="Auto" /&gt;
    &lt;/Grid.RowDefinitions&gt;
    &lt;Image Width="{Binding Image.Width}" Height="{Binding Image.Height}"
        Source="{Binding Image}"/&gt;
    &lt;Button Grid.Row="1" Margin="4,0" x:Uid="LoadNext_Button"
            Content="Next"
            Command="{Binding ClickCommand, Mode=OneTime}" /&gt;
&lt;/Grid&gt;

</pre>
<p>The view model is where the work is done to populate the UI from the camera content. In this case I was interested in retrieving JPEG content from the camera and using it to create a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.windows.media.imaging.bitmapimage?view=netframework-4.7.2">BitmapImage</a>. To get an image from a camera object the debugger must perform the same operations that the application would have to do to do the same thing. Or more accurately, the debugger must instruct the debuggee to do these steps using expression evaluation. The code below uses Visual Studio debugger APIs to evaluate a string expression given an <code>IDebugMIEngineProperty</code> <em>context</em>. It returns both a string with the debugger’s result of the evaluation and a memory context object that can be used to read the raw bytes of that result.</p>
<pre>private DEBUG_PROPERTY_INFO EvalExpression(string expr, out IDebugMemoryContext2 ppMemory)
{

   if (context.ParseText(expr, enum_PARSEFLAGS.PARSE_EXPRESSION, 10, out IDebugExpression2 ppExpr, out string error, out uint errorCode) != VSConstants.S_OK)
   {
      throw new ApplicationException($"Failed to parse expression '{expr}'.");
   }

   if (ppExpr.EvaluateSync(0, 0, null, out IDebugProperty2 prop) != VSConstants.S_OK)
   {
      throw new ApplicationException($"Failed to evaluate expression '{expr}'.");
   }

   DEBUG_PROPERTY_INFO[] value = new DEBUG_PROPERTY_INFO[1]; ;
   if (prop.GetPropertyInfo(enum_DEBUGPROP_INFO_FLAGS.DEBUGPROP_INFO_VALUE, 10, 0, null, 0, value) != VSConstants.S_OK)
   {
      throw new ApplicationException($"Failed to get expression value for '{expr}'.");
   }

   if (prop.GetMemoryContext(out ppMemory) != VSConstants.S_OK)
   {
      ppMemory = null;
   }

   return value[0];
}

</pre>
<p>Now I needed to implement the right sequence of expression evaluations. I based the sequence on the sample C++ code below that retrieves an in-memory jpg image from a camera object.</p>
<pre>raspicam::RaspiCam_Still_Cv Camera;
...
cv::Mat image;
Camera.grab();
Camera.retrieve(image);

vector&lt;uchar&gt; jpgImage;
vector&lt;int&gt; jpgParams;
cv::InputArray ia = cv::_InputArray(image);
string jpg = ".jpg";

cv::imencode(jpg, ia, jpgImage, jpgParams);

</pre>
<p>Since I have registered the visualizer for the camera type, the debugProperty object that is passed into the visualizer will contain the results of evaluating a <code>RaspiCam_Still_Cv</code> object. It can be cast to an <code>IDebugMIEngineProperty</code> and used to get a context for evaluating expressions. The final result is that the debuggee application creates an in-memory object containing a JPEG image. The debugger then reads the bytes from the debuggee memory and creates the BitmapImage.</p>
<p>The first thing you might notice is that this sequence of evaluations involves creating several objects: <em>image</em>, <em>jpgImage</em>, <em>jpgParams</em>, <em>ia</em>, and <em>jpg</em>. These objects do not exist on the debuggee so they must be created. To create an object via expression evaluation, the debugger must first malloc the memory for the object and then invoke the object’s constructor. I do this in <code>MakeHeapObject</code> below:</p>
<pre>private string MakeHeapObject(string type, string constructor, string cparams = "")
{
   var address = this.EvalExpression($"malloc(sizeof({type}))");
   if (!address.bstrValue.StartsWith("0x"))
   {
      throw new ApplicationException(address.bstrValue);
   }

   var init = this.EvalExpression(
                $"(({type} *){address.bstrValue})-&gt;{constructor}({cparams})");
   return address.bstrValue;
}</pre>
<p>For example, to make an object of type “<code>vector&lt;int&gt;</code>,” the visualizer calls:</p>
<pre>this.MakeHeapObject("std::vector&lt;int, std::allocator&lt;int&gt; &gt;", "vector")

</pre>
<p>A string containing the new object’s address in the debuggee is returned, for example “<code>0xf7003421</code>”. <span class="NormalTextRun SCXW228642498 BCX9">The object is similarly </span><span class="NormalTextRun SCXW228642498 BCX9">deleted</span><span class="NormalTextRun SCXW228642498 BCX9"> in </span><code><span class="NormalTextRun SpellingErrorV2Themed SCXW228642498 BCX9">FreeHeapObject</span></code><span class="NormalTextRun SCXW228642498 BCX9"> when it is no longe</span><span class="NormalTextRun SCXW228642498 BCX9">r</span><span class="NormalTextRun SCXW228642498 BCX9"> needed. Notice that </span><span class="NormalTextRun SCXW228642498 BCX9">it is possible to introduce new interactions that would not have occurred whenever running code in the </span><span class="NormalTextRun SpellingErrorV2Themed SCXW228642498 BCX9">debuggee</span><span class="NormalTextRun SCXW228642498 BCX9">. It may not be</span><span class="NormalTextRun SCXW228642498 BCX9"> safe </span><span class="NormalTextRun SCXW228642498 BCX9">to create and destroy </span><span class="NormalTextRun SCXW228642498 BCX9">objects that</span> <span class="NormalTextRun SCXW228642498 BCX9">affect</span> <span class="NormalTextRun SCXW228642498 BCX9">shared resources.</span></p>
<p>Now all the pieces are in place for evaluating the sequence of expressions necessary to get the jpg image into a debuggee in-memory byte array. Once this is done the <code>IDebugMemoryContext2</code> is used to read the bytes from debuggee memory into a buffer in Visual Studio. The Bitmap image is created from a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.memorystream?view=netframework-4.7.2">MemoryStream</a> built on that buffer.</p>
<p>The VSIX project also needs to contain the .natvis file containing the type-to-Visualizer mapping (see top of this section). The VSIX manifest points to the file and tags it as a “<code>NativeCrossPlatformVisualizer</code>” asset.</p>
<pre>  &lt;Asset Type="NativeCrossPlatformVisualizer" Path="raspicam.natvis"/&gt;</pre>
<p>All the details can be found in <a href="https://github.com/microsoft/VisualStudioMIEnginePictureViewer">this git repository</a>, including the sample CMake application (above) to test with.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/">A Visual Studio Debugger Extension for the Raspberry Pi Camera</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/a-visual-studio-debugger-extension-for-the-raspberry-pi-camera/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
	</channel>
</rss>
