<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C++ Team Blog</title>
	<atom:link href="https://devblogs.microsoft.com/cppblog/feed/" rel="self" type="application/rss+xml" />
	<link>https://devblogs.microsoft.com/cppblog</link>
	<description>C++ tutorials, C and C++ news, and information about Visual Studio, Visual Studio Code, and Vcpkg from the Microsoft C++ team.</description>
	<lastBuildDate>Wed, 31 Mar 2021 20:49:54 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2018/10/Microsoft-Favicon.png</url>
	<title>C++ Team Blog</title>
	<link>https://devblogs.microsoft.com/cppblog</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>vcpkg Host Dependencies for Cross-Compilation</title>
		<link>https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/</link>
					<comments>https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/#respond</comments>
		
		<dc:creator><![CDATA[Robert Schumacher]]></dc:creator>
		<pubDate>Wed, 31 Mar 2021 18:28:10 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27828</guid>

					<description><![CDATA[<p>If you’re not familiar with our C++ library manager vcpkg, welcome! This post covers an intermediate/advanced topic, so you may want to first get an overview and try things out from the vcpkg GitHub page or some of our previous blogs.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/">vcpkg Host Dependencies for Cross-Compilation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[</p>
<p>If you’re not familiar with our C++ library manager vcpkg, welcome! This post covers an intermediate/advanced topic, so you may want to first get an overview and try things out from the <a href="https://github.com/Microsoft/vcpkg">vcpkg GitHub page</a> or some of <a href="https://devblogs.microsoft.com/cppblog/?s=vcpkg">our previous blogs</a>.</p>
<p>&nbsp;</p>
<h3 id="introduction">Introduction</h3>
<p>One of the best features of C++ is that it generates tailored, specialized code for each specific machine, enabling you to squeeze every ounce of performance per watt. It enables clean abstractions to coexist peacefully with low-level platform-specific bit twiddling. However, this comes at a price for many developers that venture beyond their own machine: you must build different binaries for your developer machine compared to your final target, be it a phone, a cloud server, or an embedded microcontroller.</p>
<p>For most small-to-medium sized projects, this isn’t a problem. You already have a compiler, a code editor, and a build system, which is plenty to make tons of incredible applications. However, since time immemorial some developers need even more flexibility, extensibility, and power than just the compiler; they need to generate sophisticated code at build time. Maybe it’s computing a <a href="https://en.wikipedia.org/wiki/Perfect_hash_function">perfect hash function</a> over your known data set, maybe it’s a <a href="https://en.wikipedia.org/wiki/Yacc">table-driven parser</a>, or maybe it’s a bunch of <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">foreign function interface</a> boilerplate into your embedded scripting language. For whatever reason, you need the flexibility of C++ <em>for your development environment</em> in addition to the final runtime target.</p>
<p>In this blog post we’ll cover the newly shipped vcpkg feature designed to enable all these scenarios and more: <strong>Host Dependencies</strong>.</p>
<p>&nbsp;</p>
<h3 id="simultaneous-compilation">Simultaneous Compilation</h3>
<p>As mentioned in the introduction, because C++ compiles all the way down to the metal, you generally can’t use the same compiler and flags to simultaneously target your final runtime and your developer machine. If you’re using a multi-targeting compiler like Clang/LLVM you’ll need at least different flags and if you’re using a single-target compiler like GCC or MSVC you’ll need an entirely different compiler.</p>
<p>If you’re lucky, your buildsystem has specific documentation for how to handle this case. Even then, it can sometimes be extremely subtle to ensure things are wired up correctly: Did you accidentally pass the flags for the target to the developer machine build? What if you need libraries for your code generator to run? What about code generators generating code for other code generators? It’s a tricky problem space that has ramifications on every aspect of the build environment.</p>
<p>&nbsp;</p>
<h3 id="triplets">Triplets</h3>
<p>In vcpkg, we label each target universe as a separate &#8220;triplet&#8221;. For example, x64 Windows Desktop using dynamic CRT and MSVC, but building static libraries might be named <code>x64-windows-static-md</code>. Each library built within that universe links against other libraries from that universe, keeping everything super consistent. We include many triplet definitions in the box, but you can easily make your own to tweak compiler flags or adjust settings on a per-library basis (maybe you’d like Qt to be built dynamically, but your JSON parser built statically).</p>
<p>Naturally, your developer environment also matches one of these universes. By default, we pick <code>x64-windows</code>, <code>x64-linux</code>, or <code>x64-osx</code> as appropriate but it’s fully configurable at runtime via <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/host-dependencies.md#specifying-the-host-triplet">several methods</a>.</p>
<p>&nbsp;</p>
<h3 id="host-dependencies">Host Dependencies</h3>
<p>Despite having a triplet matching the developer environment, vcpkg didn’t have syntax for libraries to express a dependency upon a port built for that environment. We’ve gotten very far with imperfect approaches, like dynamically attempting to consume libraries from a hardcoded set of fallback triplets, however these would always fall short of the ideal and required imperfect, copied code between different ports. These workarounds also fall completely flat in <a href="https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/">manifest mode</a>, which is specifically designed to prevent the flaky behaviors that occur with these sorts of “dynamic” accesses. The fix is, of course, a way to naturally and directly express a requirement upon ports built for the developer environment.</p>
<p><strong>Enter: Host Dependencies. Available now, ports and consumers can now declare dependencies upon other ports built against the developer environment.</strong></p>
<p>The syntax to activate this is simply setting <code>"host"</code> to <code>true</code> in the manifest dependency object:</p>
<pre class="prettyprint">{
    "dependencies": [
        { "name": "contoso-cgen", "host": true }
    ]
}</pre>
<p>During execution, a port can rely on all host dependencies having been installed to <code>CURRENT_HOST_INSTALLED_DIR</code> (the analog of <code>CURRENT_INSTALLED_DIR</code>) and they can get the currently configured host triplet via <code>HOST_TRIPLET</code> (the analog of <code>TARGET_TRIPLET</code>).</p>
<pre class="prettyprint">set(CGEN ${CURRENT_HOST_INSTALLED_DIR}/tools/contoso-cgen/cgen${VCPKG_HOST_EXECUTABLE_SUFFIX})
vcpkg_cmake_configure(
    SOURCE_PATH ${SOURCE_PATH}
    OPTIONS -DCODE_GENERATOR=${CGEN}
)</pre>
<p>For projects that have their own code generators embedded inside, it’s perfectly valid to require <em>yourself</em> built for the host:</p>
<pre class="prettyprint">{
    "name": "protobuf",
    "dependencies": [
        { "name": "protobuf", "host": true }
    ]
}</pre>
<p>Then, the port can determine if it is cross-building or native-building by comparing the triplets:</p>
<pre class="prettyprint">if(HOST_TRIPLET STREQUAL TARGET_TRIPLET)
  # Native compilation, set build flags to build and install the code generator
else()
  # Cross compilation, set build flags to consume the prebuilt code generator
  # from ${CURRENT_HOST_INSTALLED_DIR}
endif()</pre>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback!</h3>
<p>Try out vcpkg by visiting our <a href="https://github.com/microsoft/vcpkg">GitHub repo</a>. We welcome your feedback on the tool and the new features <a href="https://github.com/microsoft/vcpkg/issues">in our issue tracker</a>. </p>
<p>We&#8217;ve only just begun incorporating this powerful new facility into the existing catalog, such as for Boost.Build (<a href="https://github.com/microsoft/vcpkg/blob/b5bb1511f0a07be530e0bde3ae098eb3d8e83e68/ports/boost-date-time/vcpkg.json#L10-L13">vcpkg/vcpkg.json at master · microsoft/vcpkg (github.com)</a>) and Protobuf (<a href="https://github.com/microsoft/vcpkg/blob/b5bb1511f0a07be530e0bde3ae098eb3d8e83e68/ports/protobuf/vcpkg.json#L8-L11">vcpkg/vcpkg.json at master · microsoft/vcpkg (github.com)</a>). It&#8217;s an enormous step forward for vcpkg users targeting important platforms such as iOS, Android, and Emscripten/WebAssembly.</p>
<p>The current up-to-date documentation on Host Dependencies can be found on our GitHub at <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/host-dependencies.md">vcpkg/host-dependencies.md at master · microsoft/vcpkg (github.com)</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/">vcpkg Host Dependencies for Cross-Compilation</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/vcpkg-host-dependencies/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 16.9</title>
		<link>https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/</link>
					<comments>https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/#comments</comments>
		
		<dc:creator><![CDATA[Jordan Maples]]></dc:creator>
		<pubDate>Wed, 17 Mar 2021 10:58:32 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[General C++ Series]]></category>
		<category><![CDATA[Writing Code]]></category>
		<category><![CDATA[cppcorecheck]]></category>
		<category><![CDATA[static analysis]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27707</guid>

					<description><![CDATA[<p>The C++ static analysis team&#8217;s goal is to make your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the C++ Developer Community page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/">Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 16.9</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The C++ static analysis team&#8217;s goal is to make your C++ coding experience as safe as possible. We are adding richer code safety checks and addressing high impact customer feedback bugs posted on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">C++ Developer Community</a> page. Thank you for engaging with us and giving us great feedback on the past releases and early previews leading to this point. Going forward, the C++ team will provide a list of code analysis bug and crash fixes with every GA release of Visual Studio. Below is the compilation of improvements and bug fixes that were made from VS 2019 16.8 to 16.9 for <a href="https://docs.microsoft.com/en-us/cpp/build/reference/analyze-code-analysis">code analysis</a> and <a href="https://docs.microsoft.com/en-us/cpp/code-quality/using-the-cpp-core-guidelines-checkers">Cpp Core Check</a>.</p>
<h3 id="analysis-crash-fixes">Analysis crash fixes:</h3>
<ul>
<li>Using an index operator on the address of a non-address and non-array object.</li>
</ul>
<pre class="prettyprint">void function() {
    int buf{};
    ((unsigned char*)&amp;buf)[3] = 1;
}</pre>
<ul>
<li>Functions with more than 255 arguments would cause a crash during analysis.</li>
<li>Array member field addresses were incorrectly converted in dynamic initializer function.</li>
<li>Fixed internal compiler error for aggregate initialization in /analyze.</li>
</ul>
<pre class="prettyprint">char c[]{'1', {}};</pre>
<ul>
<li>Fixed a crash caused during analysis of bitfields and enums.</li>
</ul>
<pre class="prettyprint">struct TestStruct {
public:
    enum TestEnum : char { Dummy };
    TestEnum    m1 : 1;
    TestEnum    m2 : 1;
    short       m3;
}

TestStruct Test() {
    return{ TestStruct::Dummy, TestStruct::Dummy, {} };
}</pre>
<ul>
<li>Specifying an array of three elements but only providing two elements in the initializer list.</li>
</ul>
<pre class="prettyprint">#include &lt;array&gt;
#include &lt;string&gt;
using namespace std;
void function() {
    array&lt;string, 3&gt; arr {"one", "two"};
}</pre>
<ul>
<li>Fixed crash on empty KMDF projects.</li>
</ul>
<h3 id="bug-fixes">Bug fixes:</h3>
<ul>
<li>Addressed noisy warnings in an object&#8217;s destructor when a function that would have initialized or updated the object fails.</li>
<li>Support for the GSL functions <code>gsl::as_bytes</code> and <code>gsl::as_writable_bytes</code> was added to prevent <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26710">C26710</a> warnings from being issued against otherwise valid buffer accesses.</li>
</ul>
<pre class="prettyprint">#include &lt;gsl/span&gt;
void fn1(gsl::span&lt;int, 5&gt; view, byte val) {
    auto bview = as_writable_bytes(view);
    bview[19] = val;  // OK
    bview[20] = val;  // C26710 &amp; C26000
}</pre>
<ul>
<li>Fixed ruleset loading failures that occurred when a relative path of a ruleset was used in combination with the exact path of a ruleset directory.
E.g: <code>/analyze:rulesetdirectory f:\customRuleset /analyze:ruleset myrules.ruleset</code></li>
<li>Fixed false positives of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c6237">C6237</a> and <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c6285">C6285</a> on <code>if constexpr</code> expressions.</li>
</ul>
<pre class="prettyprint">constexpr bool get_condition_a() { return false; }
constexpr bool some_other_check() { return true; }
constexpr void f1() {
    constexpr bool some_condition = get_condition_a();
    if constexpr (some_condition &amp;&amp; some_other_check()) {  //Previously issued C6237
        //...
    }
}

constexpr void f2() {
    constexpr int print_debug = false;
    constexpr int headers_debug = false;
    if constexpr (print_debug == true || headers_debug == true) { //Previously issued C6285
        //...
    }
}</pre>
<ul>
<li>Fixed false positive of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26444">C26444</a> when returning upon construction.</li>
</ul>
<pre class="prettyprint">struct Test {
    int i{};
};

Test foo() {
    return Test(); //Previously issued C26444
}</pre>
<ul>
<li>Fixed issue where casts with the same source and destination types were being misidentified as reinterpret cast, which would produce <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26490">C26490</a> instead of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26473">C26473</a>.</li>
</ul>
<pre class="prettyprint">struct S{};
void foo(S* s) {
    S* s2 = static_cast&lt;S*&gt;(s); //Previously C26490, now C26473
}</pre>
<ul>
<li>Fixed an incorrect <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26465">C26465</a> warning when attempting to cast away const. <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26492">C26492</a> will now be issued instead.</li>
</ul>
<pre class="prettyprint">struct S{};
void foo(const S&amp; s) {
    const S* pS = &amp;s;
    S* s2 = const_cast&lt;S*&gt;(pS); //Previously C26465, now C26492
}</pre>
<ul>
<li>Fixed false positive for <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26814">C26814</a> that would be issued on <code>const</code> member variables.</li>
<li>Fixed corner case where PREFast entered an infinite loop while examining buffer extents.</li>
<li>Fixed false positive of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26815">C26815</a> that fired when assigning a value to a <code>std::optional</code> that is passed by reference into a function.</li>
<li>Fixed false positive <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26816">C26816</a> when returning a pointer from a vector of pointers.</li>
<li>Fixed false positive of <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26485">C26485</a> which appeared when calls to printf used string literals chosen by a ternary operator.</li>
</ul>
<h3 id="additional-changes">Additional changes:</h3>
<ul>
<li>Updated support for SARIF format to conform to the version 2.1 specification.</li>
<li>Added SARIF support for additional rule action levels for ruleset files.
The rule actions can now be specified as “None”, “Default”, “Info”, “Warning”, and “Error”.</li>
<li>Removed <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26443">C26443</a> – The enforcement for <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final">C.128</a> has changed making C26443 obsolete.</li>
</ul>
<pre class="prettyprint">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RuleSet Name="Example For Warning Levels" Description="" ToolsVersion="16.0"&gt;
  &lt;IncludeAll Action="Info" /&gt;
  &lt;Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis"
         RuleNamespace="Microsoft.Rules.Native"&gt;
    &lt;Rule Id="C6001" Action="Error" /&gt;
    &lt;Rule Id="C6011" Action="Warning" /&gt;
    &lt;Rule Id="C6101" Action="Info" /&gt;
    &lt;Rule Id="C6201" Action="Default" /&gt;
    &lt;Rule Id="C6386" Action="None" /&gt;
  &lt;/Rules&gt;
&lt;/RuleSet&gt;</pre>
<ul>
<li>Using a C-style void cast to ignore return values decorated with <code>[[nodiscard]]</code> previously issued <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26493">C26493</a> urging developers to not use C-style casts. The new rule <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26457">C26457</a> will be issued in its place, guiding the developer to assign the return value to <code>std::ignore</code> if they intend to discard the return value.</li>
</ul>
<pre class="prettyprint">#include &lt;tuple&gt;

struct S{};
[[nodiscard]] S fn1();

void function() {
    (void)fn1(); //Previously C26493, now C26457
    std::ignore = fn1();
}</pre>
<ul>
<li>The text for <a href="https://docs.microsoft.com/en-us/cpp/code-quality/c26496">C26496</a> was updated from <code>“The variable '%variable%' is assigned only once, mark it as const (con.4)”</code> to <code>“The variable '%variable%' does not change after construction, mark it as const (con.4)”.</code></li>
</ul>
<p>As mentioned earlier, the work that we do is heavily influenced by feedback we receive on the <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a> so thank you again for your participation. Please continue to file feedback and let us know if there is a checker or rule that you would like to see added to C++ Core Check.</p>
<p>Stay tuned for more C++ static analysis blogs as we work towards 16.10. Coming soon are posts on improvements to C++ Core Check rules, improved diagnostics, and an update on the Microsoft/GSL GitHub project. In the meanwhile, do not hesitate to reach out to us. We can be reached via the comments below or <a href="https://twitter.com/visualc">@VisualC</a> on Twitter.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/">Static Analysis Fixes, Improvements, and Updates in Visual Studio 2019 16.9</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/static-analysis-fixes-improvements-and-updates-in-visual-studio-2019-16-9/feed/</wfw:commentRss>
			<slash:comments>11</slash:comments>
		
		
			</item>
		<item>
		<title>IntelliSense Improvements in Visual Studio 2019</title>
		<link>https://devblogs.microsoft.com/cppblog/intellisense-improvements-in-visual-studio-2019/</link>
					<comments>https://devblogs.microsoft.com/cppblog/intellisense-improvements-in-visual-studio-2019/#comments</comments>
		
		<dc:creator><![CDATA[Will Buik]]></dc:creator>
		<pubDate>Wed, 10 Mar 2021 06:02:16 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27741</guid>

					<description><![CDATA[<p>We’ve made many great improvements to C++ IntelliSense over the course of the Visual Studio 2019 release. We’ve collected a few of the highlights in case you are interested in upgrading to Visual Studio 2019 or just want to learn how to be more productive when writing C++ code.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/intellisense-improvements-in-visual-studio-2019/">IntelliSense Improvements in Visual Studio 2019</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We’ve made many great improvements to C++ IntelliSense over the course of the Visual Studio 2019 release. We’ve collected a few of the highlights in case you are interested in upgrading to Visual Studio 2019 or just want to learn how to be more productive when writing C++ code. If you have followed our blog since the 2019 Previews, you may be familiar with some of these features already. We hope you find this collection helpful. If you want to try all these features out, please grab the latest release of <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio 2019</a>.</p>
<p>Many of these features are rooted in community suggestions. If you have any suggestions or run into issues with Visual Studio, please let us know on <a href="https://developercommunity.visualstudio.com/">Developer Community</a>. Your feedback really does help us deliver a great product!</p>
<h2 id="c-standards">C++ Standards</h2>
<p>We strive to make Visual Studio the best IDE for working with the latest language standards. That involves a lot of work in our compilers and standard library but is not complete without the corresponding IntelliSense in the IDE to back these new features up while you are editing your code.</p>
<h3 id="c20">C++20</h3>
<p>C++20 includes great new features such as modules, coroutines, concepts, ranges, the three-way operator, designated initializers and many more. All these features are supported in the IDE by the IntelliSense features you know and love.</p>
<p><strong><em>For instance: coroutine support:</em></strong></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Co-routine-Screenshot.png"><img class="alignnone size-full wp-image-27742 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Co-routine-Screenshot.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABfAQMAAAAkkfB5AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFElEQVQ4jWNgGAWjYBSMglFAHAAABTIAAZaVpfsAAAAASUVORK5CYII="  alt="Co-routine Support in IntelliSense" width="457" height="433" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Co-routine-Screenshot.png 457w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Co-routine-Screenshot-300x284.png 300w" sizes="(max-width: 457px) 100vw, 457px" /></a></p>
<p>Most of these features deserve a blog post on their own, so here they are if you want to learn more:</p>
<ul>
<li><a href="https://devblogs.microsoft.com/cppblog/a-tour-of-cpp-modules-in-visual-studio/">Modules</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/c-coroutines-in-visual-studio-2019-version-16-8/">Coroutines</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/c20-concepts-are-here-in-visual-studio-2019-version-16-3/">Concepts</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/initial-support-for-c20-ranges/">Ranges</a></li>
</ul>
<h2 id="c-modernization">C++ Modernization</h2>
<p>We want to make it as easy as possible to update your codebases to use the latest languages standards. One way to do this is with our code analysis, code tidying, and C++ linting tools. These work together and allow you to turn the dial in Visual Studio depending on how comprehensive you want to be in analyzing and updating your code. These features range from the very lightweight like our new C++ Linters that run inside the IntelliSense engine, to features like <a href="https://docs.microsoft.com/en-us/cpp/code-quality/clang-tidy">clang-tidy</a> that bring in many more checks, and all the way up to the complete rulesets that MSVC’s Code Analysis provides.</p>
<h3 id="in-editor-code-analysis">In-Editor Code Analysis</h3>
<p>The Microsoft Visual C++ Compiler has had <a href="https://docs.microsoft.com/en-us/cpp/code-quality/code-analysis-for-c-cpp-overview">extensive support for code analysis</a> for some time. However, before VS 2019, you needed to compile your code before you could see any warnings or errors from this comprehensive analysis. In the latest version of Visual Studio, code analysis runs in the background for any files you are editing and results are shown directly in the IDE’s editor:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/In-editor-Code-Analysis.png"><img class="alignnone size-full wp-image-27745 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/In-editor-Code-Analysis.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAcAQMAAACtXYi7AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADklEQVQYlWNgGAWDAQAAAYgAAfkpKZAAAAAASUVORK5CYII="  alt="Image In editor Code Analysis" width="780" height="218" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/In-editor-Code-Analysis.png 780w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/In-editor-Code-Analysis-300x84.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/In-editor-Code-Analysis-768x215.png 768w" sizes="(max-width: 780px) 100vw, 780px" /></a></p>
<p>You can <a href="https://devblogs.microsoft.com/cppblog/in-editor-code-analysis-in-visual-studio-2019-preview-2/">learn more about in-editor code analysis here</a>.</p>
<h3 id="intellisense-linter">IntelliSense Linter</h3>
<p>We introduced the IntelliSense C++ linter as a complement to the more comprehensive code analysis that now runs in the background. The IntelliSense linter gives instantaneous results for the most critical issues, instantly, as you type. Currently, the linter is focused on common C++ typos, common bugs such arithmetic and operator mismatches, performance issues, and security issues such pointer arithmetic problems.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/C-Linter.png"><img class="alignnone size-full wp-image-27746 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/C-Linter.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAiAQMAAACTLe5mAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADklEQVQYlWNgGAXDFQAAAdwAASiQ1cwAAAAASUVORK5CYII="  alt="Image C Linter" width="936" height="322" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/C-Linter.png 936w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/C-Linter-300x103.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/C-Linter-768x264.png 768w" sizes="(max-width: 936px) 100vw, 936px" /></a></p>
<p>This complements the more comprehensive code analysis from the compiler. While code analysis is much more flexible and powerful than the linter, it also takes longer to provide results because the translation unit must be compiled first. The linter is now enabled by default in Visual Studio. You can <a href="https://devblogs.microsoft.com/cppblog/intellisense-code-linter-for-cpp/">learn more about the IntelliSense Linter here</a>.</p>
<h3 id="c-concept-intellisense">C++ Concept IntelliSense</h3>
<p>One of the great new features in C++20 is concepts. Visual Studio makes it easier than ever to create to create and use concepts in your code. In the first template in the code below we have defined a concept &#8216;is_cat&#8217; that defines the properties of a cat. In the second template we use that concept to constrain the types that can be passed to it. This is fully supported by IntelliSense automatically and you can see that the Member List contains the methods defined by the concept above (&#8216;pet&#8217; and &#8216;meow&#8217;).</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Concept-IntelliSense.png"><img class="alignnone size-full wp-image-27767 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Concept-IntelliSense.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAvAQMAAAAvs/24AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYDABAAKSAAElfz39AAAAAElFTkSuQmCC"  alt="Image Concept IntelliSense" width="642" height="299" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Concept-IntelliSense.png 642w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Concept-IntelliSense-300x140.png 300w" sizes="(max-width: 642px) 100vw, 642px" /></a></p>
<p>We didn&#8217;t need to provide any information to the IDE beyond the code and no types needed to be manually entered into the template bar (to the right of the second template). All the information instead comes from the concepts defined in the code.</p>
<h3 id="template-intellisense">Template IntelliSense</h3>
<p>If you work with C++, you have no doubt encountered a great deal of templated code. Working with this in an IDE can be tricky because the IDE doesn’t know exactly how these templates are going to be instantiated. The new Template IntelliSense Bar in Visual Studio 2019 helps solve this problem. Using the Template Bar, you can tell the IDE how your template will be used and receive full IntelliSense based on those types. If you place the cursor in any template, you will see the new template bar:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Template-IntelliSensepng.png"><img class="alignnone size-full wp-image-27748 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Template-IntelliSensepng.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAhAQMAAAAVuZzIAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADklEQVQYlWNgGAXDBwAAAc4AAcdzLzUAAAAASUVORK5CYII="  alt="Image Template IntelliSensepng" width="541" height="179" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Template-IntelliSensepng.png 541w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Template-IntelliSensepng-300x99.png 300w" sizes="(max-width: 541px) 100vw, 541px" /></a></p>
<p>You may have noticed the “Instantiations” item in the type dropdown below. Visual Studio can now scan your entire codebase to automatically provide suggestions on how the template may be used. You can <a href="https://devblogs.microsoft.com/cppblog/template-intellisense-improvements-for-visual-studio-2019-preview-2/">learn more about the Template Bar here</a>.</p>
<h3 id="perfect-forwarding-intellisense-make_unique-make_shared-emplace-emplace_back">Perfect Forwarding IntelliSense (make_unique, make_shared, emplace, emplace_back)</h3>
<p>One piece of community feedback that we have received has been to improve the IntelliSense for perfect forwarding templates in C++. We’ve taken the first steps towards that by improving the way a few perfect forwarding templates in the STL are handled. In particular, make_unique, make_shared, emplace, and emplace_back.</p>
<p>Here is how this looked before:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Perfect-Forwarding-Before.png"><img class="alignnone size-full wp-image-27749 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Perfect-Forwarding-Before.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAOAQMAAADjQysrAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADElEQVQImWNgGPoAAADEAAEGqCD0AAAAAElFTkSuQmCC"  alt="Image Perfect Forwarding Before" width="624" height="89" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Perfect-Forwarding-Before.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Perfect-Forwarding-Before-300x43.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>Notice how the parameter help doesn’t list the actual parameters of your type. In the latest version of Visual Studio, it is much more convenient:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Perfect-Forwarding-After.png"><img class="alignnone size-full wp-image-27750 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Perfect-Forwarding-After.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAjAQMAAABYcT3DAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADklEQVQYlWNgGAUjAwAAAeoAAY+owHsAAAAASUVORK5CYII="  alt="Image Perfect Forwarding After" width="260" height="92" /></a></p>
<p>We don’t want to stop with just these four STL functions though. We are investigating ways to support your own perfect forwarding templates here as well. As always, we would love to hear your feedback about this. If you are interested in this feel free to open a suggestion on <a href="https://developercommunity.visualstudio.com/">Developer Community</a>.</p>
<h2 id="c-productivity">C++ Productivity</h2>
<p>In addition to language conformance and modernization tools, we also want Visual Studio to be the most productive IDE on the market to get work done. With that in mind, we have added a number of productivity focused IntelliSense features in 2019.</p>
<h3 id="intellicode">IntelliCode</h3>
<p>IntelliCode uses machine learning to provide better code-completion recommendations. We added <a href="https://devblogs.microsoft.com/cppblog/?s=intellicode">IntelliCode</a> support for C++ in Visual Studio 2019.  By default, IntelliCode will give you recommendations on popular libraries such as STL.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Member-List-with-with-and-without-IntelliCode.png"><img class="alignnone size-full wp-image-27752 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Member-List-with-with-and-without-IntelliCode.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAlAQMAAACOKN7eAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADUlEQVQokWNgGAWjAAACBgABtBlPCQAAAABJRU5ErkJggg=="  alt="Image Member List with with and without IntelliCode" width="624" height="230" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Member-List-with-with-and-without-IntelliCode.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Member-List-with-with-and-without-IntelliCode-300x111.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>We took this a step further in Visual Studio 2019 16.5 where we added the ability to <a href="https://devblogs.microsoft.com/cppblog/custom-ai-assisted-intellisense-for-your-team/">train IntelliCode on your own codebase</a>. This enables you to get smarter completion recommendations on your team’s own types. To keep your Team Completion model up-to-date, you can <a href="https://github.com/marketplace/actions/intellicode-team-completions">automate the training process using GitHub Actions</a> or <a href="https://docs.microsoft.com/en-us/visualstudio/intellicode/custom-models#automatically-create-and-retrain-a-model-in-azure-pipelines">Azure Pipelines</a>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Custom-IntelliCode-Animation.gif"><img class="alignnone size-full wp-image-27753 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Custom-IntelliCode-Animation.gif" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAmAQMAAAAIvKxwAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjABUAAAIUAAFG9T/qAAAAAElFTkSuQmCC"  alt="Image Custom IntelliCode Animation" width="645" height="243" /></a></p>
<h3 id="intelligent-member-list-filtering">Intelligent Member List Filtering</h3>
<p>The Member List now takes more of your code’s context into account when listing available members. For instance, if you invoke the member list on a const variable, all non-const variables will no longer be shown in the list. Partial matches are also now highlighted in bold in the Member List as well.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Member-List-Filtering.gif"><img class="alignnone size-full wp-image-27761 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Member-List-Filtering.gif" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA6AQMAAAB8qG6QAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEElEQVQokWNgGAWjYBQQAwADLAABC138mwAAAABJRU5ErkJggg=="  alt="Image Member List Filtering" width="456" height="265" /></a></p>
<p>You can <a href="https://devblogs.microsoft.com/cppblog/smarter-member-list-filtering-for-c/">learn more about Member List filtering here</a>.</p>
<h3 id="doxygen-support">Doxygen Support</h3>
<p>Another feature we received feedback from the community about was that our customers wanted Doxygen support in the IDE in addition to XML doc comments. In Visual Studio 2019, Doxygen is now fully supported in C++ and will provide information in the Quick Info and Parameter Help UIs:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Doxygen-Support.png"><img class="alignnone size-full wp-image-27755 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Doxygen-Support.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA+AQMAAADnOSyGAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEUlEQVQokWNgGAWjYBTQEgAAA2QAAZDoj2MAAAAASUVORK5CYII="  alt="Image Doxygen Support" width="500" height="311" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Doxygen-Support.png 500w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Doxygen-Support-300x187.png 300w" sizes="(max-width: 500px) 100vw, 500px" /></a></p>
<p>Visual Studio does not default to Doxygen style comments, but they can be enabled in “Tools &gt; Options &gt; Text Editor &gt; C/C++ &gt; Code Style &gt; General”. Additionally, you can add your preferred type of doc comment to your project’s .editorconfig file. You can <a href="https://devblogs.microsoft.com/cppblog/doxygen-and-xml-doc-comment-support/">learn more about Doxygen support here</a>.</p>
<h3 id="intellisense-colorization-and-quick-info-improvements">IntelliSense Colorization and Quick Info Improvements</h3>
<p>To help you be as productive as possible, we’ve made several enhancements to the Quick Info, Parameter Help, and Member List UIs. The first thing you might notice is that these UIs are now fully colorized to match the editor:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Quick-Info-and-Member-List-Colorizaiotn.png"><img class="alignnone size-full wp-image-27756 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Quick-Info-and-Member-List-Colorizaiotn.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAZAQMAAAD9kBkIAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADUlEQVQYlWNgGAW0AwABXgAB5JGZUQAAAABJRU5ErkJggg=="  alt="Image Quick Info and Member List Colorizaiotn" width="624" height="159" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Quick-Info-and-Member-List-Colorizaiotn.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Quick-Info-and-Member-List-Colorizaiotn-300x76.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>Quick Info also now allows you to easily search for errors or function and type names online. You can now just hover over any red squiggle in the editor instead of searching through the error list:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Search-From-Quick-Info.png"><img class="alignnone size-full wp-image-27759 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Search-From-Quick-Info.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAPAQMAAAAoH/iOAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADElEQVQImWNgGG4AAADSAAEFhK0ZAAAAAElFTkSuQmCC"  alt="Image Search From Quick Info" width="624" height="96" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Search-From-Quick-Info.png 624w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Search-From-Quick-Info-300x46.png 300w" sizes="(max-width: 624px) 100vw, 624px" /></a></p>
<p>You can <a href="https://devblogs.microsoft.com/cppblog/quick-info-improvements-in-visual-studio-2019-colorization-and-search-online/">learn more about the enhancements to Quick Info here</a>.</p>
<h3 id="snippet-commit-options">Snippet Commit Options</h3>
<p>We’ve received feedback to make the commit options for snippets and the Member List more flexible. The defaults remain the same, but there are new options to choose between Enter, Space, and Tab now in “Tools Options &gt; Text Editor &gt; C/C++ &gt; Advanced &gt; IntelliSense”:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Snippet-Commit-Options.png"><img class="alignnone size-full wp-image-27757 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Snippet-Commit-Options.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAPAQMAAAAoH/iOAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADElEQVQImWNgGG4AAADSAAEFhK0ZAAAAAElFTkSuQmCC"  alt="Image Snippet Commit Options" width="543" height="84" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Snippet-Commit-Options.png 543w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/Snippet-Commit-Options-300x46.png 300w" sizes="(max-width: 543px) 100vw, 543px" /></a></p>
<h2 id="platform-support-and-extensibility">Platform Support and Extensibility</h2>
<p>We have introduced new flexibility and extensibility in our IntelliSense engines to support a wide variety of platforms, such as Windows, Linux, and consoles. This includes the ability to <a href="https://devblogs.microsoft.com/cppblog/configure-intellisense-with-cmake-toolchain-files-in-visual-studio-2019-16-9-preview-2/">configure the IntelliSense engine with a CMake toolchain file</a>. These toolchains can be checked in to your code and each configuration can have a unique toolchain bringing an unprecedented amount of flexibility.</p>
<p>Additionally, we have made several updates to the way <a href="https://devblogs.microsoft.com/cppblog/improvements-to-accuracy-and-performance-of-linux-intellisense/">IntelliSense is handled for remote machines</a>. This improves the accuracy of remote IntelliSense by automatically downloading system and library headers from the remote machine (or <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL</a>) and using them to provide full fidelity IntelliSense with the actual headers on the machine you are targeting.</p>
<h2 id="send-us-feedback">Send Us Feedback</h2>
<p>Please grab a copy of the <a href="https://visualstudio.microsoft.com/downloads/">latest update to Visual Studio</a> and try it out. We would love to hear your feedback about Visual Studio. Please submit any suggestions to Developer Community.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/intellisense-improvements-in-visual-studio-2019/">IntelliSense Improvements in Visual Studio 2019</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/intellisense-improvements-in-visual-studio-2019/feed/</wfw:commentRss>
			<slash:comments>12</slash:comments>
		
		
			</item>
		<item>
		<title>Address Sanitizer for MSVC Now Generally Available</title>
		<link>https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/</link>
					<comments>https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Tue, 09 Mar 2021 09:25:17 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27732</guid>

					<description><![CDATA[<p>This post was last updated on March 10th, 2021.<br />
Special thanks to Aaron Gorenstein who provided most of the content for this blog post. Special thanks as well to Kevin Cadieux and Jim Radigan who also made contributions.  <br />
You can check out a demo on this feature in the latest Visual Studio Toolbox episode on YouTube: Visual Studio Toolbox Live &#8211;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/">Address Sanitizer for MSVC Now Generally Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><a class="lightbox-link" href="https://s.w.org/images/core/emoji/13.0.1/svg/231a.svg" target="_blank" rel="noopener" aria-label="Lightbox image, click or press enter to enlarge" data-featherlight="image"><img class="emoji" role="img" draggable="false" src="https://s.w.org/images/core/emoji/13.0.1/svg/231a.svg" alt="&#x231a;" /></a> <em class="">This post was last updated on March 10th, 2021.</em></p>
<p><em>Special thanks to Aaron Gorenstein who provided most of the content for this blog post. Special thanks as well to Kevin Cadieux and Jim Radigan who also made contributions.  </em></p>
<p>You can check out a demo on this feature in the latest Visual Studio Toolbox episode on YouTube: <a href="https://www.youtube.com/watch?v=4YzFdiYPeVw&amp;t=4050s">Visual Studio Toolbox Live &#8211; What&#8217;s New in Visual Studio 2019 version 16.9? &#8211; YouTube</a></p>
<p>&#8212;</p>
<p>We’re thrilled to announce that as of Visual Studio 2019 version 16.9, the C++ Address Sanitizer (ASan) for MSVC experience is fully supported. Thanks to all who tried it out while it was experimental in earlier versions of the IDE and <a href="https://developercommunity.visualstudio.com/search?entry=suggestion&amp;space=62&amp;ftype=problem&amp;q=asan">filed issues</a> to help make this release all-the-better!</p>
<p>&nbsp;</p>
<h3 id="the-address-sanitizer">The Address Sanitizer</h3>
<p>The Address Sanitizer (ASan) is an immensely valuable technology for finding and fixing memory bugs. Here’s a quick illustration:</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example.png"><img class="alignnone size-full wp-image-27733" src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example.png" alt="Image ASan example" width="1428" height="949" srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example.png 1428w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example-300x199.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example-1024x681.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/ASan-example-768x510.png 768w" sizes="(max-width: 1428px) 100vw, 1428px" /></a></p>
<p>It was originally designed and implemented for the <a href="https://clang.llvm.org/docs/AddressSanitizer.html">LLVM/Clang compiler</a>. Starting in version 16.1, we brought the technology to Visual Studio 2019 <a href="https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-the-linux-workload-in-visual-studio-2019/">for targeting Linux</a>, then <a href="https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-windows-with-msvc/">added MSVC support</a> in version 16.4. Now with version 16.9, we have altogether resolved over 50 customer-reported bugs and improved the user experience to the point where we are ready to <strong>announce that we are moving the ASan for Windows experience out of experimental state</strong>. We consider the feature stable and ready to use for production environments. When we last blogged about the <a href="https://devblogs.microsoft.com/cppblog/asan-for-windows-x64-and-debug-build-support/">AddressSanitizer for Windows experience with version 16.7</a>, we had announced x64 and Debug target support. Since then, we simplified the compilation model to match LLVM by automatically linking runtime libraries when the <code>/fsanitize=address</code> compiler flag is specified. Now, most users will just need to add that single flag to get ASan, with no additional flags or linker options needed. We also polished the debugging experience by cleaning up runtime-generated exceptions and fixing line number mismatches.</p>
<p>ASan helps catch a variety of memory issues, all of which can have real impact in running your programs. These issues range from the “classics” like use-after-free, to subtler issues like the use of a local variable after it has left scope. We’ve provided <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-160">documentation on how to get started with ASan</a> with Visual Studio in a variety of build environments (MSBuild, CMake, and the command line), any of which require just a few small changes. Read on to learn more of what ASan is and how it can help you in developing your software.</p>
<p>&nbsp;</p>
<h3 id="the-value">The Value</h3>
<p>We’re grateful that the core ASan technologies and benefits are well-established with LLVM/Clang. It’s been exciting bringing those benefits to MSVC customers and see just how it can help find and investigate a great many bugs. Some examples:</p>
<ul>
<li>To validate our ASan feature, we ran our test suite with the ASan option turned on. The test suite includes Electron, Qt Creator, Eigen, FLAC, postgresql, OpenSSL, and around 30 other projects.</li>
<li>We built the MSVC compiler itself with ASan and ran some key tests. This is helping us identify bugs in our C++ toolchain. Furthermore, it is saving us time identifying issues when we investigate MSVC bugs reported by the community.</li>
<li>The Windows team is fuzzing their codebase with ASan and <a href="https://www.microsoft.com/security/blog/2020/09/15/microsoft-onefuzz-framework-open-source-developer-tool-fix-bugs/">OneFuzz</a> and their team has been instrumental in identifying and fixing issues in the ASan for Windows experience.</li>
<li>We are expanding efforts to use ASan internally at Microsoft, including in the Windows and Office organization.</li>
</ul>
<p>We will be saying more about the topics above in some future blog posts. We&#8217;ve also been <a href="https://github.com/llvm/llvm-project/commit/c9fa99d066f0f615538e106880fdb9fb48f8e55b">contributing</a> our changes to the ASan components shared between MSVC and Clang upstream to the shared OSS repo. <a href="https://reviews.llvm.org/D97781">The latest of our PRs has been submitted for review</a>, adding support for tracking allocations made through low-level Windows APIs. We expect with future fixes and enhancements there will be more. Our north star is to always contribute to, and use, the same OSS ASan components.</p>
<p>Moreover, with version 16.9 we have full Visual Studio IDE integration with ASan. Now you can obtain the core value of the fundamental ASan technology in the first-class Visual Studio debugging experience on Windows. In the opening picture you see how Visual Studio points right to the ASan-detected bug, complete with explanatory pop-up, call stack, and all the other debugging information you’d expect. We’ve documented more of the details of the <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan-debugger-integration?view=msvc-160">debugger integration</a>, and the text-based ASan report is still available in the Output window for advanced users.</p>
<p>Moving beyond the local dev loop, we also added the ability to save ASan crash dumps, thereby enabling whole new cloud and distributed testing scenarios. A deep dive on this scenario can be found in our <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan-offline-crash-dumps?view=msvc-160">documentation</a>.</p>
<p>&nbsp;</p>
<h3 id="getting-started">Getting Started</h3>
<p>If you’re eager to jump in and try ASan for yourself, check out our <a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-160">documentation</a>.</p>
<p>&nbsp;</p>
<h3 id="the-journey-and-thanks">The Journey, and Thanks!</h3>
<p>Bringing ASan to Visual Studio as a first-class experience took time. Of course, we are grateful for the LLVM/Clang team that created and continues to develop ASan, and we feel exceptionally grateful to the many customers who took our invitation to try out ASan while it was experimental and helped us improve its quality. False positives, those where ASan reports a memory bug that is not truly a memory bug, we treat with highest priority and we strain to fix those as soon as possible. False negatives, where ASan should have reported an issue but didn’t, are intrinsically harder to find but fortunately less disruptive; to maximize the value of ASan we also strive to fix those quickly. We have been heads-down working to address the last, recently-reported issues. While we of course hope that the ASan integration quality satisfies your requirements, we have documented an “<a href="https://docs.microsoft.com/en-us/cpp/sanitizers/asan-building?view=msvc-160">escape hatch</a>” to selectively turn off ASan in the rare case you do hit a bug.</p>
<p>We see ASan as just the start of bringing more sanitizer-and-related technology to Visual Studio. If you have thoughts on the future of undefined-behavior-, memory-, thread-, or other-sanitizers, please share them as a <a href="https://developercommunity2.visualstudio.com/search?entry=suggestion&amp;space=62&amp;ftype=idea">suggestion on Developer Community</a>! If you suspect you’ve hit an issue or bug, please also don’t hesitate to <a href="https://developercommunity2.visualstudio.com/search?entry=suggestion&amp;space=62&amp;ftype=problem">open a ticket on Developer Community</a>!</p>
<p>Thanks for reading!</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/">Address Sanitizer for MSVC Now Generally Available</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/address-sanitizer-for-msvc-now-generally-available/feed/</wfw:commentRss>
			<slash:comments>17</slash:comments>
		
		
			</item>
		<item>
		<title>Microsoft C++ Team at ACCU 2021</title>
		<link>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-accu-2021/</link>
					<comments>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-accu-2021/#respond</comments>
		
		<dc:creator><![CDATA[Erika]]></dc:creator>
		<pubDate>Mon, 08 Mar 2021 21:43:37 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27728</guid>

					<description><![CDATA[<p>Sy Brand and Erika Sweet from the Microsoft C++ Team will be presenting at ACCU 2021 this week. Come say hi in the virtual conference space and let us know if you have any questions about our talks, products, or anything else. </p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-accu-2021/">Microsoft C++ Team at ACCU 2021</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8">S</span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8">y Brand and Erika Sweet from the Microsoft C++ Team will be presenting at </span></span><a class="Hyperlink SCXW74070230 BCX8" href="https://flame.firebird.systems/archer-yates/ACCU2021/MyProgrammes#Programme.ItemPage.104.0" target="_blank" rel="noreferrer noopener"><span class="TextRun Underlined SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW74070230 BCX8" data-ccp-charstyle="Hyperlink">ACCU 2021</span></span></a><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8"> this week. </span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun CommentStart SCXW74070230 BCX8">Come </span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun ContextualSpellingAndGrammarErrorV2 SCXW74070230 BCX8">say</span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8"> hi </span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8">in the virtual conference space</span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8"> and let us know if you have any questions about our </span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8">talks, products, or anything else.</span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8"> </span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8">We also recommend dropping by the #include</span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8"> </span></span><span class="TextRun SCXW74070230 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW74070230 BCX8">&lt;C++&gt; table in the expo hall to learn more about their community. </span></span><span class="EOP SCXW74070230 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<h4 id="dynamic-polymorphism-with-code-injection-and-metaclasses-sy-brand"><span class="TextRun SCXW66306003 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun CommentStart SCXW66306003 BCX8" data-ccp-parastyle="heading 2">Dy</span></span><span class="TextRun SCXW66306003 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW66306003 BCX8" data-ccp-parastyle="heading 2">namic</span></span><span class="TextRun SCXW66306003 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW66306003 BCX8" data-ccp-parastyle="heading 2"> Polymorphism with Code Injection and </span></span><span class="TextRun SCXW66306003 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SpellingErrorV2 SCXW66306003 BCX8" data-ccp-parastyle="heading 2">Metaclasses</span></span><span class="TextRun SCXW66306003 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW66306003 BCX8" data-ccp-parastyle="heading 2"> – Sy Brand</span></span><span class="TextRun SCXW66306003 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW66306003 BCX8" data-ccp-parastyle="heading 2"> </span></span><span class="EOP SCXW66306003 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h4>
<p><b><span data-contrast="auto">Wednesday, 10 March 11:00 – 12:30 GMT </span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="none">Dynamic polymorphism in C++ has historically meant virtual functions and inheritance. However, these form only one possible design for solving this problem, and they bring several implications on performance, </span><span data-contrast="none">ergonomics</span><span data-contrast="none"> and flexibility.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="none">Type erasure is another way to implement dynamic polymorphism, as demonstrated in several talks by Sean Parent and adopted in other languages, such as Rust&#8217;s trait objects. But implementing type erasing objects which provide ergonomic interfaces in C++ is cumbersome and error-prone, leading to a large family of types and libraries with subtly different semantics and lower adoption rates compared to inheritance.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:150,&quot;335559740&quot;:240}"> </span></p>
<p><span data-contrast="none">This talk will present a possible future design for interface-based type erasure in C++ that marries the convenience of inheritance to the benefits which it otherwise lacks. It will introduce the code injection and </span><span data-contrast="none">metaclasses</span><span data-contrast="none"> facilities which are proposed for inclusion in C++ along with a prototype implementation of the design based on the experimental </span><span data-contrast="none">metaclasses</span><span data-contrast="none"> Clang fork. </span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:150,&quot;335559740&quot;:240}"> </span></p>
<h4 id="cross-platform-pitfalls-and-how-to-avoid-them-erika-sweet"><span class="TextRun SCXW224824541 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW224824541 BCX8" data-ccp-parastyle="heading 2">Cross-Platform Pitfalls and How to Avoid Them</span></span><span class="TextRun SCXW224824541 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW224824541 BCX8" data-ccp-parastyle="heading 2"> – </span></span><span class="TextRun SCXW224824541 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW224824541 BCX8" data-ccp-parastyle="heading 2">Erika Sweet</span></span><span class="EOP SCXW224824541 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559738&quot;:40,&quot;335559739&quot;:0,&quot;335559740&quot;:259}"> </span></h4>
<p><b><span data-contrast="auto">Thursday</span></b><b><span data-contrast="auto">, 1</span></b><b><span data-contrast="auto">1</span></b><b><span data-contrast="auto"> March 1</span></b><b><span data-contrast="auto">6</span></b><b><span data-contrast="auto">:00 – 1</span></b><b><span data-contrast="auto">7</span></b><b><span data-contrast="auto">:30 GMT </span></b><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:160,&quot;335559740&quot;:259}"> </span></p>
<p><span data-contrast="none">C++ cross-platform development is difficult. These difficulties are compounded by the fractured solution space, where every project seems to use a different combination of build systems, package managers, and diagnostic tools to address shared challenges. Join us for a discussion and demo of C++ cross-platform development centered on common pitfalls and widely adopted tooling.</span></p>
<p><span data-contrast="none">Learn how to leverage CMake and its new </span><span data-contrast="none">CMakePresets.json</span><span data-contrast="none"> to seamlessly build across operating systems and platforms. Untangle your dependencies with tools like </span><span data-contrast="none">vcpkg</span><span data-contrast="none"> and Conan to avoid inconsistencies between system package managers. Debug your projects across multiple platforms with remote debugging. We’ll also explore how </span><span data-contrast="none">CMakePresets.json</span><span data-contrast="none"> is supported on the command line, in Visual Studio, and in Visual Studio Code.</span><span data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:150,&quot;335559740&quot;:240}"> </span></p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/presets.png"><img class="aligncenter wp-image-27729 size-full lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/presets.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAPAQMAAAAoH/iOAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADElEQVQImWNgGG4AAADSAAEFhK0ZAAAAAElFTkSuQmCC"  alt="A screenshot of Visual Studio 2019. The toolbar contains 3 drop-downs: one for &quot;Target System&quot;, one for &quot;Configure Preset&quot;, one for &quot;Build Preset.&quot;" width="648" height="95" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/presets.png 648w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/03/presets-300x44.png 300w" sizes="(max-width: 648px) 100vw, 648px" /></a><span class="TextRun SCXW171235364 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW171235364 BCX8">A preview of </span></span><span class="TextRun SCXW171235364 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SpellingErrorV2 SCXW171235364 BCX8">CMakePresets.json</span></span><span class="TextRun SCXW171235364 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW171235364 BCX8"> integration in Visual Studio. Come </span></span><span class="TextRun SCXW171235364 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW171235364 BCX8">to Erika’s session or find us at the virtual </span></span><span class="TextRun SCXW171235364 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun CommentStart SCXW171235364 BCX8">expo hall to learn more!</span></span><span class="EOP SCXW171235364 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:150,&quot;335559740&quot;:240}"> </span></p>
<h4 id="talk-to-us">Talk to us!</h4>
<p><span class="TextRun Highlight SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8">In case you miss us at ACCU, you can always contact us directly </span></span><span class="TextRun Highlight SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8">via email (</span></span><a class="Hyperlink SCXW194730128 BCX8" href="mailto:visualcpp@microsoft.com" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink">visualcpp@microsoft.com</span></span></a><span class="TextRun Highlight SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8">) and Twitter </span></span><span class="TextRun Highlight SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8">(</span></span><a class="Hyperlink SCXW194730128 BCX8" href="https://twitter.com/visualc" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink">@VisualC</span></span></a><span class="TextRun Highlight SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink">,</span></span><span class="TextRun Highlight Underlined SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink"> </span></span><a class="Hyperlink SCXW194730128 BCX8" href="https://twitter.com/TartanLlama" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink">@TartanLlama</span></span></a><span class="TextRun Highlight SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="auto"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink">,</span></span><span class="TextRun Highlight Underlined SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink"> </span></span><a class="Hyperlink SCXW194730128 BCX8" href="https://twitter.com/arecaplm" target="_blank" rel="noreferrer noopener"><span class="TextRun Highlight Underlined SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8" data-ccp-charstyle="Hyperlink">@arecaplm</span></span></a><span class="TextRun Highlight SCXW194730128 BCX8" lang="EN-US" xml:lang="EN-US" data-contrast="none"><span class="NormalTextRun SCXW194730128 BCX8">). </span></span><span class="EOP SCXW194730128 BCX8" data-ccp-props="{&quot;201341983&quot;:0,&quot;335559739&quot;:150,&quot;335559740&quot;:240}"> </span></p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-accu-2021/">Microsoft C++ Team at ACCU 2021</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/microsoft-c-team-at-accu-2021/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Remote Debug Support in Visual Studio 2019</title>
		<link>https://devblogs.microsoft.com/cppblog/remote-debug-support-in-visual-studio-2019/</link>
					<comments>https://devblogs.microsoft.com/cppblog/remote-debug-support-in-visual-studio-2019/#comments</comments>
		
		<dc:creator><![CDATA[Lisbeth Cardoso Guerra]]></dc:creator>
		<pubDate>Fri, 26 Feb 2021 15:00:27 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[CMake]]></category>
		<category><![CDATA[Linux]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27664</guid>

					<description><![CDATA[<p>Visual Studio 2019 offers remote debug support for MSBuild and CMake projects targeting Windows and Linux. Thanks to remote debugging, the following scenarios and more are now possible:</p>
<p>Debugging on your production machines with no development tools installed other than the remote debugger tools.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/remote-debug-support-in-visual-studio-2019/">Remote Debug Support in Visual Studio 2019</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>Visual Studio 2019 offers remote debug support for MSBuild and CMake projects targeting Windows and Linux. Thanks to remote debugging, the following scenarios and more are now possible:</p>
<ul>
<li>Debugging on your production machines with no development tools installed other than the remote debugger tools.</li>
<li>Targeting developer environments that you do not use daily (i.e., less common operating systems or software configurations).</li>
<li>Targeting environments where Visual Studio is unavailable (i.e., ARM64 machines, or unsupported operating system versions).</li>
</ul>
<p>To guarantee a seamless remote debugging experience for users, you need some additional dependencies to be copied to the target machine. Luckily, we do that for you and automatically deploy these dependencies alongside the built binaries from your project we deem as needed for debugging. In Windows scenarios specifically, we automatically deploy the Universal CRT library (debug only, as the release version ships with the Windows operating system) as well as VCRuntime libraries which are necessary to run and debug binaries in environments where these libraries are not available on the system.</p>
<p>For step-by-step instructions of the various remote debug workflows, check out the following tutorials:</p>
<p><a href="https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging-cpp?view=vs-2019">Remote Debug a C++ Project &#8211; Visual Studio | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/cpp/linux/deploy-run-and-debug-your-linux-project?view=msvc-160#:~:text=%20Debug%20your%20Linux%20project%20%201%20Select,option%20if%20the%20local%20version%20of...%20More">Deploy, run, and debug your Linux MSBuild C++ project in Visual Studio | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/cpp/build/cmake-remote-debugging?view=msvc-160">Tutorial: Debug a CMake project on a remote Windows machine | Microsoft Docs</a></p>
<p><a href="https://docs.microsoft.com/en-us/cpp/build/configure-cmake-debugging-sessions?view=msvc-160">Configure CMake debugging sessions in Visual Studio | Microsoft Docs</a></p>
<p><strong>Note:</strong> Although with Visual Studio 2019 you can create MSBuild and CMake projects targeting Linux and Windows, CMake is encouraged for Linux development because the same project files can be used in both platforms.</p>
<h2 id="user-customizability-of-remote-deploy">User Customizability of Remote Deploy</h2>
<p>Whether you are targeting Windows or Linux, or using MSBuild or CMake, Visual Studio offers you the flexibility to customize your deployment. We will cover some of these in the sub-sections below.</p>
<h3 id="msbuild-projects-targeting-windows">MSBuild Projects targeting Windows</h3>
<p>You can deploy and debug MSBuild projects targeting a remote Windows machine very easily in Visual Studio 2019. In the Property Pages, within the <strong>Debugging </strong>tab, you will need to specify <strong>Remote Command</strong>, <strong>Working Directory</strong>, <strong>Remote Server Name</strong> and <strong>Deployment Directory</strong> properties as a minimum. If you want to deploy additional files, you will have to specify them in the <strong>Additional Files to Deploy</strong> property.</p>
<p><img class="alignnone wp-image-27665 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/word-image.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABFAQMAAACG3NGEAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEUlEQVQokWNgGAWjYBQMbQAAA8YAAQGGxfwAAAAASUVORK5CYII="  alt="The &quot;Deploy Visual C++ Runtime Libraries&quot; option highlighted and set to Yes" width="1176" height="817" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/word-image.png 1176w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/word-image-300x208.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/word-image-1024x711.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/word-image-768x534.png 768w" sizes="(max-width: 1176px) 100vw, 1176px" /></p>
<p>Visual Studio 2019 allows you to specify both debug and release versions of the runtime libraries. To do so, you must set the <strong>Deploy Visual C++ Debug Runtime Libraries</strong> and <strong>Deploy Visual C++ Runtime Libraries</strong> properties to <strong>Yes</strong>.</p>
<p>Once your configuration is set, Visual Studio will take care of deploying all the files (including the ucrt and vcruntime libraries needed) to your remote machine.</p>
<h3 id="msbuild-projects-targeting-linux">MSBuild Projects targeting Linux</h3>
<p>When targeting Linux using MSBuild project, you can specify a different machine from your build machine (the default) to deploy to and debug on, as shown below:</p>
<h3 id=""><img class="alignnone wp-image-27666 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/graphical-user-interface-text-application-email.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABGAQMAAAAASKMqAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEUlEQVQokWNgGAWjYBQMJwAAA9QAAf5fmNUAAAAASUVORK5CYII="  alt="The Remote Debug Machine setting set with a username, port, and authentication method" width="887" height="624" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/graphical-user-interface-text-application-email.png 887w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/graphical-user-interface-text-application-email-300x211.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/graphical-user-interface-text-application-email-768x540.png 768w" sizes="(max-width: 887px) 100vw, 887px" /></h3>
<p>By default, only the files necessary for the process to debug will be deployed to the remote debug machine. However, in some cases, you may want more control over your project&#8217;s deployment. In these cases, you can append the code MSBuild elements below to your .vcxproj file, making sure to specify the actual source and target paths you want:</p>
<pre class="prettyprint">&lt;ItemGroup&gt; 
   &lt;RemoteDeploy Include="__example.cpp"&gt; 
&lt;!-- This is the source Linux machine, can be empty if DeploymentType is LocalRemote --&gt; 
      &lt;SourceMachine&gt;$(RemoteTarget)&lt;/SourceMachine&gt; 
      &lt;TargetMachine&gt;$(RemoteDebuggingTarget)&lt;/TargetMachine&gt; 
      &lt;SourcePath&gt;~/example.cpp&lt;/SourcePath&gt; 
      &lt;TargetPath&gt;~/example.cpp&lt;/TargetPath&gt; 
&lt;!-- DeploymentType can be LocalRemote, in which case SourceMachine will be empty and SourcePath is a local file on Windows --&gt; 
      &lt;DeploymentType&gt;RemoteRemote&lt;/DeploymentType&gt; 
&lt;!-- Indicates whether the deployment contains executables --&gt; 
      &lt;Executable&gt;true&lt;/Executable&gt; 
   &lt;/RemoteDeploy&gt; 
&lt;/ItemGroup&gt;</pre>
<p>You can also specify additional source files in your solution that you want deployed if you: right-click on the source file in solution explorer &gt; select properties &gt; set the <strong>Content </strong>property to “yes”.</p>
<h3 id="cmake-projects-targeting-windows">CMake Projects targeting Windows</h3>
<p>Visual Studio 2019 has support for deploying CMake projects to a remote Windows machine and debugging them with the <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/remote-debugging-cpp?view=vs-2019">Visual Studio remote tools.</a> You can specify the <strong>type </strong>and <strong>remoteMachineName </strong>properties within the launch.vs.json file.</p>
<pre class="prettyprint">"configurations": [ 
   { 
      "type": "remoteWindows", 
      "project": "CMakeLists.txt", 
      "projectTarget": "CMakeProject.exe (CMakeProject\\CMakeProject.exe)", 
      "name": "CMakeProject.exe (CMakeProject\\CMakeProject.exe)", 
      "remoteMachineName": "[remote machine’s IP address]: [remote machine’s port number]", 
      "deployDebugRuntimeLibraries": true, 
      "deployRuntimeLibraries": true, 
      "deployDirectory": "~/foo", 
      "disableDeploy": true, 
   } 
]</pre>
<p>Visual Studio 2019 allows you to specify both debug and release versions of the runtime libraries. To do so, you must set the <strong>deployDebugRuntimeLibraries</strong> and <strong>deployRuntimeLibraries</strong> properties to <strong>true</strong>.</p>
<p>The contents of the project outputs will be deployed automatically to C:\Windows Default Deploy Directory\&lt;targetname&gt; in the remote machine. If you want to specify a different location, you can set it up in the <strong>deployDirectory </strong>property. If you do not want to deploy files at all, you can set <strong>disableDeploy </strong>to <strong>true</strong>.</p>
<p>In addition, you can specify individual additional files or entire directories you want to deploy each time in case there are some external source/content files you want to be deployed. To do this, you add the following block to your launch.vs.json (make sure you replace example.cpp/exampleDirectory with the actual path to your file/directory):</p>
<pre class="prettyprint">"deploy": [ 
   { 
      "sourcePath": "~/example.cpp", 
      "targetPath": "~/test/example.cpp", 
   }, 
   { 
      "sourcePath": "~/exampleDirectory", 
      "targetPath": "~/test/exampleDirectory", 
   }, 
]</pre>
<h3 id="cmake-projects-targeting-linux">CMake Projects targeting Linux</h3>
<p><span style="font-size: 12pt;">When targeting Linux using CMake, you can specify a different machine from your build machine (the default) to deploy to and debug on. To do this, just set the remoteMachineName json filed to one of the established connections in the Connection Manager (IntelliSense will populate the list of all the available options).</span></p>
<p><span style="font-size: 12pt;">You can also customize the deploy location on the target machine by setting the <strong>deployDirectory </strong>property in launch.vs.json to the intended directory.</span></p>
<p><span style="font-size: 12pt;">In addition, if you want complete control over your deployment, you can append the following code block in your launch.vs.json file. For example:</span></p>
<pre class="prettyprint">"deploy": [ 
   { 
      "sourceMachine": "127.0.0.1 (username=example1, port=22, authentication=Password)", 
      "targetMachine": "192.0.0.1 (username=example2, port=22, authentication=Password)", 
      "sourcePath": "~/example.cpp", 
      "targetPath": "~/example.cpp", 
      "executable": "false" 
   } 
]</pre>
<h2 id="give-us-your-feedback">Give us your feedback</h2>
<p>Download the latest <a href="https://visualstudio.microsoft.com/vs/preview/">Visual Studio 2019 Preview</a> today and give it a try. We’d love to hear from you to help us prioritize and build the right features for you. We can be reached via the comments below, <a href="https://developercommunity.visualstudio.com/spaces/8/index.html">Developer Community</a>, and Twitter (<a href="https://twitter.com/visualc">@VisualC</a>). The best way to file a bug or suggest a feature is via Developer Community.</p>
<h2 id="authors">Authors</h2>
<p>Moyo Okeremi and Lisbeth Cardoso Guerra.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/remote-debug-support-in-visual-studio-2019/">Remote Debug Support in Visual Studio 2019</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/remote-debug-support-in-visual-studio-2019/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Registries: Bring your own libraries to vcpkg</title>
		<link>https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/</link>
					<comments>https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 25 Feb 2021 21:49:24 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27658</guid>

					<description><![CDATA[<p>Special thanks to Nicole Mazzuca for providing the content of this blog post.<br />
Are you working on a C++ project with library dependencies? Are you tired of maintaining a custom-built package management workflow with duct tape and git submodules? Then you should consider trying out a package manager.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/">Registries: Bring your own libraries to vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><em>Special thanks to Nicole Mazzuca for providing the content of this blog post. </em></p>
<p>Are you working on a C++ project with library dependencies? Are you tired of maintaining a custom-built package management workflow with duct tape and git submodules? Then you should consider trying out a package manager. Perhaps you have been side-eyeing vcpkg for a while, and it looks like the perfect solution for your team, but for one problem: not all your dependencies are open source! Your company has internal libraries that they expect everyone to use too.</p>
<p>&nbsp;</p>
<h3 id="can-vcpkg-work-with-non-open-source-dependencies">Can vcpkg work with non-open-source dependencies?</h3>
<p>Yes! Up until now, your best options included hacking up overlay ports or forking the vcpkg ports tree. But there was room for improvement. Now, we are happy to announce a feature with an experience to manage any libraries you want, whether they are internal-only, open source, your own forks of open source projects, and more. In this blog post, we will delve into <strong>registries</strong>, our new experimental feature. We would love for you to try this feature out, give us feedback, and help us make it the best feature it can be!</p>
<h3 id="getting-started-with-registries">Getting started with registries</h3>
<p>So, we’ve discussed the why of registries; now let’s discuss the how. Let’s say we are developers at North Wind Traders, and our company has a GitHub Enterprise subscription. Of course, depending on your company’s or even your personal situation, you can use whatever solution you’re already using. The goal in this blog post is to set up a git registry, the most common type of registry.</p>
<h4 id="1-create-a-new-registry">1. Create a new registry</h4>
<p>The company’s GitHub organization is at <a href="https://github.com/northwindtraders">https://github.com/northwindtraders</a>, and that can be used to set up the registry. We will create our registry at <a href="https://github.com/northwindtraders/vcpkg-registry">https://github.com/northwindtraders/vcpkg-registry</a>, since that’s as good a name as any, and you can follow along with the branches there.</p>
<p>Once we’ve created this registry, we’ll have to do a few things to actually set it up to contain the packages we want, in this case our internal JSON and Unicode libraries.</p>
<ul>
<li>First, we’ll set up an empty baseline, the minimum requirement for a registry.</li>
<li>Then, we’ll add the files that our library needs to build, and make sure that they work.</li>
<li>Finally, we’ll add the library to the registry, by adding it to the versions database and writing down where to find the library in the git repository.</li>
</ul>
<h4 id="2-create-an-empty-registry-baseline">2. Create an empty registry baseline</h4>
<p>So, let’s start. Clone the (empty) repository, and add a baseline.json file underneath the top level versions directory, containing just the following:</p>
<pre class="prettyprint">{
"default": {}
}</pre>
<h4 id="3-create-a-vcpkg-port-for-your-library">3. Create a vcpkg port for your library</h4>
<p>Now, let’s set up a port entry for the first of our two libraries, the Unicode library <a href="https://github.com/northwindtraders/beicode">beicode</a>. If you have ever written a port, you know how to do this, but for those of us who haven’t, let’s go through it all the same.</p>
<p>We first create a folder for the ports to live; following the standard of the vcpkg central registry, we’ll call the folder ports. Since we use a stable git identifier to specify the directory, we don’t need to put it in a specific place, but it’s good to follow idioms. Inside this ports directory, create beicode’s port directory; inside there, place two empty files, <em>portfile.cmake</em> and <em>vcpkg.json</em>.</p>
<p>At this point, the registry directory should look something like this:</p>
<pre class="prettyprint">ports/
    beicode/
        portfile.cmake
        vcpkg.json
versions/
    baseline.json</pre>
<p>Now, let’s fill out the port. First, since the beicode GitHub repository already has a vcpkg.json manifest, copy that into the <em>vcpkg.json</em> file you created:</p>
<pre class="prettyprint">{
  "name": "beicode",
  "version": "1.0.0",
  "description": "A simple utf-8 based unicode decoding and encoding library",
  "homepage": "https://github.com/northwindtraders/beicode"
}</pre>
<h4 id="4-test-your-new-vcpkg-port-using-overlays">4. Test your new vcpkg port using overlays</h4>
<p>Let’s make sure this works by trying to install the port; we’re not using registries yet, just the pre-existing overlay-ports feature to test stuff out:</p>
<p><code>&gt; vcpkg install beicode --overlay-ports=vcpkg-registry/ports/beicode</code></p>
<p>We should get an error: “<em>The folder /include is empty or not present</em>”. Since we aren’t doing anything just yet, that makes sense. So, let’s fill out our port! Since our port is a simple CMake library, we can create a very simple <em>portfile.cmake</em>:</p>
<pre class="prettyprint">vcpkg_from_github(
  OUT_SOURCE_PATH SOURCE_PATH
  REPO northwindtraders/beicode
  REF 19a1f95c2f56a27ced90227b5e2754a602a08e69
  SHA512 7b2bb7acb2a8ff07bff59cfa27247a7b2cced03828919cd65cc0c8cf1f724f5f1e947ed6992dcdbc913fb470694a52613d1861eaaadbf8903e94eb9cdfe4d000
  HEAD_REF main
)

vcpkg_configure_cmake(
  SOURCE_PATH "${SOURCE_PATH}"
  PREFER_NINJA
)
vcpkg_install_cmake()
vcpkg_fixup_cmake_targets()

file(REMOVE_RECURSE "${CURRENT_PACKAGES_DIR}/debug/include")

file(
  INSTALL "${SOURCE_PATH}/LICENSE"
  DESTINATION "${CURRENT_PACKAGES_DIR}/share/${PORT}"
  RENAME copyright)</pre>
<p>If we run</p>
<p><code>&gt; vcpkg install beicode --overlay-ports=vcpkg-registry/ports/beicode</code></p>
<p>again, we’ll see that it successfully installed! We have written our first port for the registry, and now all that there’s left to do is to add the port to the version set in the registry.</p>
<h4 id="5-specify-each-version-of-your-library-in-the-registry">5. Specify each version of your library in the registry</h4>
<p>Every port’s version data lives in its own file: <em>versions/[first character]-/[portname].json</em>. For example, the version data for <em>fmt</em> would live in <em>versions/f-/fmt.json</em>; the version data for <em>zlib</em> would live in <em>versions/z-/zlib.json</em>. So, for <em>beicode</em>, create <em>versions/b-/beicode.json</em>:</p>
<pre class="prettyprint">{
  "versions": [
    {
      "version": "1.0.0",
      "git-tree": ""
    }
  ]
}</pre>
<p>And add the following to <em>versions/baseline.json</em>:</p>
<pre class="prettyprint">{
  "default": {
    "beicode": { "baseline": "1.0.0", "port-version": 0 }
  }
}</pre>
<p>Finally, let’s figure out what to put in that &#8220;<em>git-tree</em>&#8221; field. Do a git commit of the beicode port tree (but do not push), to make sure git knows about it:</p>
<pre class="prettyprint">&gt; git add ports/beicode
&gt; git commit -m "[beicode] new port"</pre>
<p>Then get the tree identifier for that directory:</p>
<p><code>&gt; git rev-parse HEAD:ports/beicode</code></p>
<p>You should get something like <code>7fb5482270b093d40ab8ac31db89da4f880f01ba</code>; put that in for the &#8220;<em>git-tree</em>&#8221; in <em>beicode.json</em>, and commit the new files:</p>
<pre class="prettyprint">&gt; git add versions
&gt; git commit --amend --no-edit</pre>
<p>And we should be done! The reason we have to do this slightly complex dance is so that we can grab exactly the files of the version we want; other versions will exist in the history of the repository, and thus are always there to be checked out.</p>
<h4 id="6-consume-libraries-from-your-vcpkg-registry-in-a-c-project">6. Consume libraries from your vcpkg registry in a C++ project</h4>
<p>Once we’ve done this, let’s try to consume the library from the new registry in an example codebase. Create a directory outside of the registry and change into that directory. Create a <em>vcpkg.json</em> which depends on beicode:</p>
<pre class="prettyprint">{
"name": "test",
"version": "0",
"dependencies": [
  "fmt",
  "beicode"
]
}</pre>
<p>And a <em>vcpkg-configuration.json</em> that sets up the registry as a git registry:</p>
<pre class="prettyprint">{
  "registries": [
    {
      "kind": "git",
      "repository": "[full path to]/vcpkg-registry",
      "packages": [ "beicode", "beison" ]
    }
  ]
}</pre>
<p>And try a vcpkg install:</p>
<p><code>&gt; vcpkg install --feature-flags=registries,manifests</code></p>
<p>If it works, then you’re ready to push the registry upstream! You can try again with the actual remote registry by replacing the &#8220;<em>repository</em>&#8221; field in your <em>vcpkg-configuration.json</em> file with the actual upstream repository URL.</p>
<p>&nbsp;</p>
<h3 id="how-vcpkg-resolves-libraries-from-registries">How vcpkg resolves libraries from registries</h3>
<p>You’ll notice that beicode and beison are taken from the registry we created; this is because we’ve explicitly said in vcpkg-configuration.json that this is where they’re from. Since we haven’t said where fmt should come from, it just comes from the default registry, which is in this case the registry that ships with vcpkg itself. Registries are never transitive; if you left off beicode from the registry in vcpkg-configuration.json, this would fail to work since beicode doesn’t exist in the default registry, and that’s where vcpkg will look for it. If you wanted to override fmt with your own copy, you could add it to the registry, and then add it to the packages field.</p>
<p>Packaging beison will be much the same, just with a different name. You can try it out for yourself, and then see if your code is any different from <a href="https://github.com/northwindtraders/vcpkg-registry">the upstream</a>.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback!</h3>
<p>Try out vcpkg by visiting our <a href="https://github.com/microsoft/vcpkg/issues">GitHub repo</a>. We welcome your feedback on the tool and the new features <a href="https://github.com/microsoft/vcpkg/issues">in our issue tracker</a> or by reaching out to us at <a href="mailto:vcpkg@microsoft.com">vcpkg@microsoft.com</a>. We are always looking to improve your experience. To see what’s next for vcpkg, <a href="https://aka.ms/vcpkg/roadmap">check out our roadmap</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/">Registries: Bring your own libraries to vcpkg</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/registries-bring-your-own-libraries-to-vcpkg/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
			</item>
		<item>
		<title>Take control of your vcpkg dependencies with versioning support</title>
		<link>https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/</link>
					<comments>https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/#comments</comments>
		
		<dc:creator><![CDATA[Augustin Popa]]></dc:creator>
		<pubDate>Thu, 18 Feb 2021 01:54:07 +0000</pubDate>
				<category><![CDATA[C++]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27597</guid>

					<description><![CDATA[<p>Special thanks to Victor Romero for putting together the content for this blog post.<br />
We have an exciting new feature to announce in vcpkg: the long-awaited and highly requested package versioning! This feature makes it possible to install specific versions of dependencies and control installed versions over time.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/">Take control of your vcpkg dependencies with versioning support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p><em>Special thanks to Victor Romero for putting together the content for this blog post.</em></p>
<p>We have an exciting new feature to announce in vcpkg: the long-awaited and highly requested package versioning! This feature makes it possible to install specific versions of dependencies and control installed versions over time. In order to use this feature, a <strong>vcpkg.json</strong> manifest file must be present in your repo to declare dependencies. Versioning is not currently available for libraries installed via the command line (i.e. <code>vcpkg install library_name</code> commands). The versioning feature is completely optional – you can choose not to specify library versions, and vcpkg will pick the most appropriate set of compatible versions for your dependencies from its baseline catalog. For now, we are considering this feature experimental. Please give us your feedback and let us know how we can improve.</p>
<p>&nbsp;</p>
<h3 id="announcing-package-versioning-support">Announcing package versioning support</h3>
<p>For the past year we have been focusing our efforts on implementing highly requested features in vcpkg that will help our users in a wide variety of scenarios. Two such features are manifests and binary caching, <a href="https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/">which we announced some time ago</a>, and users have been successfully using them in their projects since then. Today, we are announcing support for another anticipated feature: Package versioning. With this feature users will be able to:</p>
<ul>
<li>Declare minimum version constraints on dependencies.</li>
<li>Freeze dependencies at specific versions.</li>
<li>Conveniently upgrade all declared dependencies at once via baselines.</li>
<li>Get reproducible builds independent from the current state of the vcpkg ports registry.</li>
</ul>
<p>&nbsp;</p>
<h3 id="getting-started-with-versions">Getting started with versions</h3>
<p>To enable versioning, you must turn on the “versions” feature flag. There are several ways to do this:</p>
<ul>
<li>Setting the <code>VCPKG_FEATURE_FLAGS</code> environment variable, example in Windows 10:<a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag.png"><img class="alignnone size-full wp-image-27599 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAcAQMAAACtXYi7AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADklEQVQYlWNgGAWDAQAAAYgAAfkpKZAAAAAASUVORK5CYII="  alt="Image versioning feature flag" width="1092" height="307" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag.png 1092w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag-300x84.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag-1024x288.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/versioning-feature-flag-768x216.png 768w" sizes="(max-width: 1092px) 100vw, 1092px" /></a></li>
<li>Setting the <code>VCPKG_FEATURE_FLAGS</code> variable before invoking vcpkg in the command line (example in PowerShell):
<code>$env:VCPKG_FEATURE_FLAGS="versions"</code>
<code>vcpkg install</code></li>
<li>Passing the feature flags in the command line for vcpkg (example in PowerShell):
<code>vcpkg --feature-flags="versions" install</code></li>
</ul>
<p>In the example below, we will be using Visual Studio Code to create a simple CMake project that automatically reads a vcpkg manifest file and installs dependencies. You can do this in Visual Studio as well. For information on how to set up Visual Studio for use with vcpkg with manifests (for MSBuild or CMake), see <a href="https://devblogs.microsoft.com/cppblog/vcpkg-accelerate-your-team-development-environment-with-binary-caching-and-manifests/">vcpkg: Accelerate your team development environment with binary caching and manifests</a>.</p>
<h4 id="example-1-simple-versioning">Example #1: Simple versioning</h4>
<p>Begin by creating a folder with the following files:</p>
<p><strong>vcpkg.json</strong></p>
<pre class="prettyprint">{
    "name": "versions-test",
    "version": "1.0.0",
    "dependencies": [
        {
            "name": "fmt",
            "version&gt;=": "7.1.3"
        },
        "zlib"
    ],
    "builtin-baseline": "b60f003ccf5fe8613d029f49f835c8929a66eb61"
}</pre>
<p>vcpkg has new version declaration properties when you use manifests. Previously, you could only declare versions for your projects using the “version-string” property. Now that versioning has come around, vcpkg is aware of some new versioning schemes.</p>
<table style="width: 29.7662%;">
<tbody>
<tr>
<td style="width: 30.2663%;"><strong>Version scheme</strong></td>
<td style="width: 80.0773%;"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version</strong></td>
<td style="width: 80.0773%;">Dot-separated numerals: <strong>1.0.0</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version-semver</strong></td>
<td style="width: 80.0773%;">Compliant semantic versions: <strong>1.2.0, 1.2.1-rc</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version-date</strong></td>
<td style="width: 80.0773%;">Dates in YYYY-MM-DD format: <strong>2021-01-01</strong></td>
</tr>
<tr>
<td style="width: 30.2663%;"><strong>version-string</strong></td>
<td style="width: 80.0773%;">Arbitrary strings: <strong>vista, xp</strong></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>The selected versioning scheme has consequences in what vcpkg will allow as a valid version string and the rules for ordering versions. You can read more about versioning schemes in <a href="https://github.com/microsoft/vcpkg/blob/master/docs/users/versioning.reference.md#version-schemes">our documentation</a>.</p>
<p>Second, we use the “<code>version&gt;=</code>” property to declare a minimum version constraint on <code>fmt</code>. Notice that we also declare a dependency on <code>zlib</code> without any version constraint.</p>
<p>And lastly, we declare a “<code>builtin-baseline</code>”, the value of which is a commit SHA from the vcpkg repository.</p>
<p>In our example, vcpkg will look inside commit <code>b60f003ccf5fe8613d029f49f835c8929a66eb61</code> and find what the latest versions of <code>fmt</code> and <code>zlib</code> at that point in time were:</p>
<ul>
<li><code>fmt 7.1.3</code></li>
<li><code>zlib 1.2.11#9</code> (the #9 suffix indicates that this is the 9th version of this library build recipe)</li>
</ul>
<p>The set of libraries and versions listed above can be described as the baseline versions for the dependencies used in this project. Baseline versions get added as additional minimum version constraints when resolving package versions.</p>
<p><strong>main.cpp</strong></p>
<pre class="prettyprint">#include &lt;fmt/core.h&gt;
#include &lt;zlib.h&gt;

int main()
{
    fmt::print("fmt version is {}\n"
               "zlib version is {}\n",
               FMT_VERSION, ZLIB_VERSION);
    return 0;
}</pre>
<p><em>[Above] This is a simple single file program to test that dependencies are correctly installed.</em></p>
<p><strong>CMakeLists.txt</strong></p>
<pre class="prettyprint">cmake_minimum_required(VERSION 3.18)

set(VCPKG_FEATURE_FLAGS "versions")
project(versions-test CXX)

add_executable(main main.cpp)

find_package(ZLIB REQUIRED)
find_package(fmt CONFIG REQUIRED)
target_link_libraries(main PRIVATE ZLIB::ZLIB fmt::fmt)</pre>
<p><em>[Above] To use vcpkg manifests with a CMake project, it is necessary to add find_package and target_link_libraries functions to identify your dependencies in CMakeLists.txt. This experience is the same whether a package manager like vcpkg is being used or not. Including these lines makes it possible for dependencies to be included in builds.</em></p>
<p><strong>.vscode/settings.json</strong></p>
<pre class="prettyprint">{
    "cmake.configureSettings": {
        "CMAKE_TOOLCHAIN_FILE": "D:/vcpkg/scripts/buildsystems/vcpkg.cmake",
        "VCPKG_TARGET_TRIPLET": "x64-windows"
    }
}</pre>
<p><em>[Above] For Visual Studio Code, this is how to point a CMake project to the vcpkg CMake toolchain file. This file must be specified for any CMake project using vcpkg. Other IDEs or editors may have a different experience for pointing to CMake toolchain files.</em></p>
<p>Next, generate the CMake cache using the Visual Studio Code <strong>CMake: Configure</strong> command:</p>
<pre class="prettyprint">[cmakefileapi-driver] Removing d:/versions-test/build/CMakeCache.txt
[proc] Executing command: "C:\Program Files\CMake\bin\cmake.EXE" --no-warn-unused-cli -DCMAKE_TOOLCHAIN_FILE:STRING=D:/vcpkg/scripts/buildsystems/vcpkg.cmake -DVCPKG_TARGET_TRIPLET:STRING=x64-windows -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -Hd:/versions-test -Bd:/versions-test/build -G "Visual Studio 16 2019" -T host=x64 -A x64
[cmake] -- Running vcpkg install
[cmake] Detecting compiler hash for triplet x64-windows...
[cmake] The following packages will be built and installed:
[cmake]     fmt[core]:x64-windows -&gt; 7.1.3 -- D:\vcpkg\buildtrees\versioning\versions\fmt\d99b6a35e1406ba6b6e09d719bebd086f83ed5f3
[cmake]     zlib[core]:x64-windows -&gt; 1.2.11#9 -- D:\vcpkg\buildtrees\versioning\versions\zlib\827111046e37c98153d9d82bb6fa4183b6d728e4</pre>
<p><em>[Above] This is the output produced by the CMake command line when generating the CMake cache. In Visual Studio Code, with the CMake Tools extension installed, the cache can be generated with the &#8220;CMake: Configure&#8221; command.</em></p>
<p>You will know that versioning is working if you notice the “<code>&lt;path-to-vcpkg&gt;/buildtrees/versioning/versions/&lt;portname&gt;/&lt;sha&gt;</code>” pattern in the paths. The port files are being checked out by vcpkg for the declared versions at those locations.</p>
<p>Lastly, run the program:</p>
<pre class="prettyprint">fmt version is 70103  
zlib version is 1.2.11</pre>
<h4 id="example-2-pinning-older-versions">Example #2: Pinning older versions</h4>
<p>Since baselines establish a version floor for all packages and explicit constraints get upgraded when they are lower than the baseline, we need another mechanism to downgrade versions past the baseline.</p>
<p>The mechanism vcpkg provides for that scenario is overrides. When an override is declared on a package, vcpkg will ignore all other version constraints either directly declared in the manifest or from transitive dependencies. In short, overrides will force vcpkg to use the exact version declared, period.</p>
<p>First, change your manifest to add an override on <code>fmt</code> and force vcpkg to use version 6.0.0:</p>
<pre class="prettyprint">{
    "name": "versions-test",
    "version": "1.0.0",
    "dependencies": [
        {
            "name": "fmt",
            "version&gt;=": "7.1.3"
        },
        "zlib"
    ],
    "builtin-baseline": "b60f003ccf5fe8613d029f49f835c8929a66eb61", 
    "overrides": [
        { "name": "fmt", "version": "6.0.0" }
    ]
}</pre>
<p>Next, delete your build folder, generate the CMake cache, and build again:</p>
<pre class="prettyprint">[cmake] -- Running vcpkg install
[cmake] Detecting compiler hash for triplet x64-windows...
[cmake] The following packages will be rebuilt:
[cmake]     fmt[core]:x64-windows -&gt; 6.0.0 -- D:\Work\viromer\versioning\vcpkg\buildtrees\versioning\versions\fmt\d99b6a35e1406ba6b6e09d719bebd086f83ed5f3</pre>
<p>Lastly, run the program:</p>
<pre class="prettyprint">fmt version is 60000  
zlib version is 1.2.11</pre>
<h3 id="how-versioning-works-in-vcpkg">How versioning works in vcpkg</h3>
<p>In the diagram below we depict the chronology of versions released for four different libraries: FMT, zlib, Boost and Azure’s core C++ library.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram.png"><img class="alignnone size-full wp-image-27634 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABIAQMAAAA6QsJaAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEUlEQVQokWNgGAWjYBSMFAAAA/AAAQurTPwAAAAASUVORK5CYII="  alt="Image vcpkg versioning diagram" width="784" height="567" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram.png 784w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram-300x217.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/vcpkg-versioning-diagram-768x555.png 768w" sizes="(max-width: 784px) 100vw, 784px" /></a></p>
<p>The vcpkg versioning system is comprised of the following pieces:</p>
<h4 id="baselines">Baselines</h4>
<p>To enable versioning, it is required that you set a baseline to a specific vcpkg commit. By selecting a baseline, you are selecting a snapshot of a certain point in time of the chronology.
Setting the baseline will set a minimum version floor on all your dependencies, the minimum versions being the ones that existed at the selected snapshot. In the picture above, we would have version 7.1.0 for FMT, version 1.2.11 at port revision 9 for zlib, version 1.74.0 for Boost and the September 2020 release for Azure’s Core C++ library.
An advantage of using baselines is that versions that are contemporary are more likely to be compatible. The main vcpkg registry does, after all, build all libraries it contains at the same time to try to ensure compatibility of the whole catalog at every commit.</p>
<h4 id="constraints">Constraints</h4>
<p>In contrast with baselines that set minimum versions for all packages, constraints allow you to specify a minimum version in a package-by-package basis.</p>
<p>Constraints only allow you to upgrade versions further than those at the baseline. As stated above, the baseline sets a minimum version floor for all packages, so if you attempt to add a constraint that is lower than the baseline, the constraint will be upgraded.</p>
<p>An important thing to notice about constraints is that they are transitive where baselines and overrides are not. Dependencies in the graph can express their own constraints and they will be considered by the version resolution algorithm.</p>
<p>But what if you really need to set a version to be lower than the baseline? How can you do it without lowering the baseline? For those cases, you can use overrides.</p>
<h4 id="overrides">Overrides</h4>
<p>An override forces vcpkg to use a specific version while ignoring all other constraint (either explicit or transitive). This allows the user to solve some specific situations like:</p>
<ul>
<li>Downgrading versions lower than the baseline.</li>
<li>Forcing upgraded/downgraded versions on transitive dependencies.</li>
<li>Solving version conflicts between different packages.</li>
</ul>
<p>In the scenario depicted in the diagram, given all that we know about baselines, constraints, and overrides. We can see that version resolution for a project using all four packages would result in:</p>
<ul>
<li>FMT: Version 7.1.2, as specified via constraint.</li>
<li>zlib: Version 1.2.11 at port revision 2, as specified via override.</li>
<li>Boost: Version 1.74, as defaulted by the baseline.</li>
<li>azure-core-pp: Version 2020-09-01, as defaulted by the baseline.</li>
</ul>
<p>&nbsp;</p>
<h3 id="versions-and-custom-ports">Versions and custom ports</h3>
<p>The last thing to discuss is how overlay ports interact with versioning resolution. The answer is: they do not interact at all by design.
Going into more detail, when you provide an overlay for a port, vcpkg will always use the overlay port without caring what version is contained in it. The reasons are two-fold: (1) it is consistent with the existing behavior of overlay ports (completely masking the existing port), and (2) overlay ports do not (and are not expected to) provide enough information to power vcpkg&#8217;s versioning feature.</p>
<p>If you want to have flexible port customization along with versioning features, you should consider making your own custom registry. See our <a href="https://github.com/microsoft/vcpkg/blob/master/docs/specifications/registries-2.md">registries specification for more details</a>.</p>
<p>&nbsp;</p>
<h3 id="further-reading">Further reading</h3>
<p>If you&#8217;re interested in delving deeper into the details of how versioning works we recommended that you read the <a href="https://github.com/microsoft/vcpkg/blob/master/docs/specifications/versioning.md">original versioning specification</a>.</p>
<p>&nbsp;</p>
<h3 id="give-us-your-feedback">Give us your feedback!</h3>
<p>Try out vcpkg by visiting our <a href="https://github.com/microsoft/vcpkg/issues">GitHub repo</a>. We welcome your feedback on the tool and the new features <a href="https://github.com/microsoft/vcpkg/issues">in our issue tracker</a>. To see what’s next for vcpkg, including support for versioning and registries, <a href="https://aka.ms/vcpkg/roadmap">check out our roadmap</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/">Take control of your vcpkg dependencies with versioning support</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/take-control-of-your-vcpkg-dependencies-with-versioning-support/feed/</wfw:commentRss>
			<slash:comments>8</slash:comments>
		
		
			</item>
		<item>
		<title>Now announcing: Makefile support in Visual Studio Code!</title>
		<link>https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/</link>
					<comments>https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Wed, 17 Feb 2021 23:42:46 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Linux]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27606</guid>

					<description><![CDATA[<p>We are excited to announce a brand-new extension for building and debugging Makefile projects in Visual Studio Code: Makefile Tools (preview)! The extension is in pilot stages, but we’ve curated a list of over 70 popular opensource Makefile projects that work with Makefile Tools.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/">Now announcing: Makefile support in Visual Studio Code!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>We are excited to announce a brand-new extension for building and debugging Makefile projects in Visual Studio Code: <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Makefile Tools (preview)</a>! The extension is in pilot stages, but we’ve curated a <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/repositories.md">list of over 70 popular opensource Makefile projects</a> that work with Makefile Tools. Give it a try and let us know what you think!</p>
<h2 id="installing-the-extension">Installing the extension</h2>
<p>First, install the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Makefile Tools extension</a> from the VS Code Marketplace.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace.png"><img class="alignnone size-full wp-image-27626 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAYAQMAAAA2zMqtAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADUlEQVQYlWNgGAXUBAABUAABeLzIBgAAAABJRU5ErkJggg=="  alt="Image of Makefile Tools extension in VS Code Marketplace" width="1562" height="370" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace.png 1562w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-300x71.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-1024x243.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-768x182.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-tools-marketplace-1536x364.png 1536w" sizes="(max-width: 1562px) 100vw, 1562px" /></a></p>
<h2 id="activating-the-extension">Activating the extension</h2>
<p>Once the extension is installed, it will activate when it finds a Makefile in your project’s root folder. If your project’s Makefile is not in the root folder, you can use the <strong>Makefile Path</strong> setting to instruct the extension where to find it. Update <strong>Makefile Path</strong> by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and then selecting <strong>makefile</strong> under <strong>Extensions.</strong></p>
<p><strong><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath.png"><img class="alignnone size-full wp-image-27611 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAATAQMAAABcCzpuAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADUlEQVQYlWNgGAUQAAABCgABulSa7gAAAABJRU5ErkJggg=="  alt="Image showing the Makefile Tools extension's Makefile Path property in VS Code settings" width="1238" height="241" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath.png 1238w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath-300x58.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath-1024x199.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makefilepath-768x150.png 768w" sizes="(max-width: 1238px) 100vw, 1238px" /></a> </strong></p>
<p>After updating <strong>Makefile Path</strong>, type “makefile” into the Command Palette and run a Makefile Tools command to activate the extension.</p>
<h2 id="configuring-your-project">Configuring your project</h2>
<p>By default, the extension will attempt to use a make program that resides within your $PATH to configure the project. If your make.exe is not in your $PATH, update the <strong>Make Path </strong>setting by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and then selecting <strong>makefile</strong> under <strong>Extensions. </strong>The<strong> Make Path</strong> setting tells the extension where to find your make executable.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath.png"><img class="alignnone size-full wp-image-27612 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAARAQMAAAARw5tlAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADElEQVQImWNgGEkAAADuAAEi77b/AAAAAElFTkSuQmCC"  alt="Image showing the Makefile Tools extension's Make Path property in VS Code settings" width="1230" height="213" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath.png 1230w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath-300x52.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath-1024x177.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile.makepath-768x133.png 768w" sizes="(max-width: 1230px) 100vw, 1230px" /></a></p>
<p>Once your make path is properly set, accept the prompt to allow Makefile Tools to configure IntelliSense.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense.png"><img class="alignnone size-full wp-image-27623 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAYAQMAAAA2zMqtAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADUlEQVQYlWNgGAXUBAABUAABeLzIBgAAAABJRU5ErkJggg=="  alt="Image showing pop-up notification for allowing the Makefile Tools extension to configure IntelliSense" width="1104" height="269" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense.png 1104w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense-300x73.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense-1024x250.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-allow-intellisense-768x187.png 768w" sizes="(max-width: 1104px) 100vw, 1104px" /></a></p>
<p>If you don&#8217;t see that notification, or you accidentally dismissed it, you can grant Makefile Tools permission to configure IntelliSense by running “<strong>C/C++: Change Configuration Provider”</strong> from the Command Palette and selecting <strong>Makefile Tools</strong>.</p>
<p>Now you’re ready to configure your project! If you normally run make from the command line without passing it any additional arguments, you shouldn&#8217;t need to do anything else at this point.</p>
<p>If you regularly pass additional arguments to make, use the Makefile Tools’ <strong>Configurations</strong> setting (<strong>makefile.configurations</strong> in settings.json) to specify those arguments. Makefile.configurations is an array of configuration objects, each with a <strong>name</strong> and <strong>makeArgs</strong> property that holds the arguments to pass to make. To help you out, we’ve <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/repositories.md">documented the correct configurations</a> for over 70 popular open-source repositories. For example, to create a configuration for <a href="https://github.com/littlekernel/lk">littlekernel</a>, where you need to pass “PROJECT=armemu-test” to make, your settings.json would look something like this:</p>
<pre class="prettyprint">"makefile.configurations": [
    {
        "name": "littlekernel",
        "makeArgs": ["PROJECT=armemu-test"]
    }
]</pre>
<p>To choose the configuration for a project, select the Makefile Tools icon in the left explorer menu.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon.png"><img class="alignnone size-full wp-image-27619 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABIAQMAAAA6QsJaAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEUlEQVQokWNgGAWjYBSMFAAAA/AAAQurTPwAAAAASUVORK5CYII="  alt="Image showing the Makefile Tools icon in the explorer menu on the left" width="2871" height="2078" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon.png 2871w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-300x217.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-1024x741.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-768x556.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-1536x1112.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-explorer-icon-2048x1482.png 2048w" sizes="(max-width: 2871px) 100vw, 2871px" /></a></p>
<p>Hover over <strong>Configuration</strong> and select the pencil icon to choose a configuration for your project.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration.png"><img class="alignnone size-full wp-image-27615 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABoAQMAAAA97sdsAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFElEQVQ4jWNgGAWjYBSMglEwFAAABbAAAeubteIAAAAASUVORK5CYII="  alt="Image showing the &quot;edit Configuration&quot; button that appears on hover in the Makefile Tools UI pane" width="836" height="870" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration.png 836w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration-288x300.png 288w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-configuration-768x799.png 768w" sizes="(max-width: 836px) 100vw, 836px" /></a></p>
<p>If you didn’t define any configurations in<strong> makefile.configurations</strong>, the extension will automatically select a default one.</p>
<h2 id="building-targets">Building targets</h2>
<p>After configuring your project, you’re ready to build. Choose a Build target by selecting the pencil icon that appears on hover.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target.png"><img class="alignnone size-full wp-image-27614 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABzAQMAAABU/zU0AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFUlEQVQ4jWNgGAWjYBSMglEwCigBAAZKAAEhOufcAAAAAElFTkSuQmCC"  alt="Image showing the &quot;edit Build target&quot; button that appears on hover in the Makefile Tools UI pane" width="838" height="960" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target.png 838w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target-262x300.png 262w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-build-target-768x880.png 768w" sizes="(max-width: 838px) 100vw, 838px" /></a></p>
<p>Then choose from the list of targets found in your project’s Makefile.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets.png"><img class="alignnone size-full wp-image-27620 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABAAQMAAADWEUA3AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEUlEQVQokWNgGAWjYBQMFAAAA4AAAQxhoXYAAAAASUVORK5CYII="  alt="Image showing a list of build targets found in the project's Makefile, returned by the Makefile Tools extension" width="3240" height="2075" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets.png 3240w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-300x192.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-1024x656.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-768x492.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-1536x984.png 1536w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-list-build-targets-2048x1312.png 2048w" sizes="(max-width: 3240px) 100vw, 3240px" /></a></p>
<p>After setting the Build target, click the Build icon.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target.png"><img class="alignnone size-full wp-image-27613 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABzAQMAAABU/zU0AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFUlEQVQ4jWNgGAWjYBSMglEwCigBAAZKAAEhOufcAAAAAElFTkSuQmCC"  alt="Image showing the Build button in the top right corner of the Makefile Tools UI pane" width="838" height="960" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target.png 838w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target-262x300.png 262w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-build-target-768x880.png 768w" sizes="(max-width: 838px) 100vw, 838px" /></a></p>
<h2 id="debugging-and-running-targets">Debugging and running targets</h2>
<p>To run/debug your program, use the pencil icon to select a Launch target. A configuration for the selected target will be added to the <strong>makefile.launchConfigurations </strong>setting. If you need to pass additional arguments to your targets—things like MIMode, miDebuggerPath, stopAtEntry— add the <strong>binaryArgs</strong> property to the target’s configuration in <strong>makefile.launchConfigurations</strong>.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target.png"><img class="alignnone size-full wp-image-27616 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABxAQMAAAAZN5Q/AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFUlEQVQ4jWNgGAWjYBSMglEwCggBAAYuAAGhWb28AAAAAElFTkSuQmCC"  alt="Image showing the &quot;edit Launch target&quot; button that appears on hover in the Makefile Tools UI pane" width="841" height="952" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target.png 841w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target-265x300.png 265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-choose-launch-target-768x869.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<p>Once the Launch target is set, select the Debug icon to start a debugging session.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target.png"><img class="alignnone size-full wp-image-27618 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABxAQMAAAAZN5Q/AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFUlEQVQ4jWNgGAWjYBSMglEwCggBAAYuAAGhWb28AAAAAElFTkSuQmCC"  alt="Image showing the Debug target button in the top right corner of the Makefile Tools UI pane" width="841" height="952" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target.png 841w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target-265x300.png 265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-debug-target-768x869.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<p>To run the program without debugging, select the Run in Terminal button.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal.png"><img class="alignnone size-full wp-image-27621 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABxAQMAAAAZN5Q/AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAFUlEQVQ4jWNgGAWjYBSMglEwCggBAAYuAAGhWb28AAAAAElFTkSuQmCC"  alt="Image showing the Run in Terminal button in top right corner of the Makefile Tools UI pane" width="841" height="952" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal.png 841w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal-265x300.png 265w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-run-in-terminal-768x869.png 768w" sizes="(max-width: 841px) 100vw, 841px" /></a></p>
<h2 id="makefile-tools-commands">Makefile Tools commands</h2>
<p>You can find all the Makefile Tools commands by opening the Command Palette and typing &#8220;makefile&#8221;. For your convenience, there are commands for building clean and building ALL that you can run without changing the Build target.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands.png"><img class="alignnone size-full wp-image-27617 lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAA6AQMAAAB8qG6QAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEElEQVQokWNgGAWjYBQQAwADLAABC138mwAAAABJRU5ErkJggg=="  alt="Image showing the Makefile Tools extensions commands in the Command Palette, all beginning with &quot;makefile:&quot;" width="1471" height="856" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands.png 1471w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands-300x175.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands-1024x596.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/makefile-commands-768x447.png 768w" sizes="(max-width: 1471px) 100vw, 1471px" /></a></p>
<h2 id="makefile-tools-settings">Makefile Tools settings</h2>
<p>To find all Makefile Tools settings, go to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and then select <strong>makefile</strong> under <strong>Extensions.</strong> The settings you’ll probably use the most are:</p>
<ul>
<li>configurations (tells the extension which arguments to pass to make when configuring your project)</li>
<li>defaultLaunchConfiguration (global debugger settings)</li>
<li>launchConfigurations (debugger settings for specific launch targets)</li>
<li>makePath (path to your make executable)</li>
<li>makefilePath (path to project’s Makefile)</li>
<li>buildLog (alternative to dry-run)</li>
</ul>
<h2 id="known-limitations">Known limitations</h2>
<p>This is a preview release of Makefile Tools, and although we’ve tested it with over 70 repositories, you may need to do some fiddling to configure your project for the first time. Please feel free to submit a PR to <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/repositories.md">this document</a>, adding your repository and its correct configuration settings, to help anyone who might be trying to build the same project.</p>
<p>Check out our <a href="https://github.com/microsoft/vscode-makefile-tools/blob/main/docs/troubleshooting.md">troubleshooting guide</a> for a list of known limitations and work-arounds.</p>
<h2 id="what-do-you-think">What do you think?</h2>
<p>Download the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.makefile-tools">Makefile Tools extension</a> for Visual Studio Code today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/microsoft/vscode-makefile-tools/issues">Issues section of our GitHub repository</a>.</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/">Now announcing: Makefile support in Visual Studio Code!</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/now-announcing-makefile-support-in-visual-studio-code/feed/</wfw:commentRss>
			<slash:comments>3</slash:comments>
		
		
			</item>
		<item>
		<title>Visual Studio Code C++ Extension: Cross-Compilation IntelliSense Configurations</title>
		<link>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/</link>
					<comments>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/#comments</comments>
		
		<dc:creator><![CDATA[Julia Reid]]></dc:creator>
		<pubDate>Tue, 09 Feb 2021 16:00:05 +0000</pubDate>
				<category><![CDATA[Announcement]]></category>
		<category><![CDATA[C++]]></category>
		<category><![CDATA[Visual Studio Code]]></category>
		<guid isPermaLink="false">https://devblogs.microsoft.com/cppblog/?p=27555</guid>

					<description><![CDATA[<p>The February 2021 update of the Visual Studio Code C++ extension is now available! This latest release provides support for cross-compilation IntelliSense configurations and over 60 bug fixes! To find out more about all the enhancements, check out our release notes on GitHub.</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/">Visual Studio Code C++ Extension: Cross-Compilation IntelliSense Configurations</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<p>The February 2021 update of the <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Visual Studio Code C++ extension</a> is now available! This latest release provides <a href="https://github.com/microsoft/vscode-cpptools/issues/1083">support for cross-compilation IntelliSense configurations</a> and over 60 bug fixes! To find out more about all the enhancements, check out our <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.2.0">release notes on GitHub.</a></p>
<h3 id="cross-compilation-intellisense-configurations">Cross-compilation IntelliSense configurations</h3>
<p>With this latest release, you can configure the extension to provide proper IntelliSense when compiling for a different <em>platform</em> than your host OS. That’s right— <em>platform</em>, not just architecture. The C++ extension no longer hardcodes system defines based on your host OS; it’ll use the system defines returned by your compiler.</p>
<p>Let’s say you’re developing on macOS and your project targets Linux. Assuming you have a compiler compatible with your project’s target platform and architecture, the C++ extension will query that compiler using the <strong>Compiler path</strong>, <strong>Compiler arguments, </strong>and<strong> IntelliSense mode</strong> settings in your IntelliSense configuration. If you’re using a custom configuration provider (like CMake Tools) or compile_commands.json, then you don’t need to worry about updating the C++ extension’s IntelliSense configuration; everything should just work.</p>
<p>Your project’s IntelliSense configurations are stored in the c_cpp_properties.json file under the .vscode folder. Edit these settings by selecting <strong>C/C++: Edit Configurations (UI)</strong> from the Command Palette.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations.png"><img class="alignnone wp-image-27564 size-full lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAQAQMAAADan0jAAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADElEQVQImWNgGN4AAADgAAECHtNHAAAAAElFTkSuQmCC"  alt="The UI and JSON Edit Configurations options in the Command Palette" width="1458" height="237" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations.png 1458w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations-300x49.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations-1024x166.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/edit-configurations-768x125.png 768w" sizes="(max-width: 1458px) 100vw, 1458px" /></a></p>
<p>Under your configuration’s <strong>Compiler path </strong>setting<strong>, </strong>enter the path to the compiler compatible with your target platform and architecture.</p>
<p>Then use <strong>Compiler arguments</strong> to provide the target triplet that you use when cross-compiling your code with your compiler. For example, <em>&#8211;target=x86_64-linux</em> if you’re targeting Linux 64-bit. This allows the C++ extension to query the compiler for system defines and include paths specific to your target platform and architecture.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1.png"><img class="alignnone wp-image-27562 size-full lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAATAQMAAABcCzpuAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADUlEQVQYlWNgGAUQAAABCgABulSa7gAAAABJRU5ErkJggg=="  alt="Passing --target=x86_64-linux as a compiler argument" width="1630" height="308" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1.png 1630w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-300x57.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-1024x193.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-768x145.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/compiler-args-1-1536x290.png 1536w" sizes="(max-width: 1630px) 100vw, 1630px" /></a></p>
<p>Next, set <strong>IntelliSense mode</strong> to the platform- and architecture-specific variant of the compiler you’re using (it should closely match the target triplet defined in <strong>Compiler arguments</strong>). If the information returned from querying the compiler doesn’t match the <strong>IntelliSense mode </strong>you chose, the C++ extension will automatically correct the IntelliSense mode for you.</p>
<p><a href="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1.png"><img class="alignnone wp-image-27563 size-full lazyload" data-src="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAATAQMAAABcCzpuAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAADUlEQVQYlWNgGAUQAAABCgABulSa7gAAAABJRU5ErkJggg=="  alt="Selecting linux-clang-x64 for IntelliSense mode" width="1636" height="314" data-srcset="https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1.png 1636w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-300x58.png 300w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-1024x197.png 1024w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-768x147.png 768w, https://devblogs.microsoft.com/cppblog/wp-content/uploads/sites/9/2021/02/intellisense-mode-1-1536x295.png 1536w" sizes="(max-width: 1636px) 100vw, 1636px" /></a></p>
<p>Now when you open your project in VS Code, you’ll get IntelliSense for your target platform instead of macOS. No more squiggles from hardcoded system defines!</p>
<h3 id="additional-enhancements">Additional enhancements</h3>
<p>In addition to supporting cross-compilation IntelliSense configurations, the February 2021 update comes with the following enhancements:</p>
<ul>
<li>clang-format has been updated to version 11. <a href="https://github.com/microsoft/vscode-cpptools/issues/6326">#6326</a></li>
<li>We now ship a native ARM64 clang-format binary with the extension for ARM64 Windows devices (<a href="https://github.com/microsoft/vscode-cpptools/issues/6494">#6494</a>).</li>
<li>We added a command to generate EditorConfig contents from your code formatting settings (vcFormat) <a href="https://github.com/microsoft/vscode-cpptools/issues/6018">#6018</a></li>
<li>We support a new &#8220;console&#8221; launch config property for cppvsdbg (replacing the legacy “externalConsole” property). <a href="https://github.com/microsoft/vscode-cpptools/pull/6794">PR #6794</a></li>
</ul>
<h3 id="bug-fixes">Bug Fixes</h3>
<p>The February 2021 update of the C++ extension knocks out over 60 bug fixes! To name a few:</p>
<ul>
<li>Fix clang-format failing due to missing libtinfo5 on Linux ARM/ARM64. <a href="https://github.com/microsoft/vscode-cpptools/pull/6774">#6774</a></li>
<li>Fix handling of &#8211;sysrootand -isysroot with compileCommands. <a href="https://github.com/microsoft/vscode-cpptools/issues/1575">#1575</a></li>
<li>Fix IntelliSense not updating if a non-opened header is changed. <a href="https://github.com/microsoft/vscode-cpptools/issues/1780">#1780</a></li>
<li>Fix Switch Header/Source not switching to an existing file in another column if it&#8217;s not visible. <a href="https://github.com/microsoft/vscode-cpptools/issues/2667">#2667</a>, <a href="https://github.com/microsoft/vscode-cpptools/issues/6749">#6749</a></li>
<li>Allow the extension to run on x64 emulator of M1 Macs. <a href="https://github.com/microsoft/vscode-cpptools/issues/6713">#6713</a> (Thank you <a href="https://github.com/xymeng16"><strong>@xymeng16</strong></a>! <a href="https://github.com/microsoft/vscode-cpptools/pull/6601">PR #6601</a>)</li>
<li>Fix hover and Find All References for template function overloads. <a href="https://github.com/microsoft/vscode-cpptools/issues/4044">#4044</a>, <a href="https://github.com/microsoft/vscode-cpptools/issues/4249">#4249</a></li>
</ul>
<p>Check out <a href="https://github.com/microsoft/vscode-cpptools/releases/tag/1.2.0">the release notes</a> for more!</p>
<h3 id="what-do-you-think">What do you think?</h3>
<p><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">Download the C++ extension for Visual Studio Code</a> today, give it a try, and let us know what you think. If you run into any issues, or have any suggestions, please report them in the <a href="https://github.com/Microsoft/vscode-cpptools/issues">Issues section of our GitHub repository</a>. You can also join our Insiders program and get access to early builds of our release by going to <strong>File</strong> &gt; <strong>Preferences</strong> &gt; <strong>Settings</strong> and under <strong>Extensions</strong> &gt; <strong>C/C++,</strong> change the “<strong>C_Cpp: Update Channel</strong>” to “<strong>Insiders</strong>.” Then under <strong>Features </strong>&gt; <strong>Extensions</strong>, enable “<strong>Extensions</strong>:<strong> Auto Update</strong>.”</p>
<p>We can be reached via the comments below or in email at <a href="mailto:visualcpp@microsoft.com">visualcpp@microsoft.com</a>. You can also find our team on Twitter at <a href="https://twitter.com/visualc">@</a><a href="https://twitter.com/visualc">VisualC</a>.</p>
<p>&nbsp;</p>
<p>The post <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/">Visual Studio Code C++ Extension: Cross-Compilation IntelliSense Configurations</a> appeared first on <a rel="nofollow" href="https://devblogs.microsoft.com/cppblog">C++ Team Blog</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://devblogs.microsoft.com/cppblog/visual-studio-code-c-extension-cross-compilation-intellisense-configurations/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
			</item>
	</channel>
</rss>
