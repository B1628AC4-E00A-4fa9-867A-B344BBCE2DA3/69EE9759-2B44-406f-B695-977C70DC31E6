<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア]]></title><description><![CDATA[POSTD は、ニジボックスが運営する、エンジニアに向けたキュレーションメディアです。ニジボックスはWebサービスの企画、制作、開発、運用を一貫して担うリクルートの100%子会社です。 リクルートグループのオンラインサービスをはじめ、様々な業種・業界・業態のサービス開発を行っております。]]></description><link>https://postd.cc</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 31 Jan 2023 05:16:38 GMT</lastBuildDate><language>ja</language><atom:link href="https://postd.cc/feed/" rel="self" type="application/rss+xml"/><image><title>POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア</title><link>https://postd.cc</link></image><item><title><![CDATA[Miško HeveryのQwik記事シリーズ]]></title><description><![CDATA[POSTDでは、DEV Communityで公開されているQwikシリーズ の翻訳記事を公開予定です。 翻訳記事の更新に合わせてこのページも更新されていきます。 シリーズ記事一覧 Qwikの紹介 –…]]></description><link>https://postd.cc/series-qwik/</link><guid isPermaLink="false">https://postd.cc/series-qwik/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:01:00 GMT</pubDate><content:encoded><![CDATA[<p>POSTDでは、DEV Communityで公開されている<a href="https://dev.to/mhevery/series/13467">Qwikシリーズ</a> の翻訳記事を公開予定です。</p>
<p>翻訳記事の更新に合わせてこのページも更新されていきます。</p>
<h2>シリーズ記事一覧</h2>
<ol>
<li><a href="/a-first-look-at-qwik-the-html-first-framework/">Qwikの紹介 – HTMLファーストのフレームワーク</a></li>
<li><a href="/death-by-closure-and-how-qwik-solves-it/">クロージャによる死（とQwikによる解決方法）</a></li>
<li><a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣</a></li>
<li><a href="/qwik-the-answer-to-optimal-fine-grained-lazy-loading/">Qwik：最適できめ細かい遅延読み込みを実現</a></li>
<li><a href="/how-to-score-100-on-google-pagespeed-insights-on-mobile/">モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには</a></li>
<li><a href="/your-bundler-is-doing-it-wrong/">既存のバンドラの手法は間違っている</a></li>
</ol>]]></content:encoded></item><item><title><![CDATA[既存のバンドラの手法は間違っている]]></title><description><![CDATA[最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、…]]></description><link>https://postd.cc/your-bundler-is-doing-it-wrong/</link><guid isPermaLink="false">https://postd.cc/your-bundler-is-doing-it-wrong/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、遅延読み込みをする場所とタイミングを決定します。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> chunk <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-chunk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>someSymbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>開発者は以下を行う必要があります。</p>
<ul>
<li>コードのどの部分が遅延読み込みに適しているかを判断します。</li>
<li>既存のアプリケーションワークフローとの互換性がある方法で遅延読み込みを実行します（遅延読み込みは本質的に非同期ですが、遅延読み込みを実行するための理想的な関数は同期型の可能性があるため、遅延読み込みコードを設置できる場所は限られます）。</li>
<li><code class="language-text">./my-chunk</code>にチャンク名を割り当てます。バンドラがチャンクに割り当てる名前や、チャンクを1つのアプリケーションにまとめる方法に影響を及ぼします。</li>
<li>何をチャンクに含めるかを判断します（例えば、<code class="language-text">symbolA</code>と<code class="language-text">symbolB</code>は同じチャンクに含めるべきか、別のチャンクに分けるべきか？）。</li>
</ul>
<p>ここで問題なのは、開発者はソースコードを書いている時点では、遅延読み込みするコードの選択が適切であるか、チャンクに適切なシンボルが存在するかが分からないということです。
この点は、アプリケーションを実際にデプロイし、現実に利用状況を観察してみないとはっきりしません。
例えば、設定ページはほとんどアクセスされないので、メインバンドルから除くべきかもしれません。
あるいは、通知セクションを遅延読み込みにしたところ、実際はユーザが最もよくアクセスするページだったため、ユーザ体験がかえって悪化している可能性もあります。</p>
<p>さらに悪いことに、ひとたび開発者が選択をすると、バンドラがそれを補うためにできることはほんの少しです。
バンドラは、まさに開発者が求めることをしなければなりません。
バンドラにもっと自由を与えるには、まったく新しい方法で問題を見る必要があります。</p>
<p>ポイントは、コードを書いている時点では最終的なバンドルがどうなるかが分からないため、どこにdynamic importを挿入すべきかを判断するための十分な情報がないことです。
一方、チャンクの理想的な姿を判断するための十分なデータが集まったときには、ソースコードはすでに書き上がっています。
さかのぼってdynamic importを挿入するのは、大きな手間になるかもしれません（あるいは、過剰な遅延読み込みによって、アプリを細かく分割しすぎる恐れもあります）。</p>
<p>私たちが求めているのは、チャンクの理想的な数を判断し、現実のユーザによるアプリケーションの利用状況に基づいてチャンク間でコードを移動できることです。
これを実行する際に、さかのぼってソースコードをリファクタリングする必要がないことが望ましいでしょう。
チャンクのレイアウトは、コードとしてコードベースに組み込むのではなく、設定情報としてバンドラに移すべきです。</p>
<p>さらに複雑なことに、最近のフレームワークはすべて同期方式のレンダリングパイプラインを採用しています。
そのため、非同期方式のdynamic importをアプリケーションに挿入するのがとても難しくなります。</p>
<p>最適な遅延読み込み戦略を追求するなら、上記の問題を解決する必要があります。</p>
<h2>Qwikの登場</h2>
<p>コンポーネントはQwikアプリケーションの基本的な構成要素です。
Qwikはコンポーネントを3つの部分に分割することを求めます。</p>
<ol>
<li><strong>ビュー</strong>：コンポーネントのビジュアル部分をレンダリングするJSXコードが含まれます。</li>
<li><strong>ステート</strong>ファクトリー：コンポーネントの新たなステートを作成するコードが含まれます。</li>
<li>イベント<strong>ハンドラ</strong>：コンポーネントの挙動やユーザとのインタラクションに利用されるコードが含まれます。</li>
</ol>
<h2>なぜコンポーネントを3つの部分に分割するのか？</h2>
<p>ほとんどのフレームワークは、ビュー、ステート、ハンドラのコードを1つにまとめています。
以下は、この働きを解説するために用意した擬似フレームワークのコードです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> <span class="token punctuation">{</span>step<span class="token operator">?</span><span class="token operator">:</span>number<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> step <span class="token operator">=</span> props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">-</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">-</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">+</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
 )
}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントのビュー、ステート、ハンドラがすべて一緒になっているのに注目してください。
これはそれらのすべて（ビュー、ステート、ハンドラ）を同時にダウンロード、パース、実行しなければならないことを意味します。
そのため、遅延読み込みはかなり制限されます。</p>
<p>ここで挙げた程度の例では大きな問題にならないかもしれませんが、上記のコードがもっと複雑になって、何KBものコードを一度にダウンロード、パース、実行する必要がある場合を想像してみてください。
その場合、ビュー、ステート、ハンドラを何としても一緒に読み込ませようとするのは良くないかもしれません。
それがなぜ問題なのかを、ユーザのよくある利用パターンを通して見ていきましょう。</p>
<p><strong>ユーザがコンポーネントをクリックしてインタラクトする：</strong></p>
<ul>
<li>一部の<code class="language-text">handler</code>だけが必要：ダウンロードしなければならないのは、トリガーされた特定のハンドラのみです。その他のハンドラはすべて不要です。</li>
<li><code class="language-text">view</code>は<strong>不要</strong>：ハンドラによる再レンダリングが行われない可能性や、異なるコンポーネントの再レンダリングが行われる可能性があるので、ビューは不要かもしれません。</li>
<li><code class="language-text">state factory</code>は<strong>不要</strong>：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>コンポーネントのステートが変更される：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は不要：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>親が新たなコンポーネントを作成する：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は必要：コンポーネントが作成されるため、ステートを初期化するためのコードは必要です。</li>
</ul>
<p>上記の例は、それぞれのケースで必要なのがビュー、ステート、ハンドラ情報の一部のみであることを示しています。
問題は、3つの異なる情報がすべて一緒に埋め込まれているのに対し、それらがコンポーネントのライフサイクルにおいて異なるタイミングでしか利用されないことです。
最適なパフォーマンスを達成するには、コンポーネントに求められる役割に基づき、コンポーネントを部分ごとにダウンロード・実行する方法が必要です。
上記のコードでは、ご覧のとおり、コンポーネントを永久に分離できません。</p>
<h2>分割は簡単</h2>
<p>Qwikは、当面のタスクに必要なコードだけをダウンロード・実行することでこの問題を解決します。
上記の例のコードはシンプルですが、現実のコードはずっと複雑であることを忘れないでください。
さらに、コードが複雑になるとimportが増えることが多く（import自身もimportを必要とします）、コンポーネントのコードは一段と増加します。
この状況を「ツール」で解決することはできません。
コンポーネントをパーツ単位に分割し、必要に応じて遅延読み込みできるようにするための静的解析ツールを作成するのは不可能です。
開発者は、対応する部分ごとにコンポーネントを分割し、きめ細かい遅延読み込みを可能にしなければなりません。</p>
<p>そのために、Qwikはマーカー関数の<code class="language-text">qrlView</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を導入しています。</p>
<p>ファイル：<code class="language-text">my-counter.tsx</code></p>
<div class="gatsby-highlight" data-language="tsx"><pre style="counter-reset: linenumber NaN" class="language-tsx line-numbers"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>
 QComponent<span class="token punctuation">,</span>
 qComponent<span class="token punctuation">,</span>
 qrlView<span class="token punctuation">,</span>
 qrlHandler<span class="token punctuation">,</span>
 qrlState
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントの型を宣言し、プロパティとステートの形態を定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Counter</span> <span class="token operator">=</span> QComponent<span class="token operator">&lt;</span><span class="token punctuation">{</span> step<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
                                   <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのステートファクトリーを宣言します。</span>
<span class="token comment">//これはステートを初期化するために新たなコンポーネントが作成される際に利用されます。</span>
<span class="token comment">//（再ハイドレーションでは利用されません。）</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlState</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのレンダリングに利用されるコンポーネントのビューを定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlView</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのビューは、挙動を記述するハンドラを必要とする場合があります。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update
   <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlHandler</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token punctuation">,</span> <span class="token punctuation">{</span>direction<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
       <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//最後にすべてを1つのコンポーネントにまとめます。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qComponent</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> CounterState<span class="token punctuation">,</span>
 view<span class="token operator">:</span> CounterView<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>上記のコードは他のフレームワークに比べて冗長です。
しかし、コンポーネントを部分ごとに明確に分割するという手間をかけることで、きめ細かい遅延読み込みが可能になるというメリットが生まれます。</p>
<ul>
<li>開発者体験の観点から見て、コンポーネント当たりのオーバーヘッドはあまり変わらないことを忘れないでください。コンポーネントの複雑性が高まるにつれて、オーバーヘッドの増加は大きな問題ではなくなります。</li>
<li>この方式のメリットは、ツールによってコンポーネントを自由に複数のチャンクにパッケージ化し、必要に応じて遅延読み込みできる点です。</li>
</ul>
<h2>裏側で何が起きているのか</h2>
<p><code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>、<code class="language-text">qrlView</code>はいずれもQwik Optimizerのマーカーであり、自身への参照をQRLに変換する必要があることをツールに伝達します。
その結果、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">my-counter.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>qComponent<span class="token punctuation">,</span> qrlView<span class="token punctuation">,</span> qrlHandler<span class="token punctuation">,</span> qrlState<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token function">qComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> <span class="token string">'/chunk-abc#CounterState'</span><span class="token punctuation">,</span> <span class="token comment">// &lt;&lt;===注目</span>
 view<span class="token operator">:</span> <span class="token string">'/chunk-cde#CounterView'</span><span class="token punctuation">,</span>   <span class="token comment">// &lt;&lt;===注目</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ソースファイルの変換に加え、Optimizerはビュー、ステート、ハンドラ間の静的参照をすべて削除します。
QwikはRollupのためのエントリーポイントファイルも作成します。
これらのエントリーポイントは上記のQRLに対応します。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> Counter_update <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterView <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>重要なのは、いくつのエントリーファイルを作成するか、どのエクスポートをどのエントリーファイルと結びつけるかに関して、Qwikに大きな自由がある点です。
これは開発者が遅延読み込みする部分とそうでない部分の境界をまったく指定しないことによります。
その代わり、Qwikは、コードベースにたくさんの遅延読み込み境界（原文: lazy load boundaries）を導入するようにコードを書くよう開発者を導きます。
これによりQwikは、実際のアプリケーションの利用状況に基づき、最適なファイル配分を実現できます。
例えば、小規模なアプリケーションの場合はファイルを1つ作成し、アプリケーションの規模が大きくなるにつれて、エントリーファイルを増やすことができます。
また、特定の機能がめったに利用されない場合、その機能だけを単独のバンドルにすることもできます。</p>
<p>Rollupがエントリーファイルを処理すると、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlHandler<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlView<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>注目してほしいのは、Rollupがファイルの内容を展開してエントリーファイルにまとめ、不要なコードを削除し、理想的なサイズのバンドルを作成している点です。</p>
<h2>制約</h2>
<p>ツールが<code class="language-text">qComponent</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を移動できるようにするため、これらのメソッドの利用は制約されています（すべての有効なJavaScriptプログラムが有効なQwikプログラムとは限りません）。
その制約とは、すべてのマーカー関数が<code class="language-text">export</code>の対象となるトップレベル関数でなければならないというものです。</p>
<p>無効なコードの例は次のとおりです。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> someFn <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./some-place'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//トップレベルではないので無効</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">someFn</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//有効なimportなので問題なし</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>ツールにとっての選択肢</h2>
<p>アプリケーションを小さいファイルに分割しすぎて、ダウンロードのパフォーマンスに悪影響を与えてしまうのは、あり得ないことではありません（むしろ、とてもよくあることです）。
そのため、ツールではファイルをマージしてバンドルにすることを選択できます。
これは理想的な挙動と言えます。
アプリケーション全体の規模が比較的小さい（50KB未満の）場合、数百個ものファイルに分割するのは生産的ではないでしょう。</p>
<p>コード構造がきめ細かければ、ツールは常に、バンドルを大きくする（そして少なくする）ことを選択できます。
しかし、その逆は正しくありません。
コード構造が粗ければ、ツールがコードを分割するためにできることは何もありません。
Qwikは、開発者がアプリケーションを可能な限り小さいチャンクに分割し、ツールを利用して最適なバンドルのチャンクを発見する助けになります。
このように、Qwikはあらゆるサイズのアプリケーションに最適なパフォーマンスを提供できます。</p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには]]></title><description><![CDATA[Google PageSpeed InsightsはWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いス…]]></description><link>https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</link><guid isPermaLink="false">https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p><a href="https://developers.google.com/speed/pagespeed/">Google PageSpeed Insights</a>はWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いスコアが必要不可欠です。</p>
<p>私たちは、モバイルサイトのPageSpeed Insightsスコアを100点にするために何が必要かを探ってきました。
この取り組みを始めたとき、デスクトップサイトのスコアはすでに100点でした。
しかし、現代のeコマースの主流はモバイルコマースであり、モバイルサイトでは60点台半ばのスコアしか獲得できていませんでした。
このブログ記事では、モバイルサイトでも100点を取るための方法を共有します。
多くの企業がデスクトップサイトで100点を獲得していますが、モバイルサイトで100点を取れることは滅多にありません。
それでは始めましょう。</p>
<p>Builder.ioは標準的なNext.jsサイトです。
サイト自体がBuilderコンテンツプラットフォームで実行されているため、画像サイズや事前読み込みなど、コンテンツに関するあらゆるベストプラクティスはすでに守られているはずです。
それでもスコアはわずか60点台にとどまっていました。なぜでしょうか？</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0DMRzttv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iy8vyp90ed82l4kmhshx.png"></p>
<p>その理由を探るために、スコアの内訳を見てみましょう。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--eTUcudeP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aeaoni0mhgjyttr3utm5.png"></p>
<p>問題は以下の2つに分解できます。</p>
<ul>
<li>Total Blocking Time（TBT）とTime to Interactive（TTI）：JavaScriptによるページ上のブロッキング時間が長すぎる。</li>
<li>First Contentful Paint（FCP）とLargest Contentful Paint（LCP）：モバイルブラウザにとって、レンダリングが必要なページ上のコンテンツが多すぎる。</li>
</ul>
<p>そのため、以下を目指す必要があります。</p>
<ol>
<li>JavaScriptの量を減らす。</li>
<li>初回のレンダリング時のコンテンツ量を減らす。</li>
</ol>
<h2>なぜJavaScriptの量が増えるのか？</h2>
<p>私たちのホームページはほとんど静的なページです。
なぜJavaScriptが必要なのでしょうか？それはホームページがNext.jsサイトであり、つまりReactアプリケーションであるからです（ドラッグ&#x26;ドロップエディタによる出力をReactに変換するために<a href="https://github.com/BuilderIO/mitosis">Mitosis</a>を使用しています）。
サイトの大部分は静的ですが、JavaScriptが必要な要素が3つあります。</p>
<ol>
<li>ナビゲーションシステム：メニューにはインタラクティブ性が必要であり、したがってJavaScriptも必要。また、デスクトップとモバイル端末では異なるメニューが使用されている。</li>
<li>チャット用のウィジェットを読み込む必要がある。</li>
<li>Google Analyticsが必要。</li>
</ol>
<p>それぞれ詳しく見ていきましょう。</p>
<h2>アプリケーションのブートストラップ</h2>
<p>サイトはほとんど静的であるとはいえ、それでもアプリケーションです。
メニューを有効にするにはアプリケーションをブートストラップする必要があります。
具体的には、フレームワークは再ハイドレーションを実行する中でテンプレートをDOMと比較し、すべてのDOMリスナーをインストールする必要があります。
このプロセスによって、既存のフレームワークは<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable（再生型）</a>になります。
つまり、たとえページの95％が静的であっても、フレームワークはすべてのテンプレートをダウンロードし、リスナーが存在するかを判断するためにテンプレートを再実行しなければなりません。
これが意味するのは、最初にHTMLとして、次にJavaScriptのJSXとして、サイトが合計2回ダウンロードされるということです。</p>
<p>さらに悪いことに、再ハイドレーションのプロセスは低速です。
フレームワークはDOMの各ノードにアクセスし、仮想DOMとの差分を検出しなければならず、それに時間がかかります。
また、再ハイドレーションのプロセスはDOMリスナーのインストールと同じプロセスなので、遅延させることができません。
再ハイドレーションが遅延すると、メニューは動作しません。</p>
<p>上記は既存のあらゆるフレームワークの根本的な限界を説明したものです。
お分かりのとおり、こうしたフレームワークはすべて<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable</a>です。
これは、既存のどんなフレームワークも、現実のモバイルサイトで100点を取れないという意味でもあります。
PageSpeed Insightsが想定しているモバイルサイトのHTMLとJavaScriptのコード量はごくわずかであり、それに対して現実のコードがあまりに多すぎるのです。</p>
<p>私たちは問題を根本的に考え直す必要があります。
サイトの大部分は静的なので、その部分のJavaScriptを再ダウンロードしたり、不要な部分の再ハイドレーションに時間をかけたりすべきではありません。
このような場面でこそ、<a href="https://github.com/builderio/qwik">Qwik</a>が真の意味で輝きます。
Qwikは<a href="https://github.com/builderio/qwik">replayableではなくresumable（再開型）</a>で、それがあらゆる違いを生み出します。
結果として、Qwikでは以下が不要になります。</p>
<ol>
<li>ページを読み込むときのブートストラップ</li>
<li>リスナーをどこに入れるべきか判断するためにDOMを探索すること</li>
<li>メニューを動かすためにJavaScriptをダウンロード・実行すること</li>
</ol>
<p>これらはすべて、サイトの読み込みを実行するためのJavaScriptをほとんど必要とせず、それでもサイトのインタラクティブ性を完全に維持できることを意味します。</p>
<h2>Intercom</h2>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--On4okiXm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/v8v1uurp49y7nlkh7fr3.png"></p>
<p>Intercomは、私たちのサイトで実行されているサードパーティウィジェットで、私たちとお客様のインタラクションを可能にします。
このウィジェットをインストールする標準的な方法は、例えば以下のように、JavaScriptをHTMLに少しだけ追記することです。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">async</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://widget.intercom.io/widget/abcd1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">defer</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
<span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span><span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、上記のコードには2つの問題があります。</p>
<ol>
<li>ダウンロードと実行が必要なJavaScriptが増え、TBTとTTIに悪影響を及ぼす。</li>
<li>レイアウトシフトが発生し、CLSに悪影響を及ぼす可能性がある。その原因は、最初にウィジェット以外のUIがレンダリングされ、その後にJavaScriptのダウンロードと実行によってUIがウィジェットとともに再びレンダリングされるためである。
Qwikはそれら両方の問題を同時に解決します。</li>
</ol>
<p>まず、QwikはIntercomがウィジェットのレンダリングに使用するDOMを取得します。
次に、そのDOMが以下のように実際のページに挿入されます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app<span class="token punctuation">"</span></span> <span class="token attr-name">aria-live</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>polite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-launcher intercom-launcher<span class="token punctuation">"</span></span>
    <span class="token attr-name">role</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span>
    <span class="token attr-name">tabIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{0}</span>
    <span class="token attr-name">arial-abel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Open Intercom Messenger<span class="token punctuation">"</span></span>
    <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>ui:boot_intercom<span class="token punctuation">'</span></span>
  <span class="token punctuation">></span></span>
    ...
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-style<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">...</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この方法のメリットは、ウィジェットがアプリケーションの残りの部分と同時に即座にレンダリングされることです。
ブラウザがIntercomのJavaScriptをダウンロードし、ウィジェットの作成を実行している間、遅延や画面のちらつきは発生しません。
その結果、ユーザ体験が改善され、Webサイトのブートストラップが高速化されます（モバイル端末の通信量も節約できます）。</p>
<p>ただし、ウィジェットがクリックされたことを検知する方法や、ユーザのインタラクションに応じてウィジェットのモックアップを実際のIntercomウィジェットに置き換える何らかのコードは依然として必要です。
これは<code class="language-text">on:click=&quot;ui:boot_intercom&quot;</code>属性によって実現できます。
この属性は、ユーザがウィジェットのモックアップをクリックした場合に、Qwikに<code class="language-text">boot_intercom.js</code>をダウンロードさせるものです。</p>
<p><code class="language-text">boot_intercom.js</code>の内容</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'https://widget.intercom.io/widget/abcd1234'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> container <span class="token operator">=</span> element<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 <span class="token keyword">const</span> body <span class="token operator">=</span> container<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'show'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このファイルは、実際のIntercomウィジェットをダウンロードし、モックアップを削除し、Intercomをブートストラップします。
こうした作業はすべて勝手に行われ、ユーザはウィジェットが入れ替わったことにまったく気づきません。</p>
<h2>Google Analytics</h2>
<p>これまで私たちはJavaScriptの遅延読み込みに取り組み、Webサイトのパフォーマンスを順調に改善してきました。
しかし、アナリティクスは別物です。
なぜなら、アナリティクスを遅延させることはできず、ただちにブートストラップが必要だからです。
アナリティクスをブートストラップするだけで、モバイルサイトのPageSpeed Insightsスコアで100点を取るのは難しくなります。
この問題を解決するために、<a href="https://github.com/adamdbradley/partytown">PartyTown</a>を利用して、Web WorkerでGoogle Analyticsを実行します。
詳しくは今後の記事で説明します。</p>
<h2>JavaScriptの遅延</h2>
<p>上記の処理は、Webサイトがダウンロード・実行しなければならないJavaScriptの量を約1KBに減らします。
実行にかかる時間はわずか1ミリ秒で、ほとんどゼロと言ってよいでしょう。
このようにJavaScriptを最小限にすることで、TBTとTTIのスコアが完璧になります。</p>
<h2>HTMLの遅延</h2>
<p>しかし、JavaScriptがほとんど存在しなくても、画面上の領域をレンダリングするためにクライアントに送信するHTMLの量を修正しない限り、依然としてモバイルサイトで100点は取れません。
FCPとLCPを改善するには、とにかくHTMLを最小限に減らさなければなりません。
それを実現する方法は、画面上の領域のHTMLのみを送信することです。</p>
<p>これは目新しいアイデアではありませんが、実行するのは骨が折れます。
アプリケーションを画面上の領域と画面外の領域に簡単に分割する方法がないため、既存のフレームワークでは困難です。
ここでは仮想DOMも役に立ちません。
たとえ表示されるのがほんの一部だとしても、アプリケーションは仮想DOM全体を生成するからです。
フレームワークは、サイトの一部が欠けていると再ハイドレーション時にサイト全体を再生成するため、初回のブートストラップ時の作業がさらに増えます。</p>
<p>理想的には、画面外の領域のHTMLは送信せず、画面上の領域のメニューシステムは完全にインタラクティブな状態に維持したいところです。
しかし実際には、現実のサイトでそのようなベストプラクティスが見られないことから分かるように、実現するのは困難です。難しすぎるので誰もやらないのです。</p>
<p>QwikはDOM主体であり、それがすべての違いを生み出しています。
まずページ全体がサーバでレンダリングされます。
その後、ページの中で送信する必要がない部分が特定され、削除されます。
ユーザのスクロールに応じて、残りの部分が遅れてダウンロードされ、ページに挿入されます。
QwikはステートレスでDOM主体のフレームワークであるため、この種のDOMの操作による影響を受けません。</p>
<p>これは私たちのサーバで、サイトの画面外の領域で遅延読み込みを実現している実際のコードです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">async</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vmSandbox<span class="token punctuation">.</span><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'./server-index'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ServerIndexModule<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serverIndex</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> lazyNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'section[lazyload=true]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> lazyHTML <span class="token operator">=</span> lazyNode<span class="token punctuation">.</span>innerHTML<span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
      <span class="token punctuation">(</span>lazyNode <span class="token keyword">as</span> HTMLElement<span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'999em'</span><span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'on:document:scroll'</span><span class="token punctuation">,</span> <span class="token string">'ui:/lazy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>transpiledEsmFiles<span class="token punctuation">[</span><span class="token string">'lazy.js'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        export default (element) => {
          element.removeAttribute('on:document:scroll');
          element.style.height = null;
          element.innerHTML = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>lazyHTML<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
        };</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コードは簡潔で的確ですが、既存のどのフレームワークでも実現するのは困難でしょう。</p>
<p>以下は、画面外の領域を遅延読み込みするようにした実際のサイトです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o48jE9q6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/565yei3n8jydkkvs81yr.gif"></p>
<p>当初、ページは画面外のコンテンツを読み込んでいません。
ユーザがスクロールすると、すぐにコンテンツが追加されます。
ほとんど一瞬でコンテンツが追加されるのは、複雑なコードを実行する必要がなく、高速で単純な<code class="language-text">innerHTML</code>だけで済むためです。</p>
<h2>実際に試す</h2>
<p>こちらのページを実際に体験してみてください：<a href="https://www.builder.io/?render=qwik">https://www.builder.io/?render=qwik</a> （<a href="https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.builder.io%2F%3Frender%3Dqwik">PageSpeed Insights</a>のスコアもご覧ください）。
アナリティクスについてはまだ説明していませんが、近いうちに記事を投稿する予定です。</p>
<p>サイトは気に入っていただけましたか？
私たちは、お客様のサイトが超高速に利用できるものとなるように、Builder.ioのすべてのお客様にQwikを提供したいと考えています。
これは今まで見たことがないほど高速なプラットフォームになるはずです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Ii5M-zIi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2rgulo7ew94yp06dyevs.png"></p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwik：最適できめ細かい遅延読み込みを実現]]></title><description><![CDATA[Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけ…]]></description><link>https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</link><guid isPermaLink="false">https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけでなく、アプリケーションが続く限り行われます。
言い換えると、Qwikはきめ細かい遅延読み込みを追求しているのです。
「きめ細かい」とは、ユーザのアクションを処理するのに直接必要なコードのみがダウンロードされるという意味です。
この記事では、きめ細かい遅延読み込みを実現するために解決すべき技術的課題について探っていきます。</p>
<h2>リスナーをシリアライズ</h2>
<p>最も明確に解決すべき課題は初回のページ読み込みです。
この点に関しては、「<a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に</a>」で対応策をすでに取り上げました。
ポイントは、イベントの名称とアクションをURLとしてシリアライズし、DOMの属性として保持することです。その後、最上位のグローバルなイベントハンドラがイベントをリッスンし、そのイベントに関連するコードをダウンロードできます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>このコードは、初回のページ読み込みで（1KBのローダを除いて）JavaScriptを一切読み込むことなく、上記の処理を実現します。
これにより初回読み込み時のTime to Interactiveの目標を達成できますが、新たな問題が生まれます。
私たちは、ユーザとの初回のインタラクション時にアプリケーション全体をダウンロードしたり、ブートストラップしたりしたくはありません。
それでは初回の読み込み時から初回のインタラクション時へ問題を先送りするだけになってしまいます（それどころか、ユーザとの初回のインタラクション時に大きなレイテンシが生じるので、状況は悪化しています）。</p>
<p>この問題は、ユーザとの1回のインタラクションで、アプリケーション全体のダウンロードやブートストラップが行われないようにすれば解決です。
その代わり、インタラクションの処理に直接必要なコードやコンポーネントのみのダウンロード、ブートストラップ、再ハイドレーションを行えばよいのです。
そのため、きめ細かい遅延読み込みが必要になります。</p>
<p>これはイベントをHTMLやDOMへシリアライズすればすべて実現できます。
そうしなければ、テンプレートの読み込みを遅延させるのは不可能でしょう。
なぜなら、フレームワークはイベントの場所を特定するためにテンプレートをダウンロードする必要があるからです。</p>
<h2>非同期かつアウトオブオーダー方式によるコンポーネントのハイドレーション</h2>
<p>初回のインタラクションによるアプリケーション全体のダウンロードやブートストラップを避けるには、コンポーネントを非同期かつアウトオブオーダー方式で再ハイドレートする必要があります。</p>
<p>ここでいう非同期とは、レンダリングシステムがレンダリングを一時停止してコンポーネントのテンプレートを非同期にダウンロードし、それからレンダリングのプロセスを再開できるという意味です。
レンダリングプロセスがすべて完全な同期方式である既存のフレームワークとはとても対照的です。
レンダリングが同期方式である場合、非同期の遅延読み込みを挿入する余地はありません。その結果、すべてのテンプレートをレンダリングの呼び出し前に準備する必要があります。</p>
<p>既存の再ハイドレーション戦略にはもう1つ問題があります。
それは再ハイドレーションがルートコンポーネントから始まり、ルート以下のすべてのコンポーネントを同期方式で再ハイドレートすることです。
そのため、すべてのコンポーネントを同時に再ハイドレートしなければならず、あらゆるコンポーネントのダウンロードを強いられます。
その結果、初回のインタラクション時の処理時間が長くなります。
アウトオブオーダー方式のハイドレーションとは、各コンポーネントを他のコンポーネントとは独立して任意の順番で再ハイドレートできるという意味です。
これにより、Qwikはリクエストの処理に必要な最小限のコンポーネントのみを再ハイドレートすることが可能になります。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./path/MyComponent_template<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ... some content ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のケースでは、<code class="language-text">&lt;div&gt;</code>は<code class="language-text">MyComponent_template.ts</code>と紐づけられたコンポーネントを表しています。
Qwikは、コンポーネントを再レンダリングする必要があると判断した場合のみテンプレートをダウンロードするため、ダウンロードがさらに遅延されます。</p>
<p>再ハイドレーションがアウトオブオーダー方式でなければ、フレームワークはすべてのテンプレートを一度にダウンロードし、再ハイドレートしなければなりません。
その結果、初回のインタラクション時に、ダウンロードと実行による大きな負荷がかかります。</p>
<h2>レンダリングをイベントハンドラから分離</h2>
<p>Qwikに関して考慮が欠かせないポイントは、既存のあらゆるレンダリングシステムがイベントリスナーをテンプレートに埋め込んでいることです。
そのため、コンポーネントを再レンダリング（または再ハイドレート）する必要があるときに、ブラウザはすべてのリスナーを必要性にかかわらずダウンロードしなければなりません。
リスナーは複雑なコードに紐づいていることが多いので、ダウンロードされるコード量はさらに増加します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded eagerly
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikはイベントハンドラをテンプレートのコードから分離します。これはリスナーとテンプレートを別々に、必要に応じてダウンロードできることを意味します。</p>
<p><code class="language-text">MyComponent_template.ts</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token function">MyComponent_template</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded lazily
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">MyComponent_onClick.ts</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>イベントハンドラをテンプレートから分離しなければ、フレームワークはコンポーネントの再レンダリングに必要な量よりはるかに多くのコードをダウンロードしなければなりません。
さらに、イベントハンドラは複雑で、他の依存関係を持っていることが多いため、ダウンロードが必要なコード量は増加します。</p>
<h2>コンポーネントのステートのシリアライズ</h2>
<p>コンポーネントを再ハイドレートするプロセスの最も重要な部分は、コンポーネントのステートを復元することです。
既存のフレームワークにはステートをシリアライズする方法がありません。
コンポーネントのステートがどこにあるかを確定するための標準的な方法が存在しないからです。</p>
<p>Qwikはコンポーネントをいくつかの部分に分解します。</p>
<ul>
<li><em>props</em>：コンポーネントの単なるプロパティ。DOMに反映される。例えば<code class="language-text">&lt;counter min=&quot;0&quot; max=&quot;100&quot;/&gt;</code>のpropsは<code class="language-text">{min: 0, max: 100}</code>。</li>
<li><em>state</em>：コンポーネントの内部ステート。DOMにシリアライズできる。</li>
<li><em>transient state</em>：追加的なステートで、コンポーネントによるキャッシュは可能だが、シリアライズは不可能なものを指す。この情報は再計算する必要がある（例：コンポーネントとサーバが通信している間の一時的なプロミス）。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Conter_template<span class="token punctuation">"</span></span>
     <span class="token attr-name">:.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>{count: 42}<span class="token punctuation">'</span></span>
     <span class="token attr-name">min</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">max</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_incremente<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  42
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_decrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントがステートをシリアライズできない場合、特定のコンポーネントを独立に再ハイドレートするのは不可能でしょう（コンポーネントはどこでステートを取得するというのでしょうか？）。
その結果、フレームワークは、ステートの計算やダウンロードのための追加コードをサーバからダウンロードしなければなりません。
Qwikはこうした問題のすべてを<a href="/html-first-javascript-last-the-secret-to-web-speed/">DOM内にステートをシリアライズする</a>ことで回避します。</p>
<h2>アプリや共有ステートのシリアライズ</h2>
<p>コンポーネント内のみで有効なコンポーネントステートに加え、複数のコンポーネントで利用されるアプリケーションステートも存在します。
これもDOM内にシリアライズする必要があります。共有ステートは以下に分解できます。</p>
<ul>
<li><em>key</em>：あるステートをただ1つに特定するID。コンポーネント内でステートを参照するために利用される。</li>
<li><em>state</em>：複数のコンポーネントで共有されるステート。DOM内にシリアライズできる。</li>
<li><em>transient state</em>：アプリケーションによるキャッシュは可能だが、シリアライズは不可能な追加ステート。この情報は再計算が可能でなければならない。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span>
     <span class="token attr-name">:item:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Item<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>789</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Shoe<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>43.21<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>987</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Sock<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>12.34<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>アプリケーションのステートをシリアライズすることで、コンポーネントが同じ情報を複数の場所でレンダリングし、他のコンポーネントとコミュニケーションできます。
フレームワークが共有ステートを把握・管理しないと、フレームワークがステートの変更を認識できないため、コンポーネントの独立したハイドレーションが不可能になります（例えば、AngularとReactにはレンダリング関数に紐づけられた明確なステート管理機能がありません。その結果、アプリケーションのステートが変更されたときにアプリケーション全体を再レンダリングする以外に妥当な方法がなく、きめ細かい遅延読み込みが困難です）。</p>
<h2>アプリのステートとコンポーネントの間のリアクティブな関係</h2>
<p>ステートを把握するフレームワークの真のメリットは、フレームワークがステートとコンポーネントの関係を認識できる点にあります。
これが重要なのは、任意のステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要があるか把握できるためです。
あるいは、それ以上に重要なのは、ステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要がないかを把握できることでしょう。
例えば、ショッピングカートに商品を追加するときは、ショッピングカート内の商品の個数を表示するコンポーネントのみを再レンダリングすべきですが、これはページ全体のごく一部でしかありません。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Unrelated<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./ShoppingCart<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$cart<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   2 items
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AddItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>buy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikの目標は再ハイドレートするコンポーネントの数を最小限にすることです。
ユーザが<code class="language-text">&lt;button&gt;</code>をクリックすると、Qwikは<code class="language-text">./AddItem</code>をダウンロードし、<code class="language-text">cart:432</code>のアプリケーションステートを更新します。
さらにQwikは、<code class="language-text">bind:cart:432</code>を持つコンポーネントが、そのステートを利用している唯一のコンポーネントであり、したがって再ハイドレーションと再レンダリングが必要な唯一のコンポーネントであると判断します。
Qwikはページ上のほとんどのコンポーネントを除外できるため、きめ細かい遅延読み込みを維持できます。
どのコンポーネントがどのステートと関係しているかを把握できるという点は、他のフレームワークには存在しないとても重要な特徴です。
この特徴によって、アプリケーションの起動時やライフサイクル全体を通じたきめ細かい遅延読み込みが可能になります。</p>
<h2>コンポーネントの分離</h2>
<p>これまでQwikがどのようにコードのきめ細かい遅延読み込みをサポートするか説明してきました。
上記の仕組みがすべて機能するのは、Qwikがアプリケーション内のデータフローを認識しているからです。
Qwikはこの情報を、再ハイドレートする必要がないコンポーネントを取り除き、必要なコンポーネントのみを再ハイドレートするために利用します。
これが暗に意味するのは、Qwikがコンポーネントと他のコンポーネントの通信を認識する必要があるということです。
コンポーネントは他のコンポーネントと秘密の会話をしてはならないのです。</p>
<p>コンポーネントがステートを取得したことをQwikが把握できない場合、Qwikは、ステートが変更されたときにそのコンポーネントの再ハイドレーションや再レンダリングが必要であることを認識できません。
そのため、コンポーネントは自身の依存関係のリストをプロパティに明記する必要があります。</p>
<p>この明確なリストがないと、フレームワークは、ステートが変更された時点ですべてを再レンダリングしなければなりません。
その結果、アプリケーション全体のダウンロードとブートストラップが行われることになります。</p>
<h2>結論</h2>
<p>Webアプリケーションが遅延読み込みに対応した構造となるように、開発のアプローチを変える必要がある点は数多くあります。
ポイントは、現在のフレームワークはこの問題を解決する助けにならず、ときには悪化させるという点です（例えば、ページ全体の再ハイドレーション、同期方式のレンダリングなど）。
Qwikはきめ細かい遅延読み込みを実現し、どんなに大規模で複雑であっても1秒未満で読み込めるサイトやアプリを開発できます。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣]]></title><description><![CDATA[すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJ…]]></description><link>https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</link><guid isPermaLink="false">https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJavaScriptヒープに保持します。<a href="https://github.com/builderio/qwik">Qwik</a>のユニークな点は、ステートが属性としてDOMに保持されることです（リファレンスもクロージャもシリアライズして送受信するのは不可能ですが、文字列であるDOM属性なら可能です。これがresumability(再開性）のカギとなります）。</p>
<p>DOMにステートを保持することには、以下のように多くのユニークなメリットがあります。</p>
<ol>
<li>DOMはシリアライズの形式としてHTMLを使用します。ステートを文字列属性としてDOMに保持することで、アプリケーションをいつでもHTMLにシリアライズできます。HTMLを送信し、別のクライアントでDOMにデシリアライズすることが可能になります。デシリアライズされたDOMは、そこから再開できます。</li>
<li>各コンポーネントを他のコンポーネントとは独立して再開できます。このアウトオブオーダー方式の再ハイドレーションによって、アプリケーション全体の一部のみを再ハイドレートすることが可能であり、ユーザのアクションに応じてダウンロードしなければならないコード量が制限されます。これは従来のフレームワークとは全く異なる点です。</li>
<li>Qwikはステートレスなフレームワークです（アプリケーションのステートはすべて文字列としてDOMに保持されます）。ステートレスなコードはシリアライズ、送受信、再開が簡単です。各コンポーネントを独立に再ハイドレートすることも可能になります。</li>
<li>アプリケーションを（初回のレンダリング時だけでなく）いつでも何度でもシリアライズできます。</li>
</ol>
<p>例として、シンプルなCounterコンポーネントと、ステートのシリアライズの仕組みを見てみましょう（これはサーバサイドでレンダリングされたHTMLの出力結果であり、必ずしも開発者がこのようなコードを書くわけではありません）。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">::app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AppState<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">app-state:</span>1234</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{count: 321}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name">::.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{countStep: 5}<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span>app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state:1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_increment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
    321.
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_decrrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<ul>
<li><code class="language-text">::app-state</code>（アプリケーションステートのコード）：アプリケーションステートの変更コードをダウンロードできるURLを指します。ステートの更新コードは、ステートを変更する必要がある場合のみダウンロードされます。</li>
<li><code class="language-text">app-state:1234</code>（アプリケーションステートのインスタンス）：特定のアプリケーションのインスタンスへのポインタ。ステートをシリアライズすることで、アプリケーションはステートの再構築をやり直すのではなく、中断した所から再開できます。</li>
<li><code class="language-text">decl:template</code>（テンプレートの宣言）：コンポーネントのテンプレートをダウンロードできるURLを指します。コンポーネントのステートが変更され、再レンダリングする必要があるとQwikが判断するまで、テンプレートはダウンロードされません。</li>
<li><code class="language-text">on:q-render</code>（コンポーネントのレンダリングのスケジュール設定）：フレームワークは再レンダリングが必要なコンポーネントを追跡しなければなりません。これは通常、無効化されたコンポーネントの内部リストを保存することで行われます。Qwikでは、無効化されたコンポーネントのリストは、属性としてDOMに保存されます。その後、コンポーネントは<code class="language-text">q-render</code>イベントのブロードキャストを待ちます。</li>
<li><code class="language-text">::.=&quot;{countStep: 5}&quot;</code>（コンポーネントのインスタンスの内部ステート）：コンポーネントは、再ハイドレーション後も内部ステートを保持しなければならない場合があります。このステートはDOMに保持できます。コンポーネントは、再ハイドレートされた時点で、再開に必要なすべてのステートを保持しています。ステートの再構築は不要です。</li>
<li><code class="language-text">bind:app-state=&quot;state:1234&quot;</code>（共有アプリケーションステートへのリファレンス）：複数のコンポーネントが同じ共有アプリケーションステートを参照できるようにします。</li>
</ul>
<h2><code class="language-text">querySelectorAll</code>は強い味方</h2>
<p>フレームワークの一般的な役割の1つは、アプリケーションのステートが変更されたときに、どのコンポーネントの再レンダリングが必要か特定することです。
この作業が発生する理由はいくつかあります。
例えば、コンポーネントが明確に無効とされる場合や（<code class="language-text">markDirty()</code>）、アプリケーションの共有ステートの変更によりコンポーネントが暗黙に無効とされる場合などです。</p>
<p>上記の例では、<code class="language-text">count</code>が<code class="language-text">app-state:1234</code>をキーとしてアプリケーションステートに保持されています。
ステートが更新された場合、そのアプリケーションステートに依存するコンポーネントは無効化（再レンダリングのキュー）が必要です。
フレームワークはどのように更新すべきコンポーネントを把握するのでしょうか？</p>
<p>ほとんどのフレームワークの場合、その答えは、単純にルートコンポーネントからアプリケーション全体を再レンダリングすることです。
この戦略は、コンポーネントのテンプレートすべてをダウンロードする必要があるという残念な結果を生み、ユーザとのインタラクションのレイテンシに悪影響を及ぼします。</p>
<p>一部のフレームワークはリアクティブで、任意のステートが変更された場合に再レンダリングが必要なコンポーネントを追跡しています。
しかし、これはテンプレートを囲い込むクロージャの形式で記録されます（<a href="/death-by-closure-and-how-qwik-solves-it/">「クロージャによる死」</a>を参照）。
その結果、リアクティブな接続が初期化されるアプリケーションのブートストラップ時に、すべてのテンプレートをダウンロードしなければなりません。</p>
<p>Qwikはコンポーネントレベルでリアクティブです。
そのため、ルートからレンダリングを開始する必要はありません。
しかし、Qwikはリアクティブなリスナーをクロージャの形式で保持するのではなく、属性の形式でDOMに保持しているので、レンダリングを途中から再開できます。</p>
<p><code class="language-text">count</code>が更新されると、Qwikは以下の<code class="language-text">querySelectorAll</code>を実行し、どのコンポーネントを無効化する必要があるかを内部で判断します。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'bind\\:app-state\\:1234'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>markDirty<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>上記のクエリによって、Qwikはどのコンポーネントがステートに依存しているかを判断し、各コンポーネント上で<code class="language-text">markDirty()</code>を呼び出します。
<code class="language-text">markDirty()</code>はコンポーネントを無効化し、そのコンポーネントを再レンダリングが必要なコンポーネントのキューに追加します。
これは<code class="language-text">markDirty</code>の複数の呼び出しを1つのレンダリングパスに連結することで行われます。
レンダリングパスは<code class="language-text">requestAnimationFrame</code>を利用してスケジュールを設定します。
しかし、ほとんどのフレームワークとは異なり、Qwikはこのキューも属性としてDOMに保持します。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">requestAnimationFrame</code>はレンダリングのスケジュール設定に利用されます。
これは論理的に考えれば、コンポーネントが待っている<code class="language-text">q-render</code>イベントを<code class="language-text">requestAnimationFrame</code>がブロードキャストすることを意味します。
ここで再び<code class="language-text">querySelectorAll</code>の出番です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'on\\:q-render'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>jsxRender<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ブラウザにはブロードキャストイベント（イベントのバブリングの逆）が存在しませんが、<code class="language-text">querySelectorAll</code>を利用すれば、イベントのブロードキャストを受け取るべきコンポーネントをすべて特定できます。
さらに、<code class="language-text">jsxRender</code>関数を利用してUIを再レンダリングします。</p>
<p>ポイントは、Qwikがどの時点でもDOMの外部でステートを保持する必要がない点です。
あらゆるステートは属性としてDOMに保持され、自動的にHTMLにシリアライズされます。
つまり、いつでもアプリケーションのスナップショットをHTMLとして保存し、それを送信したり、デシリアライズしたりできるということです。アプリケーションは途中から自動的に再開されます。</p>
<p>Qwikはステートレスであり、それこそがQwikアプリケーションにresumableがある理由です。</p>
<h2>メリット</h2>
<p>アプリケーションがresumableであることは、フレームワークのステートのすべてをDOMエレメントに保持する明確なメリットです。
しかし、一見しただけでは分かりにくい、他のメリットもあります。</p>
<p>そのメリットとは、ビューポートの外側にあるコンポーネントのレンダリングをスキップできることです。
コンポーネントのレンダリングが必要かを判断するために<code class="language-text">q-render</code>イベントをブロードキャストすると、コンポーネントが表示されているかどうかを判断し、非表示コンポーネントのレンダリングを簡単にスキップできます。
また、レンダリングをスキップすれば、テンプレートなどのコードを一切ダウンロードする必要がありません。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0C5MyDdy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l7y32eh60iarvc277zl9.png"></p>
<p>ステートレスのもう1つのメリットは、アプリケーションが実行されている間にHTMLの遅延読み込みが可能であることです。
例えば、サーバは最初に表示される画面のレンダリングに必要なHTMLを送信する一方で、画面に表示されていない部分のHTMLをスキップできます。
ユーザは最初の画面でインタラクションを開始し、アプリケーションを使用することが可能です。
ユーザがスクロールし始めた時点で、アプリケーションは他のHTMLを読み込み、それをDOMの末尾に<code class="language-text">innerHTML</code>で挿入します。
Qwikはステートレスであるため、すでに実行されているアプリケーションに何の問題も発生させずに追加のHTMLを挿入できます。
Qwikが新たなHTMLを認識するのはインタラクションが行われたときであり、その時点までHTMLのハイドレーションは遅延されます。
こうしたユースケースは、現行世代のフレームワークで実現するのがとても難しいものです。</p>
<p>私たちはQwikの未来と、それが切り開くユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[クロージャによる死（とQwikによる解決方法）]]></title><description><![CDATA[世界中にQwikを紹介した前回の記事では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が…]]></description><link>https://postd.cc/death-by-closure-and-how-qwik-solves-it/</link><guid isPermaLink="false">https://postd.cc/death-by-closure-and-how-qwik-solves-it/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>世界中にQwikを紹介した<a href="/a-first-look-at-qwik-the-html-first-framework/">前回の記事</a>では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が現在の場所までどのようにたどり着いたかを理解しておくことが重要です。
現代のフレームワークはある前提のもとに成り立っており、
それが優れたTime to Interactive（TTI）スコアの実現を妨げているのですが、
その前提とはどのようなものなのでしょうか。
現行世代のフレームワークの現時点における限界を理解することで、
Qwikの設計思想がなぜ最初は驚くべきものに思えるのか、より深く知ることができるでしょう。</p>
<h2>TTIについて</h2>
<p>TTIは、URLに遷移してからページがインタラクティブになるまでの時間を測定したものです。
レスポンシブなサイトとしての体裁を整えるには、サーバーサイドレンダリング（SSR）が必須です。
この背景にある考え方は、サイトを素早く表示し、ユーザがクリックすればいいか判断できるようになるまでに、
アプリケーションが自身をブートし、すべてのリスナーをインストールするというものです。
そのためTTIは、実際にはフレームワークがDOMリスナーをインストールするのにかかる時間を測定していると言えます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--85XBH76v--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jlvs7wu983qt0846c2a1.png"></p>
<p>上の図では、ブートからインタラクティブになるまでの時間に焦点を当てています。
フレームワークがインタラクティブな状態に達するまでに実行すべきことすべてを理解できるよう、
インタラクティブになった時点からスタートして逆にたどってみましょう。</p>
<ol>
<li>フレームワークはリスナーがどこにあるかを知る必要があります。しかし、この情報はフレームワークが簡単に利用できるものではありません。リスナーはテンプレートに<code class="language-text">described</code>（記述）されています。</li>
<li>実は、筆者は<code class="language-text">described</code>よりも<code class="language-text">embedded</code>（埋め込み）という言葉のほうが適切だと考えています。情報が埋め込まれていると言えるのは、フレームワークが情報を簡単に利用できないからです。フレームワークは、リスナーのクロージャに到達するためにテンプレートを実行する必要があります。</li>
<li>テンプレートを実行するにはダウンロードしなければなりません。しかし、ダウンロードされたテンプレートには import が含まれており、これを読み込むためにさらに多くのコードのダウンロードが必要です。テンプレートはそのサブテンプレートをダウンロードする必要があります。</li>
<li>テンプレートの準備はできましたが、依然としてリスナーには到達していません。テンプレートの実行は、実際にはテンプレートとステートをマージすることを意味します。ステートがなければ、フレームワークはテンプレートを実行できず、リスナーにはたどり着けません。</li>
<li>ステートはダウンロードしたり、クライアント側で計算したりする必要があります。頻繁に計算をするということは、ステートを計算するためにさらに多くのコードをダウンロードする必要があることを意味します。</li>
</ol>
<p>すべてのコードがダウンロードされると、フレームワークはステートを計算し、そのステートをテンプレートにフィードすることが可能になります。
そして、ようやくリスナーのクロージャにたどり着き、クロージャをDOMにインストールできます。</p>
<p>インタラクティブなステートに至るには多くの作業が必要です。
現行世代のあらゆるフレームワークはこのように動作しています。
つまり、フレームワークがリスナーを発見してインストールするには、
結局はアプリケーションの大部分をダウンロードして実行しなければなりません。</p>
<h2>クロージャについて</h2>
<p>上記の問題の核は、コードをダウンロードするには大きな処理能力が必要であること、
そしてフレームワークがリスナーを発見し、ページがインタラクティブな状態になるまでに長いCPU時間がかかることです。
しかし、私たちはクロージャがコードとデータを囲い込むという性質を忘れています。
これはとても便利な特性であり、私たちがクロージャを気に入っている理由です。
しかし、これは同時にクロージャのすべてのデータとコードが、
クロージャの実行時に遅延して作成されるのではなく、
クロージャを作成した時点で利用可能でなければならないことも意味します。</p>
<p>例としてシンプルなJSXテンプレートを見てみましょう（ただし、他のテンプレートシステムにも同じ問題があります）。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>addToCart<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cart'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyBuyButton</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>cost<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    Price<span class="token operator">:</span> <span class="token punctuation">{</span>cost<span class="token punctuation">}</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">addToCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      Add to cart
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>クロージャによる死</h2>
<p>クロージャはコストが低いため、至るところで見られます。
しかし、クロージャは本当に低コストなのでしょうか。
その答えはイエスでもあり、ノーでもあります。
確かに、ランタイムにおいて短時間で作成できるという意味では低コストです。
しかし、コードを囲い込むために、クロージャがない場合より大幅に早くコードをダウンロードする必要があるという点では高コストです。
さらに、ツリーシェイキングを妨害するという意味でも高コストです。
そのため、筆者が「クロージャによる死」と呼ぶ状況が起きます。
クロージャはDOMに設置されるリスナーであり、実行される可能性がほとんどないコードを囲い込みます。</p>
<p>ページの「購入する」ボタンは複雑な割にしょっちゅうクリックされるようなものではありません。
それでも「購入する」ボタンは、関連するすべてのコードのダウンロードをしきりに促します。
これはクロージャがそのような仕組みになっているためです。</p>
<h2>QwikはリスナーのHTMLシリアライズを可能にする</h2>
<p>これまで、クロージャには隠れたコストがあるかもしれないと説明してきました。
こうしたコストはコードの頻繁なダウンロードという形で生じます。そのため、クロージャを作成し、ユーザとインタラクティブなWebサイトの間に介在させるのは困難です。</p>
<p>Qwikはリスナーの作成を可能な限り遅らせようとします。
これを実現するために、Qwikは以下のルールを掲げています。</p>
<ol>
<li>リスナーはHTMLにシリアライズできなければならない。</li>
<li>ユーザがリスナーとのインタラクションを行うまで、リスナーはコードを囲い込まない。</li>
</ol>
<p>これがどのように実現されるのか、実例で見てみましょう。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyComponent_click<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Click me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">MyComponent_click.ts</code>ファイルの内容は以下のとおりです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Clicked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のコードをご覧ください。
SSRはレンダリングプロセスの間にリスナーの場所を発見した後、
その情報を捨てるのではなく、リスナーを属性としてHTMLにシリアライズします。
そのため、クライアントはリスナーの場所を発見するためにテンプレートを再実行する必要がありません。
その代わりとして、Qwikは以下のアプローチをとります。</p>
<ol>
<li><code class="language-text">qwikloader.js</code>をページにインストールする。このファイルのサイズは1KB未満で、実行には1ミリ秒もかからない。ファイルがとても小さくHTMLに埋め込むのが最善の方法であるため、サーバーとのラウンドトリップが不要になる。</li>
<li><code class="language-text">qwikloader.js</code>は、1つのグローバルなイベントハンドラを登録し、バブリングを活用することで、すべてのイベントを同時にリッスンできる。addEventListenerの呼び出しが少なくなるため、インタラクティブな状態までの時間が短くなる。</li>
</ol>
<p>その結果が以下のとおりです。</p>
<ol>
<li>リスナーを発見するためにテンプレートをダウンロードする必要がない。リスナーは属性としてHTMLにシリアライズされる。</li>
<li>リスナーを取得するためにテンプレートを実行する必要がない。</li>
<li>テンプレートを実行するためにステートをダウンロードする必要がない。</li>
<li>すべてのコードが遅延され、ユーザがリスナーとのインタラクションを行うときにのみダウンロードされる。</li>
</ol>
<p>Qwikは現行世代のフレームワークによるブートストラップのプロセスを省略し、1つのグローバルなイベントリスナーで代替します。
この方法が最も優れているのは、アプリケーションのサイズに影響されないところです。
どんなにアプリが大規模で複雑になってもリスナーは1つだけです。
すべての情報がHTMLにシリアライズされているため、ダウンロードすべきブートストラップコードは常に一定で、その容量はアプリケーションの複雑性と無関係です。</p>
<p>まとめると、Qwikの背景にある基本的な考え方は再開性（resumability）です。
Qwikはサーバーの作業が中断された時点から作業を再開し、クライアント側が実行する必要があるファイルはわずか1KBです。
このコードはアプリケーションがどんなに大規模で複雑になっても変わりません。
これから数週間（訳注：原文では定期的に8記事まで公開されています）にわたって、
Qwikがどのように作業を再開し、ステートを管理し、コンポーネントを独立にレンダリングするかを見ていきます。お楽しみに。</p>
<p>私たちはQwikの未来や、Qwikが実現する新たな種類のユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwikの紹介 – HTMLファーストのフレームワーク]]></title><description><![CDATA[Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWe…]]></description><link>https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</link><guid isPermaLink="false">https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWeb Components、
そしてその間にあるすべてのフレームワークに至るまで、
さまざまなツールで同じサイトを生成できることです。
出力されるコードは速度が最適化されています。
私たちのツールで作成されたサイトは、手作業で作成されたサイトの大部分よりも高速です。
私たちはこれを心から誇りに思っています。
私たちの製品は、スピードがとても重要であるeコマースに焦点を当てています。</p>
<h2>優れたTime to Interactiveの実現は困難</h2>
<p>どんなにコードが最適化されていても、静的HTMLのみを提供していない限り、
eコマースサイトが<a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a>で100点中100点のスコアを達成するのは困難です。
そのため、ほとんどのeコマースサイトは20点程度の赤色スコアとなっています。
高速化に重点的に取り組む余裕がある特に優れたサイトだけが50～60点の黄色スコアを獲得できます。
Builder.ioを利用しても50～60点の黄色スコアを達成できるでしょう。
しかし、私たちはもっと点数を良くしたいのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--hNfE5FAv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5zttsnsvx80ic0y3v4wa.png"></p>
<h2>HTMLだけなら高速</h2>
<p>とはいえ、静的HTMLを提供すれば点数は良くなります。
ほぼ確実に100点中100点のスコアを獲得できるでしょう。
そもそもPageSpeed Insightsのスコアは、ページがインタラクティブになる前にブラウザが実行しなければならないコードの量に基づいて測定されます。
JavaScriptをまったく実行しないようにすれば、100点満点を獲得し、簡単に緑色スコアに到達できます。
しかし、この方法にはページが静的になるという問題があります。
Webページは動的なコンテンツを提供し、インタラクションに満ちた生き生きとしたものでなければなりません。
静的HTMLで高いスコアを獲得しつつ、同時にリッチなインタラクションを提供するにはどうすれば良いのでしょうか。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--VCPVUPTb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/inff3jmvl300d1yaxaya.png"></p>
<h2>Qwikの導入 – HTMLファーストのフレームワーク</h2>
<p>そこでQwikの登場です。
Qwikは、オープンソースで開発されている、DOM主体で resumable（再開可能な）Webアプリフレームワークです。
QwikはHTMLのサーバーサイドレンダリングの resumability（再開性）と、コードのきめ細かい遅延読み込みに重点を置くことで、
できる限り優れたTime to Interactiveを実現するように設計されています。
説明したいことが盛りだくさんで、今回のブログ記事だけではとてもカバーしきれません。
そこで、説明をいくつかのブログ記事に分割し、今後数週間にわたって投稿する予定です。
Qwikの基本的な目標は、ブラウザの遅延読み込み機能をできる限り活用し、JavaScriptを遅延させ、Time to Interactiveの指標を改善することです。
これは既存のフレームワークとはまさに対照的と言えます。
こうしたフレームワークは、サーバーサイドレンダリングとTime to Interactiveを、
その他すべての設計上の意思決定に影響する主な目標とは捉えておらず、
付け足し程度にしか考えていませんでした。
Qwikの目的は、どんなに遅いモバイル端末でも、Time to Interactiveをほんの一瞬にまで短縮することです。
私たちは、高速な静的ページをユーザに提供しつつ、インタラクティブ性も完全に維持したいと考えています。
つまり、一挙両得を目指しているのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--vNxZwFXl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dy3wa5ewpz9o9xoa87ys.png"></p>
<h2>replayable なフレームワークは作業が多すぎる</h2>
<p>ほとんどのeコマースサイトがPageSpeed Insightsで100点を取れないのには理由があります。
それは、どの既存のフレームワークもTime to Interactiveを念頭に置いて設計されていないということです。
これらのフレームワークは複雑なブートストラップのプロセスを持ち、
ページがインタラクティブになる前に多くのコードをダウンロード・実行する必要があります。
確かに、ほとんどのフレームワークはサーバーサイドレンダリングに対応しており、
初期コンテンツを素早く表示できます。
しかし、ページを再ハイドレートしてインタラクティブな状態にするには、
まずはページ上のすべてのテンプレートをダウンロードし、実行しなければなりません。
現在の既存のサイトが100点を取れずにいるのは、こうしたダウンロードや実行を行わなければならないせいです。
既存のフレームワークは、サイトをインタラクティブにするために、
サーバーサイドレンダリングにおけるすべての作業をクライアント側で再び実施する必要があるため、
replayable（再生型）であると言えます。
サイトが複雑になるにつれて、再生可能な状態を維持するためのコストも増えていきます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--PdQoT-lX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lqgpauzo2i23f3zhhke8.png"></p>
<h2>resumability が救世主に</h2>
<p>Qwikの背景にある基本的な考え方は resumability です。
Qwikはサーバーの作業が中断された時点から作業を再開できます。
クライアント側で実行するコードはほんの最小限です。
Qwikloaderは、サーバーサイドレンダリングによって生成された静的HTMLを取得し、レンダリングを再開します。
Qwikloaderのサイズは1KB未満で、実行に1ミリ秒もかかりません。
思わず前の文を読み直したくなるかもしれませんが、読み間違いではありません。
実行が必要なコードの量は驚くほど小さく、まばたきよりも短い時間で実行されます。
最も優れているのは、アプリケーションがどんなに大きくなっても、このコードが変わらないことです。
ユーザが最小限の部分でWebサイトとのインタラクションをしている間に、
サイトのその他すべてのインタラクティブな部分が遅れてダウンロードされます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ufFUjYds--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/550d4im90829stbvbvs0.png"></p>
<h2>もっと詳しく知る</h2>
<p>私たちが最も重視しているのは、この技術をお客様のために開発することです。
しかし、開発はオープンソースで行われるため、あらゆる人がどんな目的にも利用できます。
私たちはこの技術を汎用的なWebフレームワークとして設計する予定ですが、
お客様が必要とするものを最優先します。</p>
<p>読者の皆様は、もっと詳しい情報を知りたくてたまらないことでしょう。
そこで、皆様をStackBlitzのWebコンテナの<a href="https://stackblitz.com/edit/qwik-todo-demo">デモ</a>にご招待します。
素晴らしいことに、StackBlitzのスタッフはNode.jsをブラウザで実行する能力があり、
そのため私たちはフレームワークの重要な部分である、サーバーサイドレンダリングのデモを行うことができます（彼らに敬意を表します）。
オープンソースのリポジトリは<a href="https://github.com/builderio/qwik">こちら</a>です。
期待が大きくなりすぎないように言っておくと、リポジトリはあくまで概念実証の段階にあり、
多くの物事が時とともに変わると予想されるため、広く利用できる状態ではありません。
それでも、私たちは皆さんの考えを聞きたいと思っています。
ですから、ぜひ<a href="https://discord.gg/JHVpZmqSs4">Discordサーバーでのチャット</a>にご参加ください。</p>
<p>今後数週間（訳注：原文では定期的に8記事まで公開されています）で、
Qwikの背景にある多くのユニークなアイデアを詳しく解説し、
Qwikの仕組みと独自な点を説明していきます。お楽しみに。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[人材マネジメント🤯]]></title><description><![CDATA[初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いてお…]]></description><link>https://postd.cc/managing-people/</link><guid isPermaLink="false">https://postd.cc/managing-people/</guid><category><![CDATA[キャリア・働き方]]></category><category><![CDATA[開発組織]]></category><pubDate>Fri, 14 Oct 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いておく価値があるでしょう。</p>
<p>筆者は小規模なチームやスタートアップ企業のマネージャーのためにこの記事を書きました。
ほとんどのアドバイスは、大規模な企業のマネジメントには当てはまらないのではないかと思います。
なお、急成長している企業に入社する人への全般的なアドバイスについては<a href="https://klinger.io/posts/joining-hypergrowth-startups-%F0%9F%98%AC">こちら</a>をご覧ください。</p>
<p><strong>筆者について</strong></p>
<ul>
<li>
<p>中・小規模のエンジニアリングチームを数チーム管理した経験あり</p>
<ul>
<li><a href="https://beondeck.com/">On Deck</a>のCTO</li>
<li>CoinListの元エンジニアリング担当VP</li>
<li>AngelListの元リモート責任者</li>
<li>Product Huntの元CTO</li>
</ul>
</li>
</ul>
<p><strong>それでは始めましょう。</strong></p>
<h2>マネージャーはすべての失敗に責任を負う</h2>
<p>分かります……とても前向きなスタートですよね👀</p>
<ul>
<li>チームを怒る意味は全くありません</li>
<li>
<p>あなたはプロセスと人材に責任を負います</p>
<ul>
<li>あなたは常にチームより多くの情報を持っていたはずです</li>
</ul>
</li>
<li>
<p>失敗に至るプロセスを生んだのはあなたです</p>
<ul>
<li>あるいは、誤った人材を採用した（または解雇しなかった）のもあなたです</li>
</ul>
</li>
<li>結局、すべてはあなたの責任です</li>
</ul>
<h2>プロセスを管理し、人を導く</h2>
<ul>
<li>
<p>なぜかは分かりませんが、多くの人にとって、「人材のマネジメント」とは部下の仕事をコントロールしなければならないという意味になるようです</p>
<ul>
<li>彼らはマイクロマネジメントに陥り、目標やスケジュールだけでなく、仕事のやり方まで管理しています</li>
<li>あなたがマイクロマネジメントをする時間があるなら、大抵の場合、あなたの代わりにもっと人件費が安くて能力が低い人を採用し、その人に仕事をさせれば良いのです</li>
</ul>
</li>
<li>
<p>筆者が思うに、こうした行動は、マネージャの役割に関する誤解に起因しています</p>
<ul>
<li>あなたの仕事は人を管理することではありません</li>
<li>しかし、プロセスを管理し、人を導くことができます</li>
</ul>
</li>
<li>マネージャーは、仕事をどのように行うべきか、各メンバーの権限の範囲はどこからどこまでか、どのようにキャリアを形成するか、そしてこれらすべてをどのように議論し、変更できるかに関して、プロセスを管理します</li>
<li>
<p>さらに、手本を示し、共感することで人を導きます</p>
<ul>
<li>メンバーは目標、不安やモチベーションを持っています。仕事以外に問題を抱えていることもよくあります</li>
<li>仮に相手が逆の立場だったら、どう行動してほしいかを考えて行動しましょう</li>
</ul>
</li>
</ul>
<h2>プロセスとは期待を明確にしたもの</h2>
<ul>
<li>
<p>多くの人は「プロセス」に関する責任をなんとか逃れようとしています</p>
<ul>
<li>そのため「プロセスは多過ぎない方が良い」などと言います</li>
<li>筆者の私見では、これも誤解です</li>
</ul>
</li>
<li>
<p>プロセスとは、人々の行動を複雑な鎖のように結びつけ、膨大な手間を負わせるものではありません</p>
<ul>
<li>プロセスとは期待を明確にしたものです</li>
<li>例えば、「誰も作業を邪魔されないように、毎朝全員で〇〇をする」のようにシンプルなものでも構いません</li>
<li>少数のとても明確なプロセスを定め、それが守られるようにしましょう</li>
</ul>
</li>
</ul>
<h2>意思決定と意見</h2>
<ul>
<li>
<p>あらゆる議論、プロジェクト、問題や状況において、誰が意思決定するのかを明確にする必要があります</p>
<ul>
<li>他の人は意見を付け加えるにすぎません</li>
<li>理想的には、その後にフォローアップする（あるいはその仕事のリーダーとなる）人が意思決定をすべきです</li>
<li>それ以外は全員、意見を追加するだけです</li>
<li>「地位」や給与が高い人も例外ではありません</li>
</ul>
</li>
<li>
<p>マネージャーは意思決定を急に止めるためのハンドブレーキを握っています</p>
<ul>
<li>この力は文字どおりハンドブレーキのように扱いましょう</li>
<li>自動車の運転を想像してください。車を止めなければならないのに、ドライバーが反応しなければ、ハンドブレーキを引く必要があります。その結果、反動でダメージが生じるでしょう</li>
<li>絶対に必要なときにのみハンドブレーキを引き、その後に状況をどう修正するか議論します</li>
</ul>
</li>
<li>
<p>採用は意思決定スキルの優劣に基づいて判断します</p>
<ul>
<li>解雇も意思決定スキルの優劣に基づいて判断します</li>
<li>優れた意思決定スキルには他人の意見を聞くことが含まれます</li>
<li>疑問に思う場合は、意思決定者を最初から信頼できるか考えてみてください</li>
</ul>
</li>
</ul>
<h2>当事者意識</h2>
<ul>
<li>
<p>従業員が問題に対して完全な当事者意識を持つようにするのは困難です</p>
<ul>
<li>しかし、それが目標です</li>
<li>それがふさわしくない従業員なら解雇もできます</li>
</ul>
</li>
<li>
<p>フィードバックを提供し、支援しましょう</p>
<ul>
<li>従業員を信頼し、失敗を認めてください（損害を許容できる範囲で）</li>
<li>失敗を「従業員のレベルアップ」と捉えましょう</li>
</ul>
</li>
<li>
<p>最悪なのは、あなたが何度も介入し、従業員が仕事と自分を無関係と感じるようになることです</p>
<ul>
<li>彼らは当事者意識を持たず、言われたことをするだけのドローンになってしまいます</li>
<li>それがあなたの目的なら、人件費が安くて能力が低い人を採用すれば良いでしょう</li>
</ul>
</li>
</ul>
<h2>堂々巡りを避ける</h2>
<ul>
<li>
<p>プロセスを定めるときは、堂々巡りを避けましょう</p>
<ul>
<li>例えば、何かについてフィードバックを提供するときは、相手が言われたとおりにするか、あるいはそれができない理由を答えるだろうと考えてください</li>
<li>承認されることを期待してはいけません</li>
<li>誰もそんなことをしている暇はありません</li>
</ul>
</li>
</ul>
<h2>信頼</h2>
<ul>
<li>
<p>自分が神経質になっているのは、他人の仕事と自分の不安のどちらが原因かを常によく考えましょう</p>
<ul>
<li>他人があなたの感情の面倒を見る必要があるでしょうか？</li>
</ul>
</li>
<li>
<p>物事がうまくいっているときは、人を信頼するのは簡単です</p>
<ul>
<li>本当に難しいのは、物事がうまくいかないときです</li>
<li>状況に対するいら立ちと、人に対するいら立ちを常に区別しましょう</li>
</ul>
</li>
<li>
<p>「距離を置け」と言っているのではありません</p>
<ul>
<li>輪に加わり、目標を定め、意見を表明すべきですが、課題への対処はチームに任せるべきです。ただし、必要に応じてハンドブレーキを使いましょう</li>
</ul>
</li>
</ul>
<h2>率直な共有を通じて信頼を築く</h2>
<ul>
<li>
<p>従業員があなたの仕事を信頼するようになるための最も簡単な方法は、何も要求されなくても、成果を率直に共有することです</p>
<ul>
<li>従業員が探すだろうと思う場所に、すべてを利用可能な状態で置いておきましょう</li>
<li>従業員からの要求を待ってはなりません。ほとんどの従業員は要求をしないからです</li>
</ul>
</li>
</ul>
<h2>信頼は0か1ではない</h2>
<ul>
<li>
<p>私たちは信頼を0か1と考えがちです</p>
<ul>
<li>誰かを信頼するか、信頼しないかのどちらかということです</li>
</ul>
</li>
<li>
<p>しかし、これは正しくありません</p>
<ul>
<li>時とともに、信頼する人や、その人の何をどのように信頼するかは変わります</li>
</ul>
</li>
<li>
<p>信頼はシステム化できるものだと考えましょう</p>
<ul>
<li>例えば、チームの新しいメンバーにはどのような信頼を与えますか？</li>
<li>最初の数週間や1か月はどのような仕事をすることを求めますか？</li>
</ul>
</li>
</ul>
<h2>自律と放任を混同しない</h2>
<ul>
<li>筆者は、人材を採用した後は「好きなようにさせている」という創業者によく会います</li>
<li>これは原則としては正しいものの、従業員の成功を支援する責任から解放されることにはなりません</li>
</ul>
<h2>多層的な意思決定</h2>
<ul>
<li>
<p>会社では、さまざまな階層の人々が、仕事をするうえでお互いに頼りあっています</p>
<ul>
<li>CEOがプロダクトマネージャーの優先順位を認識していなければ、彼らは仕事ができません</li>
</ul>
</li>
<li>
<p>自分の仕事を社内の他人に押し付けてはなりません</p>
<ul>
<li>自分の仕事より楽しそうだからという理由だけで、他人の仕事に踏み込むこともやめましょう</li>
</ul>
</li>
</ul>
<h2>乱射型マネジメントを避ける</h2>
<ul>
<li>
<p>ミーティングで自分の意見やアイデアを手当たり次第にぶつけてはなりません</p>
<ul>
<li>あなたは経緯を十分に理解していない可能性が高く、大抵の場合、課題を最後までフォローする当事者になることはないからです</li>
</ul>
</li>
<li>
<p>単なる意見であって、意思決定ではないことを明確にしてください</p>
<ul>
<li>ただし、「創業者（またはマネージャー）の意見」がほとんどの従業員にとって大きな力を持つことを理解しましょう</li>
<li>一般的に非同期コミュニケーションでは声の「ニュアンス」が伝わりにくいため、<a href="https://klinger.io/posts/fyi-how-founders-can-avoid-drive-by-management">fyi（for your opinion 訳注：ご参考までに）タグ</a>を利用しましょう</li>
</ul>
</li>
</ul>
<p>ところで、筆者はこれを乱射型マネジメントと呼んでいます。なぜなら、グループで議論しているところにマネージャーがやってきて、銃を乱射するように要求、変更指示、アイデアを投げかけ、混乱、パニック、カオスを生み出した後、悲惨な状況を残して去っていくからです。</p>
<h2>フィードバックを提供する</h2>
<ul>
<li>人×文脈 = 成果</li>
<li>
<p>筆者の経験では、優れた人材でも、環境が悪いと不十分な成果しか出せないことがあります</p>
<ul>
<li>一方、とても平凡な人材でも、環境が素晴らしければチーム全体を上回る成果をあげることもあります</li>
</ul>
</li>
<li>
<p>フィードバックをする際、通常はその人自身よりも経緯について客観的に議論するほうが簡単です</p>
<ul>
<li>現在の問題の原因となったのはどのような状況ですか？</li>
<li>何が変わりましたか？現在何が必要とされていますか？</li>
</ul>
</li>
<li>
<p>若手エンジニアが仕事について行けていない場合</p>
<ul>
<li>それはエンジニア自身の責任ですか？それとも、チームは今の時点では、現在、若手が仕事を覚えるための役に立っていないのでしょうか？</li>
<li>すぐに問題になることはありませんが、いずれは解決するか、能力不足を受け入れる（解雇する）ことが必要です</li>
</ul>
</li>
<li>
<p>本番環境で大きなインシデントが発生した場合</p>
<ul>
<li>そもそも、なぜそのような事態が起きたのですか？</li>
<li>エンジニアリングチームは何に注目していましたか？</li>
<li>問題を回避するためのプロセスは導入されていましたか？</li>
<li>プロセスを導入する必要はありますか？</li>
<li>インシデントを起こした従業員に責任はありません</li>
<li>チーム全体が他の優先課題に注目していたからです</li>
<li>
<p>それは適切な理由（リリースへのプレッシャーなど）によるものでしたか？</p>
<ul>
<li>それとも不適切な理由（知識の不足など）によるものでしたか？</li>
</ul>
</li>
</ul>
</li>
<li>
<p>あなたが採用した人材は、モチベーションが高く、最善を尽くそうとしていると常に想定しましょう</p>
<ul>
<li>そうでない人材は解雇しましょう</li>
</ul>
</li>
</ul>
<h2>解雇は決してサプライズであってはならない</h2>
<ul>
<li>
<p>従業員にとって、解雇は決してサプライズであってはなりません</p>
<ul>
<li>状況が変わり、新たな要件が生じたことを伝える必要があります</li>
</ul>
</li>
<li>
<p>通常、従業員を解雇する理由は状況の変化です</p>
<ul>
<li>例えば、会社が変化したとき、</li>
<li>役職に求められるものが変化したときや、</li>
<li>誤った採用基準を定めていたことに気づいたときです</li>
<li>大抵の場合、責任は従業員よりもあなたにあります</li>
</ul>
</li>
<li>
<p>従業員は、自分の努力が新たな要件に足りるものであってほしいと願うかもしれません</p>
<ul>
<li>それでも、あなたが彼らを解雇しようとするときは理解を示すでしょう</li>
</ul>
</li>
</ul>
<h2>解雇を先延ばししない</h2>
<ul>
<li>従業員を解雇すると決定したら、すぐに行動しましょう</li>
<li>
<p>従業員をゾンビのような状態で雇い続けていることはよくあります</p>
<ul>
<li>「彼を解雇すべきだ」</li>
<li>そう思っても解雇しないのです</li>
<li>従業員のためになりません</li>
<li>
<p>従業員はおそらく今の環境に満足していないでしょう</p>
<ul>
<li>評価が低く、</li>
<li>良い仕事もできないからです</li>
</ul>
</li>
<li>
<p>大抵の場合、あなたが解雇を避けるのは自分のためです</p>
<ul>
<li>なぜなら、誰かを解雇するのは良い気分ではないからです</li>
<li>自分の感情や未来を、従業員の感情や未来より気にすることはやめるべきです</li>
</ul>
</li>
</ul>
</li>
<li>
<p>面談を設定し、解雇を伝えます</p>
<ul>
<li>最初に余計なおしゃべりをするのはやめましょう</li>
<li>本題を率直に切り出し、次のステップを明確にしましょう</li>
<li>必ず真剣な事実として伝えます</li>
<li>解雇を伝えるときには、あなたの感情や問題は重要ではないことを忘れないでください</li>
</ul>
</li>
<li>
<p>その後、従業員が新たな仕事を探せるように支援します</p>
<ul>
<li>従業員はかつてキャリアをあなたに委ねたのですから、その信頼を維持しましょう</li>
</ul>
</li>
<li>
<p>最後に：一部の国では、従業員を解雇するのに月によっては数日かかる場合もあります</p>
<ul>
<li>どちらにせよ、解雇のプロセスを主体的に管理し、あなたを信頼している人に敬意を持って接するようにしましょう</li>
<li>彼らはあなたのチームにキャリアを委ねたのです</li>
<li>ほとんどの場合、従業員が去るのは自らの責任ではなく、状況の変化によるものです</li>
<li>彼らが自分に適した新しい仕事を見つけられるように支援しましょう</li>
</ul>
</li>
</ul>
<h2>明確 > 不明確</h2>
<ul>
<li>
<p>ミーティング後の明確な意思決定</p>
<ul>
<li>明確な意思決定がなされていない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>明確な責任者</p>
<ul>
<li>明確な責任者がいない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>全員の意見を聞く</p>
<ul>
<li>誰が意思決定するかを明確にしましょう</li>
<li>意思決定の内容も明確にします</li>
</ul>
</li>
<li>などなど</li>
</ul>
<h2>ベストプラクティス：「現実は正しい」という認識から始める</h2>
<ul>
<li>
<p>チームやプロセスの中でベストプラクティスや変化を求めるときは、まずは既存の自然に生まれたものに必ず注目しましょう</p>
<ul>
<li>優れた人材を採用していれば、通常は彼らが自然と解決策を探し始めています</li>
<li>その解決策は適切でしょうか？もしそうなら明確にしましょう</li>
<li>「現実は正しい」という認識が重要です</li>
<li>もし適切でないなら、それを変える方法について議論しましょう</li>
</ul>
</li>
</ul>
<h2>会社は数カ月ごとにリファクタリングされるものと考える</h2>
<ul>
<li>
<p>急成長しているスタートアップ企業は、3～6カ月ごとに事業の進め方を社内でリファクタリングする必要があります</p>
<ul>
<li>現在必要な最低限の変化のみに取り組みましょう</li>
</ul>
</li>
<li>
<p>決定的な最終バージョンは存在しません</p>
<ul>
<li>あなたは会社のプロセスに対して常に不満を感じ続けるでしょう</li>
<li>伸び悩みに直面しない限り、成長痛は続くはずです</li>
</ul>
</li>
<li>
<p>コードをリファクタリングするときと同じ原則を適用しましょう</p>
<ul>
<li>以下の点に気を付けてください</li>
<li>まずは小規模な隔離された環境でテストする</li>
<li>ピアレビューを行う</li>
<li>すべてを一度に変えようとしない</li>
<li>オーバーエンジニアリングを回避する</li>
<li>などなど</li>
</ul>
</li>
</ul>
<h2>燃え尽き症候群</h2>
<ul>
<li>よくある誤解は、燃え尽き症候群は働き過ぎが原因というものです</li>
<li>
<p>実際の原因は、仕事をコントロールできない、自分が影響を与えられていないと感じることです</p>
<ul>
<li>仕事がほとんどないにもかかわらず、従業員（あるいは自分）が燃え尽きる場合があることを忘れないでください</li>
</ul>
</li>
<li>
<p>従業員が自らの影響をコントロールできるようにするには、どうすれば良いのでしょうか？</p>
<ul>
<li>どうすれば従業員と周囲の混沌とした状況の間に境界線を引けるのでしょうか？</li>
</ul>
</li>
</ul>
<h2>混乱を生み出す人間はそれに気づきにくい</h2>
<ul>
<li>
<p>創業者のよくある不満は、チームが変化について来られないというものです</p>
<ul>
<li>創業者は、大抵は変化に至る背景をよく理解し、変化の前段階を把握しています。また最も重要な点として、創業者は変化をコントロールできます</li>
<li>従業員はそうではありません</li>
</ul>
</li>
</ul>
<h2>自分の部下よりもマネージャーに多くのことを要求すべし</h2>
<ul>
<li>
<p>基本的に、失敗はチームの責任ではなく、マネージャーの責任です</p>
<ul>
<li>物事に関する率直な意見をマネージャーと個人的に共有しましょう</li>
</ul>
</li>
<li>基本的に、マネージャーが意思決定できるように信頼すべきです</li>
<li>
<p>マネージャーは結果に対する説明責任を負います</p>
<ul>
<li>すべての失敗に責任があります</li>
<li>しかし、成功はマネージャーの手柄ではありません</li>
<li>成功はチームの手柄です</li>
</ul>
</li>
<li>
<p>マネージャーは、可能なときはいつでも、成功を一人占めするのではなくチームにスポットライトを当てるべきです</p>
<ul>
<li>ポイントは簡単です。チームに与える権限を増やすとともに、チームが輝くための方法を増やしましょう</li>
</ul>
</li>
</ul>
<p>気分が明るくなるような結論ですね😬</p>
<p>とにかく……この記事が誰かの役に立つことを願っています🙏</p>
<p>当然、筆者が見逃していることも数多くあるでしょう。ですから、<a href="https://twitter.com/andreasklinger">twitter</a>でお気軽にご質問ください。また、この記事を改善するためのアイデアがあれば、<a href="https://github.com/andreasklinger/klinger-io">プルリクエストをお送りください</a>。</p>
<p>この記事が気に入ったら<a href="https://twitter.com/intent/tweet?text=Managing%20People%20an%20article%20by%20%40andreasklinger%3A%20https%3A%2F%2Fklinger.io%2Fposts%2Fmanaging-people-%25F0%259F%25A4%25AF">シェアしていただけると幸いです</a>。</p>
<p>追伸：<a href="https://www.notion.so/odteam/Product-Engineer-Playbook-859b2c4c95f849788554f1749d038c6f">筆者のチーム</a>は人材を募集中です</p>]]></content:encoded></item><item><title><![CDATA[変化するフロントエンドエンジニアの役割。「モダンフロントエンド」開発組織のつくりかた]]></title><description><![CDATA[POSTD読者の皆さんはじめまして、本メディアでキュレーターを担当させていただいている古川陽介と申します。
株式会社ニジボックスでデベロップメント室室長を務める他、株式会社リクルートでプロダクト開発…]]></description><link>https://postd.cc/postdev-furukawa/</link><guid isPermaLink="false">https://postd.cc/postdev-furukawa/</guid><category><![CDATA[キャリア・働き方]]></category><category><![CDATA[開発組織]]></category><pubDate>Mon, 12 Sep 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<div style="padding: 1rem;">
  <img style="width: 50px; height: 50px;" src="https://lp.nijibox.jp/wp-content/themes/nijibox-lp/assets/lp-assets/postdev/images/speaker_yosuke_furukawa.jpg" alt="古川陽介" >
  <span>by <a href="https://twitter.com/yosuke_furukawa">古川陽介</a></span>
</div>
<p>POSTD読者の皆さんはじめまして、本メディアでキュレーターを担当させていただいている古川陽介と申します。
株式会社ニジボックスでデベロップメント室室長を務める他、株式会社リクルートでプロダクト開発部署のマネージャーも兼務しています。
また、Japan Node.js Associationの代表理事として、Node.js の普及を目指す活動なども行っています。</p>
<p>私が普段の仕事や活動の中で強く感じているのは、フロントエンドエンジニアの役割が大きな変換点を迎えているということです。
端的に表現するとスマートフォンの登場をきっかけとしたデバイスの多様化によって、フロントエンドエンジニアの領域が拡大したと言うことになると思います。</p>
<p>パフォーマンスや開発の生産性を著しく上昇させる、ReactやVueを駆使したモダンフロントエンド開発と、それを実現するための組織構築は、今後のサービスやプロダクト開発において、ビジネスを加速させる上で欠かせないものだと考えています。
この記事では、主に開発組織の構築に焦点をあてて、私たちエンジニアがこれから進むべき道について考察していきたいと思います。</p>
<h2>私がエンジニアの組織作りに興味を持ったきっかけ</h2>
<p>キャリアの中で初めてマネジメントをすることになった2017年、私は大いに悩んでいました。</p>
<p>リクルートでエンジニア組織のマネージャーとなり、最初は本当に右も左も分からない状態でした。
「マネージャーとして何をすればよいのか？」「どうメンバーを育成していけばよいのか？」そんな悩みが尽きない日々を送っていたのです。</p>
<p>そんなある日、一冊の本に出会います。
株式会社レクター取締役の広木大地さんが著した『エンジニアリング組織論への招待』。
この本には、まさに当時の私が求めていた「どうエンジニアを成長させるか」「どうエンジニア組織を作るか」「不確実性に対応するための組織設計」といった、私の問いに対する答えが明解に記されていたのです。
この本を何度も繰り返し読み込むにつれ、組織作りの奥深さ、面白さに強く惹かれるようになりました。</p>
<p>同時期さらにもう1つ、組織作りに興味を持つきっかけとなる出会いがありました。
株式会社一休CTOの伊藤直也さんです。
彼は、CTOという立場ながら今でも現役バリバリでコードを書いていて、かつ組織作りも並行し、ビジネスの拡大を目的として事業を進めていくスーパーマンです。
理想的なマネジメントのスタイルとして彼に憧れを抱くとともに、強い開発組織を志す想いが自分の中で高まっていくのを感じていました。</p>
<h2>メンバーが成長を遂げ、大規模カンファレンスに登壇した日</h2>
<p>手探りでマネジメントや組織作りに取り組む中で、また広木大地さんの書籍や伊藤直也さんのスタイルに影響を受け、そのエッセンスを取り入れながら試行錯誤してきたことで、徐々に結果が出てくるようになりました。</p>
<p>結果が出てくると、ますます「組織」というものに対する興味が強くなります。
それにさらに拍車をかけたのが、「メンバーの成長」を目の当たりにした瞬間です。</p>
<p>入社当時は、まだエンジニアとしておぼつかなかったあるメンバーが、数年後、グループ全体の大規模カンファレンスに登壇したことがあります。
数万人を超えるグループ従業員の中から登壇者として選ばれるのはたったの数人。
彼の成長をずっとそばで見てきた私にとって、これほど嬉しいことはありませんでした。
彼がカンファレンスに登壇した日、仲間の成長という、私がそれまでに体験したことのない喜びを感じました。</p>
<p>また、チーム内の誰かのポジティブな行動や実績に対して、「次は私も挑戦してみよう」といった化学反応が生まれることもあります。
その化学反応によって、チームや組織はさらに強くなっていくと思います。
組織が強くなれば、新しく人が集まることもありますし、会社の成長にもつながります。
このようなダイナミズムは、組織作りの醍醐味と言えるでしょう。</p>
<h2>【10/1（土）開催】モダンフロントエンド×組織論がテーマのオンラインイベント「Post Dev」</h2>
<p>繰り返しになりますが、私の実体験からも「開発組織」は今後の重要なキーワードになると考えています。
モダンフロントエンド技術と開発組織の成長。
この2つの要素がうまくクロスオーバーすることで、エンジニアはさらに進化し、ビジネスが加速すると確信しています。</p>
<p>そんな、フロントエンドの未来に向けたヒントをより多くの方と共有したいという想いで、この度2022/10/1（土）に「Post Dev」というオンラインイベントを開催する運びとなりました。</p>
<p>私が大きな影響を受けた伊藤直也さん、広木大地さんをはじめ、国内外のエキスパートを登壇者としてお招きしています。
例えば、「State Of JavaScript」（JavaScriptの現状調査）で知られるSacha GreifさんからはJavaScriptの最新トレンドと今後の展望を、MicrosoftのTomomi ImuraさんからはVS Code開発を、ICSの池田泰延さんからはCSSの最新トレンドを語っていただく予定です。
※イベント詳細は<a href="https://lp.nijibox.jp/cp/postdev/">こちらのページ</a>をご覧ください。</p>
<p>今回イベントを企画するにあたって、技術的な話と組織という2つのテーマをあえて掛け合わせました。
コンテンツを全て見ていただくと、「今」と「これからすべきこと」が全体像として把握いただけるように設計しています。
「フロントエンドの新たなる可能性」を今後皆さんと一緒に追求していけるような機会となると良いなと思っています。</p>
<h2>これからのエンジニアがやるべき“2種類のアウトプット”</h2>
<p>最後に、一エンジニアという視点に立って、その役割が変化する時代においてやるべき“2種類のアウトプット”というお話で締めくくりたいと思います。</p>
<p>1つ目は、プロダクト開発そのものを意味するアウトプットです。
皆さんやっていることだとは思いますが、デバイスやサービスの多様化・複雑化に対応するため、継続的に技術を日々磨いていくことはとても大切だと考えています。
また、技術の追求はエンジニアごとのユニークな価値がもっとも発揮される行為だと思います。
ぜひ、ご自身を信頼し知的好奇心の誘うままに「道」を極めていただきたいです。</p>
<p>そしてもう１つは、ご自分が追求してきた体験に基づいたストーリーを言語化し、外へ発信する意味でのアウトプットです。
自らの試みをアウトプットすることによって、コミュニティー全体の研究水準が上がり、最終的に業界全体の技術進歩にもつながっていくと思います。
また、発表者の観点としても、技術への理解がより深められるメリットも見逃せません。
私自身、多くのイベント・カンファレンスへの登壇や記事の執筆を通して、技術面での成長も実感しています。</p>
<p>アウトプットをするためには、インプットが必要です。
ぜひ、今回の「POST Dev」でも良質なインプットをしてください。
きっと、私が一冊の本によって受けた雷のような衝撃を、尊敬すべきエキスパートたちとの出会いから生まれた高揚感を、皆さんも体験できるはずです。</p>]]></content:encoded></item><item><title><![CDATA[モダンWebにおけるキャッシングのための新HTTP標準]]></title><description><![CDATA[一般ユーザー向けの大規模なWebサイトや、モダンWeb上で動作するWebアプリケーションを運営する場合、CDNなどのキャッシングサービスによって静的コンテンツをキャッシュすることが極めて重要です。 …]]></description><link>https://postd.cc/status-targeted-caching-headers/</link><guid isPermaLink="false">https://postd.cc/status-targeted-caching-headers/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[HTTP]]></category><category><![CDATA[キャッシング]]></category><pubDate>Wed, 31 Aug 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>一般ユーザー向けの大規模なWebサイトや、モダンWeb上で動作するWebアプリケーションを運営する場合、CDNなどのキャッシングサービスによって静的コンテンツをキャッシュすることが極めて重要です。</p>
<p>しかしこうしたサービスは、非常に複雑で分かりにくいものです。</p>
<p>幸い、IETF（Internet Engineering Task Force）のHTTPワーキンググループがこの状況を改善すべく、HTTPの新標準策定に取り組んでいます。
最近、同ワーキンググループでは、キャッシングのデバッグとキャッシュ設定の管理を容易にすることを目的とした、HTTPヘッダに関する2つの新標準案の発表に向けて活発な動きがありました。</p>
<p>このことが何を意味し、どのように機能するのか、そしてWeb制作に携わる開発者全てがなぜ注目すべきなのかについて見ていきます。</p>
<h2>新標準</h2>
<p>この記事で取り上げる標準案は以下の2つです。</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache-header/">Cache-Statusヘッダ</a></li>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-targeted-cache-control/">Targeted Cache-Controlヘッダ</a></li>
</ul>
<p>これらはHTTP標準を改訂し、CDNを活用した現在のWebに対応したものにすることを目的としており、Fastly、Akamai、Cloudflareといった人気の高いCDNが用いている既存の手法を取り入れた仕様を提供します。
ここに挙げた企業はいずれも自ら標準の策定に携わっています。</p>
<p>どちらの標準案も比較的新しい仕様です。Cache-Statusは2021年に複数回にわたるレビューが行われており、現在は（8月以降）最終レビューと正式なRFCとしての発表を待っているところです。
一方、Targeted Cache-Controlヘッダは現在標準案として採用されていますが、最後のフィードバックを募っているところです。
どちらもIETFの支持を得ており、既に多くの議論が行われています。
今後大きな変更が行われる可能性は低いものの、どちらもまだ新しいため、現時点ではまだ幅広いサポートは期待できないでしょう。</p>
<h2>キャッシングが重要な理由</h2>
<p>ユーザ向けの注目度の高いWebアプリケーションを運営する場合、キャッシュとCDNはエンドユーザに優れたパフォーマンスを妥当なコストで提供するうえで不可欠です。
キャッシュとCDNはWebサーバの手前でリバースプロキシの役割を果たし、以下を保証します。</p>
<ul>
<li>コンテンツのキャッシング。全ての訪問者から直接バックエンドサーバに対して静的コンテンツのリクエストが行われないようにし、リクエストの頻度を減らすため。</li>
<li>トラフィックの急増に耐えうるコンテンツデリバリ。静的キャッシュはアプリケーションサーバよりも規模の拡大がはるかに容易であるため。</li>
<li>コンテンツリクエストのバッチ処理。1000件のキャッシュミスが同時に発生しても、バックエンドサーバへのリクエストが1件で済むようにするため。</li>
<li>コンテンツの物理的分散。ユーザの所在地にかかわらず、レスポンスが迅速に届くようにするため。</li>
</ul>
<p>注目度の高いWebサイトを運営するなら、モダンWebにコンテンツをホスティングするうえでこれら全てが必須となります。
ネットが広く普及している今、トラフィックの急増とレイテンシの問題はネット利用者の増加に伴い解決が困難になる一方です。</p>
<p>Troy Huntが、自身が運営する人気サイト「Pwned Passwords」について執筆した、<a href="https://www.troyhunt.com/serverless-to-the-max-doing-big-things-for-small-dollars-with-cloudflare-workers-and-azure-functions/">キャッシングの仕組みを詳しく説明した記事</a>が参考になります。
記事では以下の具体例が紹介されています。</p>
<ul>
<li>毎週彼のドメインから477.6GBのサブリソースが配信されている</li>
<li>そのうち476.7GBはキャッシュから配信されている（キャッシュヒット率99.8%）</li>
<li>同サイトのAPIには毎週3240万件のクエリが送信されている</li>
<li>そのうち3230万件はキャッシュから配信されている（キャッシュ率99.6%）</li>
<li>残りのAPIエンドポイントは、Azureのサーバレス関数が対処する</li>
</ul>
<p>このサイトのホスティング（1日数百万件ものパスワードチェック）に要する費用は、1日3セント程度です。
これだけのトラフィックを全て自前のサーバで処理した場合、膨大なコストがかかります。
合理的なキャッシングの仕組みを構築すれば、迅速かつ効果的に、安く処理できます。これは大きな問題です。</p>
<h2>解決すべき問題は何か</h2>
<p>これは結構なことなのですが、キャッシング設定の構築とデバッグは容易ではありません。</p>
<p>主な問題は、一定の規模になるとほとんどの場合、任意のリクエストパスに多数のキャッシングレイヤーが関与することです。
ほとんどの構成では、独自のキャッシング機能が組み込まれた何らかのロードバランサ、APIゲートウェイ、リバースプロキシがバックエンドサーバの手前に配置され、さらにその前には広く分散された低レイテンシ拠点からエンドユーザにこのコンテンツを提供するグローバルCDNがあります。
さらに、バックエンドサーバ自体も内部の結果をキャッシュする場合があり、企業やプロバイダが独自のキャッシングプロキシを運用していることもあり、多くのクライアント（特にWebブラウザ）が独自のキャッシング機能を備えています（こうしたクライアントにも、Service Workerなどのキャッシングレイヤーがさらに備わっている場合もあり、一層複雑にしています）。</p>
<p>各レイヤーには異なるキャッシング構成が求められます。
例えば、ブラウザはユーザ固有のデータをキャッシュできる場合がありますが、CDNがこうしたデータをキャッシュできてはいけません。
また、新しいコンテンツができるだけ早くエンドユーザに見えるようにするため全てのレイヤーのキャッシュに適用されなくてはいけません。</p>
<p>これらのレイヤーと、各レイヤー独自の構成がどう作用し合うのかを予測するのも複雑であり、さまざまな形で好ましくない結果につながる可能性があります。</p>
<ul>
<li>コンテンツが一切キャッシュされず、トラフィックがバックエンドサーバに過剰な負荷をかける。</li>
<li>コンテンツはキャッシュされるが、分散CDNではない下位のレイヤーに限定される。</li>
<li>古いレスポンスが想定よりも長くキャッシュに保持され、コンテンツのアップデートを困難にする。</li>
<li>キャッシュから間違ったレスポンスが配信され、ドイツのユーザにフランス語のコンテンツが提供されたり、ひどいケースでは未認証のユーザにログインコンテンツが提供されたりする。</li>
<li>リクエストがCDNを全く通らず、バックエンドまたはリバースプロキシから直接配信される。</li>
<li>WebサイトまたはAPIのキャッシングが一貫して行われず、古いデータと新しいデータが混在した全く役に立たないデータが読み出される。</li>
</ul>
<p>これはかなりひどい状態です。</p>
<p>多くのキャッシュ設定が、リクエストやレスポンスのメタデータ自体（Cache-Controlヘッダなど）の中に存在することが、事態を一層悪くしています。
これは正確な設定を実現するうえでは非常に効果的ですが、設定自体がこれらのレイヤーを通過して、途中でキャッシュされる可能性があることも意味します。</p>
<p>知らず知らずのうちに誤って「これを永久にキャッシュする」というレスポンスをキャッシュした場合、極めて面倒なことになってしまいます。
全てのレイヤーのキャッシュを強制的に無効化して問題を解決するのは、想像するより難しいことです。</p>
<p><img src="https://imgs.xkcd.com/comics/refresh_types.png">
<em>ピッタリのXKCDは常に存在する（訳注: XKCD とはアメリカの風刺系web漫画サイト）</em></p>
<h2>Cache-Statusはどう役立つか？</h2>
<p>明確な問題の1つは、キャッシングシステム内のトレーサビリティです。
レスポンスはどこから来たのか？なぜそのレスポンスが送信されたのか？</p>
<p>そのレスポンスはキャッシュから返されたのか、それともサーバから送信されたのか？
キャッシュから返された場合、どのキャッシュか？
それはあとどれくらい有効か？
キャッシュから返されたのではない場合、それはなぜか？
その新しいレスポンスは後で使用するために保存されたものか？</p>
<p><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache-header/">Cache-Statusレスポンスヘッダ</a>は、これら全ての情報がレスポンス自体に含まれるようにし、リクエストを見た全てのCDNおよびその他のキャッシュを1つの一貫した形式で提供するための構造を提供します。
ヘッダは以下のようなものになります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: OriginCache; hit; ttl=1100, &quot;CDN Company Here&quot;; fwd=uri-miss;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<h3>Cache-Statusヘッダの形式</h3>
<p>ヘッダの形式は以下になります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: CacheName; param; param=value; param..., CacheName2; param; param...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>キャッシュのリストであり、それぞれゼロ以上のステータスパラメータを持ちます。
キャッシュはレスポンス順に並びます。
最初のキャッシュがオリジンサーバに最も近く、最後のキャッシュがクライアントに最も近いものです。</p>
<p>レスポンスがこのヘッダとともにキャッシュされると、その後のレスポンスでもそれが保持されます。
しかし、今回のレスポンスがどこに保存され、前回のレスポンスがどこから来たのかを右側のパラメータ値から判断することも可能です。</p>
<p>パラメータ付きのキャッシュはカンマで区切られ、パラメータ自体はセミコロンで区切られます（現在は標準化されている<a href="https://datatracker.ietf.org/doc/rfc8941/">構造化ヘッダRFC</a>のsf-listとsf-item構文）。
キャッシュ名は、スペースなど本来無効な文字が含まれる場合は引用符で囲まれることがあります。</p>
<h3>Cache-Statusヘッダパラメータ</h3>
<p>各キャッシュの挙動を説明するため、いくつかのパラメータと値を定義します。</p>
<ul>
<li><code class="language-text">hit</code> - リクエストが上流に送られることなく、レスポンスはこのキャッシュから返されます</li>
<li>
<p><code class="language-text">fwd=&lt;reason&gt;</code> - これが設定されている場合、リクエストが次の上流レイヤーに送信されています。これには次のような理由が付いてきます。</p>
<ul>
<li><code class="language-text">fwd=bypass</code> - キャッシュはこのリクエストを処理しないよう構成されている</li>
<li><code class="language-text">fwd=method</code> - 使用したHTTPメソッドにより、リクエストを転送する必要がある</li>
<li><code class="language-text">fwd=uri-miss</code> - リクエストURIと一致するキャッシュデータはなかった</li>
<li><code class="language-text">fwd=vary-miss</code> - URIと一致するキャッシュデータはあったが、Varyヘッダに含まれるヘッダが一致しなかった</li>
<li><code class="language-text">fwd=miss</code> - 一致するキャッシュデータはなかった（理由が不明な場合など、他の理由による）</li>
<li><code class="language-text">fwd=stale</code> - 一致するキャッシュデータはあったが、古い（stale）データである</li>
<li><code class="language-text">fwd=partial</code> - 一致するキャッシュデータはあったが、レスポンスの一部に対してのみ（前回のリクエストがRangeヘッダを使用したなど）</li>
<li><code class="language-text">fwd=request</code> - リクエストがキャッシュされていないデータを要求した（Cache-Controlヘッダで）</li>
</ul>
</li>
<li><code class="language-text">fwd-status=&lt;status&gt;</code> - fwdが設定されている場合、次のホップから受け取ったレスポンスステータスです</li>
<li><code class="language-text">stored</code> - fwdが設定されている場合、このキャッシュが受信したレスポンスを後で使用するために保管したかどうかを示します</li>
<li><code class="language-text">collapsed</code> - fwdが設定されている場合、リクエストが他のリクエストと一緒に畳まれているかどうかを示します（同等のリクエストが既に処理中のため、複製されていない）</li>
<li><code class="language-text">ttl=&lt;ttl&gt;</code> - このキャッシュがこのレスポンスをあとどれくらい（秒数）「fresh」（鮮度が高い）と見なすか</li>
<li><code class="language-text">key</code> - このキャッシュのレスポンスのキー（実装固有）</li>
<li><code class="language-text">detail</code> - 追加の実装固有情報のための自由形式フィールド</li>
</ul>
<p>これらを使用することで、以下のようなレスポンスヘッダを解釈できます。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: ExampleCache; hit; ttl=30; key=/abc</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>これは、ExampleCacheがリクエストを受信し、キャッシュの中（key / abcの下）にレスポンスがあったのでそれを返し、そこから30秒間はそのキャッシュを返し続けることを意味します。</p>
<p>以下のようなもっと複雑な例も検討してみましょう。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status:
    Nginx; hit,
    Cloudflare; fwd=stale; fwd-status=304; collapsed; ttl=300,
    BrowserCache; fwd=vary-miss; fwd-status=200; stored</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p><em>（可読性を上げるために改行しています）</em></p>
<p>これは、ブラウザがリクエストを送信したが、Varyヘッダに含まれるヘッダが一致しなかったため、同じURIで保持するキャッシュレスポンスを使用しなかったことを意味します。</p>
<p>リクエストは次にCloudflareが受信し、Cloudflareは一致するレスポンスをキャッシュしていましたが（<code class="language-text">Nginx; hit</code>というレスポンス。Nginxのキャッシュから読み出されたレスポンスであることを意味する）、そのレスポンスは古くなっています。</p>
<p>これに対処するため、CloudflareはNginxにレスポンスを再検証するようリクエストを送信し、Nginxは304（変更なし）レスポンスをCloudflareに返して既存のキャッシュレスポンスがまだ有効であることを伝えています。
送信されたリクエストは折り畳まれており、同じコンテンツについて同時に複数のリクエストがCloudflareに届いたが、上流に送信されたリクエストは1つだけであることを意味します。
Cloudflareは次の5分間、再検証されたデータを提供し続けます。</p>
<p>有益な情報がたくさん含まれています。
注意深く読み解くことで、このヘッダだけでもレスポンスのコンテンツがどこから来たのか、リクエストパス全体に沿って現在どのようにキャッシュされているのかが正確に分かります。</p>
<p>（キャッシング構成のデバッグに不慣れな人には、上記は手ごわそうに聞こえるかもしれませんが、これらの情報が1カ所にまとめられていることで、同じ情報を一から導き出すより何倍も負担が軽減されます。）</p>
<h3>Cache-Statusの実践</h3>
<p>これは全く新しい概念ではありませんが、全てのキャッシュを1カ所にまとめることで、一貫したデータの単一の供給源を提供することに本当のメリットがあります。</p>
<p>現在、各キャッシュプロバイダがさまざまな（それぞれ微妙に一致しない）ヘッダを使用しており、Nginxの<a href="https://support.cpanel.net/hc/en-us/articles/4402904983703-How-to-add-the-X-Cache-Status-header-to-NGINX-to-assist-with-optimizing-and-troubleshooting-cache-settings">X-Cache-Status</a>、Cloudflareの<a href="https://developers.cloudflare.com/cache/about/default-cache-behavior#cloudflare-cache-responses">CF-Cache-Status</a>、Fastlyの<a href="https://developer.fastly.com/reference/http/http-headers/X-Served-By/">X-Served-By</a>や<a href="https://developer.fastly.com/reference/http/http-headers/X-Cache/">X-Cache</a>などがあります。それぞれ、ここに含めることができる情報の一部を提供しており、今後は徐々にCache-Statusに置き換わっていくことが望まれます。
現在、ほとんどの主要コンポーネントとプロバイダはデフォルトでCache-Statusを搭載していませんが、Fastly、Akamai、Facebookなど多数の企業が標準化プロセスに関わっているため、多くのWebサービスやツールに採用される日はそう遠くないと思います。
実際、<a href="https://github.com/squid-cache/squid/commit/5fdc549054b11eb8bbc7e9640d6d071fa1ef742b">Squid</a>の組み込みサポートや<a href="https://github.com/caddyserver/cache-handler#readme">Caddyのキャッシングハンドラー</a>、<a href="https://gist.github.com/mnot/74ba8ed638a3d85659aa2868b9240d50">Fastlyのドロップインレシピ</a>など、既に進展が見られています。
2021年8月にRFCの発表があったばかりなのでまだかなり新しいですが、今後も引き続きサポートが広がっていくことを期待しています。
CDNまたはキャッシングコンポーネントの開発者は、ユーザのデバッグを支援するためにCache-Statusを採用することをお勧めします（これらのサービスを使っているのであれば、Cache-Statusの導入を求めることをお勧めします）。</p>
<h2>Targeted Cache-Controlのメリット</h2>
<p>既存の<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">Cache-Controlヘッダ</a>は、キャッシングがこれほど複雑化する前（1999年）に設計されたものです。
当時はIE 4.5がリリースされたばかりで、RIMが最初のBlackberryの発売準備を進めており、インタラクティブWebページの第一波を表す「Web 2.0」という言葉が生まれた時代でした。
テラバイト単位のデータをキャッシュするためにマルチレイヤーCDNアーキテクチャを構成することは大きなテーマではなかったのです。</p>
<p>時代は変わりました。</p>
<p>1999年に定義されたCache-Controlヘッダはリクエスト／レスポンスヘッダであり、リクエスト（どのようなキャッシュレスポンスを受け入れるか）とレスポンス（このレスポンスを今後どのようにキャッシュするか）に関するさまざまなキャッシングパラメータを定義できます。</p>
<p>ここではリクエストの構成については特に注目していませんが、レスポンスキャッシュの構成は非常に重要です。
レスポンスのCache-Controlは現在、以下のようにレスポンスの処理方法をキャッシュに伝えるディレクティブのリストによって定義されます。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Control: max-age=600, stale-while-revalidate=300, private</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>これは、「このコンテンツを10分間キャッシュし、次に、これを再検証する間、古いコンテンツを最大5分間配信する。ただし、これはプライベート（シングルユーザのブラウザなど）キャッシュでのみ行う」という意味です。</p>
<p>ここで設定されたルールは、同じリクエストを処理する全てのキャッシュが同様に従わなくてはならず、ツールとしてはやや粒度が粗いと言えます。
制御ルールの対象をエンドユーザのキャッシュに制限することは可能であり（<code class="language-text">private</code>を使用）、過去には、共有されたキャッシュ（CDNなど）にしか適用されないいくつかの重複したディレクティブ（<code class="language-text">s-maxage</code>や<code class="language-text">proxy-revalidate</code>など）を追加していましたが、それ以上の精度や柔軟性を望むことはできません。
これはつまり、以下のことは行えないことを意味します。</p>
<ul>
<li>ブラウザとCDNで、stale-while-revalidateに異なる時間を設定する</li>
<li>レスポンスに対し、内部のキャッシングロードバランサにおける全てのリクエストで再検証が必要だが、CDNでは不要とのフラグを付ける</li>
<li>CDNでのキャッシングは有効にしつつ、外部の共有キャッシュ（エンタープライズプロキシなど）にはコンテンツをキャッシュしないよう伝える</li>
</ul>
<p>これでは、多くの高度なユースケースに対応できません。
ほとんどのキャッシングコンポーネントでは、これに対処するためにコンポーネント内のルールを定義するための構成オプションが用意されていますが、これはこれで柔軟性に欠け、レスポンスに応じて異なるルールを構成するのが難しくなります。</p>
<p><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-targeted-cache-control/">Targeted Cache-Control</a>は、全てのキャッシュではなく特定のキャッシュのみを対象としたCache-Controlのディレクティブを設定するための新しいヘッダを定義することで、この問題の解決を図るものです。</p>
<h3>Targeted Cache-Controlの仕組み</h3>
<p>Targeted Cache-Controlを使用するには、サーバが以下のような形式のレスポンスヘッダを設定する必要があります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">&lt;Target&gt;-Cache-Control: param, param=value, param...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ヘッダのプレフィックスには、これを適用する特定の対象が入ります。
構文は、<a href="https://datatracker.ietf.org/doc/rfc8941/">Structured Fields</a>の標準形式を使用するため、厳密にはCache-Controlが使用する構文とは若干異なりますが、実質的にはほとんど同じです。</p>
<p>ここで使用する対象には、固有のサービスやコンポーネントの名前、あるいはキャッシュクラスなどが入ります。
仕様で定義する対象は1つだけ（<code class="language-text">CDN-Cache-Control</code>。全ての分散CDNキャッシュに適用し、他のキャッシュには適用しない）ですが、後から他のクラスを定義することもできます。
将来的には、<code class="language-text">Client-Cache-Control</code>がHTTPクライアントにおけるキャッシングのみを対象にルールを設定し、<code class="language-text">ISP-</code>がインターネットサービスプロバイダ、<code class="language-text">Organization-</code>が企業組織のキャッシュを対象とする、といったことも可能です。</p>
<p>これらのヘッダを使用するには、それをサポートする各キャッシュがマッチする対象のリストを優先順に定義（固定またはユーザ定義）します。他により具体的なマッチがなければ、最初にマッチした<code class="language-text">&lt;target&gt;-Cache-Control</code>ヘッダまたは通常の<code class="language-text">Cache-Control</code>ヘッダ（あれば）を使用します。</p>
<p>全体として、既存のキャッシングの仕組みに既になじみがある場合、かなりシンプルで使いやすいと感じるでしょう。Targetedヘッダは特定の対象とマッチし、キャッシングのルールは対象に応じて自由に設定でき、ベストマッチが優先されます。以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Client-Cache-Control: must-revalidate
CDN-Cache-Control: max-age=600, stale-after-revalidate=300
Squid-Cache-Control: max-age=60
Cache-Control: no-store</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>これは以下のような意味になります。</p>
<ul>
<li>エンドクライアント（少なくとも、筆者が考案した<code class="language-text">Client-Cache-Control</code>ヘッダを認識するもの）は、このコンテンツをキャッシュできるが、使用する前に毎回再検証しなくてはならない</li>
<li>全てのCDNがコンテンツを10分間キャッシュでき、次に、これを再検証する間、古いレスポンスをさらに5分間使用できる</li>
<li>Squid（キャッシング機能を備えたリバースプロキシ）は、コンテンツを60秒間だけキャッシュできる（<code class="language-text">stale-while-revalidate</code>指示はないため、古い間は暗黙的に使用できない）</li>
<li>Targeted Cache-Control指示を理解できないものは、このコンテンツをキャッシュしてはならない</li>
</ul>
<h3>Targeted Cache-Controlの実践</h3>
<p>Cache-Statusよりも新しく、標準化プロセスの早い段階にあるため、まだ変更が加わる可能性があります。フィードバックがある場合、<a href="https://github.com/httpwg/http-extensions/blob/main/draft-ietf-httpbis-targeted-cache-control.md">ここから</a>GitHubにアクセスして仕様書を入手し、同じレポジトリ内で問題を報告（または<a href="https://datatracker.ietf.org/wg/httpbis/about/">ワーキンググループのメーリングリスト</a>にメッセージを送信）し、意見を述べることができます。
とは言え、仕様書自体はFastly、Akamai、Cloudflareの代表者が執筆しているため、業界のサポートは既に十分得られており、作業はもうかなり進んでいるため、大きな変更が加えられる可能性は低いと思われます。</p>
<p>現状、<a href="https://blog.cloudflare.com/cdn-cache-control/">Cloudflare</a>と<a href="https://www.akamai.com/blog/news/targeted-cache-control">Akamai</a>が既にサポートしているため、これらのキャッシュを使用する場合、今から<code class="language-text">CDN-Cache-Control</code>、<code class="language-text">Akamai-Cache-Control</code>、<code class="language-text">Cloudflare-CDN-Cache-Control</code>を使用した正確な構成を開始できます。今後他の多くのツールやサービスについても同様のサポートが行われる可能性が高いため、引き続き注目してください。</p>
<h2>今後の展望</h2>
<p>2021年、キャッシングは依然として複雑ですが、Cache-StatusとTargeted Cache-Controlが急速に成熟しており、これらによって構成とデバッグはかなり容易になると見られます。キャッシングに携わっている方は注目する価値があります。</p>
<p>IETFが最近取り組んでいるHTTP標準は2つだけですが、Webの発展に寄与したい方や今後登場する予定の標準について知りたい方は、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/">Rate-Limitingヘッダ</a>、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-proxy-status/">Proxy-Status</a>、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-digest-headers/">HTTPメッセージダイジェスト</a>、<a href="https://datatracker.ietf.org/doc/rfc8942/">HTTPクライアントヒント</a>など他にも多数あるのでチェックしてみてください。
HTTPは発展途上の標準であり、今後も続々登場します。
これらのいずれかに興味のある方は、<a href="https://datatracker.ietf.org/wg/httpbis/about/">ワーキンググループのメーリングリスト</a>に参加し、新たな開発情報をチェックしたり意見を共有したりすることをお勧めします。</p>
<p><em>HTTPリクエスト、キャッシング、エラーのテストやデバッグをご希望の方は、<a href="https://httptoolkit.tech/">HTTP Toolkit</a>でHTTPの傍受、調査、模擬をお試しください。</em></p>
<p><em>10か月前(※訳注：2022年8月の翻訳記事公開時点)に<a href="https://twitter.com/pimterry">Tim Perry</a>が公開</em></p>]]></content:encoded></item></channel></rss>