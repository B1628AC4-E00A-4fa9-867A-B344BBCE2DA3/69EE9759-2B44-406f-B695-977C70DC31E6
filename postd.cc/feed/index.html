<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア]]></title><description><![CDATA[POSTD は、ニジボックスが運営する、エンジニアに向けたキュレーションメディアです。ニジボックスはWebサービスの企画、制作、開発、運用を一貫して担うリクルートの100%子会社です。 リクルートグループのオンラインサービスをはじめ、様々な業種・業界・業態のサービス開発を行っております。]]></description><link>https://postd.cc</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 23 Dec 2022 04:29:15 GMT</lastBuildDate><language>ja</language><atom:link href="https://postd.cc/feed/" rel="self" type="application/rss+xml"/><image><title>POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア</title><link>https://postd.cc</link></image><item><title><![CDATA[Miško HeveryのQwik記事シリーズ]]></title><description><![CDATA[POSTDでは、DEV Communityで公開されているQwikシリーズ の翻訳記事を公開予定です。 翻訳記事の更新に合わせてこのページも更新されていきます。 シリーズ記事一覧 Qwikの紹介 –…]]></description><link>https://postd.cc/series-qwik/</link><guid isPermaLink="false">https://postd.cc/series-qwik/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:01:00 GMT</pubDate><content:encoded><![CDATA[<p>POSTDでは、DEV Communityで公開されている<a href="https://dev.to/mhevery/series/13467">Qwikシリーズ</a> の翻訳記事を公開予定です。</p>
<p>翻訳記事の更新に合わせてこのページも更新されていきます。</p>
<h2>シリーズ記事一覧</h2>
<ol>
<li><a href="/a-first-look-at-qwik-the-html-first-framework/">Qwikの紹介 – HTMLファーストのフレームワーク</a></li>
<li><a href="/death-by-closure-and-how-qwik-solves-it/">クロージャによる死（とQwikによる解決方法）</a></li>
<li><a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣</a></li>
<li><a href="/qwik-the-answer-to-optimal-fine-grained-lazy-loading/">Qwik：最適できめ細かい遅延読み込みを実現</a></li>
</ol>]]></content:encoded></item><item><title><![CDATA[Qwik：最適できめ細かい遅延読み込みを実現]]></title><description><![CDATA[Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけ…]]></description><link>https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</link><guid isPermaLink="false">https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけでなく、アプリケーションが続く限り行われます。
言い換えると、Qwikはきめ細かい遅延読み込みを追求しているのです。
「きめ細かい」とは、ユーザのアクションを処理するのに直接必要なコードのみがダウンロードされるという意味です。
この記事では、きめ細かい遅延読み込みを実現するために解決すべき技術的課題について探っていきます。</p>
<h2>リスナーをシリアライズ</h2>
<p>最も明確に解決すべき課題は初回のページ読み込みです。
この点に関しては、「<a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に</a>」で対応策をすでに取り上げました。
ポイントは、イベントの名称とアクションをURLとしてシリアライズし、DOMの属性として保持することです。その後、最上位のグローバルなイベントハンドラがイベントをリッスンし、そのイベントに関連するコードをダウンロードできます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>このコードは、初回のページ読み込みで（1KBのローダを除いて）JavaScriptを一切読み込むことなく、上記の処理を実現します。
これにより初回読み込み時のTime to Interactiveの目標を達成できますが、新たな問題が生まれます。
私たちは、ユーザとの初回のインタラクション時にアプリケーション全体をダウンロードしたり、ブートストラップしたりしたくはありません。
それでは初回の読み込み時から初回のインタラクション時へ問題を先送りするだけになってしまいます（それどころか、ユーザとの初回のインタラクション時に大きなレイテンシが生じるので、状況は悪化しています）。</p>
<p>この問題は、ユーザとの1回のインタラクションで、アプリケーション全体のダウンロードやブートストラップが行われないようにすれば解決です。
その代わり、インタラクションの処理に直接必要なコードやコンポーネントのみのダウンロード、ブートストラップ、再ハイドレーションを行えばよいのです。
そのため、きめ細かい遅延読み込みが必要になります。</p>
<p>これはイベントをHTMLやDOMへシリアライズすればすべて実現できます。
そうしなければ、テンプレートの読み込みを遅延させるのは不可能でしょう。
なぜなら、フレームワークはイベントの場所を特定するためにテンプレートをダウンロードする必要があるからです。</p>
<h2>非同期かつアウトオブオーダー方式によるコンポーネントのハイドレーション</h2>
<p>初回のインタラクションによるアプリケーション全体のダウンロードやブートストラップを避けるには、コンポーネントを非同期かつアウトオブオーダー方式で再ハイドレートする必要があります。</p>
<p>ここでいう非同期とは、レンダリングシステムがレンダリングを一時停止してコンポーネントのテンプレートを非同期にダウンロードし、それからレンダリングのプロセスを再開できるという意味です。
レンダリングプロセスがすべて完全な同期方式である既存のフレームワークとはとても対照的です。
レンダリングが同期方式である場合、非同期の遅延読み込みを挿入する余地はありません。その結果、すべてのテンプレートをレンダリングの呼び出し前に準備する必要があります。</p>
<p>既存の再ハイドレーション戦略にはもう1つ問題があります。
それは再ハイドレーションがルートコンポーネントから始まり、ルート以下のすべてのコンポーネントを同期方式で再ハイドレートすることです。
そのため、すべてのコンポーネントを同時に再ハイドレートしなければならず、あらゆるコンポーネントのダウンロードを強いられます。
その結果、初回のインタラクション時の処理時間が長くなります。
アウトオブオーダー方式のハイドレーションとは、各コンポーネントを他のコンポーネントとは独立して任意の順番で再ハイドレートできるという意味です。
これにより、Qwikはリクエストの処理に必要な最小限のコンポーネントのみを再ハイドレートすることが可能になります。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./path/MyComponent_template<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ... some content ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のケースでは、<code class="language-text">&lt;div&gt;</code>は<code class="language-text">MyComponent_template.ts</code>と紐づけられたコンポーネントを表しています。
Qwikは、コンポーネントを再レンダリングする必要があると判断した場合のみテンプレートをダウンロードするため、ダウンロードがさらに遅延されます。</p>
<p>再ハイドレーションがアウトオブオーダー方式でなければ、フレームワークはすべてのテンプレートを一度にダウンロードし、再ハイドレートしなければなりません。
その結果、初回のインタラクション時に、ダウンロードと実行による大きな負荷がかかります。</p>
<h2>レンダリングをイベントハンドラから分離</h2>
<p>Qwikに関して考慮が欠かせないポイントは、既存のあらゆるレンダリングシステムがイベントリスナーをテンプレートに埋め込んでいることです。
そのため、コンポーネントを再レンダリング（または再ハイドレート）する必要があるときに、ブラウザはすべてのリスナーを必要性にかかわらずダウンロードしなければなりません。
リスナーは複雑なコードに紐づいていることが多いので、ダウンロードされるコード量はさらに増加します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded eagerly
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikはイベントハンドラをテンプレートのコードから分離します。これはリスナーとテンプレートを別々に、必要に応じてダウンロードできることを意味します。</p>
<p><code class="language-text">MyComponent_template.ts</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token function">MyComponent_template</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded lazily
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">MyComponent_onClick.ts</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>イベントハンドラをテンプレートから分離しなければ、フレームワークはコンポーネントの再レンダリングに必要な量よりはるかに多くのコードをダウンロードしなければなりません。
さらに、イベントハンドラは複雑で、他の依存関係を持っていることが多いため、ダウンロードが必要なコード量は増加します。</p>
<h2>コンポーネントのステートのシリアライズ</h2>
<p>コンポーネントを再ハイドレートするプロセスの最も重要な部分は、コンポーネントのステートを復元することです。
既存のフレームワークにはステートをシリアライズする方法がありません。
コンポーネントのステートがどこにあるかを確定するための標準的な方法が存在しないからです。</p>
<p>Qwikはコンポーネントをいくつかの部分に分解します。</p>
<ul>
<li><em>props</em>：コンポーネントの単なるプロパティ。DOMに反映される。例えば<code class="language-text">&lt;counter min=&quot;0&quot; max=&quot;100&quot;/&gt;</code>のpropsは<code class="language-text">{min: 0, max: 100}</code>。</li>
<li><em>state</em>：コンポーネントの内部ステート。DOMにシリアライズできる。</li>
<li><em>transient state</em>：追加的なステートで、コンポーネントによるキャッシュは可能だが、シリアライズは不可能なものを指す。この情報は再計算する必要がある（例：コンポーネントとサーバが通信している間の一時的なプロミス）。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Conter_template<span class="token punctuation">"</span></span>
     <span class="token attr-name">:.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>{count: 42}<span class="token punctuation">'</span></span>
     <span class="token attr-name">min</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">max</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_incremente<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  42
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_decrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントがステートをシリアライズできない場合、特定のコンポーネントを独立に再ハイドレートするのは不可能でしょう（コンポーネントはどこでステートを取得するというのでしょうか？）。
その結果、フレームワークは、ステートの計算やダウンロードのための追加コードをサーバからダウンロードしなければなりません。
Qwikはこうした問題のすべてを<a href="/html-first-javascript-last-the-secret-to-web-speed/">DOM内にステートをシリアライズする</a>ことで回避します。</p>
<h2>アプリや共有ステートのシリアライズ</h2>
<p>コンポーネント内のみで有効なコンポーネントステートに加え、複数のコンポーネントで利用されるアプリケーションステートも存在します。
これもDOM内にシリアライズする必要があります。共有ステートは以下に分解できます。</p>
<ul>
<li><em>key</em>：あるステートをただ1つに特定するID。コンポーネント内でステートを参照するために利用される。</li>
<li><em>state</em>：複数のコンポーネントで共有されるステート。DOM内にシリアライズできる。</li>
<li><em>transient state</em>：アプリケーションによるキャッシュは可能だが、シリアライズは不可能な追加ステート。この情報は再計算が可能でなければならない。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span>
     <span class="token attr-name">:item:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Item<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>789</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Shoe<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>43.21<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>987</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Sock<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>12.34<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>アプリケーションのステートをシリアライズすることで、コンポーネントが同じ情報を複数の場所でレンダリングし、他のコンポーネントとコミュニケーションできます。
フレームワークが共有ステートを把握・管理しないと、フレームワークがステートの変更を認識できないため、コンポーネントの独立したハイドレーションが不可能になります（例えば、AngularとReactにはレンダリング関数に紐づけられた明確なステート管理機能がありません。その結果、アプリケーションのステートが変更されたときにアプリケーション全体を再レンダリングする以外に妥当な方法がなく、きめ細かい遅延読み込みが困難です）。</p>
<h2>アプリのステートとコンポーネントの間のリアクティブな関係</h2>
<p>ステートを把握するフレームワークの真のメリットは、フレームワークがステートとコンポーネントの関係を認識できる点にあります。
これが重要なのは、任意のステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要があるか把握できるためです。
あるいは、それ以上に重要なのは、ステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要がないかを把握できることでしょう。
例えば、ショッピングカートに商品を追加するときは、ショッピングカート内の商品の個数を表示するコンポーネントのみを再レンダリングすべきですが、これはページ全体のごく一部でしかありません。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Unrelated<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./ShoppingCart<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$cart<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   2 items
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AddItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>buy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikの目標は再ハイドレートするコンポーネントの数を最小限にすることです。
ユーザが<code class="language-text">&lt;button&gt;</code>をクリックすると、Qwikは<code class="language-text">./AddItem</code>をダウンロードし、<code class="language-text">cart:432</code>のアプリケーションステートを更新します。
さらにQwikは、<code class="language-text">bind:cart:432</code>を持つコンポーネントが、そのステートを利用している唯一のコンポーネントであり、したがって再ハイドレーションと再レンダリングが必要な唯一のコンポーネントであると判断します。
Qwikはページ上のほとんどのコンポーネントを除外できるため、きめ細かい遅延読み込みを維持できます。
どのコンポーネントがどのステートと関係しているかを把握できるという点は、他のフレームワークには存在しないとても重要な特徴です。
この特徴によって、アプリケーションの起動時やライフサイクル全体を通じたきめ細かい遅延読み込みが可能になります。</p>
<h2>コンポーネントの分離</h2>
<p>これまでQwikがどのようにコードのきめ細かい遅延読み込みをサポートするか説明してきました。
上記の仕組みがすべて機能するのは、Qwikがアプリケーション内のデータフローを認識しているからです。
Qwikはこの情報を、再ハイドレートする必要がないコンポーネントを取り除き、必要なコンポーネントのみを再ハイドレートするために利用します。
これが暗に意味するのは、Qwikがコンポーネントと他のコンポーネントの通信を認識する必要があるということです。
コンポーネントは他のコンポーネントと秘密の会話をしてはならないのです。</p>
<p>コンポーネントがステートを取得したことをQwikが把握できない場合、Qwikは、ステートが変更されたときにそのコンポーネントの再ハイドレーションや再レンダリングが必要であることを認識できません。
そのため、コンポーネントは自身の依存関係のリストをプロパティに明記する必要があります。</p>
<p>この明確なリストがないと、フレームワークは、ステートが変更された時点ですべてを再レンダリングしなければなりません。
その結果、アプリケーション全体のダウンロードとブートストラップが行われることになります。</p>
<h2>結論</h2>
<p>Webアプリケーションが遅延読み込みに対応した構造となるように、開発のアプローチを変える必要がある点は数多くあります。
ポイントは、現在のフレームワークはこの問題を解決する助けにならず、ときには悪化させるという点です（例えば、ページ全体の再ハイドレーション、同期方式のレンダリングなど）。
Qwikはきめ細かい遅延読み込みを実現し、どんなに大規模で複雑であっても1秒未満で読み込めるサイトやアプリを開発できます。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣]]></title><description><![CDATA[すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJ…]]></description><link>https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</link><guid isPermaLink="false">https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJavaScriptヒープに保持します。<a href="https://github.com/builderio/qwik">Qwik</a>のユニークな点は、ステートが属性としてDOMに保持されることです（リファレンスもクロージャもシリアライズして送受信するのは不可能ですが、文字列であるDOM属性なら可能です。これがresumability(再開性）のカギとなります）。</p>
<p>DOMにステートを保持することには、以下のように多くのユニークなメリットがあります。</p>
<ol>
<li>DOMはシリアライズの形式としてHTMLを使用します。ステートを文字列属性としてDOMに保持することで、アプリケーションをいつでもHTMLにシリアライズできます。HTMLを送信し、別のクライアントでDOMにデシリアライズすることが可能になります。デシリアライズされたDOMは、そこから再開できます。</li>
<li>各コンポーネントを他のコンポーネントとは独立して再開できます。このアウトオブオーダー方式の再ハイドレーションによって、アプリケーション全体の一部のみを再ハイドレートすることが可能であり、ユーザのアクションに応じてダウンロードしなければならないコード量が制限されます。これは従来のフレームワークとは全く異なる点です。</li>
<li>Qwikはステートレスなフレームワークです（アプリケーションのステートはすべて文字列としてDOMに保持されます）。ステートレスなコードはシリアライズ、送受信、再開が簡単です。各コンポーネントを独立に再ハイドレートすることも可能になります。</li>
<li>アプリケーションを（初回のレンダリング時だけでなく）いつでも何度でもシリアライズできます。</li>
</ol>
<p>例として、シンプルなCounterコンポーネントと、ステートのシリアライズの仕組みを見てみましょう（これはサーバサイドでレンダリングされたHTMLの出力結果であり、必ずしも開発者がこのようなコードを書くわけではありません）。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">::app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AppState<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">app-state:</span>1234</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{count: 321}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name">::.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{countStep: 5}<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span>app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state:1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_increment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
    321.
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_decrrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<ul>
<li><code class="language-text">::app-state</code>（アプリケーションステートのコード）：アプリケーションステートの変更コードをダウンロードできるURLを指します。ステートの更新コードは、ステートを変更する必要がある場合のみダウンロードされます。</li>
<li><code class="language-text">app-state:1234</code>（アプリケーションステートのインスタンス）：特定のアプリケーションのインスタンスへのポインタ。ステートをシリアライズすることで、アプリケーションはステートの再構築をやり直すのではなく、中断した所から再開できます。</li>
<li><code class="language-text">decl:template</code>（テンプレートの宣言）：コンポーネントのテンプレートをダウンロードできるURLを指します。コンポーネントのステートが変更され、再レンダリングする必要があるとQwikが判断するまで、テンプレートはダウンロードされません。</li>
<li><code class="language-text">on:q-render</code>（コンポーネントのレンダリングのスケジュール設定）：フレームワークは再レンダリングが必要なコンポーネントを追跡しなければなりません。これは通常、無効化されたコンポーネントの内部リストを保存することで行われます。Qwikでは、無効化されたコンポーネントのリストは、属性としてDOMに保存されます。その後、コンポーネントは<code class="language-text">q-render</code>イベントのブロードキャストを待ちます。</li>
<li><code class="language-text">::.=&quot;{countStep: 5}&quot;</code>（コンポーネントのインスタンスの内部ステート）：コンポーネントは、再ハイドレーション後も内部ステートを保持しなければならない場合があります。このステートはDOMに保持できます。コンポーネントは、再ハイドレートされた時点で、再開に必要なすべてのステートを保持しています。ステートの再構築は不要です。</li>
<li><code class="language-text">bind:app-state=&quot;state:1234&quot;</code>（共有アプリケーションステートへのリファレンス）：複数のコンポーネントが同じ共有アプリケーションステートを参照できるようにします。</li>
</ul>
<h2><code class="language-text">querySelectorAll</code>は強い味方</h2>
<p>フレームワークの一般的な役割の1つは、アプリケーションのステートが変更されたときに、どのコンポーネントの再レンダリングが必要か特定することです。
この作業が発生する理由はいくつかあります。
例えば、コンポーネントが明確に無効とされる場合や（<code class="language-text">markDirty()</code>）、アプリケーションの共有ステートの変更によりコンポーネントが暗黙に無効とされる場合などです。</p>
<p>上記の例では、<code class="language-text">count</code>が<code class="language-text">app-state:1234</code>をキーとしてアプリケーションステートに保持されています。
ステートが更新された場合、そのアプリケーションステートに依存するコンポーネントは無効化（再レンダリングのキュー）が必要です。
フレームワークはどのように更新すべきコンポーネントを把握するのでしょうか？</p>
<p>ほとんどのフレームワークの場合、その答えは、単純にルートコンポーネントからアプリケーション全体を再レンダリングすることです。
この戦略は、コンポーネントのテンプレートすべてをダウンロードする必要があるという残念な結果を生み、ユーザとのインタラクションのレイテンシに悪影響を及ぼします。</p>
<p>一部のフレームワークはリアクティブで、任意のステートが変更された場合に再レンダリングが必要なコンポーネントを追跡しています。
しかし、これはテンプレートを囲い込むクロージャの形式で記録されます（<a href="/death-by-closure-and-how-qwik-solves-it/">「クロージャによる死」</a>を参照）。
その結果、リアクティブな接続が初期化されるアプリケーションのブートストラップ時に、すべてのテンプレートをダウンロードしなければなりません。</p>
<p>Qwikはコンポーネントレベルでリアクティブです。
そのため、ルートからレンダリングを開始する必要はありません。
しかし、Qwikはリアクティブなリスナーをクロージャの形式で保持するのではなく、属性の形式でDOMに保持しているので、レンダリングを途中から再開できます。</p>
<p><code class="language-text">count</code>が更新されると、Qwikは以下の<code class="language-text">querySelectorAll</code>を実行し、どのコンポーネントを無効化する必要があるかを内部で判断します。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'bind\\:app-state\\:1234'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>markDirty<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>上記のクエリによって、Qwikはどのコンポーネントがステートに依存しているかを判断し、各コンポーネント上で<code class="language-text">markDirty()</code>を呼び出します。
<code class="language-text">markDirty()</code>はコンポーネントを無効化し、そのコンポーネントを再レンダリングが必要なコンポーネントのキューに追加します。
これは<code class="language-text">markDirty</code>の複数の呼び出しを1つのレンダリングパスに連結することで行われます。
レンダリングパスは<code class="language-text">requestAnimationFrame</code>を利用してスケジュールを設定します。
しかし、ほとんどのフレームワークとは異なり、Qwikはこのキューも属性としてDOMに保持します。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">requestAnimationFrame</code>はレンダリングのスケジュール設定に利用されます。
これは論理的に考えれば、コンポーネントが待っている<code class="language-text">q-render</code>イベントを<code class="language-text">requestAnimationFrame</code>がブロードキャストすることを意味します。
ここで再び<code class="language-text">querySelectorAll</code>の出番です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'on\\:q-render'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>jsxRender<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ブラウザにはブロードキャストイベント（イベントのバブリングの逆）が存在しませんが、<code class="language-text">querySelectorAll</code>を利用すれば、イベントのブロードキャストを受け取るべきコンポーネントをすべて特定できます。
さらに、<code class="language-text">jsxRender</code>関数を利用してUIを再レンダリングします。</p>
<p>ポイントは、Qwikがどの時点でもDOMの外部でステートを保持する必要がない点です。
あらゆるステートは属性としてDOMに保持され、自動的にHTMLにシリアライズされます。
つまり、いつでもアプリケーションのスナップショットをHTMLとして保存し、それを送信したり、デシリアライズしたりできるということです。アプリケーションは途中から自動的に再開されます。</p>
<p>Qwikはステートレスであり、それこそがQwikアプリケーションにresumableがある理由です。</p>
<h2>メリット</h2>
<p>アプリケーションがresumableであることは、フレームワークのステートのすべてをDOMエレメントに保持する明確なメリットです。
しかし、一見しただけでは分かりにくい、他のメリットもあります。</p>
<p>そのメリットとは、ビューポートの外側にあるコンポーネントのレンダリングをスキップできることです。
コンポーネントのレンダリングが必要かを判断するために<code class="language-text">q-render</code>イベントをブロードキャストすると、コンポーネントが表示されているかどうかを判断し、非表示コンポーネントのレンダリングを簡単にスキップできます。
また、レンダリングをスキップすれば、テンプレートなどのコードを一切ダウンロードする必要がありません。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0C5MyDdy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l7y32eh60iarvc277zl9.png"></p>
<p>ステートレスのもう1つのメリットは、アプリケーションが実行されている間にHTMLの遅延読み込みが可能であることです。
例えば、サーバは最初に表示される画面のレンダリングに必要なHTMLを送信する一方で、画面に表示されていない部分のHTMLをスキップできます。
ユーザは最初の画面でインタラクションを開始し、アプリケーションを使用することが可能です。
ユーザがスクロールし始めた時点で、アプリケーションは他のHTMLを読み込み、それをDOMの末尾に<code class="language-text">innerHTML</code>で挿入します。
Qwikはステートレスであるため、すでに実行されているアプリケーションに何の問題も発生させずに追加のHTMLを挿入できます。
Qwikが新たなHTMLを認識するのはインタラクションが行われたときであり、その時点までHTMLのハイドレーションは遅延されます。
こうしたユースケースは、現行世代のフレームワークで実現するのがとても難しいものです。</p>
<p>私たちはQwikの未来と、それが切り開くユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[クロージャによる死（とQwikによる解決方法）]]></title><description><![CDATA[世界中にQwikを紹介した前回の記事では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が…]]></description><link>https://postd.cc/death-by-closure-and-how-qwik-solves-it/</link><guid isPermaLink="false">https://postd.cc/death-by-closure-and-how-qwik-solves-it/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>世界中にQwikを紹介した<a href="/a-first-look-at-qwik-the-html-first-framework/">前回の記事</a>では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が現在の場所までどのようにたどり着いたかを理解しておくことが重要です。
現代のフレームワークはある前提のもとに成り立っており、
それが優れたTime to Interactive（TTI）スコアの実現を妨げているのですが、
その前提とはどのようなものなのでしょうか。
現行世代のフレームワークの現時点における限界を理解することで、
Qwikの設計思想がなぜ最初は驚くべきものに思えるのか、より深く知ることができるでしょう。</p>
<h2>TTIについて</h2>
<p>TTIは、URLに遷移してからページがインタラクティブになるまでの時間を測定したものです。
レスポンシブなサイトとしての体裁を整えるには、サーバーサイドレンダリング（SSR）が必須です。
この背景にある考え方は、サイトを素早く表示し、ユーザがクリックすればいいか判断できるようになるまでに、
アプリケーションが自身をブートし、すべてのリスナーをインストールするというものです。
そのためTTIは、実際にはフレームワークがDOMリスナーをインストールするのにかかる時間を測定していると言えます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--85XBH76v--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jlvs7wu983qt0846c2a1.png"></p>
<p>上の図では、ブートからインタラクティブになるまでの時間に焦点を当てています。
フレームワークがインタラクティブな状態に達するまでに実行すべきことすべてを理解できるよう、
インタラクティブになった時点からスタートして逆にたどってみましょう。</p>
<ol>
<li>フレームワークはリスナーがどこにあるかを知る必要があります。しかし、この情報はフレームワークが簡単に利用できるものではありません。リスナーはテンプレートに<code class="language-text">described</code>（記述）されています。</li>
<li>実は、筆者は<code class="language-text">described</code>よりも<code class="language-text">embedded</code>（埋め込み）という言葉のほうが適切だと考えています。情報が埋め込まれていると言えるのは、フレームワークが情報を簡単に利用できないからです。フレームワークは、リスナーのクロージャに到達するためにテンプレートを実行する必要があります。</li>
<li>テンプレートを実行するにはダウンロードしなければなりません。しかし、ダウンロードされたテンプレートには import が含まれており、これを読み込むためにさらに多くのコードのダウンロードが必要です。テンプレートはそのサブテンプレートをダウンロードする必要があります。</li>
<li>テンプレートの準備はできましたが、依然としてリスナーには到達していません。テンプレートの実行は、実際にはテンプレートとステートをマージすることを意味します。ステートがなければ、フレームワークはテンプレートを実行できず、リスナーにはたどり着けません。</li>
<li>ステートはダウンロードしたり、クライアント側で計算したりする必要があります。頻繁に計算をするということは、ステートを計算するためにさらに多くのコードをダウンロードする必要があることを意味します。</li>
</ol>
<p>すべてのコードがダウンロードされると、フレームワークはステートを計算し、そのステートをテンプレートにフィードすることが可能になります。
そして、ようやくリスナーのクロージャにたどり着き、クロージャをDOMにインストールできます。</p>
<p>インタラクティブなステートに至るには多くの作業が必要です。
現行世代のあらゆるフレームワークはこのように動作しています。
つまり、フレームワークがリスナーを発見してインストールするには、
結局はアプリケーションの大部分をダウンロードして実行しなければなりません。</p>
<h2>クロージャについて</h2>
<p>上記の問題の核は、コードをダウンロードするには大きな処理能力が必要であること、
そしてフレームワークがリスナーを発見し、ページがインタラクティブな状態になるまでに長いCPU時間がかかることです。
しかし、私たちはクロージャがコードとデータを囲い込むという性質を忘れています。
これはとても便利な特性であり、私たちがクロージャを気に入っている理由です。
しかし、これは同時にクロージャのすべてのデータとコードが、
クロージャの実行時に遅延して作成されるのではなく、
クロージャを作成した時点で利用可能でなければならないことも意味します。</p>
<p>例としてシンプルなJSXテンプレートを見てみましょう（ただし、他のテンプレートシステムにも同じ問題があります）。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>addToCart<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cart'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyBuyButton</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>cost<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    Price<span class="token operator">:</span> <span class="token punctuation">{</span>cost<span class="token punctuation">}</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">addToCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      Add to cart
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>クロージャによる死</h2>
<p>クロージャはコストが低いため、至るところで見られます。
しかし、クロージャは本当に低コストなのでしょうか。
その答えはイエスでもあり、ノーでもあります。
確かに、ランタイムにおいて短時間で作成できるという意味では低コストです。
しかし、コードを囲い込むために、クロージャがない場合より大幅に早くコードをダウンロードする必要があるという点では高コストです。
さらに、ツリーシェイキングを妨害するという意味でも高コストです。
そのため、筆者が「クロージャによる死」と呼ぶ状況が起きます。
クロージャはDOMに設置されるリスナーであり、実行される可能性がほとんどないコードを囲い込みます。</p>
<p>ページの「購入する」ボタンは複雑な割にしょっちゅうクリックされるようなものではありません。
それでも「購入する」ボタンは、関連するすべてのコードのダウンロードをしきりに促します。
これはクロージャがそのような仕組みになっているためです。</p>
<h2>QwikはリスナーのHTMLシリアライズを可能にする</h2>
<p>これまで、クロージャには隠れたコストがあるかもしれないと説明してきました。
こうしたコストはコードの頻繁なダウンロードという形で生じます。そのため、クロージャを作成し、ユーザとインタラクティブなWebサイトの間に介在させるのは困難です。</p>
<p>Qwikはリスナーの作成を可能な限り遅らせようとします。
これを実現するために、Qwikは以下のルールを掲げています。</p>
<ol>
<li>リスナーはHTMLにシリアライズできなければならない。</li>
<li>ユーザがリスナーとのインタラクションを行うまで、リスナーはコードを囲い込まない。</li>
</ol>
<p>これがどのように実現されるのか、実例で見てみましょう。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyComponent_click<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Click me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">MyComponent_click.ts</code>ファイルの内容は以下のとおりです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Clicked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のコードをご覧ください。
SSRはレンダリングプロセスの間にリスナーの場所を発見した後、
その情報を捨てるのではなく、リスナーを属性としてHTMLにシリアライズします。
そのため、クライアントはリスナーの場所を発見するためにテンプレートを再実行する必要がありません。
その代わりとして、Qwikは以下のアプローチをとります。</p>
<ol>
<li><code class="language-text">qwikloader.js</code>をページにインストールする。このファイルのサイズは1KB未満で、実行には1ミリ秒もかからない。ファイルがとても小さくHTMLに埋め込むのが最善の方法であるため、サーバーとのラウンドトリップが不要になる。</li>
<li><code class="language-text">qwikloader.js</code>は、1つのグローバルなイベントハンドラを登録し、バブリングを活用することで、すべてのイベントを同時にリッスンできる。addEventListenerの呼び出しが少なくなるため、インタラクティブな状態までの時間が短くなる。</li>
</ol>
<p>その結果が以下のとおりです。</p>
<ol>
<li>リスナーを発見するためにテンプレートをダウンロードする必要がない。リスナーは属性としてHTMLにシリアライズされる。</li>
<li>リスナーを取得するためにテンプレートを実行する必要がない。</li>
<li>テンプレートを実行するためにステートをダウンロードする必要がない。</li>
<li>すべてのコードが遅延され、ユーザがリスナーとのインタラクションを行うときにのみダウンロードされる。</li>
</ol>
<p>Qwikは現行世代のフレームワークによるブートストラップのプロセスを省略し、1つのグローバルなイベントリスナーで代替します。
この方法が最も優れているのは、アプリケーションのサイズに影響されないところです。
どんなにアプリが大規模で複雑になってもリスナーは1つだけです。
すべての情報がHTMLにシリアライズされているため、ダウンロードすべきブートストラップコードは常に一定で、その容量はアプリケーションの複雑性と無関係です。</p>
<p>まとめると、Qwikの背景にある基本的な考え方は再開性（resumability）です。
Qwikはサーバーの作業が中断された時点から作業を再開し、クライアント側が実行する必要があるファイルはわずか1KBです。
このコードはアプリケーションがどんなに大規模で複雑になっても変わりません。
これから数週間（訳注：原文では定期的に8記事まで公開されています）にわたって、
Qwikがどのように作業を再開し、ステートを管理し、コンポーネントを独立にレンダリングするかを見ていきます。お楽しみに。</p>
<p>私たちはQwikの未来や、Qwikが実現する新たな種類のユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwikの紹介 – HTMLファーストのフレームワーク]]></title><description><![CDATA[Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWe…]]></description><link>https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</link><guid isPermaLink="false">https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWeb Components、
そしてその間にあるすべてのフレームワークに至るまで、
さまざまなツールで同じサイトを生成できることです。
出力されるコードは速度が最適化されています。
私たちのツールで作成されたサイトは、手作業で作成されたサイトの大部分よりも高速です。
私たちはこれを心から誇りに思っています。
私たちの製品は、スピードがとても重要であるeコマースに焦点を当てています。</p>
<h2>優れたTime to Interactiveの実現は困難</h2>
<p>どんなにコードが最適化されていても、静的HTMLのみを提供していない限り、
eコマースサイトが<a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a>で100点中100点のスコアを達成するのは困難です。
そのため、ほとんどのeコマースサイトは20点程度の赤色スコアとなっています。
高速化に重点的に取り組む余裕がある特に優れたサイトだけが50～60点の黄色スコアを獲得できます。
Builder.ioを利用しても50～60点の黄色スコアを達成できるでしょう。
しかし、私たちはもっと点数を良くしたいのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--hNfE5FAv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5zttsnsvx80ic0y3v4wa.png"></p>
<h2>HTMLだけなら高速</h2>
<p>とはいえ、静的HTMLを提供すれば点数は良くなります。
ほぼ確実に100点中100点のスコアを獲得できるでしょう。
そもそもPageSpeed Insightsのスコアは、ページがインタラクティブになる前にブラウザが実行しなければならないコードの量に基づいて測定されます。
JavaScriptをまったく実行しないようにすれば、100点満点を獲得し、簡単に緑色スコアに到達できます。
しかし、この方法にはページが静的になるという問題があります。
Webページは動的なコンテンツを提供し、インタラクションに満ちた生き生きとしたものでなければなりません。
静的HTMLで高いスコアを獲得しつつ、同時にリッチなインタラクションを提供するにはどうすれば良いのでしょうか。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--VCPVUPTb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/inff3jmvl300d1yaxaya.png"></p>
<h2>Qwikの導入 – HTMLファーストのフレームワーク</h2>
<p>そこでQwikの登場です。
Qwikは、オープンソースで開発されているDOM主体の再開型（resumable）Webアプリフレームワークです。
QwikはHTMLのサーバーサイドレンダリングの再開性（resumability）と、コードのきめ細かい遅延読み込みに重点を置くことで、
できる限り優れたTime to Interactiveを実現するように設計されています。
説明したいことが盛りだくさんで、今回のブログ記事だけではとてもカバーしきれません。
そこで、説明をいくつかのブログ記事に分割し、今後数週間にわたって投稿する予定です。
Qwikの基本的な目標は、ブラウザの遅延読み込み機能をできる限り活用し、JavaScriptを遅延させ、Time to Interactiveの指標を改善することです。
これは既存のフレームワークとはまさに対照的と言えます。
こうしたフレームワークは、サーバーサイドレンダリングとTime to Interactiveを、
その他すべての設計上の意思決定に影響する主な目標とは捉えておらず、
付け足し程度にしか考えていませんでした。
Qwikの目的は、どんなに遅いモバイル端末でも、Time to Interactiveをほんの一瞬にまで短縮することです。
私たちは、高速な静的ページをユーザに提供しつつ、インタラクティブ性も完全に維持したいと考えています。
つまり、一挙両得を目指しているのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--vNxZwFXl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dy3wa5ewpz9o9xoa87ys.png"></p>
<h2>再生型のフレームワークは作業が多すぎる</h2>
<p>ほとんどのeコマースサイトがPageSpeed Insightsで100点を取れないのには理由があります。
それは、どの既存のフレームワークもTime to Interactiveを念頭に置いて設計されていないということです。
これらのフレームワークは複雑なブートストラップのプロセスを持ち、
ページがインタラクティブになる前に多くのコードをダウンロード・実行する必要があります。
確かに、ほとんどのフレームワークはサーバーサイドレンダリングに対応しており、
初期コンテンツを素早く表示できます。
しかし、ページを再ハイドレートしてインタラクティブな状態にするには、
まずはページ上のすべてのテンプレートをダウンロードし、実行しなければなりません。
現在の既存のサイトが100点を取れずにいるのは、こうしたダウンロードや実行を行わなければならないせいです。
既存のフレームワークは、サイトをインタラクティブにするために、
サーバーサイドレンダリングにおけるすべての作業をクライアント側で再び実施する必要があるため、
再生型（replayable）であると言えます。
サイトが複雑になるにつれて、再生可能な状態を維持するためのコストも増えていきます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--PdQoT-lX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lqgpauzo2i23f3zhhke8.png"></p>
<h2>再開性が救世主に</h2>
<p>Qwikの背景にある基本的な考え方は再開性です。
Qwikはサーバーの作業が中断された時点から作業を再開できます。
クライアント側で実行するコードはほんの最小限です。
Qwikloaderは、サーバーサイドレンダリングによって生成された静的HTMLを取得し、レンダリングを再開します。
Qwikloaderのサイズは1KB未満で、実行に1ミリ秒もかかりません。
思わず前の文を読み直したくなるかもしれませんが、読み間違いではありません。
実行が必要なコードの量は驚くほど小さく、まばたきよりも短い時間で実行されます。
最も優れているのは、アプリケーションがどんなに大きくなっても、このコードが変わらないことです。
ユーザが最小限の部分でWebサイトとのインタラクションをしている間に、
サイトのその他すべてのインタラクティブな部分が遅れてダウンロードされます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ufFUjYds--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/550d4im90829stbvbvs0.png"></p>
<h2>もっと詳しく知る</h2>
<p>私たちが最も重視しているのは、この技術をお客様のために開発することです。
しかし、開発はオープンソースで行われるため、あらゆる人がどんな目的にも利用できます。
私たちはこの技術を汎用的なWebフレームワークとして設計する予定ですが、
お客様が必要とするものを最優先します。</p>
<p>読者の皆様は、もっと詳しい情報を知りたくてたまらないことでしょう。
そこで、皆様をStackBlitzのWebコンテナの<a href="https://stackblitz.com/edit/qwik-todo-demo">デモ</a>にご招待します。
素晴らしいことに、StackBlitzのスタッフはNode.jsをブラウザで実行する能力があり、
そのため私たちはフレームワークの重要な部分である、サーバーサイドレンダリングのデモを行うことができます（彼らに敬意を表します）。
オープンソースのリポジトリは<a href="https://github.com/builderio/qwik">こちら</a>です。
期待が大きくなりすぎないように言っておくと、リポジトリはあくまで概念実証の段階にあり、
多くの物事が時とともに変わると予想されるため、広く利用できる状態ではありません。
それでも、私たちは皆さんの考えを聞きたいと思っています。
ですから、ぜひ<a href="https://discord.gg/JHVpZmqSs4">Discordサーバーでのチャット</a>にご参加ください。</p>
<p>今後数週間（訳注：原文では定期的に8記事まで公開されています）で、
Qwikの背景にある多くのユニークなアイデアを詳しく解説し、
Qwikの仕組みと独自な点を説明していきます。お楽しみに。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[人材マネジメント🤯]]></title><description><![CDATA[初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いてお…]]></description><link>https://postd.cc/managing-people/</link><guid isPermaLink="false">https://postd.cc/managing-people/</guid><category><![CDATA[キャリア・働き方]]></category><category><![CDATA[開発組織]]></category><pubDate>Fri, 14 Oct 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いておく価値があるでしょう。</p>
<p>筆者は小規模なチームやスタートアップ企業のマネージャーのためにこの記事を書きました。
ほとんどのアドバイスは、大規模な企業のマネジメントには当てはまらないのではないかと思います。
なお、急成長している企業に入社する人への全般的なアドバイスについては<a href="https://klinger.io/posts/joining-hypergrowth-startups-%F0%9F%98%AC">こちら</a>をご覧ください。</p>
<p><strong>筆者について</strong></p>
<ul>
<li>
<p>中・小規模のエンジニアリングチームを数チーム管理した経験あり</p>
<ul>
<li><a href="https://beondeck.com/">On Deck</a>のCTO</li>
<li>CoinListの元エンジニアリング担当VP</li>
<li>AngelListの元リモート責任者</li>
<li>Product Huntの元CTO</li>
</ul>
</li>
</ul>
<p><strong>それでは始めましょう。</strong></p>
<h2>マネージャーはすべての失敗に責任を負う</h2>
<p>分かります……とても前向きなスタートですよね👀</p>
<ul>
<li>チームを怒る意味は全くありません</li>
<li>
<p>あなたはプロセスと人材に責任を負います</p>
<ul>
<li>あなたは常にチームより多くの情報を持っていたはずです</li>
</ul>
</li>
<li>
<p>失敗に至るプロセスを生んだのはあなたです</p>
<ul>
<li>あるいは、誤った人材を採用した（または解雇しなかった）のもあなたです</li>
</ul>
</li>
<li>結局、すべてはあなたの責任です</li>
</ul>
<h2>プロセスを管理し、人を導く</h2>
<ul>
<li>
<p>なぜかは分かりませんが、多くの人にとって、「人材のマネジメント」とは部下の仕事をコントロールしなければならないという意味になるようです</p>
<ul>
<li>彼らはマイクロマネジメントに陥り、目標やスケジュールだけでなく、仕事のやり方まで管理しています</li>
<li>あなたがマイクロマネジメントをする時間があるなら、大抵の場合、あなたの代わりにもっと人件費が安くて能力が低い人を採用し、その人に仕事をさせれば良いのです</li>
</ul>
</li>
<li>
<p>筆者が思うに、こうした行動は、マネージャの役割に関する誤解に起因しています</p>
<ul>
<li>あなたの仕事は人を管理することではありません</li>
<li>しかし、プロセスを管理し、人を導くことができます</li>
</ul>
</li>
<li>マネージャーは、仕事をどのように行うべきか、各メンバーの権限の範囲はどこからどこまでか、どのようにキャリアを形成するか、そしてこれらすべてをどのように議論し、変更できるかに関して、プロセスを管理します</li>
<li>
<p>さらに、手本を示し、共感することで人を導きます</p>
<ul>
<li>メンバーは目標、不安やモチベーションを持っています。仕事以外に問題を抱えていることもよくあります</li>
<li>仮に相手が逆の立場だったら、どう行動してほしいかを考えて行動しましょう</li>
</ul>
</li>
</ul>
<h2>プロセスとは期待を明確にしたもの</h2>
<ul>
<li>
<p>多くの人は「プロセス」に関する責任をなんとか逃れようとしています</p>
<ul>
<li>そのため「プロセスは多過ぎない方が良い」などと言います</li>
<li>筆者の私見では、これも誤解です</li>
</ul>
</li>
<li>
<p>プロセスとは、人々の行動を複雑な鎖のように結びつけ、膨大な手間を負わせるものではありません</p>
<ul>
<li>プロセスとは期待を明確にしたものです</li>
<li>例えば、「誰も作業を邪魔されないように、毎朝全員で〇〇をする」のようにシンプルなものでも構いません</li>
<li>少数のとても明確なプロセスを定め、それが守られるようにしましょう</li>
</ul>
</li>
</ul>
<h2>意思決定と意見</h2>
<ul>
<li>
<p>あらゆる議論、プロジェクト、問題や状況において、誰が意思決定するのかを明確にする必要があります</p>
<ul>
<li>他の人は意見を付け加えるにすぎません</li>
<li>理想的には、その後にフォローアップする（あるいはその仕事のリーダーとなる）人が意思決定をすべきです</li>
<li>それ以外は全員、意見を追加するだけです</li>
<li>「地位」や給与が高い人も例外ではありません</li>
</ul>
</li>
<li>
<p>マネージャーは意思決定を急に止めるためのハンドブレーキを握っています</p>
<ul>
<li>この力は文字どおりハンドブレーキのように扱いましょう</li>
<li>自動車の運転を想像してください。車を止めなければならないのに、ドライバーが反応しなければ、ハンドブレーキを引く必要があります。その結果、反動でダメージが生じるでしょう</li>
<li>絶対に必要なときにのみハンドブレーキを引き、その後に状況をどう修正するか議論します</li>
</ul>
</li>
<li>
<p>採用は意思決定スキルの優劣に基づいて判断します</p>
<ul>
<li>解雇も意思決定スキルの優劣に基づいて判断します</li>
<li>優れた意思決定スキルには他人の意見を聞くことが含まれます</li>
<li>疑問に思う場合は、意思決定者を最初から信頼できるか考えてみてください</li>
</ul>
</li>
</ul>
<h2>当事者意識</h2>
<ul>
<li>
<p>従業員が問題に対して完全な当事者意識を持つようにするのは困難です</p>
<ul>
<li>しかし、それが目標です</li>
<li>それがふさわしくない従業員なら解雇もできます</li>
</ul>
</li>
<li>
<p>フィードバックを提供し、支援しましょう</p>
<ul>
<li>従業員を信頼し、失敗を認めてください（損害を許容できる範囲で）</li>
<li>失敗を「従業員のレベルアップ」と捉えましょう</li>
</ul>
</li>
<li>
<p>最悪なのは、あなたが何度も介入し、従業員が仕事と自分を無関係と感じるようになることです</p>
<ul>
<li>彼らは当事者意識を持たず、言われたことをするだけのドローンになってしまいます</li>
<li>それがあなたの目的なら、人件費が安くて能力が低い人を採用すれば良いでしょう</li>
</ul>
</li>
</ul>
<h2>堂々巡りを避ける</h2>
<ul>
<li>
<p>プロセスを定めるときは、堂々巡りを避けましょう</p>
<ul>
<li>例えば、何かについてフィードバックを提供するときは、相手が言われたとおりにするか、あるいはそれができない理由を答えるだろうと考えてください</li>
<li>承認されることを期待してはいけません</li>
<li>誰もそんなことをしている暇はありません</li>
</ul>
</li>
</ul>
<h2>信頼</h2>
<ul>
<li>
<p>自分が神経質になっているのは、他人の仕事と自分の不安のどちらが原因かを常によく考えましょう</p>
<ul>
<li>他人があなたの感情の面倒を見る必要があるでしょうか？</li>
</ul>
</li>
<li>
<p>物事がうまくいっているときは、人を信頼するのは簡単です</p>
<ul>
<li>本当に難しいのは、物事がうまくいかないときです</li>
<li>状況に対するいら立ちと、人に対するいら立ちを常に区別しましょう</li>
</ul>
</li>
<li>
<p>「距離を置け」と言っているのではありません</p>
<ul>
<li>輪に加わり、目標を定め、意見を表明すべきですが、課題への対処はチームに任せるべきです。ただし、必要に応じてハンドブレーキを使いましょう</li>
</ul>
</li>
</ul>
<h2>率直な共有を通じて信頼を築く</h2>
<ul>
<li>
<p>従業員があなたの仕事を信頼するようになるための最も簡単な方法は、何も要求されなくても、成果を率直に共有することです</p>
<ul>
<li>従業員が探すだろうと思う場所に、すべてを利用可能な状態で置いておきましょう</li>
<li>従業員からの要求を待ってはなりません。ほとんどの従業員は要求をしないからです</li>
</ul>
</li>
</ul>
<h2>信頼は0か1ではない</h2>
<ul>
<li>
<p>私たちは信頼を0か1と考えがちです</p>
<ul>
<li>誰かを信頼するか、信頼しないかのどちらかということです</li>
</ul>
</li>
<li>
<p>しかし、これは正しくありません</p>
<ul>
<li>時とともに、信頼する人や、その人の何をどのように信頼するかは変わります</li>
</ul>
</li>
<li>
<p>信頼はシステム化できるものだと考えましょう</p>
<ul>
<li>例えば、チームの新しいメンバーにはどのような信頼を与えますか？</li>
<li>最初の数週間や1か月はどのような仕事をすることを求めますか？</li>
</ul>
</li>
</ul>
<h2>自律と放任を混同しない</h2>
<ul>
<li>筆者は、人材を採用した後は「好きなようにさせている」という創業者によく会います</li>
<li>これは原則としては正しいものの、従業員の成功を支援する責任から解放されることにはなりません</li>
</ul>
<h2>多層的な意思決定</h2>
<ul>
<li>
<p>会社では、さまざまな階層の人々が、仕事をするうえでお互いに頼りあっています</p>
<ul>
<li>CEOがプロダクトマネージャーの優先順位を認識していなければ、彼らは仕事ができません</li>
</ul>
</li>
<li>
<p>自分の仕事を社内の他人に押し付けてはなりません</p>
<ul>
<li>自分の仕事より楽しそうだからという理由だけで、他人の仕事に踏み込むこともやめましょう</li>
</ul>
</li>
</ul>
<h2>乱射型マネジメントを避ける</h2>
<ul>
<li>
<p>ミーティングで自分の意見やアイデアを手当たり次第にぶつけてはなりません</p>
<ul>
<li>あなたは経緯を十分に理解していない可能性が高く、大抵の場合、課題を最後までフォローする当事者になることはないからです</li>
</ul>
</li>
<li>
<p>単なる意見であって、意思決定ではないことを明確にしてください</p>
<ul>
<li>ただし、「創業者（またはマネージャー）の意見」がほとんどの従業員にとって大きな力を持つことを理解しましょう</li>
<li>一般的に非同期コミュニケーションでは声の「ニュアンス」が伝わりにくいため、<a href="https://klinger.io/posts/fyi-how-founders-can-avoid-drive-by-management">fyi（for your opinion 訳注：ご参考までに）タグ</a>を利用しましょう</li>
</ul>
</li>
</ul>
<p>ところで、筆者はこれを乱射型マネジメントと呼んでいます。なぜなら、グループで議論しているところにマネージャーがやってきて、銃を乱射するように要求、変更指示、アイデアを投げかけ、混乱、パニック、カオスを生み出した後、悲惨な状況を残して去っていくからです。</p>
<h2>フィードバックを提供する</h2>
<ul>
<li>人×文脈 = 成果</li>
<li>
<p>筆者の経験では、優れた人材でも、環境が悪いと不十分な成果しか出せないことがあります</p>
<ul>
<li>一方、とても平凡な人材でも、環境が素晴らしければチーム全体を上回る成果をあげることもあります</li>
</ul>
</li>
<li>
<p>フィードバックをする際、通常はその人自身よりも経緯について客観的に議論するほうが簡単です</p>
<ul>
<li>現在の問題の原因となったのはどのような状況ですか？</li>
<li>何が変わりましたか？現在何が必要とされていますか？</li>
</ul>
</li>
<li>
<p>若手エンジニアが仕事について行けていない場合</p>
<ul>
<li>それはエンジニア自身の責任ですか？それとも、チームは今の時点では、現在、若手が仕事を覚えるための役に立っていないのでしょうか？</li>
<li>すぐに問題になることはありませんが、いずれは解決するか、能力不足を受け入れる（解雇する）ことが必要です</li>
</ul>
</li>
<li>
<p>本番環境で大きなインシデントが発生した場合</p>
<ul>
<li>そもそも、なぜそのような事態が起きたのですか？</li>
<li>エンジニアリングチームは何に注目していましたか？</li>
<li>問題を回避するためのプロセスは導入されていましたか？</li>
<li>プロセスを導入する必要はありますか？</li>
<li>インシデントを起こした従業員に責任はありません</li>
<li>チーム全体が他の優先課題に注目していたからです</li>
<li>
<p>それは適切な理由（リリースへのプレッシャーなど）によるものでしたか？</p>
<ul>
<li>それとも不適切な理由（知識の不足など）によるものでしたか？</li>
</ul>
</li>
</ul>
</li>
<li>
<p>あなたが採用した人材は、モチベーションが高く、最善を尽くそうとしていると常に想定しましょう</p>
<ul>
<li>そうでない人材は解雇しましょう</li>
</ul>
</li>
</ul>
<h2>解雇は決してサプライズであってはならない</h2>
<ul>
<li>
<p>従業員にとって、解雇は決してサプライズであってはなりません</p>
<ul>
<li>状況が変わり、新たな要件が生じたことを伝える必要があります</li>
</ul>
</li>
<li>
<p>通常、従業員を解雇する理由は状況の変化です</p>
<ul>
<li>例えば、会社が変化したとき、</li>
<li>役職に求められるものが変化したときや、</li>
<li>誤った採用基準を定めていたことに気づいたときです</li>
<li>大抵の場合、責任は従業員よりもあなたにあります</li>
</ul>
</li>
<li>
<p>従業員は、自分の努力が新たな要件に足りるものであってほしいと願うかもしれません</p>
<ul>
<li>それでも、あなたが彼らを解雇しようとするときは理解を示すでしょう</li>
</ul>
</li>
</ul>
<h2>解雇を先延ばししない</h2>
<ul>
<li>従業員を解雇すると決定したら、すぐに行動しましょう</li>
<li>
<p>従業員をゾンビのような状態で雇い続けていることはよくあります</p>
<ul>
<li>「彼を解雇すべきだ」</li>
<li>そう思っても解雇しないのです</li>
<li>従業員のためになりません</li>
<li>
<p>従業員はおそらく今の環境に満足していないでしょう</p>
<ul>
<li>評価が低く、</li>
<li>良い仕事もできないからです</li>
</ul>
</li>
<li>
<p>大抵の場合、あなたが解雇を避けるのは自分のためです</p>
<ul>
<li>なぜなら、誰かを解雇するのは良い気分ではないからです</li>
<li>自分の感情や未来を、従業員の感情や未来より気にすることはやめるべきです</li>
</ul>
</li>
</ul>
</li>
<li>
<p>面談を設定し、解雇を伝えます</p>
<ul>
<li>最初に余計なおしゃべりをするのはやめましょう</li>
<li>本題を率直に切り出し、次のステップを明確にしましょう</li>
<li>必ず真剣な事実として伝えます</li>
<li>解雇を伝えるときには、あなたの感情や問題は重要ではないことを忘れないでください</li>
</ul>
</li>
<li>
<p>その後、従業員が新たな仕事を探せるように支援します</p>
<ul>
<li>従業員はかつてキャリアをあなたに委ねたのですから、その信頼を維持しましょう</li>
</ul>
</li>
<li>
<p>最後に：一部の国では、従業員を解雇するのに月によっては数日かかる場合もあります</p>
<ul>
<li>どちらにせよ、解雇のプロセスを主体的に管理し、あなたを信頼している人に敬意を持って接するようにしましょう</li>
<li>彼らはあなたのチームにキャリアを委ねたのです</li>
<li>ほとんどの場合、従業員が去るのは自らの責任ではなく、状況の変化によるものです</li>
<li>彼らが自分に適した新しい仕事を見つけられるように支援しましょう</li>
</ul>
</li>
</ul>
<h2>明確 > 不明確</h2>
<ul>
<li>
<p>ミーティング後の明確な意思決定</p>
<ul>
<li>明確な意思決定がなされていない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>明確な責任者</p>
<ul>
<li>明確な責任者がいない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>全員の意見を聞く</p>
<ul>
<li>誰が意思決定するかを明確にしましょう</li>
<li>意思決定の内容も明確にします</li>
</ul>
</li>
<li>などなど</li>
</ul>
<h2>ベストプラクティス：「現実は正しい」という認識から始める</h2>
<ul>
<li>
<p>チームやプロセスの中でベストプラクティスや変化を求めるときは、まずは既存の自然に生まれたものに必ず注目しましょう</p>
<ul>
<li>優れた人材を採用していれば、通常は彼らが自然と解決策を探し始めています</li>
<li>その解決策は適切でしょうか？もしそうなら明確にしましょう</li>
<li>「現実は正しい」という認識が重要です</li>
<li>もし適切でないなら、それを変える方法について議論しましょう</li>
</ul>
</li>
</ul>
<h2>会社は数カ月ごとにリファクタリングされるものと考える</h2>
<ul>
<li>
<p>急成長しているスタートアップ企業は、3～6カ月ごとに事業の進め方を社内でリファクタリングする必要があります</p>
<ul>
<li>現在必要な最低限の変化のみに取り組みましょう</li>
</ul>
</li>
<li>
<p>決定的な最終バージョンは存在しません</p>
<ul>
<li>あなたは会社のプロセスに対して常に不満を感じ続けるでしょう</li>
<li>伸び悩みに直面しない限り、成長痛は続くはずです</li>
</ul>
</li>
<li>
<p>コードをリファクタリングするときと同じ原則を適用しましょう</p>
<ul>
<li>以下の点に気を付けてください</li>
<li>まずは小規模な隔離された環境でテストする</li>
<li>ピアレビューを行う</li>
<li>すべてを一度に変えようとしない</li>
<li>オーバーエンジニアリングを回避する</li>
<li>などなど</li>
</ul>
</li>
</ul>
<h2>燃え尽き症候群</h2>
<ul>
<li>よくある誤解は、燃え尽き症候群は働き過ぎが原因というものです</li>
<li>
<p>実際の原因は、仕事をコントロールできない、自分が影響を与えられていないと感じることです</p>
<ul>
<li>仕事がほとんどないにもかかわらず、従業員（あるいは自分）が燃え尽きる場合があることを忘れないでください</li>
</ul>
</li>
<li>
<p>従業員が自らの影響をコントロールできるようにするには、どうすれば良いのでしょうか？</p>
<ul>
<li>どうすれば従業員と周囲の混沌とした状況の間に境界線を引けるのでしょうか？</li>
</ul>
</li>
</ul>
<h2>混乱を生み出す人間はそれに気づきにくい</h2>
<ul>
<li>
<p>創業者のよくある不満は、チームが変化について来られないというものです</p>
<ul>
<li>創業者は、大抵は変化に至る背景をよく理解し、変化の前段階を把握しています。また最も重要な点として、創業者は変化をコントロールできます</li>
<li>従業員はそうではありません</li>
</ul>
</li>
</ul>
<h2>自分の部下よりもマネージャーに多くのことを要求すべし</h2>
<ul>
<li>
<p>基本的に、失敗はチームの責任ではなく、マネージャーの責任です</p>
<ul>
<li>物事に関する率直な意見をマネージャーと個人的に共有しましょう</li>
</ul>
</li>
<li>基本的に、マネージャーが意思決定できるように信頼すべきです</li>
<li>
<p>マネージャーは結果に対する説明責任を負います</p>
<ul>
<li>すべての失敗に責任があります</li>
<li>しかし、成功はマネージャーの手柄ではありません</li>
<li>成功はチームの手柄です</li>
</ul>
</li>
<li>
<p>マネージャーは、可能なときはいつでも、成功を一人占めするのではなくチームにスポットライトを当てるべきです</p>
<ul>
<li>ポイントは簡単です。チームに与える権限を増やすとともに、チームが輝くための方法を増やしましょう</li>
</ul>
</li>
</ul>
<p>気分が明るくなるような結論ですね😬</p>
<p>とにかく……この記事が誰かの役に立つことを願っています🙏</p>
<p>当然、筆者が見逃していることも数多くあるでしょう。ですから、<a href="https://twitter.com/andreasklinger">twitter</a>でお気軽にご質問ください。また、この記事を改善するためのアイデアがあれば、<a href="https://github.com/andreasklinger/klinger-io">プルリクエストをお送りください</a>。</p>
<p>この記事が気に入ったら<a href="https://twitter.com/intent/tweet?text=Managing%20People%20an%20article%20by%20%40andreasklinger%3A%20https%3A%2F%2Fklinger.io%2Fposts%2Fmanaging-people-%25F0%259F%25A4%25AF">シェアしていただけると幸いです</a>。</p>
<p>追伸：<a href="https://www.notion.so/odteam/Product-Engineer-Playbook-859b2c4c95f849788554f1749d038c6f">筆者のチーム</a>は人材を募集中です</p>]]></content:encoded></item><item><title><![CDATA[変化するフロントエンドエンジニアの役割。「モダンフロントエンド」開発組織のつくりかた]]></title><description><![CDATA[POSTD読者の皆さんはじめまして、本メディアでキュレーターを担当させていただいている古川陽介と申します。
株式会社ニジボックスでデベロップメント室室長を務める他、株式会社リクルートでプロダクト開発…]]></description><link>https://postd.cc/postdev-furukawa/</link><guid isPermaLink="false">https://postd.cc/postdev-furukawa/</guid><category><![CDATA[キャリア・働き方]]></category><category><![CDATA[開発組織]]></category><pubDate>Mon, 12 Sep 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<div style="padding: 1rem;">
  <img style="width: 50px; height: 50px;" src="https://lp.nijibox.jp/wp-content/themes/nijibox-lp/assets/lp-assets/postdev/images/speaker_yosuke_furukawa.jpg" alt="古川陽介" >
  <span>by <a href="https://twitter.com/yosuke_furukawa">古川陽介</a></span>
</div>
<p>POSTD読者の皆さんはじめまして、本メディアでキュレーターを担当させていただいている古川陽介と申します。
株式会社ニジボックスでデベロップメント室室長を務める他、株式会社リクルートでプロダクト開発部署のマネージャーも兼務しています。
また、Japan Node.js Associationの代表理事として、Node.js の普及を目指す活動なども行っています。</p>
<p>私が普段の仕事や活動の中で強く感じているのは、フロントエンドエンジニアの役割が大きな変換点を迎えているということです。
端的に表現するとスマートフォンの登場をきっかけとしたデバイスの多様化によって、フロントエンドエンジニアの領域が拡大したと言うことになると思います。</p>
<p>パフォーマンスや開発の生産性を著しく上昇させる、ReactやVueを駆使したモダンフロントエンド開発と、それを実現するための組織構築は、今後のサービスやプロダクト開発において、ビジネスを加速させる上で欠かせないものだと考えています。
この記事では、主に開発組織の構築に焦点をあてて、私たちエンジニアがこれから進むべき道について考察していきたいと思います。</p>
<h2>私がエンジニアの組織作りに興味を持ったきっかけ</h2>
<p>キャリアの中で初めてマネジメントをすることになった2017年、私は大いに悩んでいました。</p>
<p>リクルートでエンジニア組織のマネージャーとなり、最初は本当に右も左も分からない状態でした。
「マネージャーとして何をすればよいのか？」「どうメンバーを育成していけばよいのか？」そんな悩みが尽きない日々を送っていたのです。</p>
<p>そんなある日、一冊の本に出会います。
株式会社レクター取締役の広木大地さんが著した『エンジニアリング組織論への招待』。
この本には、まさに当時の私が求めていた「どうエンジニアを成長させるか」「どうエンジニア組織を作るか」「不確実性に対応するための組織設計」といった、私の問いに対する答えが明解に記されていたのです。
この本を何度も繰り返し読み込むにつれ、組織作りの奥深さ、面白さに強く惹かれるようになりました。</p>
<p>同時期さらにもう1つ、組織作りに興味を持つきっかけとなる出会いがありました。
株式会社一休CTOの伊藤直也さんです。
彼は、CTOという立場ながら今でも現役バリバリでコードを書いていて、かつ組織作りも並行し、ビジネスの拡大を目的として事業を進めていくスーパーマンです。
理想的なマネジメントのスタイルとして彼に憧れを抱くとともに、強い開発組織を志す想いが自分の中で高まっていくのを感じていました。</p>
<h2>メンバーが成長を遂げ、大規模カンファレンスに登壇した日</h2>
<p>手探りでマネジメントや組織作りに取り組む中で、また広木大地さんの書籍や伊藤直也さんのスタイルに影響を受け、そのエッセンスを取り入れながら試行錯誤してきたことで、徐々に結果が出てくるようになりました。</p>
<p>結果が出てくると、ますます「組織」というものに対する興味が強くなります。
それにさらに拍車をかけたのが、「メンバーの成長」を目の当たりにした瞬間です。</p>
<p>入社当時は、まだエンジニアとしておぼつかなかったあるメンバーが、数年後、グループ全体の大規模カンファレンスに登壇したことがあります。
数万人を超えるグループ従業員の中から登壇者として選ばれるのはたったの数人。
彼の成長をずっとそばで見てきた私にとって、これほど嬉しいことはありませんでした。
彼がカンファレンスに登壇した日、仲間の成長という、私がそれまでに体験したことのない喜びを感じました。</p>
<p>また、チーム内の誰かのポジティブな行動や実績に対して、「次は私も挑戦してみよう」といった化学反応が生まれることもあります。
その化学反応によって、チームや組織はさらに強くなっていくと思います。
組織が強くなれば、新しく人が集まることもありますし、会社の成長にもつながります。
このようなダイナミズムは、組織作りの醍醐味と言えるでしょう。</p>
<h2>【10/1（土）開催】モダンフロントエンド×組織論がテーマのオンラインイベント「Post Dev」</h2>
<p>繰り返しになりますが、私の実体験からも「開発組織」は今後の重要なキーワードになると考えています。
モダンフロントエンド技術と開発組織の成長。
この2つの要素がうまくクロスオーバーすることで、エンジニアはさらに進化し、ビジネスが加速すると確信しています。</p>
<p>そんな、フロントエンドの未来に向けたヒントをより多くの方と共有したいという想いで、この度2022/10/1（土）に「Post Dev」というオンラインイベントを開催する運びとなりました。</p>
<p>私が大きな影響を受けた伊藤直也さん、広木大地さんをはじめ、国内外のエキスパートを登壇者としてお招きしています。
例えば、「State Of JavaScript」（JavaScriptの現状調査）で知られるSacha GreifさんからはJavaScriptの最新トレンドと今後の展望を、MicrosoftのTomomi ImuraさんからはVS Code開発を、ICSの池田泰延さんからはCSSの最新トレンドを語っていただく予定です。
※イベント詳細は<a href="https://lp.nijibox.jp/cp/postdev/">こちらのページ</a>をご覧ください。</p>
<p>今回イベントを企画するにあたって、技術的な話と組織という2つのテーマをあえて掛け合わせました。
コンテンツを全て見ていただくと、「今」と「これからすべきこと」が全体像として把握いただけるように設計しています。
「フロントエンドの新たなる可能性」を今後皆さんと一緒に追求していけるような機会となると良いなと思っています。</p>
<h2>これからのエンジニアがやるべき“2種類のアウトプット”</h2>
<p>最後に、一エンジニアという視点に立って、その役割が変化する時代においてやるべき“2種類のアウトプット”というお話で締めくくりたいと思います。</p>
<p>1つ目は、プロダクト開発そのものを意味するアウトプットです。
皆さんやっていることだとは思いますが、デバイスやサービスの多様化・複雑化に対応するため、継続的に技術を日々磨いていくことはとても大切だと考えています。
また、技術の追求はエンジニアごとのユニークな価値がもっとも発揮される行為だと思います。
ぜひ、ご自身を信頼し知的好奇心の誘うままに「道」を極めていただきたいです。</p>
<p>そしてもう１つは、ご自分が追求してきた体験に基づいたストーリーを言語化し、外へ発信する意味でのアウトプットです。
自らの試みをアウトプットすることによって、コミュニティー全体の研究水準が上がり、最終的に業界全体の技術進歩にもつながっていくと思います。
また、発表者の観点としても、技術への理解がより深められるメリットも見逃せません。
私自身、多くのイベント・カンファレンスへの登壇や記事の執筆を通して、技術面での成長も実感しています。</p>
<p>アウトプットをするためには、インプットが必要です。
ぜひ、今回の「POST Dev」でも良質なインプットをしてください。
きっと、私が一冊の本によって受けた雷のような衝撃を、尊敬すべきエキスパートたちとの出会いから生まれた高揚感を、皆さんも体験できるはずです。</p>]]></content:encoded></item><item><title><![CDATA[モダンWebにおけるキャッシングのための新HTTP標準]]></title><description><![CDATA[一般ユーザー向けの大規模なWebサイトや、モダンWeb上で動作するWebアプリケーションを運営する場合、CDNなどのキャッシングサービスによって静的コンテンツをキャッシュすることが極めて重要です。 …]]></description><link>https://postd.cc/status-targeted-caching-headers/</link><guid isPermaLink="false">https://postd.cc/status-targeted-caching-headers/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[HTTP]]></category><category><![CDATA[キャッシング]]></category><pubDate>Wed, 31 Aug 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>一般ユーザー向けの大規模なWebサイトや、モダンWeb上で動作するWebアプリケーションを運営する場合、CDNなどのキャッシングサービスによって静的コンテンツをキャッシュすることが極めて重要です。</p>
<p>しかしこうしたサービスは、非常に複雑で分かりにくいものです。</p>
<p>幸い、IETF（Internet Engineering Task Force）のHTTPワーキンググループがこの状況を改善すべく、HTTPの新標準策定に取り組んでいます。
最近、同ワーキンググループでは、キャッシングのデバッグとキャッシュ設定の管理を容易にすることを目的とした、HTTPヘッダに関する2つの新標準案の発表に向けて活発な動きがありました。</p>
<p>このことが何を意味し、どのように機能するのか、そしてWeb制作に携わる開発者全てがなぜ注目すべきなのかについて見ていきます。</p>
<h2>新標準</h2>
<p>この記事で取り上げる標準案は以下の2つです。</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache-header/">Cache-Statusヘッダ</a></li>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-targeted-cache-control/">Targeted Cache-Controlヘッダ</a></li>
</ul>
<p>これらはHTTP標準を改訂し、CDNを活用した現在のWebに対応したものにすることを目的としており、Fastly、Akamai、Cloudflareといった人気の高いCDNが用いている既存の手法を取り入れた仕様を提供します。
ここに挙げた企業はいずれも自ら標準の策定に携わっています。</p>
<p>どちらの標準案も比較的新しい仕様です。Cache-Statusは2021年に複数回にわたるレビューが行われており、現在は（8月以降）最終レビューと正式なRFCとしての発表を待っているところです。
一方、Targeted Cache-Controlヘッダは現在標準案として採用されていますが、最後のフィードバックを募っているところです。
どちらもIETFの支持を得ており、既に多くの議論が行われています。
今後大きな変更が行われる可能性は低いものの、どちらもまだ新しいため、現時点ではまだ幅広いサポートは期待できないでしょう。</p>
<h2>キャッシングが重要な理由</h2>
<p>ユーザ向けの注目度の高いWebアプリケーションを運営する場合、キャッシュとCDNはエンドユーザに優れたパフォーマンスを妥当なコストで提供するうえで不可欠です。
キャッシュとCDNはWebサーバの手前でリバースプロキシの役割を果たし、以下を保証します。</p>
<ul>
<li>コンテンツのキャッシング。全ての訪問者から直接バックエンドサーバに対して静的コンテンツのリクエストが行われないようにし、リクエストの頻度を減らすため。</li>
<li>トラフィックの急増に耐えうるコンテンツデリバリ。静的キャッシュはアプリケーションサーバよりも規模の拡大がはるかに容易であるため。</li>
<li>コンテンツリクエストのバッチ処理。1000件のキャッシュミスが同時に発生しても、バックエンドサーバへのリクエストが1件で済むようにするため。</li>
<li>コンテンツの物理的分散。ユーザの所在地にかかわらず、レスポンスが迅速に届くようにするため。</li>
</ul>
<p>注目度の高いWebサイトを運営するなら、モダンWebにコンテンツをホスティングするうえでこれら全てが必須となります。
ネットが広く普及している今、トラフィックの急増とレイテンシの問題はネット利用者の増加に伴い解決が困難になる一方です。</p>
<p>Troy Huntが、自身が運営する人気サイト「Pwned Passwords」について執筆した、<a href="https://www.troyhunt.com/serverless-to-the-max-doing-big-things-for-small-dollars-with-cloudflare-workers-and-azure-functions/">キャッシングの仕組みを詳しく説明した記事</a>が参考になります。
記事では以下の具体例が紹介されています。</p>
<ul>
<li>毎週彼のドメインから477.6GBのサブリソースが配信されている</li>
<li>そのうち476.7GBはキャッシュから配信されている（キャッシュヒット率99.8%）</li>
<li>同サイトのAPIには毎週3240万件のクエリが送信されている</li>
<li>そのうち3230万件はキャッシュから配信されている（キャッシュ率99.6%）</li>
<li>残りのAPIエンドポイントは、Azureのサーバレス関数が対処する</li>
</ul>
<p>このサイトのホスティング（1日数百万件ものパスワードチェック）に要する費用は、1日3セント程度です。
これだけのトラフィックを全て自前のサーバで処理した場合、膨大なコストがかかります。
合理的なキャッシングの仕組みを構築すれば、迅速かつ効果的に、安く処理できます。これは大きな問題です。</p>
<h2>解決すべき問題は何か</h2>
<p>これは結構なことなのですが、キャッシング設定の構築とデバッグは容易ではありません。</p>
<p>主な問題は、一定の規模になるとほとんどの場合、任意のリクエストパスに多数のキャッシングレイヤーが関与することです。
ほとんどの構成では、独自のキャッシング機能が組み込まれた何らかのロードバランサ、APIゲートウェイ、リバースプロキシがバックエンドサーバの手前に配置され、さらにその前には広く分散された低レイテンシ拠点からエンドユーザにこのコンテンツを提供するグローバルCDNがあります。
さらに、バックエンドサーバ自体も内部の結果をキャッシュする場合があり、企業やプロバイダが独自のキャッシングプロキシを運用していることもあり、多くのクライアント（特にWebブラウザ）が独自のキャッシング機能を備えています（こうしたクライアントにも、Service Workerなどのキャッシングレイヤーがさらに備わっている場合もあり、一層複雑にしています）。</p>
<p>各レイヤーには異なるキャッシング構成が求められます。
例えば、ブラウザはユーザ固有のデータをキャッシュできる場合がありますが、CDNがこうしたデータをキャッシュできてはいけません。
また、新しいコンテンツができるだけ早くエンドユーザに見えるようにするため全てのレイヤーのキャッシュに適用されなくてはいけません。</p>
<p>これらのレイヤーと、各レイヤー独自の構成がどう作用し合うのかを予測するのも複雑であり、さまざまな形で好ましくない結果につながる可能性があります。</p>
<ul>
<li>コンテンツが一切キャッシュされず、トラフィックがバックエンドサーバに過剰な負荷をかける。</li>
<li>コンテンツはキャッシュされるが、分散CDNではない下位のレイヤーに限定される。</li>
<li>古いレスポンスが想定よりも長くキャッシュに保持され、コンテンツのアップデートを困難にする。</li>
<li>キャッシュから間違ったレスポンスが配信され、ドイツのユーザにフランス語のコンテンツが提供されたり、ひどいケースでは未認証のユーザにログインコンテンツが提供されたりする。</li>
<li>リクエストがCDNを全く通らず、バックエンドまたはリバースプロキシから直接配信される。</li>
<li>WebサイトまたはAPIのキャッシングが一貫して行われず、古いデータと新しいデータが混在した全く役に立たないデータが読み出される。</li>
</ul>
<p>これはかなりひどい状態です。</p>
<p>多くのキャッシュ設定が、リクエストやレスポンスのメタデータ自体（Cache-Controlヘッダなど）の中に存在することが、事態を一層悪くしています。
これは正確な設定を実現するうえでは非常に効果的ですが、設定自体がこれらのレイヤーを通過して、途中でキャッシュされる可能性があることも意味します。</p>
<p>知らず知らずのうちに誤って「これを永久にキャッシュする」というレスポンスをキャッシュした場合、極めて面倒なことになってしまいます。
全てのレイヤーのキャッシュを強制的に無効化して問題を解決するのは、想像するより難しいことです。</p>
<p><img src="https://imgs.xkcd.com/comics/refresh_types.png">
<em>ピッタリのXKCDは常に存在する（訳注: XKCD とはアメリカの風刺系web漫画サイト）</em></p>
<h2>Cache-Statusはどう役立つか？</h2>
<p>明確な問題の1つは、キャッシングシステム内のトレーサビリティです。
レスポンスはどこから来たのか？なぜそのレスポンスが送信されたのか？</p>
<p>そのレスポンスはキャッシュから返されたのか、それともサーバから送信されたのか？
キャッシュから返された場合、どのキャッシュか？
それはあとどれくらい有効か？
キャッシュから返されたのではない場合、それはなぜか？
その新しいレスポンスは後で使用するために保存されたものか？</p>
<p><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache-header/">Cache-Statusレスポンスヘッダ</a>は、これら全ての情報がレスポンス自体に含まれるようにし、リクエストを見た全てのCDNおよびその他のキャッシュを1つの一貫した形式で提供するための構造を提供します。
ヘッダは以下のようなものになります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: OriginCache; hit; ttl=1100, &quot;CDN Company Here&quot;; fwd=uri-miss;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<h3>Cache-Statusヘッダの形式</h3>
<p>ヘッダの形式は以下になります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: CacheName; param; param=value; param..., CacheName2; param; param...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>キャッシュのリストであり、それぞれゼロ以上のステータスパラメータを持ちます。
キャッシュはレスポンス順に並びます。
最初のキャッシュがオリジンサーバに最も近く、最後のキャッシュがクライアントに最も近いものです。</p>
<p>レスポンスがこのヘッダとともにキャッシュされると、その後のレスポンスでもそれが保持されます。
しかし、今回のレスポンスがどこに保存され、前回のレスポンスがどこから来たのかを右側のパラメータ値から判断することも可能です。</p>
<p>パラメータ付きのキャッシュはカンマで区切られ、パラメータ自体はセミコロンで区切られます（現在は標準化されている<a href="https://datatracker.ietf.org/doc/rfc8941/">構造化ヘッダRFC</a>のsf-listとsf-item構文）。
キャッシュ名は、スペースなど本来無効な文字が含まれる場合は引用符で囲まれることがあります。</p>
<h3>Cache-Statusヘッダパラメータ</h3>
<p>各キャッシュの挙動を説明するため、いくつかのパラメータと値を定義します。</p>
<ul>
<li><code class="language-text">hit</code> - リクエストが上流に送られることなく、レスポンスはこのキャッシュから返されます</li>
<li>
<p><code class="language-text">fwd=&lt;reason&gt;</code> - これが設定されている場合、リクエストが次の上流レイヤーに送信されています。これには次のような理由が付いてきます。</p>
<ul>
<li><code class="language-text">fwd=bypass</code> - キャッシュはこのリクエストを処理しないよう構成されている</li>
<li><code class="language-text">fwd=method</code> - 使用したHTTPメソッドにより、リクエストを転送する必要がある</li>
<li><code class="language-text">fwd=uri-miss</code> - リクエストURIと一致するキャッシュデータはなかった</li>
<li><code class="language-text">fwd=vary-miss</code> - URIと一致するキャッシュデータはあったが、Varyヘッダに含まれるヘッダが一致しなかった</li>
<li><code class="language-text">fwd=miss</code> - 一致するキャッシュデータはなかった（理由が不明な場合など、他の理由による）</li>
<li><code class="language-text">fwd=stale</code> - 一致するキャッシュデータはあったが、古い（stale）データである</li>
<li><code class="language-text">fwd=partial</code> - 一致するキャッシュデータはあったが、レスポンスの一部に対してのみ（前回のリクエストがRangeヘッダを使用したなど）</li>
<li><code class="language-text">fwd=request</code> - リクエストがキャッシュされていないデータを要求した（Cache-Controlヘッダで）</li>
</ul>
</li>
<li><code class="language-text">fwd-status=&lt;status&gt;</code> - fwdが設定されている場合、次のホップから受け取ったレスポンスステータスです</li>
<li><code class="language-text">stored</code> - fwdが設定されている場合、このキャッシュが受信したレスポンスを後で使用するために保管したかどうかを示します</li>
<li><code class="language-text">collapsed</code> - fwdが設定されている場合、リクエストが他のリクエストと一緒に畳まれているかどうかを示します（同等のリクエストが既に処理中のため、複製されていない）</li>
<li><code class="language-text">ttl=&lt;ttl&gt;</code> - このキャッシュがこのレスポンスをあとどれくらい（秒数）「fresh」（鮮度が高い）と見なすか</li>
<li><code class="language-text">key</code> - このキャッシュのレスポンスのキー（実装固有）</li>
<li><code class="language-text">detail</code> - 追加の実装固有情報のための自由形式フィールド</li>
</ul>
<p>これらを使用することで、以下のようなレスポンスヘッダを解釈できます。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: ExampleCache; hit; ttl=30; key=/abc</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>これは、ExampleCacheがリクエストを受信し、キャッシュの中（key / abcの下）にレスポンスがあったのでそれを返し、そこから30秒間はそのキャッシュを返し続けることを意味します。</p>
<p>以下のようなもっと複雑な例も検討してみましょう。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status:
    Nginx; hit,
    Cloudflare; fwd=stale; fwd-status=304; collapsed; ttl=300,
    BrowserCache; fwd=vary-miss; fwd-status=200; stored</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p><em>（可読性を上げるために改行しています）</em></p>
<p>これは、ブラウザがリクエストを送信したが、Varyヘッダに含まれるヘッダが一致しなかったため、同じURIで保持するキャッシュレスポンスを使用しなかったことを意味します。</p>
<p>リクエストは次にCloudflareが受信し、Cloudflareは一致するレスポンスをキャッシュしていましたが（<code class="language-text">Nginx; hit</code>というレスポンス。Nginxのキャッシュから読み出されたレスポンスであることを意味する）、そのレスポンスは古くなっています。</p>
<p>これに対処するため、CloudflareはNginxにレスポンスを再検証するようリクエストを送信し、Nginxは304（変更なし）レスポンスをCloudflareに返して既存のキャッシュレスポンスがまだ有効であることを伝えています。
送信されたリクエストは折り畳まれており、同じコンテンツについて同時に複数のリクエストがCloudflareに届いたが、上流に送信されたリクエストは1つだけであることを意味します。
Cloudflareは次の5分間、再検証されたデータを提供し続けます。</p>
<p>有益な情報がたくさん含まれています。
注意深く読み解くことで、このヘッダだけでもレスポンスのコンテンツがどこから来たのか、リクエストパス全体に沿って現在どのようにキャッシュされているのかが正確に分かります。</p>
<p>（キャッシング構成のデバッグに不慣れな人には、上記は手ごわそうに聞こえるかもしれませんが、これらの情報が1カ所にまとめられていることで、同じ情報を一から導き出すより何倍も負担が軽減されます。）</p>
<h3>Cache-Statusの実践</h3>
<p>これは全く新しい概念ではありませんが、全てのキャッシュを1カ所にまとめることで、一貫したデータの単一の供給源を提供することに本当のメリットがあります。</p>
<p>現在、各キャッシュプロバイダがさまざまな（それぞれ微妙に一致しない）ヘッダを使用しており、Nginxの<a href="https://support.cpanel.net/hc/en-us/articles/4402904983703-How-to-add-the-X-Cache-Status-header-to-NGINX-to-assist-with-optimizing-and-troubleshooting-cache-settings">X-Cache-Status</a>、Cloudflareの<a href="https://developers.cloudflare.com/cache/about/default-cache-behavior#cloudflare-cache-responses">CF-Cache-Status</a>、Fastlyの<a href="https://developer.fastly.com/reference/http/http-headers/X-Served-By/">X-Served-By</a>や<a href="https://developer.fastly.com/reference/http/http-headers/X-Cache/">X-Cache</a>などがあります。それぞれ、ここに含めることができる情報の一部を提供しており、今後は徐々にCache-Statusに置き換わっていくことが望まれます。
現在、ほとんどの主要コンポーネントとプロバイダはデフォルトでCache-Statusを搭載していませんが、Fastly、Akamai、Facebookなど多数の企業が標準化プロセスに関わっているため、多くのWebサービスやツールに採用される日はそう遠くないと思います。
実際、<a href="https://github.com/squid-cache/squid/commit/5fdc549054b11eb8bbc7e9640d6d071fa1ef742b">Squid</a>の組み込みサポートや<a href="https://github.com/caddyserver/cache-handler#readme">Caddyのキャッシングハンドラー</a>、<a href="https://gist.github.com/mnot/74ba8ed638a3d85659aa2868b9240d50">Fastlyのドロップインレシピ</a>など、既に進展が見られています。
2021年8月にRFCの発表があったばかりなのでまだかなり新しいですが、今後も引き続きサポートが広がっていくことを期待しています。
CDNまたはキャッシングコンポーネントの開発者は、ユーザのデバッグを支援するためにCache-Statusを採用することをお勧めします（これらのサービスを使っているのであれば、Cache-Statusの導入を求めることをお勧めします）。</p>
<h2>Targeted Cache-Controlのメリット</h2>
<p>既存の<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">Cache-Controlヘッダ</a>は、キャッシングがこれほど複雑化する前（1999年）に設計されたものです。
当時はIE 4.5がリリースされたばかりで、RIMが最初のBlackberryの発売準備を進めており、インタラクティブWebページの第一波を表す「Web 2.0」という言葉が生まれた時代でした。
テラバイト単位のデータをキャッシュするためにマルチレイヤーCDNアーキテクチャを構成することは大きなテーマではなかったのです。</p>
<p>時代は変わりました。</p>
<p>1999年に定義されたCache-Controlヘッダはリクエスト／レスポンスヘッダであり、リクエスト（どのようなキャッシュレスポンスを受け入れるか）とレスポンス（このレスポンスを今後どのようにキャッシュするか）に関するさまざまなキャッシングパラメータを定義できます。</p>
<p>ここではリクエストの構成については特に注目していませんが、レスポンスキャッシュの構成は非常に重要です。
レスポンスのCache-Controlは現在、以下のようにレスポンスの処理方法をキャッシュに伝えるディレクティブのリストによって定義されます。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Control: max-age=600, stale-while-revalidate=300, private</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>これは、「このコンテンツを10分間キャッシュし、次に、これを再検証する間、古いコンテンツを最大5分間配信する。ただし、これはプライベート（シングルユーザのブラウザなど）キャッシュでのみ行う」という意味です。</p>
<p>ここで設定されたルールは、同じリクエストを処理する全てのキャッシュが同様に従わなくてはならず、ツールとしてはやや粒度が粗いと言えます。
制御ルールの対象をエンドユーザのキャッシュに制限することは可能であり（<code class="language-text">private</code>を使用）、過去には、共有されたキャッシュ（CDNなど）にしか適用されないいくつかの重複したディレクティブ（<code class="language-text">s-maxage</code>や<code class="language-text">proxy-revalidate</code>など）を追加していましたが、それ以上の精度や柔軟性を望むことはできません。
これはつまり、以下のことは行えないことを意味します。</p>
<ul>
<li>ブラウザとCDNで、stale-while-revalidateに異なる時間を設定する</li>
<li>レスポンスに対し、内部のキャッシングロードバランサにおける全てのリクエストで再検証が必要だが、CDNでは不要とのフラグを付ける</li>
<li>CDNでのキャッシングは有効にしつつ、外部の共有キャッシュ（エンタープライズプロキシなど）にはコンテンツをキャッシュしないよう伝える</li>
</ul>
<p>これでは、多くの高度なユースケースに対応できません。
ほとんどのキャッシングコンポーネントでは、これに対処するためにコンポーネント内のルールを定義するための構成オプションが用意されていますが、これはこれで柔軟性に欠け、レスポンスに応じて異なるルールを構成するのが難しくなります。</p>
<p><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-targeted-cache-control/">Targeted Cache-Control</a>は、全てのキャッシュではなく特定のキャッシュのみを対象としたCache-Controlのディレクティブを設定するための新しいヘッダを定義することで、この問題の解決を図るものです。</p>
<h3>Targeted Cache-Controlの仕組み</h3>
<p>Targeted Cache-Controlを使用するには、サーバが以下のような形式のレスポンスヘッダを設定する必要があります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">&lt;Target&gt;-Cache-Control: param, param=value, param...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ヘッダのプレフィックスには、これを適用する特定の対象が入ります。
構文は、<a href="https://datatracker.ietf.org/doc/rfc8941/">Structured Fields</a>の標準形式を使用するため、厳密にはCache-Controlが使用する構文とは若干異なりますが、実質的にはほとんど同じです。</p>
<p>ここで使用する対象には、固有のサービスやコンポーネントの名前、あるいはキャッシュクラスなどが入ります。
仕様で定義する対象は1つだけ（<code class="language-text">CDN-Cache-Control</code>。全ての分散CDNキャッシュに適用し、他のキャッシュには適用しない）ですが、後から他のクラスを定義することもできます。
将来的には、<code class="language-text">Client-Cache-Control</code>がHTTPクライアントにおけるキャッシングのみを対象にルールを設定し、<code class="language-text">ISP-</code>がインターネットサービスプロバイダ、<code class="language-text">Organization-</code>が企業組織のキャッシュを対象とする、といったことも可能です。</p>
<p>これらのヘッダを使用するには、それをサポートする各キャッシュがマッチする対象のリストを優先順に定義（固定またはユーザ定義）します。他により具体的なマッチがなければ、最初にマッチした<code class="language-text">&lt;target&gt;-Cache-Control</code>ヘッダまたは通常の<code class="language-text">Cache-Control</code>ヘッダ（あれば）を使用します。</p>
<p>全体として、既存のキャッシングの仕組みに既になじみがある場合、かなりシンプルで使いやすいと感じるでしょう。Targetedヘッダは特定の対象とマッチし、キャッシングのルールは対象に応じて自由に設定でき、ベストマッチが優先されます。以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Client-Cache-Control: must-revalidate
CDN-Cache-Control: max-age=600, stale-after-revalidate=300
Squid-Cache-Control: max-age=60
Cache-Control: no-store</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>これは以下のような意味になります。</p>
<ul>
<li>エンドクライアント（少なくとも、筆者が考案した<code class="language-text">Client-Cache-Control</code>ヘッダを認識するもの）は、このコンテンツをキャッシュできるが、使用する前に毎回再検証しなくてはならない</li>
<li>全てのCDNがコンテンツを10分間キャッシュでき、次に、これを再検証する間、古いレスポンスをさらに5分間使用できる</li>
<li>Squid（キャッシング機能を備えたリバースプロキシ）は、コンテンツを60秒間だけキャッシュできる（<code class="language-text">stale-while-revalidate</code>指示はないため、古い間は暗黙的に使用できない）</li>
<li>Targeted Cache-Control指示を理解できないものは、このコンテンツをキャッシュしてはならない</li>
</ul>
<h3>Targeted Cache-Controlの実践</h3>
<p>Cache-Statusよりも新しく、標準化プロセスの早い段階にあるため、まだ変更が加わる可能性があります。フィードバックがある場合、<a href="https://github.com/httpwg/http-extensions/blob/main/draft-ietf-httpbis-targeted-cache-control.md">ここから</a>GitHubにアクセスして仕様書を入手し、同じレポジトリ内で問題を報告（または<a href="https://datatracker.ietf.org/wg/httpbis/about/">ワーキンググループのメーリングリスト</a>にメッセージを送信）し、意見を述べることができます。
とは言え、仕様書自体はFastly、Akamai、Cloudflareの代表者が執筆しているため、業界のサポートは既に十分得られており、作業はもうかなり進んでいるため、大きな変更が加えられる可能性は低いと思われます。</p>
<p>現状、<a href="https://blog.cloudflare.com/cdn-cache-control/">Cloudflare</a>と<a href="https://www.akamai.com/blog/news/targeted-cache-control">Akamai</a>が既にサポートしているため、これらのキャッシュを使用する場合、今から<code class="language-text">CDN-Cache-Control</code>、<code class="language-text">Akamai-Cache-Control</code>、<code class="language-text">Cloudflare-CDN-Cache-Control</code>を使用した正確な構成を開始できます。今後他の多くのツールやサービスについても同様のサポートが行われる可能性が高いため、引き続き注目してください。</p>
<h2>今後の展望</h2>
<p>2021年、キャッシングは依然として複雑ですが、Cache-StatusとTargeted Cache-Controlが急速に成熟しており、これらによって構成とデバッグはかなり容易になると見られます。キャッシングに携わっている方は注目する価値があります。</p>
<p>IETFが最近取り組んでいるHTTP標準は2つだけですが、Webの発展に寄与したい方や今後登場する予定の標準について知りたい方は、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/">Rate-Limitingヘッダ</a>、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-proxy-status/">Proxy-Status</a>、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-digest-headers/">HTTPメッセージダイジェスト</a>、<a href="https://datatracker.ietf.org/doc/rfc8942/">HTTPクライアントヒント</a>など他にも多数あるのでチェックしてみてください。
HTTPは発展途上の標準であり、今後も続々登場します。
これらのいずれかに興味のある方は、<a href="https://datatracker.ietf.org/wg/httpbis/about/">ワーキンググループのメーリングリスト</a>に参加し、新たな開発情報をチェックしたり意見を共有したりすることをお勧めします。</p>
<p><em>HTTPリクエスト、キャッシング、エラーのテストやデバッグをご希望の方は、<a href="https://httptoolkit.tech/">HTTP Toolkit</a>でHTTPの傍受、調査、模擬をお試しください。</em></p>
<p><em>10か月前(※訳注：2022年8月の翻訳記事公開時点)に<a href="https://twitter.com/pimterry">Tim Perry</a>が公開</em></p>]]></content:encoded></item><item><title><![CDATA[React Server Componentsの仕組み：詳細ガイド]]></title><description><![CDATA[React Server Components（RSC）は、ページの読み込みパフォーマンスやバンドルサイズのほか、Reactアプリケーションの書き方に近い将来大きな影響を与えることになる、素晴らしい…]]></description><link>https://postd.cc/how-react-server-components-work/</link><guid isPermaLink="false">https://postd.cc/how-react-server-components-work/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[React]]></category><pubDate>Wed, 27 Jul 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>React Server Components（RSC）は、ページの読み込みパフォーマンスやバンドルサイズのほか、Reactアプリケーションの書き方に近い将来大きな影響を与えることになる、素晴らしい新機能です。
Plasmicでは、<a href="https://plasmic.app/">Reactのビジュアルビルダー</a>を開発しており、Reactのパフォーマンスには大きな関心を持もっています。
当社のクライアントの多くは、Plasmicを使用して高いパフォーマンスが求められるマーケティングサイトやECサイトを構築しています。
したがって、RSCはまだReact 18の初期実験機能ですが、Plasmicではその仕組みを詳しく調べています。
このブログ記事では、これまでに分かったことを紹介したいと思います。
Plasmicのメンバーによる<a href="https://www.reddit.com/r/reactjs/comments/s8r0ve/how_react_server_components_work_an_indepth_guide/">ツイートまとめ</a>もご覧ください。</p>
<ul class="toc-for-article">
    <li><a href="#01">React Server Componentsとは何か</a></li>
    <li><a href="#02">サーバサイドレンダリングとの違いは？</a></li>
    <li><a href="#03">RSCを使うメリット</a></li>
    <li><a href="#04">RSCの全体像</a></li>
    <li><a href="#05">サーバコンポーネントとクライアントコンポーネントの分断</a></li>
    <li>
        <a href="#06">RSCレンダリングの流れ</a>
        <ul>
            <li><a href="#07">1. サーバがレンダリングリクエストを受け取る</a></li>
            <li><a href="#08">2. サーバがルートコンポーネント要素をJSON形式にシリアライズ</a></li>
            <li><a href="#09">3. ブラウザがReactツリーを再構築</a></li>
            <li><a href="#10">Suspenseとの互換性は問題ないか？</a></li>
        </ul>
    </li>
    <li>
        <a href="#11">RSCワイヤーフォーマット</a>
        <ul>
            <li><a href="#12">RSCフォーマットを使う</a></li>
            <li><a href="#13">単にプレーンHTMLを出力すればよいのでは？</a></li>
            <li><a href="#14">クライアントコンポーネントからデータを取得するだけよりもメリットがある？</a></li>
            <li><a href="#15">サーバサイドレンダリングはどうなる？</a></li>
        </ul>
    </li>
    <li><a href="#16">サーバコンポーネントがレンダリングしているコンテンツのアップデート</a></li>
    <li><a href="#17">RSCにメタフレームワークを使うべき理由</a></li>
    <li><a href="#18">RSCは実用化の準備ができているのか？</a></li>
</ul>
<h2>React Server Componentsとは何か<a name="01"></a></h2>
<p>React Server Components（RSC）は、サーバとクライアント（ブラウザ）が連携してReactアプリケーションのレンダリングを行うことを可能にします。
Webページを表示する際にレンダリングされる一般的なReact要素ツリーは、通常異なるReactコンポーネントがさらに多くのReactコンポーネントをレンダリングする構成になっています。
RSCは、このツリーを構成する一部のコンポーネントが<em>サーバによって</em>レンダリングされ、他のコンポーネントが<em>ブラウザによって</em>レンダリングされることを可能にします。🤯</p>
<p>これはReactチームによる概略図です。
最終的なゴールは、オレンジのコンポーネントはサーバ側でレンダリングされ、青のコンポーネントはクライアント側でレンダリングされるようなReactツリーです。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components.png"></p>
<h2>サーバサイドレンダリングとの違いは？<a name="02"></a></h2>
<p><strong>RSCはサーバサイドレンダリング（SSR）ではありません</strong>。
どちらも名前に「サーバ」が含まれ、どちらもサーバ上で動いているので少し混乱しますね。
しかし、両者はそれぞれ独立した直交する機能であると理解した方がずっと分かりやすいでしょう。
RSCはSSRを必要とせず、その逆もまたしかりです。
SSRは、Reactツリーを生HTMLにレンダリングするための環境をシミュレーションします。
<em>サーバコンポーネントとクライアントコンポーネントを区別せず、どちらも同じようにレンダリングします。</em></p>
<p>SSRとRSCを組み合わせ、サーバコンポーネントでサーバサイドレンダリングを行い、ブラウザ上で適切にハイドレーションすることも可能です。
両者を併用する方法については、後日別の記事で詳しく話したいと思います。</p>
<p>SSRについてはひとまず無視し、RSCだけにフォーカスしましょう。</p>
<h2>RSCを使うメリット<a name="03"></a></h2>
<p>RSC以前のReactコンポーネントはすべてクライアントコンポーネントであり、ブラウザ上で実行されます。
Reactページにアクセスすると、ブラウザは必要なReactコンポーネントすべてのコードをダウンロードし、React要素ツリーを構築してDOMにレンダリングします（SSRを使用している場合は、DOMをハイドレーションします）。
これらの処理がブラウザ上で行われることで React アプリケーションはインタラクティブに（イベントハンドラをインストールし、ステートを追跡し、イベントに応じてReactツリーに変更を加え、DOMを効率的にアップデートできるように）なります。
では、サーバ上でレンダリングを行うメリットは何でしょうか。
ブラウザよりサーバ上でレンダリングを行った方がよい理由はいくつかあります。</p>
<ul>
<li>サーバは、データベース、GraphQLエンドポイント、ファイルシステムなどのデータソースにもっとダイレクトにアクセスできます。パブリックAPIエンドポイントを経由することなく、必要なデータを直接取得でき、通常データソースに近い場所に配置されているため、ブラウザよりも素早くデータを取得できます。</li>
<li>サーバは、たとえばマークダウンをHTMLに変換してレンダリングするためのnpmパッケージなどの「重い」コードモジュールを手軽に利用できます。それは、これらの依存関係を使用するたびにダウンロードする必要がないからです。ブラウザの場合、使用するコードをすべてJavaScriptのバンドルとしてダウンロードする必要があります。</li>
</ul>
<p>要するに、<strong>RSCはサーバとブラウザが互いに得意な処理を行えるようにするのです</strong>。
サーバコンポーネントはデータの取得とコンテンツのレンダリング、クライアントコンポーネントはステートフルなインタラクティビティに注力できるため、ページの読み込み速度が速くなるほか、JavaScriptのバンドルサイズが小さくなり、ユーザ体験が改善されます。</p>
<h2>RSCの全体像<a name="04"></a></h2>
<p>では、まずその仕組みについて直感的に理解することから始めましょう。</p>
<p>筆者の子供たちはカップケーキのデコレーションは<em>大好き</em>なのですが、焼くことに関してはさほど興味を示しません。
カップケーキを一から作らせ、デコレーションまでさせるのは、きっと（かわいらしい）悪夢のような経験になるでしょう。
小麦粉と砂糖、バターを用意し、オーブンの使用を許可し、さまざまな取扱説明書を延々と読んで聞かせなくてはいけません。
そんなことをしていては、丸一日かかってしまいます。
しかし筆者ならば、オーブンで焼く作業をずっと速く行えます。
一部の作業を事前に行っておけば（原材料をそのまま渡すのではなく、カップケーキを焼き、アイシングを作り、それらを渡す）、子供たちは楽しいデコレーションにもっと早く取り掛かれます。
さらに良いことに、子供たちがオーブンを使用することについて心配する必要がありません。
素晴らしい！</p>
<p><img src="https://www.plasmic.app/blog/static/images/cake.jpg"></p>
<p>RSCの目的は、この役割分担を可能にすることです。
サーバが得意な作業は事前にサーバに行わせてから、残りの作業をブラウザに引き継ぐのです。
そうすることで、サーバがブラウザに渡すデータ量も減らすことができます。
袋いっぱいの小麦粉とオーブンに比べ、小さなカップケーキ12個の方がはるかに効率的に運べます。</p>
<p>一部のコンポーネントはサーバ側で、残りはクライアント側でレンダリングされるようなページのReactツリーを想像してみてください。
RSCのハイレベルな戦略を簡略化すると以下のような形になります。
サーバは、いつも通りサーバコンポーネントをレンダリングし、Reactコンポーネントを<code class="language-text">div</code>や<code class="language-text">p</code>などのネイティブHTML要素に変換します。
しかし、ブラウザ上でレンダリングされるクライアントコンポーネントに遭遇すると、代わりにプレースホルダを出力します。
サーバは、プレースホルダーに適切なクライアントコンポーネントとpropsを適用するように指示を加えます。
ブラウザはこの出力を受け取り、クライアントコンポーネントで穴埋めを行います。
これで完成です。</p>
<p><strong>実際の仕組みはそんなに単純ではありません</strong>。
詳細については後ほど話しますが、まずは全体像を頭に入れておくと有益です。</p>
<h2>サーバコンポーネントとクライアントコンポーネントの分断<a name="05"></a></h2>
<p>ところで、サーバコンポーネントとは何でしょうか。
サーバ用とクライアント用のコンポーネントはどのようにして区別するのでしょうか。</p>
<p>Reactチームでは、コンポーネントが記述されたファイルの拡張子を基に定義しています。
<code class="language-text">.server.jsx</code>で終わるファイルにはサーバコンポーネント、<code class="language-text">.client.jsx</code>で終わるファイルにはクライアントコンポーネントが含まれています。
これらいずれの拡張子ももたないファイルには、サーバ用としてもクライアント用としても使用できるコンポーネントが含まれています。</p>
<p>これは実用的な定義であり、人間にとってもバンドラーにとっても区別が容易です。
特にバンドラーにとっては、ファイル名を調べることでクライアントコンポーネントを区別し、処理方法を変えられるようになりました。
後述しますが、バンドラーはRSCが適切に機能する上で重要な役割を果たします。</p>
<p>サーバコンポーネントはサーバ上で、クライアントコンポーネントはクライアント上で実行されるため、それぞれできることにさまざまな制限があります。
その中でも最も重要なのが、<strong>クライアントコンポーネントはサーバコンポーネントをインポートできない</strong>ということです。
それは、サーバコンポーネントはブラウザ上で実行できず、ブラウザ上では機能しないコードが含まれる可能性があるためです。
クライアントコンポーネントがサーバコンポーネントに依存する場合、不正な依存関係がブラウザバンドルに入り込んでしまうことになります。
つまり、以下のようなクライアントコンポーネントは不正ということになってしまうため、この最後の点は難題になり得ます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// ClientComponent.client.jsx</span>
<span class="token comment">// 悪い例:</span>
<span class="token keyword">import</span> ServerComponent <span class="token keyword">from</span> <span class="token string">'./ServerComponent.server'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">ClientComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ServerComponent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、クライアントコンポーネントがサーバコンポーネントをインポートできず、サーバコンポーネントのインスタンスを生成できないのであれば、どうすれば以下のようにサーバコンポーネントとクライアントコンポーネントが交互に配置されたReactツリーができるのでしょうか。またどうすれば、クライアントコンポーネント（青い丸）の下にサーバコンポーネント（オレンジ色の丸）を配置できるのでしょうか。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components.png"></p>
<p>クライアントコンポーネントからサーバコンポーネントをインポートしてレンダリングすることはできませんが、コンポジションは使用できます。
つまり、クライアントコンポーネントは単なる不透明な<code class="language-text">ReactNode</code>であるpropsを取り込むことはでき、<code class="language-text">ReactNode</code>がサーバコンポーネントによってレンダリングされることも可能です。
以下に例を挙げます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// ClientComponent.client.jsx</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">ClientComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> children <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">Hello from client land</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// ServerComponent.server.jsx</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">ServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">Hello from server land</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span>

<span class="token comment">// OuterServerComponentはクライアントコンポーネントも</span>
<span class="token comment">// サーバーコンポーネントもインスタンス化することができ、</span>
<span class="token comment">// ClientComponentのchildrenとして&lt;ServerComponent/>を渡します。</span>
<span class="token keyword">import</span> ClientComponent <span class="token keyword">from</span> <span class="token string">'./ClientComponent.client'</span>
<span class="token keyword">import</span> ServerComponent <span class="token keyword">from</span> <span class="token string">'./ServerComponent.server'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">OuterServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ServerComponent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この制限は、RSCを有効に活用するためのコンポーネントの配置を検討する上で大きな影響があります。</p>
<h2>RSCレンダリングの流れ<a name="06"></a></h2>
<p>それでは、Reactサーバコンポーネントをレンダリングするときに実際何が起こるのか、肝心な部分を詳しく見ていきましょう。
ここで説明することをすべて理解しなくてもサーバコンポーネントは使えますが、仕組みについて直感的な理解は得られると思います。</p>
<h3>1. サーバがレンダリングリクエストを受け取る<a name="07"></a></h3>
<p>レンダリングの一部はサーバが行わなくてはならないため、RSCを使用する場合、ページのレンダリングは必ずサーバで始まります。
その際、APIコールによってReactコンポーネントのレンダリングが開始します。
この「ルート」コンポーネントは必ずサーバコンポーネントであり、他のサーバコンポーネントまたはクライアントコンポーネントをレンダリングする場合もあります。
サーバは、リクエストに含まれる情報をもとに、使用するサーバコンポーネントとpropsを判断します。
このリクエストは、通常特定のURLでページリクエストの形で届きますが、Shopify Hydrogenはより<a href="https://shopify.dev/custom-storefronts/hydrogen/framework/server-state">きめ細かい方法</a>を使用しており、Reactチームの公式デモでは<a href="https://github.com/reactjs/server-components-demo/blob/main/server/api.server.js">raw実装</a>を行っています。</p>
<h3>2. サーバがルートコンポーネント要素をJSON形式にシリアライズ<a name="08"></a></h3>
<p>ここでの最終目的は、最初のルートサーバコンポーネントをHTMLのタグとクライアントコンポーネントのプレースホルダで構成されるツリーとしてレンダリングすることです。
次に、そのツリーをシリアライズしてブラウザに送ります。
ブラウザ側では、受け取ったデータをデシリアライズし、プレースホルダを実際のクライアントコンポーネントに置き換え、最終結果をレンダリングします。</p>
<p>上の例に沿って見てみましょう。
<code class="language-text">&lt;OuterServerComponent/&gt;</code>をレンダリングしたい場合、<code class="language-text">JSON.stringify(&lt;OuterServerComponent /&gt;)</code>を実行すればシリアライズされた要素ツリーが得られるでしょうか？</p>
<p>惜しいですが、少し違います。😅
React要素とは実際のところどういうものだったか、思い出してみてください。
<code class="language-text">type</code>というフィールドに文字列または関数をとるオブジェクトです。
<code class="language-text">type</code> には、文字列なら<code class="language-text">&quot;div&quot;</code>のようなhtmlのタグ名が、関数ならReactコンポーネントのインスタンスが入ります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// &lt;div>oh my&lt;/div> を返す場合</span>
<span class="token operator">></span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> <span class="token string">"div"</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>

<span class="token comment">// &lt;MyComponent>oh my&lt;/MyComponent> を返す場合</span>
<span class="token operator">></span> <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>children<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token operator">></span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span> children<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> MyComponent   <span class="token comment">// MyComponent 関数への参照 function</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span> children<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">type</code>にHTMLタグではなくコンポーネントを指定した場合、typeフィールドはコンポーネントとして定義した関数（訳注: 原文ではcomponent function。本記事では、以降「コンポーネント関数」と訳します）を参照します。
しかし、関数はJSON 形式にシリアライズできません。</p>
<p>すべての要素をJSON文字列に適切に変換するために、Reactはこれらのコンポーネント関数の参照に適切に対処する特別な<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter">置換関数</a>を<code class="language-text">JSON.stringify()</code>に渡します。
そのa関数は、<a href="https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L368">ReactFlightServer.jsにあるresolveModelToJSON()</a>です。</p>
<p>具体的には、シリアライズ対象のReact要素に対して以下の処理を行います。</p>
<ul>
<li>HTMLのbaseタグ（<code class="language-text">type</code>フィールドには、「<code class="language-text">div</code>」のような文字列が入ります）の場合、すでにシリアライズ可能です。特別な処理は必要ありません。</li>
<li>サーバコンポーネントの要素の場合、サーバコンポーネント関数（<code class="language-text">type</code>フィールドに格納されている）とそのpropsを呼び出し、その結果をシリアライズします。これは実質的にサーバーコンポーネントのレンダリングに相当します。つまり、全てのサーバーコンポーネントをただのHTMLタグに変換するのです。</li>
<li>クライアントコンポーネントの場合も、すでにシリアライズ可能です。<code class="language-text">type</code>フィールドはすでにコンポーネント関数ではなく、モジュール参照オブジェクトを指し示しています。このモジュール参照オブジェクトとは一体何なのでしょう。</li>
</ul>
<h4>「モジュール参照」オブジェクトとは何か</h4>
<p>RSCでは、React要素の<code class="language-text">type</code>フィールドに「モジュール参照」と呼ばれる新しい値を導入できます。
コンポーネント関数の代わりに、コンポーネント関数へのシリアライズ可能な「参照」を渡すのです。
例えば、<code class="language-text">ClientComponent</code>という要素は以下のような形を取ることができます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// type フィールドが、実際のコンポーネント関数の代わりに参照オブジェクトを持つようになりました</span>
  type<span class="token operator">:</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>module<span class="token punctuation">.</span>reference<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// ClientComponent は以下のファイルから default export されます</span>
    name<span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>
    <span class="token comment">// ClientComponent を default export しているファイルのパス</span>
    filename<span class="token operator">:</span> <span class="token string">"./src/ClientComponent.client.js"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span> children<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、このマジックのような処理はどこで行われているのでしょうか。
クライアントコンポーネント関数への参照は、どこでシリアライズ可能な「モジュール参照」オブジェクトに変換されているのでしょうか。</p>
<p>なんと、この手品のような処理はバンドラーが行なっているのです。
Reactチームは、webpack向けの公式RSCサポートを、<code class="language-text">react-server-dom-webpack</code>で<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackNodeLoader.js">webpackローダ</a>または<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackNodeRegister.js">node-register</a>として公開しています。
サーバコンポーネントが<code class="language-text">*.client.jsx</code>ファイルから何かをインポートする際、実際のインポート対象を取得する代わりに、そのファイル名とエクスポート名が含まれたモジュール参照オブジェクトだけを取得しています。
クライアントコンポーネント関数が、サーバ上に構築されるReactツリーの一部に組み込まれることはありません。</p>
<p><a href="#08">このセクションの冒頭で</a><code class="language-text">&lt;OuterServerComponent /&gt;</code>をシリアライズしようとした例を思い出してください。
最終的には以下のようなJSONツリーになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token punctuation">{</span>
  <span class="token comment">//「モジュール参照」を持つ ClientComponent のプレースホルダー</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>module<span class="token punctuation">.</span>reference<span class="token punctuation">)</span><span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token string">"./src/ClientComponent.client.js"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ClientComponent に渡される children（ここでは &lt;ServerComponent />）</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// ServerComponentは html タグに直でレンダリングされます。</span>
      <span class="token comment">// ServerComponent への参照が一切なく、直でspanをレンダリングしていることに注目してください。</span>
      $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
      type<span class="token operator">:</span> <span class="token string">"span"</span><span class="token punctuation">,</span>
      props<span class="token operator">:</span> <span class="token punctuation">{</span>
        children<span class="token operator">:</span> <span class="token string">"Hello from server land"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h4>シリアライズ可能なReactツリー</h4>
<p>このプロセスの終わりには、サーバ上に以下のようなReactツリーができていることが望まれます。
これをブラウザに送信して「仕上げ」を行います。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components-placeholders.png"></p>
<p><strong>propsはすべてシリアライズ可能であること</strong></p>
<p>Reactツリー全体をJSON形式にシリアライズするため、クライアントコンポーネントまたはHTMLのbaseタグに渡すpropsもすべてシリアライズ可能でなくてはなりません。
これはつまり、サーバコンポーネントからイベントハンドラをpropsとして渡すことはできないということです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 悪い例: サーバーコンポーネントは props として子孫コンポーネントに関数を渡すことができません。なぜなら関数はシリアライズできないからです。</span>
<span class="token keyword">function</span> <span class="token function">SomeServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'OHHAI'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">Click me!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、1つ留意すべき点として、RSCプロセスの際にクライアントコンポーネントに遭遇しても、決してクライアントコンポーネント関数を呼び出したり、クライアントコンポーネントに「降りて行く」ことはありません。
したがって、別のクライアントコンポーネントのインスタンスを生成するクライアントコンポーネントがある場合、以下のようになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SomeServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent1</span></span><span class="token punctuation">></span></span><span class="token plain-text">Hello world!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent1</span></span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ClientComponent1</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>children<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// クライアントからクライアントコンポーネントに props として関数を渡すのは可</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent2</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent2</span></span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このRSC JSONツリーには、<code class="language-text">ClientComponent2</code>は一切出てきません。
その代わり、<code class="language-text">ClientComponent1</code>のモジュール参照とpropsをもつ要素だけがあります。
そのため、<code class="language-text">ClientComponent1</code>がpropsとしてイベントハンドラを<code class="language-text">ClientComponent2</code>に渡すのは、全く正常なことです。</p>
<h3>3. ブラウザがReactツリーを再構築<a name="09"></a></h3>
<p>ブラウザは、サーバからJSON出力を受け取ったら、ブラウザ上でレンダリングするReactツリーの再構築を開始しなくてはいけません。
<code class="language-text">type</code>がモジュール参照である要素に遭遇した場合、実際のクライアントコンポーネント関数への参照に置き換える必要があります。
この作業には、再びバンドラーの助けが必要になります。
バンドラーを用いてサーバ上でクライアントコンポーネント関数をモジュール参照に置き換えたように、今度はバンドラーを用いてブラウザ上でモジュール参照を実際のクライアントコンポーネント関数に置き換えます。
再構築されたReactツリーは以下のようになります。異なる点は、ネイティブのタグとクライアントコンポーネントが置き換わっていることだけです。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components-client.png"></p>
<p>あとは、いつも通りこのツリーをレンダリングし、DOMにコミットするだけです。</p>
<h3>Suspenseとの互換性は問題ないか？<a name="10"></a></h3>
<p>問題ありません。
Suspenseは、上で述べたすべてのステップで欠かせない役割を果たします。</p>
<p>Suspenseはそれ自体が壮大なテーマであり、それ単体でブログ記事1本分に相当するものなので、この記事ではあえて軽く触れるだけに留めています。
ごく簡単に説明すると、Suspenseは何か準備ができていないもの（データのフェッチ、コンポーネントの遅延インポートなど）を必要とする際、ReactコンポーネントからPromiseをスローすることを可能にします。
それらのPromiseは、Suspenseの境界でキャッチされます。
Suspenseサブツリーのレンダリング時にPromiseがスローされると、ReactはPromiseが解決されるまでサブツリーのレンダリングを停止し、再度トライします。</p>
<p>RSC出力を生成するためにサーバ上でサーバコンポーネント関数を呼び出すと、それらの関数が必要なデータを取得する際にPromiseを返す場合があります。
<a href="https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L416">スローされたPromiseに遭遇</a>すると、プレースホルダを出力します。
Promiseが解決すると、再びサーバコンポーネント関数を呼び出し、成功すれば完成したチャンクを出力します。
RSC出力ストリームを作成しているのであり、Promiseがスローされると停止し、解決すると追加のチャンクをストリーミングします。</p>
<p>同様に、ブラウザ上では上の<code class="language-text">fetch()</code>コールからRSC JSON出力ストリームを作成します。
このプロセスも、出力の中にSuspenseのプレースホルダがあり（サーバがスローされたPromiseに遭遇している）、ストリーム内にまだプレースホルダのコンテンツを見つけていない（<a href="https://github.com/facebook/react/blob/main/packages/react-client/src/ReactFlightClientStream.js">詳細はこちら</a>）場合、Promiseをスローすることになるかもしれません。
あるいは、クライアントコンポーネントのモジュール参照に遭遇したものの、まだブラウザ上にクライアントコンポーネント関数が読み込まれていない場合も、Promiseをスローする可能性があります。
その場合、バンドラーのランタイムが動的に<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightClientWebpackBundlerConfig.js">必要なチャンクを取得</a>する必要があります。</p>
<p>Suspenseのおかげで、サーバコンポーネントがデータを取得する間にサーバはRSC出力をストリーミングし、ブラウザは受け取ったデータから徐々にレンダリングし、必要になったクライアントコンポーネントバンドルを動的に取得します。</p>
<h2>RSCワイヤーフォーマット<a name="11"></a></h2>
<p>具体的にサーバは何を出力しているのでしょうか。
「JSON」と「ストリーム」の文字を見て疑念を抱いたのであれば、それは正しい反応です。
では、サーバはブラウザにどのようなデータをストリーミングしているのでしょうか。</p>
<p>IDがタグ付けされたJSONの塊が各行に一つ追加された、単純なフォーマットです。
以下は、<code class="language-text">&lt;OuterServerComponent/&gt;</code>の例のRSC出力です。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">M1:{&quot;id&quot;:&quot;./src/ClientComponent.client.js&quot;,&quot;chunks&quot;:[&quot;client1&quot;],&quot;name&quot;:&quot;&quot;}
J0:[&quot;$&quot;,&quot;@1&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;span&quot;,null,{&quot;children&quot;:&quot;Hello from server land&quot;}]}]</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>上のスニペットでは、<code class="language-text">M</code>で始まる行はクライアントコンポーネントのモジュール参照を定義しており、クライアントバンドルの中からコンポーネント関数を検索するのに必要な情報が含まれています。
<code class="language-text">J</code>で始まる行は、実際のReact要素ツリーを定義しており、<code class="language-text">M</code>行で定義されたクライアントコンポーネントを参照する<code class="language-text">@1</code>などが含まれます。</p>
<p>このフォーマットは非常にストリーミングしやすく、クライアントは1行読み終えるとすぐにJSONのスニペットを解析して処理を進めることができます。
サーバがレンダリング中にSuspense境界に遭遇した場合、各チャンクが解決される度たびにそれと一致する複数の<code class="language-text">J</code>行が出てきます。</p>
<p>もう少し興味深い例を見てみましょう。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// Tweets.server.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> fetch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-fetch'</span> <span class="token comment">// React の Suspense 対応した fetch()</span>
                                    
<span class="token keyword">import</span> Tweet <span class="token keyword">from</span> <span class="token string">'./Tweet.client'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Tweets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> tweets <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/tweets</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>tweets<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">tweet</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Tweet</span></span> <span class="token attr-name">tweet</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>tweet<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Tweet.client.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Tweet</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> tweet <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Written by </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tweet<span class="token punctuation">.</span>username<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>tweet<span class="token punctuation">.</span>body<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span>

<span class="token comment">// OuterServerComponent.server.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">OuterServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ServerComponent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token string">'Loading tweets...'</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Tweets</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この場合、RSCストリームはどのように見えるでしょうか。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">M1:{&quot;id&quot;:&quot;./src/ClientComponent.client.js&quot;,&quot;chunks&quot;:[&quot;client1&quot;],&quot;name&quot;:&quot;&quot;}
S2:&quot;react.suspense&quot;
J0:[&quot;$&quot;,&quot;@1&quot;,null,{&quot;children&quot;:[[&quot;$&quot;,&quot;span&quot;,null,{&quot;children&quot;:&quot;Hello from server land&quot;}],[&quot;$&quot;,&quot;$2&quot;,null,{&quot;fallback&quot;:&quot;Loading tweets...&quot;,&quot;children&quot;:&quot;@3&quot;}]]}]
M4:{&quot;id&quot;:&quot;./src/Tweet.client.js&quot;,&quot;chunks&quot;:[&quot;client8&quot;],&quot;name&quot;:&quot;&quot;}
J3:[&quot;$&quot;,&quot;ul&quot;,null,{&quot;children&quot;:[[&quot;$&quot;,&quot;li&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;@4&quot;,null,{&quot;tweet&quot;:{...}}}]}],[&quot;$&quot;,&quot;li&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;@4&quot;,null,{&quot;tweet&quot;:{...}}}]}]]}]</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">J0</code>行には新たな子が追加されています。
<code class="language-text">children</code>が参照<code class="language-text">@3</code>を指している新しい<code class="language-text">Suspense</code>境界です。
興味深いことに、この時点ではまだ<code class="language-text">@3</code>は定義されていません。
サーバはツイートの読み込みを完了すると、<code class="language-text">M4</code>と<code class="language-text">J3</code>の行を出力します。
前者は<code class="language-text">Tweet.client.js</code>コンポーネントへのモジュール参照を定義し、後者は<code class="language-text">@3</code>を置き換えるべき別のReact要素ツリーを定義します（ここでも、<code class="language-text">J3</code>のchildrenは<code class="language-text">M4</code>で定義された<code class="language-text">Tweet</code>コンポーネントを参照しています）。</p>
<p>バンドラーが<code class="language-text">ClientComponent</code>と<code class="language-text">Tweet</code>を二つの異なるバンドルに自動的に入れており、それによってブラウザが<code class="language-text">Tweet</code>バンドルのダウンロードを遅らせることができる点も、ここで述べておくべきでしょう。</p>
<h3>RSCフォーマットを使う<a name="12"></a></h3>
<p>このRSCストリームをブラウザ上で実際のReact要素に変換するにはどうすればよいのでしょうか。
<code class="language-text">react-server-dom-webpack</code>には、RSCレスポンスを用いてReact要素ツリーを再構築する<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightDOMClient.js">エントリーポイント</a>があります。
以下はルートクライアントコンポーネントを簡略化した例です。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> createFromFetch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-server-dom-webpack'</span>
<span class="token keyword">function</span> <span class="token function">ClientRootComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// RSC API のエンドポイントから fetch() を実行します。</span>
  <span class="token comment">// react-server-dom-webpack はフェッチした結果を受け取り、</span>
  <span class="token comment">// React の要素ツリーを再構築することができます。</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token function">createFromFetch</span><span class="token punctuation">(</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/rsc?...'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>response<span class="token punctuation">.</span><span class="token function">readRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* Returns a React element! */</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">react-server-dom-webpack</code>に、APIエンドポイントからのRSCレスポンスを読むよう指示します。
次に、<code class="language-text">response.readRoot()</code>が、レスポンスストリームが処理されると更新されるReact要素を返します。
ストリームがまだ読まれる前に、直ちにPromiseがスローされます。
これは、まだコンテンツが用意できていないからです。
最初の<code class="language-text">J0</code>が処理されると、対応するReact要素ツリーが作成され、返されたPromiseが解決されます。
Reactはレンダリングを再開しますが、まだ準備ができていない<code class="language-text">@3</code>の参照に遭遇すると、新たなPromiseがスローされます。
そのPromiseは<code class="language-text">J3</code>を読んだ時点で解決され、Reactは再びレンダリングを開始し、今回は完了します。
したがって、RSCレスポンスをストリーミングしながら、Suspense境界によって定義されたチャンク単位で要素ツリーの更新とレンダリングを完了するまで継続します。</p>
<h3>単にプレーンHTMLを出力すればよいのでは？<a name="13"></a></h3>
<p>なぜ全く新しいワイヤーフォーマットを発明する必要があるのでしょうか。
クライアント側における目的は、React要素ツリーを再構築することです。
HTMLは、解析しなければReact要素を作成できないため、この目的はHTMLよりもこのフォーマットから行う方がずっと簡単に果たせます。
React要素ツリーを再構築することで、DOMへのコミットを最小限に留めつつReactツリーへのその後の変更をマージできるようになるため、これは重要なプロセスです。</p>
<h3>クライアントコンポーネントからデータを取得するだけよりもメリットがある？<a name="14"></a></h3>
<p>このコンテンツを取得するために、どちらにしてもサーバにAPIリクエストを送信する必要があるのであれば、現在のようにリクエストを送信してデータだけを取得し、クライアント側ですべてのレンダリングを行うよりも、RSCを使った方が本当によいのでしょうか。</p>
<p>最終的には、何をレンダリングして画面上に表示するのかによります。
RSCでは、ユーザに向けて表示されるコンテンツに直接マッピングされる、非正規化された「処理済み」のデータを受け取ります。
したがって、取得するデータの一部だけをレンダリングしたい場合や、レンダリング自体に大量のJavaScriptが必要なため、ブラウザへのダウンロードを避けたい場合はメリットがあります。
さらに、レンダリングを行うために複数回データを取得する必要があり、ウォーターフォールにおいてそれぞれ互いに依存し合う場合、ブラウザよりもデータのレイテンシがはるかに低いサーバ上でデータを取得した方がよいでしょう。</p>
<h3>サーバサイドレンダリングはどうなる？<a name="15"></a></h3>
<p>SSRがどうなるのか気になる方が多いのはよく分かります。
React 18ではSSRとRSCの併用が可能なため、サーバ上でHTMLを生成し、ブラウザ上でRSCを用いてHTMLをハイドレーションすることが可能です。
このテーマについてはまた別の機会に詳しく話したいと思います。</p>
<h2>サーバコンポーネントがレンダリングしているコンテンツのアップデート<a name="16"></a></h2>
<p>ある製品のページから別の製品のページに切り替えたい場合など、サーバコンポーネントに新しいコンテンツをレンダリングさせる必要がある場合はどうすればよいでしょうか。</p>
<p>この場合も、レンダリングはサーバ側で行われるため、新しいコンテンツをRSCワイヤーフォーマットで取得するためにはサーバに新たなAPIコールを行う必要があります。
よいニュースは、ブラウザが新しいコンテンツを受け取ると、クライアントコンポーネントにステートハンドラとイベントハンドラを保持しつつ、新しいReact要素ツリーを構築し、前のReactツリーとの差分を取るための通常の差分検出処理を行い、DOMに対する必要最小限のアップデートを判断できるという点です。
クライアントコンポーネントにとっては、このアップデートはすべてブラウザ上で行われた場合と比べても何ら違いがありません。</p>
<p>現時点では、Reactツリー全体をルートサーバコンポーネントから再レンダリングする必要がありますが、将来的にはこれをサブツリーに対して行えるようになるかもしれません。</p>
<h2>RSCにメタフレームワークを使うべき理由<a name="17"></a></h2>
<p>Reactチームは、RSCは当初プレーンなReactプロジェクトで直接使用するのではなく、Next.jsやShopify Hydrogenのように<a href="https://github.com/josephsavona/rfcs/blob/server-components/text/0000-server-components.md#adoption-strategy">メタフレームワーク経由での導入</a>を意図していると述べています。
これはなぜでしょうか。
メタフレームワークにはどのようなメリットがあるのでしょうか。</p>
<p>メタフレームワークの使用は必須ではありませんが、作業が楽になります。
メタフレームワークが提供するラッパーや抽象化は使いやすいため、サーバ上でRSCストリームを生成し、ブラウザ上で消費することを考える必要がありません。
また、メタフレームワークはサーバサイドレンダリングもサポートしており、サーバコンポーネントを使用している場合にサーバが生成したHTMLを適切にハイドレーションできるよう、必要な<a href="https://github.com/Shopify/hydrogen/issues/250">作業</a>を<a href="https://github.com/vercel/next.js/issues/30994">実施</a>しています。</p>
<p>上で説明したように、クライアントコンポーネントを適切に送信し、ブラウザ上で使用するためにはバンドラーの助けも必要です。
webpackインテグレーションはすでにあり、現在はShopifyが<a href="https://github.com/facebook/react/pull/22952">viteへのインテグレーション</a>に取り組んでいます。
RSCに必要なプラグインの多くはパブリックnpmパッケージとして公開されていないため、これらのプラグインはReactリポジトリの一部でなくてはいけません。
しかし、一度開発されれば、メタフレームワークなしでこれらのプラグインを使用できるようになるはずです。</p>
<h2>RSCは実用化の準備ができているのか？<a name="18"></a></h2>
<p>RSCは、現在<a href="https://nextjs.org/docs/advanced-features/react-18">Next.jsの実験的な機能</a>として提供されており、<a href="https://hydrogen.shopify.dev/">Shopify Hydrogenの現在の開発者プレビュー</a>段階にありますが、どちらもまだ本番環境で使用できる状態ではありません。
今後のブログ記事では、これらのフレームワークがそれぞれRSCをどのように使用しているのか詳しく説明したいと思います。</p>
<p>しかし、RSCが今後のReactを大きく左右する存在であることは間違いありません。RSCは、ページの読み込み速度向上、JavaScriptバンドルの軽量化、Time To Interactive（TTI）の短縮という課題に対するReactの答えであり、Reactを使用して複数ページのアプリケーションを構築する方法に関するより包括的なテーゼです。未完成ではあるものの、注目すべき時が近づいています。</p>
<p><em>この記事の草案をレビューしてくれた<a href="https://twitter.com/Nutlope">Hassan</a>と<a href="https://twitter.com/jplhomer">Josh</a>に感謝します。</em></p>]]></content:encoded></item><item><title><![CDATA[tscをGoに移植]]></title><description><![CDATA[筆者はTypeScript型チェッカーtscをRustではなく、Goに移植しようと思います。拡張可能なRustプラットフォームSWCの作者の発言としては、奇妙に聞こえるかもしれません。理由を説明した…]]></description><link>https://postd.cc/tsc-go/</link><guid isPermaLink="false">https://postd.cc/tsc-go/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[TypeScript]]></category><category><![CDATA[Go言語]]></category><category><![CDATA[tsc]]></category><category><![CDATA[SWC]]></category><pubDate>Mon, 13 Jun 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>筆者はTypeScript型チェッカー<strong>tsc</strong>をRustではなく、Goに移植しようと思います。拡張可能なRustプラットフォーム<a href="https://swc.rs/">SWC</a>の作者の発言としては、奇妙に聞こえるかもしれません。理由を説明したいと思います。</p>
<h2>なぜtscを移植するのか</h2>
<p>TypeScriptの普及が進むにつれて、大規模プロジェクトではあるジレンマに直面しています。<strong>型チェックは、ワークフローの中で最も時間がかかるプロセスの一つになっているのです</strong>。開発者は、イテレーションのサイクルを遅らせることなく、型安全を保証することを望んでいます。
<strong>tsc</strong>（TypeScript Compiler）は、型の妥当性をチェックし、コードをJavaScriptにコンパイルします。コードの量が多いほど、コンパイルには時間がかかります。中規模から大規模のTypeScriptプロジェクトでは、このコンパイルに膨大な時間がかかります。開発者はワークフローのトランスパイル部分をSWCに置き換えることができますが、それでも型チェックはボトルネックとなっています。</p>
<h2>型チェッカーとは何か</h2>
<p>型チェッカーは、実行前にプログラムを検証し、関数呼び出しや変数割り当ての値が正しいことを確認します。また、いたるところで型を指定することがないよう、可能な限り変数の型を推測します。型チェックは、自信を持って開発を行い、エラーをなくし、大規模なコードベースのリファクタリングをよりスムーズに行うことを可能にします。</p>
<h2>なぜRustではないのか</h2>
<p>筆者は<strong>tsc</strong>をRustで書き直そうと試みました。最初はサイドプロジェクトとして取り組み、大いに楽しみました。<strong>tsc</strong>のソースコードを見ずに型チェックのロジックを作り直す作業を開始しました。
筆者が書き直したRust版の初期テストでは、<strong>型チェックのスピードがtscの62倍に改善されていました</strong>。SWCとtscのコンパイル時間を測定するため、公式TypeScriptコンパイラの<strong>コンフォーマンス（適合性）</strong>テストスイートを使用しました。結果は以下の通りです（8スレッド使用）：</p>
<ul>
<li><strong>tsc</strong>：133.2秒</li>
<li>Rustリライト版：<strong>2.13秒（62倍速い）</strong></li>
</ul>
<p>最終的に、<strong>tsc</strong>のような巨大プロジェクトを書き直すのは、継続するのが極めて難しいことを悟りました。しかし、パフォーマンスの向上はかなりのものだったため、別の方法として完全なリライトではなく移植を試してみることにしたのです。そこで、TypeScriptのソースコードを見始めました。
<strong>tsc</strong>は共有の可変性を多く使い、<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">ガベージコレクション</a>に依存する部分が多くあります。筆者はRustの支持者であり、信者ですが、このプロジェクトに合ったツールではないと感じます。このプロジェクトでRustを使用するには、<a href="https://doc.rust-lang.org/std/keyword.unsafe.html">unsafe</a>を使用しなければならない場面が多すぎました。
<strong>tsc</strong>は共有の可変性に依存しており、周期的な可変参照を持っています。Rustはこの挙動を防ぐよう設計されています。同じデータに対し二つの参照を持つこと（共有の可変性）は、Rustでは定義されていない挙動です。
どの言語を選ぶかは、好みではなく作業によって決めるべきです。筆者はRustを好みますが、このプロジェクトのためにGoとZigを試し、Goを使うことにしました。</p>
<h2>オープンソース化するのか</h2>
<p><strong>tsc</strong>をGoに移植する作業は、Vercelがスポンサーとして資金を提供しています。将来的にはオープンソース化する予定です。この新バージョンの<strong>tsc</strong>をSWCとともに使用するためのブリッジも作成します。
型チェックのサポートを得て、SWCはJavaScriptとTypeScriptのツールチェーン全体のパフォーマンス向上に取り組んでいます。</p>
<ul>
<li>✅トランスパイル（Babelの代替）</li>
<li>🚧型チェック（<strong>tsc</strong>の代替）</li>
<li>🚧最小化（Terserの代替）</li>
<li>🚧バンドリング（webpackの代替）</li>
</ul>
<p>プロジェクトの最新情報については、<a href="https://twitter.com/kdy1dev">Twitterをフォローしてください</a>。</p>]]></content:encoded></item></channel></rss>