<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア]]></title><description><![CDATA[POSTD は、ニジボックスが運営する、エンジニアに向けたキュレーションメディアです。ニジボックスはWebサービスの企画、制作、開発、運用を一貫して担うリクルートの100%子会社です。 リクルートグループのオンラインサービスをはじめ、様々な業種・業界・業態のサービス開発を行っております。]]></description><link>https://postd.cc</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 31 May 2023 04:36:10 GMT</lastBuildDate><language>ja</language><atom:link href="https://postd.cc/feed/" rel="self" type="application/rss+xml"/><image><title>POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア</title><link>https://postd.cc</link></image><item><title><![CDATA[フロントエンドパフォーマンスのチェックリスト2021年版（PDF、Apple Pages、MS Word）-前編]]></title><description><![CDATA[クイックサマリー：2021年のWebパフォーマンスを高速化しましょう。
毎年恒例のフロントエンドパフォーマンスのチェックリスト（PDF、Apple Pages、MS Wordに対応）は、指標やツール…]]></description><link>https://postd.cc/front-end-performance-2021-checklist-1/</link><guid isPermaLink="false">https://postd.cc/front-end-performance-2021-checklist-1/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Wed, 31 May 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p><strong>クイックサマリー</strong>：2021年のWebパフォーマンスを高速化しましょう。
毎年恒例のフロントエンドパフォーマンスのチェックリスト（<a href="https://www.dropbox.com/s/34noajrbm324iai/performance-checklist-1.4.pdf?dl=0">PDF</a>、<a href="https://www.dropbox.com/s/ikuk5ikcxxv39uu/performance-checklist-1.4.pages?dl=0">Apple Pages</a>、<a href="https://www.dropbox.com/scl/fi/s7ctdj89zd5zlvtt7dkhi/performance-checklist-1.4.docx?dl=0&#x26;rlkey=2xzs55e3kdg1jcraw5u1tnpl8">MS Word</a>に対応）は、指標やツールからフロントエンドのテクニックに至るまで、現代のWebで高速なユーザ体験を生み出すために知る必要があるすべてを提供します。
このチェックリストは2016年から更新を続けてきました。
<a href="https://www.smashingmagazine.com/the-smashing-newsletter/">メールのニュースレターでも、フロントエンドに関する便利な情報をご確認いただけます</a>。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>このガイドは、<a href="https://logrocket.com/?utm_source=smashing&#x26;utm_medium=syndication&#x26;utm_campaign=sm_q12021#utm_source=smashing&#x26;utm_medium=syndication&#x26;utm_campaign=sm_q12021">LogRocket</a>に勤務する筆者の友人の厚意によるサポートを受けています。
LogRocketは、<strong>フロントエンドパフォーマンスのモニタリング</strong>、セッションリプレイ、製品分析を組み合わせ、顧客体験の向上に貢献するサービスです。
また、DOM完了時間、サーバ初期応答時間（TTFB）、初回入力までの遅延時間（FID）、クライアントのCPUとメモリの利用状況などの重要な指標を追跡します。
LogRocketの無料トライアルは<a href="https://logrocket.com/?utm_source=smashing&#x26;utm_medium=syndication&#x26;utm_campaign=sm_q12021#utm_source=smashing&#x26;utm_medium=syndication&#x26;utm_campaign=sm_q12021">こちら</a>です。</p></div></div>
<p>Webパフォーマンスは厄介な代物だと思いませんか。
どうすれば現在のパフォーマンスを実際に知ることができるのでしょう。
いったい何がパフォーマンスのボトルネックになっているのでしょうか。
読み込みに時間がかかるJavaScriptか、表示が遅いWebフォントか、サイズが大きい画像か、それとも緩慢なレンダリングでしょうか。
果たして私たちは、ツリーシェイキング、スコープホイスティング、コード分割による最適化や、インターセクションオブザーバー、プログレッシブハイドレーション、クライアントヒント、HTTP/3、サービスワーカー、さらにはエッジワーカーによる、手の込んだ読み込みパターンを使用した最適化を十分に行っているでしょうか。
そして最も重要な点として、<strong>いったいどこからパフォーマンス改善に手をつけ</strong>、どのように長期にわたってパフォーマンスを重視する文化を確立すればよいのでしょうか。</p>
<p>かつては、パフォーマンスは通常、あくまで後で考えるものでした。
プロジェクトの最後の最後まで後回しにされた結果、最小化、連結、アセットの最適化に加え、
場合によりサーバのconfigファイルにいくつかの微調整を加えるだけで済むことが珍しくありませんでした。
いま振り返ってみると、状況はずいぶん変わったように感じられます。</p>
<p>パフォーマンスは単なる技術的な問題ではありません。
アクセシビリティやユーザビリティから検索エンジン最適化に至るまで、あらゆる要素に影響を与えます。
パフォーマンスをワークフローに組み込むならば、デザインはパフォーマンスへの影響を考慮して決定する必要があります。
<strong>パフォーマンスは継続的に測定、監視、改良しなければなりません</strong>。
さらに、Webの複雑性が高まることによって新たな課題が生まれ、指標の追跡が困難になっています。
なぜなら、端末、ブラウザ、プロトコル、ネットワークのタイプとレイテンシによってデータが大きく変わるからです（CDN、ISP、キャッシュ、プロキシ、ファイアウォール、ロードバランサ、サーバのすべてがパフォーマンスに関係します）。</p>
<p>それでは、プロジェクトの最初からWebサイトの最終リリースまで、パフォーマンスを改善するときに考慮すべきことをすべてまとめた全体像を作成するとしたら、どのようなものになるでしょうか。
以下に（なるべく偏りがなく客観的な）<strong>フロントエンドパフォーマンスのチェックリスト2021年版</strong>を紹介します。
高速な反応時間と円滑なユーザインタラクションを確保し、Webサイトがユーザの帯域幅を奪わないようにするために、考慮する必要がある項目の最新情報をまとめました。</p>
<h2>目次<a href="#00">＃</a></h2>
<p><strong>前編</strong></p>
<ul>
<li><a href="#01">準備段階：計画と指標</a><br>
パフォーマンスを重視する文化、Core Web Vitals、パフォーマンスのプロファイル、CrUX、Lighthouse、FID、TTI、CLS、端末。</li>
<li><a href="#02">現実的な目標の設定</a><br>
パフォーマンスバジェット、パフォーマンス目標、RAILフレームワーク、170KB/30KBバジェット。</li>
<li><a href="#03">環境の定義</a><br>
フレームワークの選択、パフォーマンスコストの基準設定、Webpack、依存関係、CDN、フロントエンドアーキテクチャ、CSR、SSR、CSR + SSR、静的レンダリング、プリレンダリング、PRPLパターン。</li>
</ul>
<p><strong>中編</strong></p>
<ul>
<li>アセットの最適化<br>
Brotli、AVIF、WebP、レスポンシブ画像、AV1、アダプティブメディア読み込み、動画圧縮、Webフォント、Googleフォント。</li>
</ul>
<p><strong>後編</strong></p>
<ul>
<li>ビルドの最適化<br>
JavaScriptモジュール、モジュール/ノーモジュールのパターン、ツリーシェイキング、コード分割、スコープホイスティング、Webpack、デファレンシャルサービング、Webワーカー、WebAssembly、JavaScriptバンドル、React、SPA、パーシャルハイドレーション、インポート・オン・インタラクション、サードパーティ、キャッシュ</li>
<li>デリバリの最適化<br>
遅延読み込み、インターセクションオブザーバー、遅延レンダリングとデコーディング、クリティカルCSS、ストリーミング、リソースヒント、レイアウトシフト、サービスワーカー。</li>
<li>ネットワーク接続、HTTP/2、HTTP/3<br>
OCSPステープリング、EV/DV証明書、パッケージング、IPv6、QUIC、HTTP/3。</li>
<li>テストとモニタリング<br>
監査ワークフロー、プロキシブラウザ、404ページ、GDPRに基づくcookie同意プロンプト、パフォーマンス診断CSS、アクセシビリティ。</li>
<li>手軽に成果を上げる</li>
<li>チェックリストのダウンロード（PDF、Apple Pages、MS Word）</li>
<li>さあ、始めよう！</li>
</ul>
<p>（<a href="https://www.dropbox.com/s/34noajrbm324iai/performance-checklist-1.4.pdf?dl=0">チェックリストのPDFファイル</a>（166KB）、<a href="https://www.dropbox.com/s/ikuk5ikcxxv39uu/performance-checklist-1.4.pages?dl=0">編集可能なApple Pagesファイル</a>（275KB）、<a href="https://www.dropbox.com/scl/fi/s7ctdj89zd5zlvtt7dkhi/performance-checklist-1.4.docx?dl=0&#x26;rlkey=2xzs55e3kdg1jcraw5u1tnpl8">.docxファイル</a>（151KB）も自由にダウンロードできます。皆さんが最適化を楽しめますように！）</p>
<h2>準備段階：計画と指標 <a href="#01">#</a><a name="01"></a></h2>
<p>細かい最適化はパフォーマンスを維持するにはとても重要ですが、明確な目標を念頭に置くことも必要不可欠です。
測定可能な目標を定め、プロセス全体を通したすべての意思決定に反映させるようにしましょう。
目標設定に関してはいくつもの異なるモデルがあり、以下で紹介するモデルは筆者の独断によるものです。
早いうちに自分が何を優先するかを決めるようにしましょう。</p>
<h3>01. パフォーマンスを重視する文化を確立する。</h3>
<p>多くの組織において、フロントエンドの開発者は、共通する基本的な問題が何であるかや、それを修正するためにどんな戦略を採用すべきかをはっきりと把握しています。
しかし、パフォーマンスを重視する文化がしっかりと確立されていないと、意思決定のたびに部門同士で争いが起き、分断化した組織になってしまいます。
開発を進めるには、ビジネスのステークホルダーの支持が必要です。
支持を得るには、速度（特に、後で詳しく説明するCore Web Vitals）の向上が、ステークホルダーが関心を持っている基準や重要業績評価指標（KPI）にプラスの影響を与えるというケーススタディ、すなわち<a href="https://medium.com/%40armelpingault/how-to-convince-your-client-to-focus-on-web-performance-a-case-study-35f12385689">概念実証（PoC）</a>を確立しなければなりません。</p>
<p>パフォーマンス向上のメリットをより明確にする手段として、例えばコンバージョン率と、アプリケーション読み込み速度やレンダリングのパフォーマンスの相関を明らかにし、<a href="https://simplified.dev/performance/impact-of-web-performance">収益パフォーマンスへの影響</a>を示すことができます。
あるいは、<a href="https://drive.google.com/file/d/1o0lWk3c-d3xRuLw61jVeQwHJr_SdOCYP/view">サーチボットのクローリング率</a>（PDF、27～50ページ）を利用しても良いでしょう。</p>
<p>開発/デザインチームと業務/マーケティングチームの方向性がしっかりと一致していなければ、パフォーマンスを長く維持することはできません。
カスタマーサービスと営業チームによく寄せられる苦情を精査し、直帰率が高い場合やコンバージョン率が低下した場合は詳しく分析しましょう。
そして、パフォーマンスの向上によって、こうしたよくある問題を軽減することができないか調べてみましょう。
どのステークホルダーと話すのかに応じて、<a href="https://youtu.be/SE0HhF4TO0Q?t=1052">主張の内容を調整する</a>ことも必要です。</p>
<p>モバイルとデスクトップの両方でパフォーマンス実験を行い、結果を測定してみましょう（例えば、<a href="https://dev.to/thegreengreek/show-me-the-money-justifying-performance-improvements-using-google-analytics-3231">Google Analytics</a>などを利用できます）。
こうした実験は、現実のデータに基づき、自社に合ったケーススタディを構築するのに役立ちます。
さらに、<a href="https://wpostats.com/">WPO Stats</a>上で公表されたケーススタディと実験データを利用することで、なぜパフォーマンスが重要なのか、それがユーザ体験と業績指標にどのような影響を与えるのか、これらに対する企業の感性が磨かれます。
ただし、パフォーマンスが重要だと主張するだけでは不十分です。
測定と追跡が可能な目標を定め、それを継続的に観測する必要があります。</p>
<p>そのためには、どうすればよいのでしょうか。Allison McKnightは、<a href="https://vimeo.com/album/4970467/video/254947097">長期的なパフォーマンスの向上</a>に関する講演の中で、Etsyにおいてパフォーマンスを重視する文化の確立をどのように促進したかに関する包括的なケーススタディを紹介しています（<a href="https://speakerdeck.com/aemcknig/building-performance-for-the-long-term">スライド</a>）。
最近では、Tammy Evertsが、小規模な組織と大規模な組織の両方で<a href="https://www.youtube.com/watch?v=SE0HhF4TO0Q">非常に高いパフォーマンスを上げるチームの習慣</a>について語っています。</p>
<p>こうした対話を組織内で実施するときは、UXがさまざまな体験のスペクトルであるのと同様に、<a href="https://medium.com/firebase-developers/how-fast-should-your-site-load-cfb14be48e8b">Webパフォーマンスにも幅がある</a>という点に留意するのが重要です。
<a href="https://mailchi.mp/perf.email/56?e=7a7df41374">Karolina Szczur</a>が述べているとおり、「1つの数値だけが望ましい評価をもたらすと考えるのは誤っています」。
したがって、パフォーマンスに関する目標は、きめ細かく、追跡可能で、目に見えるものである必要があります。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9b76f03b-6b76-4d18-9c54-f1280ba3e91b/conversion-rate-tracking-performance-szptss.jpg">
<em>モバイルでは、ユーザが体験する読み込み時間が速い場合、セッション当たりの収益は平均と比べて17％増加します。（<a href="https://mailchi.mp/perf.email/56?e=7a7df41374">Addy Osmani</a>による<a href="https://simplified.dev/performance/impact-of-web-performance">Impact of Web Performance</a>からの引用）</em></p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9e69134f-4ec0-4bb7-803b-ebce880b8029/bounce-rate-time-to-app-load-opt.png">
<em>1つの数値だけが望ましい評価をもたらすと考えるのは誤っています。（画像の出典：<a href="https://mailchi.mp/perf.email/56?e=7a7df41374">Karolina Czczur</a>による<a href="https://simplified.dev/performance/impact-of-web-performance">Performance is a distribution</a>からの引用）</em></p>
<h3>02. 目標：最も速い競合サイトよりも20％以上速くなることを目指す。</h3>
<p><a href="https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/#the-need-for-performance-optimization-the-20-rule">心理学的な調査</a>によれば、ユーザがあなたのWebサイトを競合サイトよりも速いと感じるには、比較対象との速度差が20％以上で速くなければなりません。
主要な競合サイトを調べ、こうしたサイトのモバイルとデスクトップにおけるパフォーマンス関連の指標を収集し、それらを上回るための基準値を設定しましょう。
ただし、正確な成果や目標を定めるには、まず自社サイトの分析を精査し、ユーザ体験の全体像を把握する必要があります。
その後は、90パーセンタイル値に相当するユーザ体験を再現し、テストしてみましょう。</p>
<p>競合サイトのパフォーマンスを把握する最初の一歩として、<a href="https://web.dev/fast/chrome-ux-report">Chrome UX Report</a>（CrUX。既製のRUMデータセット。Ilya Grigorikの<a href="https://vimeo.com/254834890">動画による紹介はこちら</a>、Rick Viscomiによる詳細なガイドはこちら）や、Chrome UX Reportに基づくRUMモニタリングツールである<a href="https://treo.sh/sites">Treo</a>を利用することができます。
データはChromeブラウザのユーザから収集されるため、レポートはChrome固有のものとなりますが、幅広い訪問者に関して、とても詳細なパフォーマンスの分布（最も重要なのはCore Web Vitalsのスコア）を知ることが可能です。
なお、新たなCrUXデータセットは毎月第2火曜日に公表されます。</p>
<p>他にも以下を利用することができます。</p>
<ul>
<li>Addy Osmaniの<a href="https://crux-compare.netlify.app/">Chrome UX Report Compare Tool</a></li>
<li><a href="https://www.thinkwithgoogle.com/feature/mobile/">Speed Scorecard</a>（収益への影響の推定も可能）</li>
<li><a href="https://ruxt.dexecure.com/compare">Real User Experience Test Comparison</a></li>
<li><a href="https://www.sitespeed.io/">SiteSpeed CI</a>（合成テストに基づく）</li>
</ul>
<p>注記：<a href="https://developers.google.com/speed/pagespeed/insights/">Page Speed Insights</a>や<a href="https://dev.to/addyosmani/monitoring-performance-with-the-pagespeed-insights-api-33k7">Page Speed Insights API</a>（非推奨とはなっていません）を使用する場合、CrUXのパフォーマンスデータは、単なる合計値ではなく特定ページのデータを取得できます。
このデータは、「ランディングページ」や「商品一覧」などのアセットにパフォーマンス目標を設定するときには、合計値よりもはるかに役立つ可能性があります。
バジェットのテストにCIを使用する場合において、CrUXを目標設定に使用したときは、テスト対象の環境がCrUXと一致するようにしてください（Patrick Meenanに感謝します）。</p>
<p>速度を重視する理由を示すのに助けが必要な場合、パフォーマンス不良遅いパフォーマンスによるコンバージョン率の低下や直帰率の上昇を可視化したい場合、あるいは組織内でRUMソリューションを提唱する必要がある場合は、Sergey Chernyshevが<a href="https://dev.to/addyosmani/monitoring-performance-with-the-pagespeed-insights-api-33k7">開発したUX Speed Calculator</a>を利用しましょう。
このオープンソースのツールは、データをシミュレーションし、可視化することで、あなたの意見を理解してもらうのに役立ちます。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b5eebba0-3123-4d14-8ead-4be33834e6c0/smashing-distribution-opt.png">
<em>CrUXは、Google Chromeのユーザからトラフィックを収集し、時系列のパフォーマンス分布の概要を作成します。<a href="https://g.co/chromeuxdash">Chrome UXダッシュボード</a>で独自のCrUXを作成することが可能です。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b5eebba0-3123-4d14-8ead-4be33834e6c0/smashing-distribution-opt.png">プレビューを拡大</a>）</em></p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/430e2362-e8f8-4db9-9ac2-2187fd638d52/16-ux-speed-calculator-front-end-performance-checklist-2020.png">
あなたの意見を理解してもらうために、パフォーマンスに関する証拠が必要なときは、<a href="https://ux-speed-calculator.netlify.com/">UX Speed Calculator</a>が便利です。これは実際のデータに基づき、パフォーマンスが直帰率、コンバージョン率、合計収益に与える影響を可視化します。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/430e2362-e8f8-4db9-9ac2-2187fd638d52/16-ux-speed-calculator-front-end-performance-checklist-2020.png">プレビューを拡大</a>）</p>
<p>時には、もっと詳しいデータが欲しいこともあるでしょう。
CrUXのデータを、すでに持っている他のデータと組み合わせ、競合サイトや自社プロジェクトのどこでパフォーマンスが遅くなり、どこに盲点があり、非効率な部分があるのかを迅速に見つけ出したい場合です。Harry Robertsは、自分の仕事に<a href="https://csswizardry.com/2020/11/site-speed-topography/">Site-Speed Topographyスプレッドシート</a>を利用しています。
彼はこのスプレッドシートを、主要なページの種類ごとにパフォーマンスを分析し、主要指標がどのように変わるかを追跡するのに使っています。
Google Sheets、Excel、OpenOfficeドキュメント、CSV形式で<a href="https://gumroad.com/l/site-speed-topography">スプレッドシートをダウンロード</a>できます。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cc19294f-7bed-4974-ab6f-6344b51e538c/milestones-chart-opt.png">
<em><a href="https://csswizardry.com/2020/11/site-speed-topography/">Topography</a>。主要指標がサイトの主なページごとに表示されている。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/cc19294f-7bed-4974-ab6f-6344b51e538c/milestones-chart-opt.png">プレビューを拡大</a>）</em></p>
<p>徹底的に追求したい場合は、（<a href="https://www.npmjs.com/package/lighthouse-parade">Lighthouse Parade</a>を通じて）<a href="https://cloudfour.com/thinks/big-picture-performance-analysis-using-lighthouse-parade/">サイトのすべてのページに対してLighthouseのパフォーマンス監査を実施することができます</a>。結果はCSV形式で保存可能です。
これは、競合サイトのどの特定のページ（またはページのタイプ）のパフォーマンスが悪い（または優れている）かや、何に重点的に取り組むべきかを特定するのに役立ちます（ただし、自社サイトなら<a href="https://github.com/GoogleChrome/web-vitals/">分析エンドポイントにデータを送信</a>する方が良いでしょう）。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/98a2d45b-e3b6-468b-994e-1bd6b08b0794/hero-lighthouse-parade-opt.png">
<em><a href="https://cloudfour.com/thinks/big-picture-performance-analysis-using-lighthouse-parade/">Lighthouse Parade</a>を使用すれば、サイトのあらゆるページに対してパフォーマンス監査を実施し、結果をCSV形式で保存できます。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/98a2d45b-e3b6-468b-994e-1bd6b08b0794/hero-lighthouse-parade-opt.png">プレビューを拡大</a>）</em></p>
<p>このようにデータを収集し、<a href="https://danielmall.com/articles/how-to-make-a-performance-budget/">スプレッドシート</a>（※訳注：原文指定URL消失）を設定し、時間を20％削減することで、目標（パフォーマンスバジェット）を確立します。
これで、テストで測定を行う準備ができました。
バジェットを気にかけながら、インタラクティブになるまでの時間（TTI）を高速化するためにペイロードを最小限にしようとしている場合、これが合理的な方法であると言えます。</p>
<p>始めるのにリソースが必要なら、以下を利用してみましょう。</p>
<ul>
<li>Addy Osmaniは、<a href="https://medium.com/%40addyosmani/start-performance-budgeting-dabde04cf6a3">パフォーマンスバジェット作成の始め方</a>、新機能の影響を定量化する方法、バジェットを超過している場合にどこから手をつけるべきかについて、とても詳しい記事を執筆しています。</li>
<li>Lara Hoganの<a href="https://designingforperformance.com/weighing-aesthetics-and-performance/#approach-new-designs-with-a-performance-budget">パフォーマンスバジェットからデザインにアプローチするためのガイド</a>は、デザイナーにとって便利なヒントを提供します。</li>
<li>Harry Robertsは、<a href="https://requestmap.webperf.tools/">Request Map</a>を使用して、サードパーティのスクリプトがパフォーマンスに与える影響を表示するための<a href="https://csswizardry.com/2018/05/identifying-auditing-discussing-third-parties/">Google Sheetsの設定ガイド</a>を公表しています。</li>
<li>Jonathan Fieldingの<a href="https://www.performancebudget.io/">Performance Budget Calculator</a>や、Katie Hempeniusの<a href="https://perf-budget-calculator.firebaseapp.com/">perf-budget-calculator</a>と<a href="https://browserdiet.com/calories/">Browser Calories</a>（※訳注：原文指定URL消失）は、バジェット作成の助けとなります（この情報を教えてくれた<a href="https://medium.com/%40fox/talk-the-state-of-the-web-3e12f8e413b3">Karolina Szczur</a>に感謝します）。</li>
<li>多くの企業では、パフォーマンスバジェットは、特定のポイントを超過しないための目安となるように、野心的ではなく現実的な内容に設定すべきです。この場合、過去2週間で最悪のデータを基準値として選び、それを出発点とするのも方法の一つです。<a href="https://csswizardry.com/2020/01/performance-budgets-pragmatically/">Performance Budgets, Pragmatically</a>という記事では、そのための戦略が紹介されています。</li>
<li>また、ビルドサイズを示したグラフ付きのダッシュボードを設定することで、パフォーマンスバジェットと現在のパフォーマンスの両方を可視化できます。そのためのツールは数多く存在しており、例を挙げると<a href="https://www.sitespeed.io/">SiteSpeed.ioダッシュボード</a>（オープンソース）、<a href="https://speedcurve.com/">SpeedCurve</a>、<a href="https://calibreapp.com/">Calibre</a>などがあります。<a href="https://perf.rocks/tools/">perf.rocks</a>では、さらに多くのツールを探すことができます。</li>
</ul>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fc5615ec-2ffd-4510-a94f-d781c17267a7/browser-calories-opt.png">
<em><a href="https://browserdiet.com/calories/">Browser Calories</a>は、パフォーマンスバジェットを設定し、ページがその数値を超過しているかどうかを測定するのに役立ちます。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fc5615ec-2ffd-4510-a94f-d781c17267a7/browser-calories-opt.png">プレビューを拡大</a>）</em></p>
<p>バジェットを設定したら、<a href="https://web.dev/fast/incorporate-performance-budgets-into-your-build-tools">Webpack Performance HintsとBundlesize</a>、<a href="https://github.com/GoogleChrome/lighthouse-ci">Lighthouse CI</a>、<a href="https://github.com/paulirish/pwmetrics">PWMetrics</a>や<a href="https://www.sitespeed.io/">Sitespeed CI</a>を利用してビルドのプロセスに組み込み、プルリクエストに対してバジェットを実行し、PRコメントにスコアの履歴を表示するようにします。</p>
<p>パフォーマンスバジェットをチーム全体に浸透させるには、<a href="https://web.dev/use-lighthouse-for-performance-budgets/">Lightwalletを通じてLighthouseにパフォーマンスバジェットを統合する</a>か、<a href="https://github.com/treosh/lighthouse-ci-action">LHCI Actionを使用してGitHub Actionsに手早く統合しましょう</a>。何らかのカスタマイズが必要な場合は、<a href="https://github.com/trulia/webpagetest-charts-api">webpagetest-charts-api</a>を利用できます。
これはWebPageTestの結果から図表を作成するエンドポイントのAPIです。</p>
<p>しかし、パフォーマンスバジェットだけでは、パフォーマンスに対する認識を高めることはできないでしょう。
<a href="https://medium.com/%40Pinterest_Engineering/a-one-year-pwa-retrospective-f4a2f4129e05">Pinterest</a>のように、カスタマイズされた<a href="https://medium.com/pinterest-engineering/a-one-year-pwa-retrospective-f4a2f4129e05#d6bc">ESLint</a>のルールを定めることで、依存関係が多く、バンドルのサイズを膨張させるファイルやディレクトリからのインポートを禁止できます。
また、チーム全体で共有できる「安全な」パッケージの一覧を設定しましょう。</p>
<p>さらに、ビジネスにとって最もメリットが大きい必要不可欠なカスタマータスクについて考えてみてください。
<strong>必要不可欠なアクションについて、許容できる速度の基準値</strong>に関する調査と議論を行い、その基準値を決定しましょう。
さらに、組織全体が承認した「UXを考慮した」<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance">User Timingの測定ポイント</a>を設定しましょう。
多くの場合、ユーザジャーニーは多様な部門の業務に関係します。
そのため、許容できる速度について合意できるか次第で、今後のパフォーマンスに関する議論が促進されるか妨げられるかが変わってきます。
追加的なリソースと機能による追加コストを可視化し、把握するようにしてください。</p>
<p>パフォーマンスに関する取り組みと、その他の技術的な取り組み（製品の新機能の開発、リファクタリング、世界中の新たなターゲット層へのリーチなど）の整合性を取るようにしましょう。
そうすれば、今後の展開について議論をするたびに、パフォーマンスについても一緒に議論することができます。
コードベースが新しい場合や、リファクタリングされたばかりの場合は、パフォーマンス目標を達成するのがはるかに簡単になります。</p>
<p>また、<a href="https://twitter.com/patmeenan">Patrick Meenan</a>が提案しているとおり、デザインプロセスの間に、<strong>読み込みのシーケンスとトレードオフについて計画すること</strong>は考慮に値します。
早いうちに必要不可欠な部分に優先順位をつけ、それが表示される順番を定めれば、表示を遅らせて構わないものも把握できます。
この順番はCSSとJavaScriptのインポートシーケンスも反映し、ビルドプロセスでこれらを扱いやすいようにするのが理想的です。
また、ページ読み込み中の「中間」の状態（例えば、Webフォントの読み込みが終わるまで）における視覚的なユーザ体験がどのようなものであるべきかについても検討しておきましょう。</p>
<p>パフォーマンスを重視する強固な文化を組織内で確立したら、過去の自社サイトに比べて20％高速化することを目指し、時が経っても優先順位を忘れないようにしましょう（Guy Podjarnyに感謝します）。
ただし、顧客のタイプと利用行動がさまざまであること（Tobias Baldaufは<a href="https://calendar.perfplanet.com/2020/y-u-no-revenue-cadence-cohorts-trained-behavior/">カデンスとコホート</a>と呼んでいます）や、ボットのトラフィックと季節的な影響も考慮してください。</p>
<p>とにかく計画することが大切です。プロジェクトの初期に、「手の届く所にある」最適化を即座に実行するのは魅力的で、すぐに成果を上げたい場合は良い戦略かもしれません。
しかし、計画を立てず、自社に合った現実的なパフォーマンス目標を定めない限り、パフォーマンスを優先し続けることはとても困難になるでしょう。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dbbae59c-44fa-4967-9598-33e56ab07475/10-treo-front-end-performance-checklist-2020.jpeg">
<em><a href="https://treo.sh/">Treo</a>は現実のデータに基づく競合分析を提供します。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dbbae59c-44fa-4967-9598-33e56ab07475/10-treo-front-end-performance-checklist-2020.jpeg">プレビューを拡大</a>）</em></p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0ae6761d-b6d6-4a0f-baa6-22e7543a3830/11-metrics-front-end-performance-checklist-2020.png">
<em>2020年初頭に新たな指標がLighthouse v6に導入されました。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/0ae6761d-b6d6-4a0f-baa6-22e7543a3830/11-metrics-front-end-performance-checklist-2020.png">プレビューを拡大</a>）</em></p>
<h3>03. 適切な指標を選択する。</h3>
<p><a href="https://speedcurve.com/blog/rendering-metrics/">すべての指標が同等に重要なわけではありません</a>。
自社のアプリケーションにとって、どの指標が最も重要であるかを調査しましょう。
通常は、インターフェースの最も重要なピクセルのレンダリングをどれだけ速く開始できるかや、これらのレンダリングされたピクセルへの<strong>入力に対してどれだけ速く応答できるか</strong>が重要となります。
何が重要な指標であるかを知ることで、現在の取り組みに対する最善の最適化目標が分かります。
最終的には、ユーザ体験の決め手となるのは読み込みイベントでもサーバの応答時間でもなく、UIがどれだけサクサク動くと感じられるかです。</p>
<p>どういうことかというと、ページ全体の読み込み時間（例えばonLoadやDOMContentLoadedなど）に注目するよりも、<a href="https://web.dev/user-centric-performance-metrics/">顧客の印象に合わせて</a>ページの読み込みに優先順位を付けるべきだという意味です。
つまり、注目すべき指標が微妙に異なっているのです。
実際、適切な指標の選択というプロセスにおいて、明確に選択すべき指標は存在しません。</p>
<p>Tim Kadlecの調査と、Marcos Iglesiasの<a href="https://docs.google.com/presentation/d/e/2PACX-1vTk8geAszRTDisSIplT02CacJybNtrr6kIYUCjW3-Y_7U9kYSjn_6TbabEQDnk9Ao8DX9IttL-RD_p7/pub?start=false&#x26;loop=false&#x26;delayms=10000&#x26;slide=id.g3ccc19d32d_0_98">講演</a>のメモによれば、<strong>従来の指標</strong>はいくつかのグループに分けられます。
通常、パフォーマンスを完全に把握するにはすべての指標が必要ですが、個別のケースでは一部の指標が他の指標よりも重要となります。</p>
<ul>
<li>数量ベースの指標は、複数のリクエスト、ウェイト、パフォーマンススコアを測定します。
アラートを設定したり、時系列の変化をモニタリングしたりするのには向いていますが、ユーザ体験の把握には向いていません。</li>
<li>マイルストーン指標（例えばTime To First ByteやTime To Interactiveなど）は、プロセスが読み込まれるまでの状態を利用します。
ユーザ体験の把握やモニタリングには向いていますが、複数のマイルストーン間で何が起きているかを把握するのには向きません。</li>
<li>レンダリング指標（例えばStart Render TimeやSpeed Indexなど）は、コンテンツのレンダリングの速さの推定値を提供します。
レンダリングのパフォーマンスの測定や修正には向いていますが、重要なコンテンツが表示されるタイミングや、そのコンテンツとのインタラクションが可能になるタイミングの測定には向きません。</li>
<li>カスタム指標（例えばTwitterの<a href="https://blog.alexmaccaw.com/time-to-first-tweet">Time To First Tweet</a>やPinterestの<a href="https://medium.com/%40Pinterest_Engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7">PinnerWaitTime</a>など）は、ユーザごとにカスタマイズされた特定のイベントを測定します。
ユーザ体験を正確に描写するのには向いていますが、指標を拡張したり、競合サイトと比較したりするのには向きません。</li>
</ul>
<p>全体像を把握するには、通常はこれらすべてのグループの有用な指標に注目します。
一般に、最も特別な意味を持ち、重要とされる指標を以下に紹介します。</p>
<ul>
<li><a href="https://calibreapp.com/blog/time-to-interactive/">Time to Interactive</a>（TTI）<br>
レイアウトが<strong>安定</strong>し、主要なWebフォントが表示され、メインスレッドがユーザの入力を十分に処理できるようになるまでの時間を表します。
つまり、ユーザとUIのインタラクションが可能になるまでの時間です。
ユーザがタイムラグなしでサイトを利用するためにどの程度待つ必要があるかを把握するための主要な指標です。
Boris Schapiraは<a href="https://blog.dareboost.com/en/2019/05/time-to-interactive-tti-measure-interactivity/">信頼性が高いTTIの測定方法</a>に関して詳細な記事を書いています。</li>
<li><a href="https://developers.google.com/web/updates/2018/05/first-input-delay">First Input Delay</a>（FID）、またはInput responsiveness<br>
ユーザが最初にサイトとのインタラクションを実施してから、ブラウザが実際にそのインタラクションに対して<strong>応答できる</strong>までの時間です。
ユーザがサイトと実際にインタラクションをするときに何が起きるかを把握できるため、TTIでは捕捉できない部分を補完する指標としてとても優れています。
これはRUMの指標としてのみ使用されることを意図しています。
ブラウザでFIDを測定するための<a href="https://github.com/GoogleChromeLabs/first-input-delay">JavaScriptライブラリ</a>も存在します。</li>
<li><a href="https://web.dev/lcp/">Largest Contentful Paint</a>（LCP）<br>
ページを読み込む過程において、ページの<strong>重要なコンテンツ</strong>が読み込まれる可能性が高い時点を示します。
前提として、ページの最も重要な要素は、<a href="https://medium.com/speedrank-app/new-performance-metric-what-is-largest-contentful-paint-dc784a497dd5">ユーザのビューポートに表示される最も大きな要素</a>であると想定しています。
スクロールしなくても見える範囲と、スクロールしなければ見えない範囲の両方で要素がレンダリングされる場合、見える範囲の部分のみが重要とみなされます。</li>
<li><a href="https://web.dev/tbt/">Total Blocking Time</a>（TBT）<br>
ページとのインタラクションが確実に可能になる前の時点で、その<a href="https://web.dev/tbt/">ページとのインタラクションが不可能である度合いの深刻さ</a>を定量化することに役立つ指標です（インタラクションが確実に可能であるとは、メインスレッドに、50ミリ秒以上を要するタスク（<a href="https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/">ロングタスク</a>）が存在しない時間が5秒以上続くことを指します）。
この指標は、最初の描画からTime to Interactive（TTI）までの間において、メインスレッドが一定時間にわたってブロックされており、入力への応答が妨げられていた時間の合計を測定するものです。
そのため、当然ながら、TBTが小さいことは良いパフォーマンスの目安となります。（ArtemとPhilに感謝します）。</li>
<li><a href="https://web.dev/cls">Cumulative Layout Shift</a>（CLS）<br>
この指標は、ユーザがサイトにアクセスしたときに、予期しない<strong>レイアウトシフト</strong>（ブラウザによるリフロー）（※訳注：ページ閲覧中に広告等の要素が読み込まれて、ガタンとコンテンツの位置がずれること）を体験する頻度を測定します。
これは、不安定な要素と、それが全体的なユーザ体験に与える影響を検証するものです。
このスコアは低いほど優れています。</li>
<li><a href="https://dev.to/borisschapira/web-performance-fundamentals-what-is-the-speed-index-2m5i">Speed Index</a><br>
ページのコンテンツがどれだけ速く目に見える形で表示されるかを測定します。
スコアが低いほど優れています。
Speed Indexのスコアは、<strong>視覚的な表示の速度</strong>に基づいて計算されますが、あくまで計算上の値です。
このスコアはビューポートのサイズにも影響されるため、ターゲット層に合わせてテスト上のさまざまな設定を定める必要があります。
LCPがより重要な指標となるにつれて、Speed Indexの重要性が低下していることに注意してください（<a href="https://twitter.com/borisschapira">Boris</a>（※訳注：原文指定URL消失）とArtemに感謝します）。</li>
<li>CPU使用時間<br>
メインスレッドが描画、レンダリング、スクリプティング、読み込み作業のためにブロックされた頻度と時間の長さを表す指標です。
CPU使用時間が長いことは、低品質なユーザ体験の明確な指標となります。
つまり、ユーザがアクションとレスポンスの間に、はっきりと分かるタイムラグを体験するということです。
WebPageTestでは、<a href="https://deanhume.com/ten-things-you-didnt-know-about-webpagetest-org/">"Chrome"タブで"Capture Dev Tools Timeline"を選択</a>することで、WebPageTestを使用している端末上で実行されるメインスレッドの内訳を明らかにすることができます。</li>
<li><a href="https://calendar.perfplanet.com/2019/javascript-component-level-cpu-costs/">Component-Level CPU Costs</a><br>
Stoyan Stefanovが提案したこの指標は、CPU使用時間と同様に、JavaScriptが<strong>CPUに与える影響</strong>を測定します。
基本的な考え方は、コンポーネント当たりのCPUインストラクションの回数を利用して、全体的なユーザ体験に対する影響を独立に把握するというものです。
<a href="https://calendar.perfplanet.com/2019/javascript-component-level-cpu-costs/">PuppeteerとChrome</a>を利用して実装できます。</li>
<li><a href="https://www.frustrationindex.com/">FrustrationIndex</a><br>
上記の指標の多くは特定のイベントが発生したタイミングを明らかにするものですが、Tim VereeckeのFrustrationIndexは指標を個別に見るのではなく、指標の間のギャップに注目します。
これは、Title is visible、First content is visible、Visually ready、Page looks readyなどのエンドユーザが体験する主要なマイルストーンに注目し、ページ読み込み中のフラストレーションの水準を示すスコアを算出します。
ギャップが大きいほど、ユーザがイライラする可能性は高くなります。
恐らく、ユーザ体験の優れたKPIになるでしょう。
Timは <a href="https://calendar.perfplanet.com/2019/frustrationindex-mind-the-gap/">FrustrationIndexとその機能に関する詳しい記事</a>を公表しています。</li>
<li><a href="https://calendar.perfplanet.com/2017/measuring-adweight/">Ad Weight Impact</a><br>
サイトが広告収入に依存している場合、広告関連のコードの重さを調べることは役に立ちます。
Paddy Gantiの<a href="https://calendar.perfplanet.com/2017/measuring-adweight/">スクリプト</a>は、2つのURL（1つは通常のURL、もう1つは広告をブロックしたもの）を構築し、WebPageTestを通じた比較動画の作成を促し、両者の差に関するレポートを生成します。</li>
<li><a href="https://phabricator.wikimedia.org/phame/live/7/post/117/performance_testing_in_a_controlled_lab_environment_-_the_metrics/">偏りに関する指標</a><br>
<a href="https://phabricator.wikimedia.org/phame/live/7/post/117/performance_testing_in_a_controlled_lab_environment_-_the_metrics/">Wikipediaのエンジニアが述べているとおり</a>、測定結果にどれだけの<strong>変動</strong>があるかというデータは、ツールをどこまで信頼すべきか、データの偏りと外れ値にどこまで注意すべきかに関して、有益な情報をもたらす可能性があります。
大きな変動は、設定を調整する必要があるというサインです。このデータは、例えばサードパーティのスクリプトが大きな変動の原因となっているなどの理由により、特定のページの測定値の信頼性が比較的低いことを把握するのにも役立ちます。
また、ブラウザの新しいバージョンが導入されたときに、パフォーマンスに支障がないか確認するために、ブラウザのバージョンを追跡するのも良い考えかもしれません。</li>
<li><a href="https://speedcurve.com/blog/user-timing-and-custom-metrics/">カスタム指標</a><br>
カスタム指標は、ビジネス上のニーズと顧客体験によって決まります。
それには、重要なピクセル、不可欠なスクリプト、必要なCSS、重要なアセットを特定し、それらがユーザにどれだけ速く提供されるかを測定する必要があります。
例えば、<a href="https://speedcurve.com/blog/web-performance-monitoring-hero-times/">Hero Rendering Times</a>をモニタリングしたり、<a href="https://css-tricks.com/breaking-performance-api/">Performance API</a>を使用したりすることで、ビジネスにとって重要なイベントについて特定のタイムスタンプを示すことができます。
また、テストの終了時に任意のJavaScriptを実行すれば、<a href="https://github.com/WPO-Foundation/webpagetest-docs/blob/master/user/custom_metrics.md">WebPageTestでカスタム指標を収集する</a>（※訳注：原文指定URL消失）ことも可能です。</li>
</ul>
<p>なお、<a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint">First Meaningful Paint</a>（FMP）が上記の概要に含まれていないことに注意してください。
FMPは、サーバが何らかのデータをどれだけ速く出力するかに関する情報を提供してきました。
FMPの時間が長いことは通常、JavaScriptがメインスレッドをブロックしていることを表していましたが、バックエンドやサーバの問題に関連している可能性もありました。
しかし、この指標は最近、約20％のケースで正確ではないとみられることが判明し、<a href="https://calendar.perfplanet.com/2019/developing-the-largest-contentful-paint-metric/">非推奨とされています</a>。
FMPは、信頼性が高く、解釈しやすいLCPにほとんど取って代わられています。
<a href="https://web.dev/first-meaningful-paint/">現在はLighthouseでもサポートされていません</a>。
<a href="https://web.dev/metrics/">最新のユーザ中心のパフォーマンス指標と推奨事項</a>をダブルチェックし、自社のページに問題がないことを確認しましょう（Patrick Meenanに感謝します）。</p>
<p>Steve Soudersは<a href="https://speedcurve.com/blog/rendering-metrics/">これらの指標の多くについて詳しく説明しています</a>。
重要な点として、Time-To-Interactiveはいわゆるラボ環境で自動化された監査を実行することによって測定されますが、First Input Delayは実際のユーザ体験を示すものであり、現実のユーザがはっきりと分かるタイムラグを体験したことを意味しています。
一般的には、両方を常に測定・追跡するのが良いでしょう。</p>
<p>アプリケーションの状況に応じて、好ましい指標は変わる可能性があります。
例えば、Netflix TVのUIにとっては<a href="https://medium.com/netflix-techblog/crafting-a-high-performance-tv-user-interface-using-react-3350e5a6ad3b">キー入力への応答性、メモリ使用、TTI</a>が特に決定的な意味を持ち、Wikipediaにとっては、<a href="https://phabricator.wikimedia.org/phame/live/7/post/117/performance_testing_in_a_controlled_lab_environment_-_the_metrics/">最初と最後の視覚的表示の変化と、CPU使用時間の指標</a>がより重要となります。</p>
<p>注記：FIDとTTIはともに、スクロールの挙動を考慮していません。
スクロールはメインスレッド外で処理されるため、独立的に発生する可能性があります。
そのため、コンテンツを消費するサイトの多くでは、これらの指標の重要性は大幅に低くなるかもしれません（Patrickに感謝します）。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5d80f91c-9807-4565-b616-a4735fcd4949/network-requests-first-input-delay.png">
<em>ユーザ中心のパフォーマンス指標は、実際のユーザ体験について、優れた情報を提供します。<a href="https://developers.google.com/web/updates/2018/05/first-input-delay">First Input Delay</a>（FID）は、まさにこれを実現することを目指す新たな指標です。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5d80f91c-9807-4565-b616-a4735fcd4949/network-requests-first-input-delay.png">プレビューを拡大</a>）</em></p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/7231a3c8-f610-4609-9829-27628aaf54bf/core-web-vitals-opt.jpg">
<em>新たなCore Web Vitalsの概要。LCP &#x3C; 2.5秒、FID &#x3C; 100ミリ秒、CLS &#x3C; 0.1（<a href="https://twitter.com/addyosmani/status/1257704191528599552/photo/1">Core Web Vitals</a>、<a href="https://twitter.com/addyosmani/status/1257704191528599552">Addy Osmani</a>のツイートより引用）。</em></p>
<h3>04. Core Web Vitalsを測定・最適化する。</h3>
<p>長い間、パフォーマンス指標はかなり技術的なものであり、サーバがどれだけ速く応答するか、ブラウザの読み込みがどれだけ速いかといったエンジニア側の視点に重点を置いていました。
こうした指標は、サーバのタイミングではなく、実際のユーザ体験を把握する方法を見つけ出すために、時とともに変化してきました。
2020年5月、GoogleはCore Web Vitalsを発表しました。
これはユーザに重点を置いた一連の新しいパフォーマンス指標で、各指標が別個のユーザ体験の要素を表します。</p>
<p>各指標について、Googleは許容できる速度の範囲の推奨目標を示しています。
この評価に合格するには、すべてのページビューの75％以上で「Good」の範囲を超える必要があります。
Core Web Vitalsは急速に広まり、2021年5月にはCore Web VitalsがGoogle検索ランキングシグナルに導入されたことで（ページエクスペリエンスのランキングアルゴリズムのアップデート）、多くの企業がパフォーマンススコアに関心を向けるようになりました。</p>
<p>ここでは、Core Web Vitalsを一つずつ見ていくとともに、これらの指標を考慮してユーザ体験を最適化するための便利なテクニックとツールを紹介します（この記事の一般的なアドバイスに従うことで、Core Web Vitalsスコアを改善できるでしょう）。</p>
<ul>
<li>
<p>Largest Contentful Paint （LCP）&#x3C; 2.5秒。</p>
<p>ページの読み込みを測定し、ビューポートに表示される最大の画像またはテキストブロックのレンダリング時間を報告します。
したがって、LCPは、サーバ応答時間の遅さ、ブロッキングCSS、実行中のJavaScript（ファーストパーティかサードパーティかを問わない）、Webフォントの読み込み、重いレンダリングや描画作業、読み込みが遅い画像、スケルトンスクリーン、クライアントサイドのレンダリングなど、重要な情報のレンダリングを遅らせるあらゆる要素の影響を受けます。</p>
<p>優れたユーザ体験を実現するには、LCPは、ページの読み込みが最初に開始されてから2.5秒以内とすべきです。
これは、ページ内で最初に表示される部分を可能な限り早くレンダリングする必要があることを意味します。
そのためには、各テンプレート向けにクリティカルCSSをカスタマイズし、 <code class="language-text">&lt;head&gt;</code> の順番を調整し、クリティカルなアセットを先読みすることが必要となります（これらの点については後で説明します）。</p>
<p>LCPスコアが低い主な理由は、通常は画像です。
Fast 3Gで2.5秒未満のLCPを達成するには（十分に最適化されたサーバでホスティングし、レンダリングはすべて静的で、クライアントサイドでのレンダリングは行わず、画像は専用の画像CDNによるものである場合）、理論上の画像の最大サイズはわずか約144KBとなります。
これが画像の応答性の高さや、（preloadによる）クリティカルな画像の早期の先読みが重要である理由です。</p>
<p>簡単なtips：ページ上で何がLCPの対象となるかを特定するには、DevToolsのパフォーマンスパネルの"Timings"のLCPバッジにカーソルを合わせてください（Tim Kadlecに感謝します）。</p>
</li>
<li>
<p>First Input Delay（FID）&#x3C; 100ミリ秒。</p>
<p>UIの応答性、すなわちユーザによる独立した入力イベント（タップやクリックなど）に反応できるようになる前に、ブラウザが他のタスクによってビジー状態となる時間の長さを測定します。
この指標は、メインスレッドが（特にページの読み込み中に）ビジー状態となることによる遅れを把握できるように設計されています。</p>
<p>目標はすべてのインタラクションにつき50～100ミリ秒を維持することです。
これを達成するには、ロングタスク（50ミリ秒を超える時間にわたってメインスレッドをブロックするタスク）を特定してそれを分割すること、バンドルを複数のまとまりにコード分割すること、JavaScriptの実行時間を短縮すること、データ取得を最適化すること、サードパーティのスクリプト実行を延期すること、WebワーカーによってJavaScriptをバックグラウンドスレッドに移動すること、プログレッシブハイドレーションを活用してSPAにおけるリハイドレーションコストを削減することが必要です。</p>
<p>簡単なtips：一般に、FIDスコアを改善するための信頼性が高い戦略は、大規模なバンドルを小規模なバンドルに分割して、ユーザが必要なときにバンドルを提供することで、メインスレッドの作業を最小化し、ユーザインタラクションの遅延を防ぐことです。この点については後で詳しく説明します。</p>
</li>
<li>
<p>Cumulative Layout Shift（CLS）&#x3C; 0.1。</p>
<p>UIの視覚的な安定性を測定することで、円滑で自然なインタラクションを確実にします。
この指標では、ページのライフスパン全体で発生したあらゆる予期しないレイアウトシフトについて、すべての個々のレイアウトシフトのスコアを合計します。
すでに表示されている要素のページ内の位置が変化した場合は常に、個々のレイアウトシフトが発生したとみなされます。
このスコアは、コンテンツのサイズと、移動した距離に基づいています。</p>
<p>シフトが発生するたびに（例えば、フォールバックフォントとWebフォントのフォントメトリックが異なる場合、広告、エンベッドやインラインフレームが遅れて表示される場合、画像や動画のアスペクト比が保存されない場合、CSSが遅いために再描画が必要になる場合、JavaScriptが遅いために変更が挿入される場合など）、CLSスコアに影響を与えます。
優れたユーザ体験として推奨されるCLSの値は0.1未満です。</p>
</li>
</ul>
<p>Core Web Vitalsが、予測可能な年1回のサイクルで、時とともに変化すると見込まれていることは注目に値します。
初年度のアップデートの可能性としては、First Contentful PaintがCore Web Vitalsに昇格すること、FIDの基準値が引き下げられること、シングルページアプリケーションのサポートが改善することなどが考えられます。
また、セキュリティ、プライバシー、アクセシビリティ（！）に関する考慮事項とともに、読み込み後のユーザ入力に対する応答のウェイトが大きくなる可能性もあります。</p>
<p>Core Web Vitalsに関しては、一見の価値がある有用なリソースや記事が数多く存在します。</p>
<ul>
<li>Web Vitals Leaderboardでは、モバイル、タブレット、デスクトップ、3Gと4Gでスコアを競合と比較することができます。</li>
<li>Core SERP Vitalsは、CrUXのCore Web VitalsをGoogle検索結果に表示できるChromeエクステンションです。</li>
<li>Layout Shift GIF Generatorは、シンプルなGIFでCLSを可視化します（コマンドラインでも利用できます）。</li>
<li>web-vitalsライブラリでは、Core Web Vitalsを収集し、それをGoogle - Analytics、Google Tag Managerなどの分析エンドポイントに送信できます。</li>
<li>Analyzing Web Vitals with WebPageTestでは、Patrick Meenanが、WebPageTestがCore Web Vitalsに関するデータをどのように明らかにするかを説明しています。</li>
<li>Optimizing with Core Web Vitalsは50分間の動画です。この動画では、Addy Osmaniが、eコマースのケーススタディでCore Web Vitalsを改善する方法を明らかにしています。</li>
<li>Cumulative Layout Shift in PracticeとCumulative Layout Shift in the Real Worldは、Nic Jansmaによる総合的な内容の記事です。これらの記事では、CLSに関するほとんどのテーマと、それが直帰率、セッションタイム、レイジクリック（狭いエリアでのクリックやタップの連打）などの主要な指標とどのように関係しているかについて扱っています。</li>
<li>What Forces Reflowは、JavaScriptでリクエストされたときや呼び出されたときに、ブラウザが同期してスタイルとレイアウトを計算するトリガーとなるプロパティやメソッドの一覧です。</li>
<li>CSS Triggersは、レイアウト、ペイント、コンポジットをトリガーするCSSプロパティの一覧です。</li>
<li>Fixing Layout Instabilityは、WebPageTestを使用して不安定なレイアウトの問題を特定・修正するためのガイドです。</li>
<li>Cumulative Layout Shift, The Layout Instability Metricは、Boris Schapiraが執筆したCLSに関するとても詳細なガイドで、CLSの計算、測定、最適化の方法を取り扱っています。</li>
<li>How To Improve Core Web Vitalsでは、各指標（FCP、TTI、TBTなどの他のWeb Vitalsを含む）や、それがいつ、どのように測定されるのかをSimon Hearneが詳細に説明しています。</li>
</ul>
<p>では、Core Web Vitalsとは<strong>追跡すべき究極の指標なのでしょうか？</strong>そうとは限りません。確かにCore Web Vitalsは、<a href="https://blog.cloudflare.com/start-measuring-web-vitals-with-browser-insights/">Cloudflare</a>、<a href="https://treo.sh/">Treo</a>、<a href="https://speedcurve.com/blog/web-vitals-user-experience/">SpeedCurve</a>、<a href="https://calibreapp.com/blog/core-web-vitals">Calibre</a>、<a href="https://calendar.perfplanet.com/2020/analyzing-web-vitals-with-webpagetest/">WebPageTest</a>（<a href="https://twitter.com/patmeenan/status/1346902718837895168">すでにフィルム型のビューに追加済み</a>）、<a href="https://blog.newrelic.com/product-news/w3c-context-trace-cumulative-layout-shift-measurement/">Newrelic</a>、<a href="https://apps.shopify.com/vitals-1">Shopify</a>、<a href="https://twitter.com/vercel/status/1259866549319618560">Next.js</a>、<a href="https://twitter.com/ChromiumDev/status/1266044527409639424">すべてのGoogleツール</a>（PageSpeed Insights、Lighthouse + CI、Search Consoleなど）やその他数多くのソリューションやプラットフォームを含め、ほとんどのRUMソリューションとプラットフォームにすでに導入されています。
しかし、Katie Sylor-Millerが<a href="https://sylormiller.com/posts/2020/core-web-vitals/">説明しているとおり</a>、Core Web Vitalsには、<a href="https://sylormiller.com/posts/2020/core-web-vitals/">対応ブラウザが限られていること</a>、実際はユーザ体験のライフサイクル全体を測定していないこと、FIDとCLSの変化をビジネスの成果と結びつけるのが困難であることといった大きな問題があります。</p>
<p>Core Web Vitalsには進化を期待すべきですが、当面の間は、パフォーマンス面の状況をよく把握できるように、Core Web Vitalsとカスタマイズ指標を常に組み合わせるのが賢明でしょう。</p>
<h3>05. ターゲット層の代表的な端末でデータを収集する。</h3>
<p>正確なデータを収集するには、テストを行う端末を徹底的に選び抜く必要があります。
ほとんどの企業では、最も一般的な端末のタイプに基づいてアナリティクスを検証し、ユーザプロファイルを構築すべきです。
しかし、アナリティクスだけでは全体像が分からないことはよくあります。
ターゲット層の大部分は、反応が遅すぎるというだけでサイトを離れる（そして戻ってこない）可能性があります。
その場合、こうしたユーザの端末は、アナリティクスで最も一般的な端末として表示される可能性は低いでしょう。
そのため、ターゲット層の一般的な端末に関して、追加調査を実施するのは良いアイデアかもしれません。</p>
<p>IDCによれば、2020年の世界の<a href="https://www.idc.com/promo/smartphone-market-share/os">スマートフォン出荷台数全体の84.8％（※訳注：原文執筆時）はAndroid端末</a>でした。
消費者は平均で<a href="https://www.cnbc.com/2019/05/17/smartphone-users-are-waiting-longer-before-upgrading-heres-why.html">2年ごとにスマートフォンをアップグレードしており</a>、米国では<a href="https://www.mobileworldlive.com/devices/news-devices/us-phone-upgrade-cycle-stretches-to-33-months/">スマートフォンの買い替えサイクルは33カ月</a>となっています。
世界で最もよく売れているスマートフォンの平均コストは200ドル未満とみられます。</p>
<p>上記よりもやや悲観的な想定に基づくと、代表的な端末は、<strong>2年以上使用されている</strong>Android端末で、価格は200ドル以下、通信規格は低速の3G、RTTは400ミリ秒、通信速度は400kbpsとなります。
これは当然、企業によって大きく異なる可能性がありますが、世の中の大部分の顧客に十分に近い想定であると言えます。
さらに、ターゲット市場の現在の<a href="https://www.amazon.co.uk/gp/bestsellers/electronics/356496011/ref=sr_bs_1">Amazonベストセラー</a>を確認するのは良いアイデアかもしれません。（このアドバイスをくれたTim Kadlec、Henri Helvetica、Alex Russellに感謝します）。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1436a0fc-40ed-4665-8fbb-bae8aa1ad740/amazon-bestsellers-opt.png">
<em>新たなサイトやアプリを開発するときは、現在のターゲット市場の<a href="https://www.amazon.co.uk/gp/bestsellers/electronics/356496011/ref=sr_bs_1">Amazonベストセラー</a>を必ず最初にチェックしましょう。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1436a0fc-40ed-4665-8fbb-bae8aa1ad740/amazon-bestsellers-opt.png">プレビューを拡大</a>）</em></p>
<p>では、どの端末をテストに選べばよいのでしょうか。その答えは、上記のプロファイルによく一致した端末です。<a href="https://twitter.com/katiehempenius/statuses/1067969800205422593">少し古いMoto G4/G5 Plus</a>、中価格帯のSamsung端末（Galaxy A50、S8）、Nexus 5X、Xiaomi Mi A3、Xiaomi Redmi Note 7などの優良な中級レベルの端末、Alcatel 1XやCubot X19などの遅い端末を、<a href="https://www.smashingmagazine.com/2016/11/worlds-best-open-device-labs/">オープンデバイスラボ</a>などでテストするのは良い選択肢の1つです。サーマルスロットリング済みのさらに遅い端末でのテストには、Nexus 4が利用できます。価格はわずか約100ドルです。</p>
<p>また、各端末で使用されているチップセットを確認し、<strong>1つのチップセットに対するテストを過剰に行わないようにしましょう</strong>。
SnapdragonやApple、ローエンドのRockchipやMediatekは数世代で十分です（Patrickに感謝します）。</p>
<p>手元に端末がない場合は、<strong>スロットリングした3Gネットワーク</strong>（例：RTTは300ミリ秒、下り1.6Mbps、上り0.8Mbps）とCPU（5倍減速）でモバイルのユーザ体験をデスクトップでエミュレートしてみましょう。
その後、通常の3G、遅い4G（例：RTTは170ミリ秒、下り9Mbps、上り9Mbps）、Wi-Fiへ徐々に切り替えていきます。パフォーマンスへの影響をより明確にするには、<a href="https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world">2G Tuesdays</a>を導入したり、<a href="https://twitter.com/thommaskelly/status/938127039403610112">スロットリングした3G/4Gネットワークをオフィスに設定</a>してテストを高速化したりすることもできます。</p>
<p>モバイル端末では、<a href="https://youtu.be/JvJ0v5OohNg?t=892">デスクトップマシンに比べてスピードが4～5倍遅くなる</a>と予想されることに注意しましょう。
モバイル端末のGPU、CPU、メモリ、バッテリーの特性はさまざまです。
そのため、平均的な端末のプロファイルを把握し、常に<a href="https://www.webpagetest.org/easy">そうしたデバイスでテストを行う</a>ことが重要です。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_800/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dfe1a4ec-2088-4e39-8a39-9f2010380a53/tuesday-2g-opt.png">
<em>1週間で接続が最も遅い日を決めるという手段もあります。Facebookは、接続が遅い環境への認識と感度を高めるため、<a href="https://www.theverge.com/2015/10/28/9625062/facebook-2g-tuesdays-slow-internet-developing-world">2G Tuesdays</a>という取り組みを導入しました。（<a href="https://www.businessinsider.com/facebook-2g-tuesdays-to-slow-employee-internet-speeds-down-2015-10?IR=T">画像の出典</a>）</em></p>
<p>幸運にも、データ収集を自動化したり、上記の指標に従ってWebサイトのパフォーマンスを時系列で測定したりするための素晴らしい選択肢は数多く存在します。パフォーマンスをよく把握するには、<a href="https://twitter.com/izzionfire/status/1326102215573041152">ラボデータとフィールドデータの両方</a>の複数のパフォーマンス指標をカバーする必要があることに注意しましょう。</p>
<ul>
<li><strong>合成テストツール</strong>は、事前に定めた端末とネットワークの設定に基づき、再現可能な環境でラボデータを収集します（Lighthouse、Calibre、WebPageTestなど）。</li>
<li><strong>リアルユーザモニタリング</strong>（RUM）ツールは、ユーザのインタラクションを継続的に評価し、フィールドデータを収集します（SpeedCurve、New Relicなど。これらのツールでは合成テストも可能です）。</li>
</ul>
<p>前者は、サービスを開発しつつ、パフォーマンスに関する問題を特定、分離、修正することに役立つので、開発中は特に便利です。
後者は、生のデータ、つまりユーザが実際にサイトにアクセスしたときのデータを測定し、パフォーマンスのボトルネックを把握するのに役立つので、長期的なメンテナンスに向いています。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API">Navigation Timing</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API">Resource Timing</a>、<a href="https://css-tricks.com/paint-timing-api/">Paint Timing</a>、<a href="https://w3c.github.io/longtasks/">Long Tasks</a>などのビルトインRUM APIを利用することで、合成テストツールとRUMは一体となってアプリケーションのパフォーマンスの全体像を明らかにします。<a href="https://calibreapp.com/">Calibre</a>、<a href="https://treo.sh/">Treo</a>、<a href="https://speedcurve.com/">SpeedCurve</a>、<a href="https://www.akamai.com/us/en/products/performance/mpulse-real-user-monitoring.jsp">mPulse</a>、<a href="https://github.com/akamai/boomerang">Boomerang</a>、<a href="https://www.sitespeed.io/">Sitespeed.io</a>を利用することもできます。これらはいずれも、パフォーマンスをモニタリングするための素晴らしい選択肢です。
さらに、<a href="https://www.smashingmagazine.com/2018/10/performance-server-timing/">Server Timingヘッダ</a>では、バックエンドとフロントエンドのパフォーマンスを1カ所でモニタリングすることも可能です。</p>
<p><strong>注記</strong>：スロットリングについては、ブラウザ外の<a href="https://calendar.perfplanet.com/2016/testing-with-realistic-networking-conditions/">ネットワークレベルで設定を行う</a>方が常に安全です。
その理由の1つとして、DevToolsには、導入方法の関係上、HTTP/2のプッシュとのインタラクションに問題があることが挙げられます（YoavとPatrickに感謝します）。
Mac OSでは<a href="https://nshipster.com/network-link-conditioner/">Network Link Conditioner</a>、Windowsでは<a href="https://github.com/WPO-Foundation/win-shaper/releases">Windows Traffic Shaper</a>、Linuxでは<a href="https://wiki.linuxfoundation.org/networking/netem">netem</a>、FreeBSDでは<a href="http://info.iet.unipi.it/~luigi/dummynet/">dummynet</a>を利用できます。</p>
<p>テストはLighthouseで実施する可能性が高いでしょう。
その場合は以下に留意してください。</p>
<ul>
<li><a href="https://github.com/GoogleChrome/lighthouse-ci">Lighthouse CIを使用</a>することで、Lighthouseスコアを時系列で追跡できます（<a href="https://twitter.com/_developit/status/1266112451155841024">とても素晴らしい</a>機能です）。</li>
<li><a href="https://calendar.perfplanet.com/2020/running-lighthouse-in-github-actions/">GitHub ActionsでLighthouseを実行</a>することで、PRのたびにLighthouseレポートを取得できます。</li>
<li>（<a href="https://www.npmjs.com/package/lighthouse-parade">Lighthouse Parade</a>を通じて）<a href="https://cloudfour.com/thinks/big-picture-performance-analysis-using-lighthouse-parade/">サイトのすべてのページに対してLighthouseのパフォーマンス監査を実施することができます</a>。結果はCSV形式で保存されます。</li>
<li><a href="https://twitter.com/TheRealNooshu/status/1273045993035005952">Lighthouse Scores Calculator</a>と<a href="https://twitter.com/HenriHelvetica/status/1237408016250687488">Lighthouse metric weights</a>を使用することで、必要に応じて詳細な情報を把握できます。</li>
<li>Lighthouseは<a href="https://addons.mozilla.org/en-US/firefox/addon/google-lighthouse/">Firefoxでも利用できます</a>が、内部でPageSpeed Insights APIを利用し、<a href="https://twitter.com/boostmarks/status/1261183488037961728">ヘッドレスChrome 79 User-Agentに基づいてレポートを作成します</a>（※訳注：原文指定URL消失）。</li>
</ul>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9c380575-7a95-48cc-bd49-08bbd2c006bd/lighthouse-ci-opt.png">
<em><a href="https://github.com/GoogleChrome/lighthouse-ci">Lighthouse CI</a>はとても素晴らしいツールで、Lighthouseの継続的な実行、その結果の保存と取得、結果に対するアサーションが可能です。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9c380575-7a95-48cc-bd49-08bbd2c006bd/lighthouse-ci-opt.png">プレビューを拡大</a>）</em></p>
<h3>06. テスト用の「クリーン」な「顧客」プロファイルを設定する。</h3>
<p>パッシブなモニタリングツールでテストを実行する場合、（<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiple_profiles">Firefox</a>（※訳注：原文指定URL消失）と<a href="https://support.google.com/chrome/answer/2364824?hl=en&#x26;co=GENIE.Platform=Desktop">Chrome</a>において）偏った結果を避けるために、アンチウイルスソフトやバックグラウンドのCPUタスクをオフにする、バックグラウンドの帯域幅転送を除外する、ブラウザ拡張機能がインストールされていないクリーンなユーザプロファイルでテストを行うといった戦略がよく使われます。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/78d6672a-013c-4b55-b258-7efd153a30d9/chrome-extension-page-cpu-time-opt.png">
<em>DebugBearのレポートは、パスワードマネージャ、アドブロッカ、EvernoteやGrammarlyといった人気のアプリケーションなど、<a href="https://www.debugbear.com/blog/2020-chrome-extension-performance-report">遅い拡張機能ワースト20</a>を明らかにしています。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/78d6672a-013c-4b55-b258-7efd153a30d9/chrome-extension-page-cpu-time-opt.png">プレビューを拡大</a>）</em></p>
<p>しかし、顧客がどの<strong>ブラウザ拡張機能</strong>を頻繁に使用しているかを調査し、専用の「顧客」プロファイルに基づいてテストを実施するのも良いアイデアです。
実際、一部の拡張機能はアプリケーションの<a href="https://twitter.com/denar90_/statuses/1065712688037277696">パフォーマンスに重大な影響を与える</a>可能性があります（<a href="https://www.debugbear.com/blog/2020-chrome-extension-performance-report">2020 Chrome Extension Performance Report</a>）。
ユーザがその拡張機能を大量に使用する場合、それを事前に織り込んでおくべきかもしれません。したがって、「クリーン」なプロファイルのみによるテスト結果は楽観的過ぎて、現実のシナリオでは悲惨な状況になる可能性があります。`</p>
<h3>07. 同僚とパフォーマンス目標を共有する。</h3>
<p>今後の誤解を避けるために、チームのあらゆるメンバーがパフォーマンス目標をよく理解するようにしましょう。
デザインにせよ、マーケティングにせよ、その中間の何かにせよ、あらゆる意思決定は<strong>パフォーマンスに影響</strong>します。
チーム全体に責任とオーナーシップを分配することは、その後のパフォーマンスに重点を置いた意思決定の合理化につながります。
デザインに関する意思決定と、パフォーマンスバジェットや早期に定めた優先事項の対応関係を明らかにしましょう。</p>
<h2>現実的な目標の設定 <a href="#02">#</a><a name="02"></a></h2>
<h3>08. 応答時間100ミリ秒、60fps。</h3>
<p>インタラクションがスムーズに感じられるには、インターフェースがユーザの入力から100ミリ秒以内に応答する必要があります。
それ以上遅いと、ユーザはアプリにタイムラグがあると感じます。
<a href="https://www.smashingmagazine.com/2015/10/rail-user-centric-model-performance/">ユーザ中心主義のパフォーマンスモデルであるRAIL</a>は、<strong>妥当な目標</strong>を掲げています。
その目標とは、応答時間を100ミリ秒未満にするには、遅くとも50ミリ秒未満ごとにメインスレッドを解放するようにページを作成しなければならないというものです。
<a href="https://developers.google.com/web/tools/lighthouse/audits/estimated-input-latency">Estimated Input Latency</a>は、この基準値を満たしているかどうかを明らかにします。
理想的には、この値は50ミリ秒未満であるべきです。
アニメーションなどの負荷が大きい部分では、可能な場合は他に何も処理せず、不可能な場合は処理を絶対的な最小限に抑えるのが望ましいと言えます。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/c91c910d-e934-4610-9dc5-369ec9071b57/rail-perf-model-opt.png">
<em><a href="https://developers.google.com/web/fundamentals/performance/rail">RAIL</a>はユーザ中心主義のパフォーマンスモデル。</em></p>
<p>また、アニメーションの各フレームは16ミリ秒未満とし、1秒間のフレーム数が60フレーム（1秒÷60=16.6ミリ秒）となるようにすべきです。
なるべく1フレームを10ミリ秒未満にするのが望ましいと言えます。
ブラウザは新たなフレームを画面に描画するのに時間がかかるため、16.6ミリ秒の基準値に達する前にコードの実行が終了するようにすべきです。
120fpsに関する議論はすでに始まっており（例えば、iPad Proの画面のリフレッシュレートは120Hz）、Surmaは<a href="https://dassur.ma/things/120fps/">120fpsを実現するためのレンダリングパフォーマンスソリューション</a>についての記事を執筆していますが、現時点では120fpsを目指さなくてもよいでしょう。</p>
<p>パフォーマンスを予想するときは悲観的であるべきですが、<a href="https://www.smashingmagazine.com/2016/11/true-lies-of-optimistic-user-interfaces/">インターフェースをデザインするときは楽観的であるべき</a>であり、<a href="https://philipwalton.com/articles/idle-until-urgent/">アイドルタイムは賢明に活用すべき</a>です（<a href="https://github.com/GoogleChromeLabs/idlize">idlize</a>、<a href="https://github.com/TehShrike/idle-until-urgent">idle-until-urgent</a>、react-idleをチェックしましょう）。
当然ながら、上記の目標は読み込みのパフォーマンスではなく、ランタイムのパフォーマンスに適用されます。</p>
<h3>09. 3GでFID&#x3C;100ミリ秒、LCP&#x3C;2.5秒、TTI&#x3C;5秒。クリティカルなファイルの容量は170KB未満（gzip形式で圧縮した場合）。</h3>
<p>最終的な目標としては、（達成するのはとても困難かもしれませんが）<a href="https://www.youtube.com/watch?v=_srJ7eHS3IM&#x26;feature=youtu.be&#x26;t=6m21s">Time To Interactiveは5秒未満</a>、リピート訪問については2秒未満（サービスワーカーによってのみ達成可能）とするのが良いでしょう。
Largest Contentful Paintは2.5秒未満を目指し、Total Blocking TimeとCumulative Layout Shiftを最小化しましょう。
許容できるFirst Input Delayは70～100ミリ秒未満です。
上記のとおり、低速な3Gネットワークに接続された200ドルのAndroidスマートフォン（Moto G4など）を、400ミリ秒のRTTと400kbpsの転送速度によってエミュレートしたものを基準とします。</p>
<p>Web上のコンテンツを迅速に提供するには、2つの大きな制約があり、それが妥当なファイル容量を実質的に決める要因となります。
まず、<a href="https://hpbn.co/building-blocks-of-tcp/#slow-start">TCP Slow Start</a>による<strong>ネットワークデリバリの制約</strong>があります。
HTMLの最初の14KB（10個のTCPパケットが各1460バイトで約14.25 KB。
<a href="https://www.tunetheweb.com/blog/critical-resources-and-the-first-14kb/">ただし、鵜呑みにすべきではありません</a>）は、最もクリティカルなペイロードのチャンクであり、バジェットのうち最初のラウンドトリップで提供できる唯一の部分です（モバイルのウェイクアップタイムの関係上、RTTが400ミリ秒の場合に1秒間で受信できるのはこの部分に限られます）。</p>
<p><img src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9c5bf6fb-5027-4388-abd2-4355b9c8994f/new-congestion-control-opt.png">
<em>TCP接続では、小規模な輻輳ウィンドウからスタートして、ラウンドトリップごとにウィンドウを2倍に拡大します。最初のラウンドトリップでは14KBを提供することが可能です。出典：<a href="https://hpbn.co/building-blocks-of-tcp/#slow-start">High Performance Browser Networking</a>（Ilya Grigorik著）。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9c5bf6fb-5027-4388-abd2-4355b9c8994f/new-congestion-control-opt.pngv">プレビューを拡大</a>）</em></p>
<p>もう1つの制約として、JavaScriptのパーシングと実行時間の関係上、メモリとCPUに対する<strong>ハードウェアの制約</strong>があります（これらについては後で詳しく説明します）。
最初のパラグラフで述べた目標を達成するには、JavaScriptにとってクリティカルなファイルの容量のバジェットを考慮することが必要です。
バジェットの適切な容量についてはさまざまな意見があります（プロジェクトの性質にも大きく依存します）が、170KBのJavaScriptファイルをgzip形式で圧縮した場合、中価格帯のスマートフォンではパーシングとコンパイルに最大で1秒かかります。
170KBのファイルを解凍すると容量が3倍（0.7MB）になると想定すると、それだけでMoto G4/G5 Plusでは「まとも」なユーザ体験が失われかねません。</p>
<p>Wikipediaのサイトの場合、2020年に、<a href="https://twitter.com/MonsieurPerf/status/1252184196426104832">コードの実行速度はWikipediaのユーザにとって世界全体で19％速くなりました</a>。
ですから、もしWebパフォーマンスの指標に前年比で変化がない場合、それは通常、環境の継続的な改善に伴って、自社サイトが実質的に後退しているという警戒すべきサインです（<a href="https://techblog.wikimedia.org/2020/05/07/measuring-the-performance-of-wikipedia-visitors-devices/">詳細はGilles Dubucのブログ記事を参照</a>）。</p>
<p>東南アジア、アフリカ、インドなどの成長中の市場をターゲットとする場合、まったく異なる制約に直面することになります。
Addy Osmaniは<a href="https://dev.to/addyosmani/loading-web-pages-fast-on-a-20-feature-phone-8h6">フィーチャーフォンの主な制約</a>（例えば、低コストの優良な端末は少数、高品質なネットワークは利用できない、モバイルデータ通信のコストが大きい）、<strong>PRPL-30バジェット</strong>、こうした環境における開発のガイドラインについて述べています。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/02143033-61ad-4808-bf3e-9c5f6a515927/12-30kb-front-end-performance-checklist-2020.png">
<em><a href="https://dev.to/addyosmani/loading-web-pages-fast-on-a-20-feature-phone-8h6">Addy Osmaniによれば</a>、遅延読み込み経路における推奨容量も35KB未満です。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/02143033-61ad-4808-bf3e-9c5f6a515927/12-30kb-front-end-performance-checklist-2020.png">プレビューを拡大</a>）</em></p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d9d1033f-f45f-4789-aca1-1bb61fbd44c5/13-prpl-budget-front-end-performance-checklist-2020.jpeg">
<em>Addy Osmaniは、フィーチャーフォンをターゲットとする場合のPRPL-30パフォーマンスバジェット（gzip形式で圧縮・軽量化した初期バンドル30KB）を<a href="https://dev.to/addyosmani/loading-web-pages-fast-on-a-20-feature-phone-8h6">提唱しています</a>。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d9d1033f-f45f-4789-aca1-1bb61fbd44c5/13-prpl-budget-front-end-performance-checklist-2020.jpeg">プレビューを拡大</a>）</em></p>
<p>実際、GoogleのAlex Russellは、妥当な容量の上限として<a href="https://infrequently.org/2017/10/can-you-afford-it-real-world-web-performance-budgets/">gzip形式で130～170KBを目指すこと</a>を推奨しています。
現実には、ほとんどのサービスはこの上限に近づいてすらいません。
現在のバンドル容量の中央値は<a href="https://beta.httparchive.org/reports/state-of-javascript#bytesJs">約452KB</a>で、2015年初めと比べて53.6％増加しています。
これはミドルクラスのモバイル端末で12～20秒のTime To Interactiveに相当します。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1b311ffb-7c1e-442c-8122-53ee39fe5b7b/11-perf-phones-front-end-performance-checklist-2020.png">
<em>上記のグラフは、2019年に世界で最も売れたスマートフォンについて、GeekbenchでCPUパフォーマンスのベンチマークを比較したものです。JavaScriptはシングルコアのパフォーマンスにとって負担となり（他のWebプラットフォームに比べて本質的にシングルスレッドとなりやすいことに注意してください）、CPUの制約を受けます。Addyの記事「<a href="https://dev.to/addyosmani/loading-web-pages-fast-on-a-20-feature-phone-8h6">Loading Web Pages Fast On A $20 Feature Phone</a>」より引用。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/1b311ffb-7c1e-442c-8122-53ee39fe5b7b/11-perf-phones-front-end-performance-checklist-2020.png">プレビューを拡大</a>）</em></p>
<p>しかし、バンドル容量のバジェットを超えることもできます。
例えば、ブラウザのメインスレッドのアクティビティ、つまりレンダリング開始前の描画時間に基づいてパフォーマンスバジェットを設定することや、<a href="https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/">フロントエンドでCPUに大きな負荷をかけている存在を見つけ出すことが可能です</a>。
<a href="https://calibreapp.com/">Calibre</a>、<a href="https://speedcurve.com/">SpeedCurve</a>、<a href="https://github.com/siddharthkp/bundlesize">Bundlesize</a>などのツールは、バジェットを管理するのに役立ち、ビルドのプロセスに統合できます。</p>
<p>最後に、パフォーマンスのバジェットはおそらく<strong>固定すべきではありません</strong>。
ネットワーク接続に合わせて、<a href="https://twitter.com/katiehempenius/status/1075478356311924737">パフォーマンスのバジェットは調整すべきです</a>。
ただし、接続が遅くなると、どのように利用してもペイロードは大幅に「重く」なります。</p>
<p><strong>注記</strong>：HTTP/2が普及し、<a href="https://www.speedtest.net/ookla-5g-map">5G</a>と<a href="https://twitter.com/FredKSchott/status/1313910775199612929">HTTP/3</a>の登場が近づき、スマートフォンが急速に進化し、SPAが繁栄するなかで、上記のような厳格なバジェットを設定するのは奇妙に思えるかもしれません。
しかし、ネットワークの輻輳、インフラ開発の遅さ、<a href="https://youtu.be/JvJ0v5OohNg?t=397">データ上限</a>、プロキシブラウザ、<a href="https://timkadlec.com/remembers/2019-08-29-save-data-usage/">省データモード</a>から隠れたローミング手数料に至るまで、ネットワークやハードウェアの予測不能な性質に対処するときには、こうしたバジェットは合理的に感じられるはずです。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3bb4ab9e-978a-4db0-83c3-57a93d70516d/file-size-budget-fast-default-addy-osmani-opt.png">
<em><a href="https://speakerdeck.com/addyosmani/fast-by-default-modern-loading-best-practices">Fast By Default:Modern loading best practices</a>（Addy Osmani著）より（スライド19）</em></p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/949e5601-04e7-48ee-91a5-10bd7af19a0f/perf-budgets-network-connection.jpg">
<em>パフォーマンスのバジェットは、平均的なモバイル端末のネットワークの状況に応じて調整すべきです。（画像の出典：<a href="https://twitter.com/katiehempenius/status/1075478356311924737">Katie Hempenius</a>）（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/949e5601-04e7-48ee-91a5-10bd7af19a0f/perf-budgets-network-connection.jpg">プレビューを拡大</a>）</em></p>
<h2>環境の定義<a href="#03">#</a><a name="03"></a></h2>
<h3>10. ビルドツールを選択・設定する。</h3>
<p><a href="https://24ways.org/2017/all-that-glisters/">現在、流行しているツールに気をとられすぎないようにしましょう</a>。
Gruntにせよ、Gulpにせよ、Webpackにせよ、Parcelにせよ、あるいは複数のツールの組み合わせにせよ、自分のビルド環境にこだわるべきです。
必要な成果を出していて、ビルドのプロセスを維持するのに支障がない限り、それで問題ありません。</p>
<p>ビルドツールのなかでは、Rollupや<a href="https://www.snowpack.dev/">Snowpack</a>の勢いが強まっていますが、最も定評があるのはWebpackのようです。
Webpackでは、ビルドの容量を最適化するために、文字どおり何百ものプラグインが利用できます。
<a href="https://webpack.js.org/blog/2020-12-08-roadmap-2021/">Webpack Roadmap 2021</a>に注目しましょう。</p>
<p>最近登場した特に注目すべき戦略の1つは、<a href="https://web.dev/granular-chunking-nextjs/">Next.jsとGatsbyにおいてWebpackでグラニュラチャンキングを行い</a>、コードの重複を最小化することです。
デフォルトでは、すべてのエントリポイントで共有されていないモジュールは、それを利用しないルートでもリクエストされる可能性があります。
その結果、必要以上にコードがダウンロードされ、オーバーヘッドが発生します。
Next.jsにおけるグラニュラチャンキングでは、<strong>サーバサイドのビルドマニフェストファイル</strong>を利用して、出力されたどのチャンクをさまざまなエントリポイントで使用するかを決定できます。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/733b3ac0-489e-44d5-b7ed-bcfa67a6a575/js-size-reductions-across-all-routes.jpg">
<em>Webpackプロジェクトのコードの重複を削減するためにgranular chunkingを利用できます。Next.jsとGatsbyではデフォルトで有効です。画像の出典：<a href="https://twitter.com/addyosmani/status/1256153891135258624">Addy Osmani</a>。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/733b3ac0-489e-44d5-b7ed-bcfa67a6a575/js-size-reductions-across-all-routes.jpg">プレビューを拡大</a>）</em></p>
<p><a href="https://webpack.js.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a>では、いくつかの条件に応じて複数の分割済みのチャンクを作成し、複数のルートで重複したコードを取得することを防ぎます。
これはページの読み込み時間や、操作中のキャッシングを改善します。
この機能はNext.js 9.2とGatsby v2.20.7に搭載されています。</p>
<p>とはいえ、Webpackを始めるのは難しいかもしれません。
そこで、Webpackの世界に飛び込みたい人のために、素晴らしいリソースを紹介します。</p>
<ul>
<li><a href="https://webpack.js.org/concepts/">Webpackのドキュメント</a>は、当然ながら、良い出発点となります。Raja Raoの<a href="https://medium.com/%40rajaraodv/webpack-the-confusing-parts-58712f8fcad9">Webpack — The Confusing Bits</a>や、Andrew Welchの<a href="https://medium.com/%40rajaraodv/webpack-the-confusing-parts-58712f8fcad9">An Annotated Webpack Config</a>も最初の一歩に適しています。</li>
<li>Sean Larkinは<a href="https://webpack.academy/p/the-core-concepts">Webpack:The Core Concepts</a>という無料の講義を提供しています。Jeffrey Wayも<a href="https://laracasts.com/series/webpack-for-everyone">Webpack for Everyone</a>という素晴らしい無料の講義を公開しています。どちらもWebpackの導入として優れた内容です。</li>
<li><a href="https://frontendmasters.com/courses/webpack-fundamentals/">Webpack Fundamentals</a>は、FrontendMastersが公開したSean Larkinによる4時間の講義で、とても包括的な内容となっています。</li>
<li><a href="https://github.com/webpack/webpack/tree/master/examples">Webpack examples</a>は、トピックと目的別に、すぐに使えるWebpack設定を数多く公開しています。さらに、基本設定ファイルを生成する<a href="https://webpack.jakoblind.no/">Webpack設定のコンフィギュレータ</a>もあります。</li>
<li><a href="https://github.com/webpack-contrib/awesome-webpack">awesome-webpack</a>は、Webpackに関する便利なリソース、ライブラリ、ツールを厳選したリストです。記事、動画、講義、書籍や、Angular、Reactやフレームワークを問わないプロジェクトの例も含まれています。</li>
<li><a href="https://codeascraft.com/2020/02/03/production-webpack-builds/">The journey to fast production asset builds with Webpack</a>はEtsyのケーススタディです。EtsyがどのようにRequireJSベースのJavaScriptビルドシステムからWebpackへ移行し、どうやってビルドを最適化し、13,200を超えるアセットを平均<strong>4分</strong>で管理しているかを説明しています。
<a href="https://twitter.com/iamakulov/status/1275769142809944064">Webpack performance tips</a>は、Ivan Akulovによる宝の山のようなスレッドです。パフォーマンスに焦点を当てた数多くのtipsを紹介しており、その中には<a href="https://twitter.com/iamakulov/status/1275819105644412942">特にWebpackに焦点を当てたものもあります</a>。</li>
<li><a href="https://github.com/iamakulov/awesome-webpack-perf">awesome-webpack-perf</a>というGitHubリポジトリは、パフォーマンス向上のための便利なWebpackツールとプラグインの宝庫です。こちらもIvan Akulovがメンテナンスしています。</li>
</ul>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/df28a3b5-b899-4a9e-93d1-be97569e9198/etsy-journey-fast-production-builds-webpack.jpg">
<em>Etsyが<a href="https://codeascraft.com/2020/02/03/production-webpack-builds/">Webpackによって本番環境用の高速なビルドを実現するまでの道のり</a>（<a href="https://twitter.com/addyosmani/status/1240563662143668224">Addy Osmani</a>より）（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/df28a3b5-b899-4a9e-93d1-be97569e9198/etsy-journey-fast-production-builds-webpack.jpg">プレビューを拡大</a>）</em></p>
<h3>11. プログレッシブエンハンスメントをデフォルトで使用する。</h3>
<p><a href="https://briefs.video/videos/is-progressive-enhancement-dead-yet/">プログレッシブエンハンスメント</a>は、提唱されてから何年も経ちますが、それでもフロントエンドのアーキテクチャやデプロイの指針としておくのが無難です。
まずは中心となるユーザ体験の設計・開発を行い、それから先進的な機能によって対応ブラウザのユーザ体験を向上させることで、ユーザ体験を<a href="https://resilientwebdesign.com/">強固</a>にすることができます。貧弱な画面とブラウザを搭載した遅いマシンが、最適化されていないネットワークからアクセスしてもWebサイトの動作が速いのならば、優れたブラウザを搭載した高速なマシンが、真っ当なネットワークからアクセスすればもっと速く動くはずです。</p>
<p>実際、<a href="https://www.youtube.com/watch?v=puUPpVrIRkc&#x26;t=488s">アダプティブなモジュール提供</a>によって、プログレッシブエンハンスメントは新たなレベルに進んだように感じられます。
これは、ローエンドの端末には中核のみの「ライト」なユーザ体験を提供し、ハイエンドの端末では洗練された機能によってユーザ体験を向上させるというものです。
プログレッシブエンハンスメントは、当面は消えないでしょう。</p>
<h3>12. パフォーマンスの強固な基準を選択する。</h3>
<p>読み込みに影響を与える未知の要因は数多くあります。
例えば、ネットワーク、サーマルスロットリング、キャッシュエビクション、サードパーティのスクリプト、パーサのブロッキングパターン、ディスクI/O、IPCレイテンシ、インストール済みの拡張機能、アンチウイルスソフトウェアとファイアウォール、バックグラウンドのCPUタスク、ハードウェアとメモリの制約、L2とL3のキャッシングの差、RTTSなどです。
その中でも<a href="https://v8.dev/blog/cost-of-javascript-2019">JavaScript</a>は、レンダリングをデフォルトでブロックするWebフォントや、メモリを使いすぎることが多い画像に次いで、ユーザ体験の中で特にコストが重い部分となっています。
パフォーマンスのボトルネックが<a href="https://calendar.perfplanet.com/2017/tracking-cpu-with-long-tasks-api/">サーバからクライアントへ移動している</a>ことを踏まえ、私たち開発者はこうした未知の要因のすべてをもっと詳しく検討する必要があります。</p>
<p>170KBのバジェットには、すでにクリティカルパスHTML/CSS/JavaScript、ルータ、状態管理、ユーティリティ、フレームワーク、アプリケーションロジックが含まれているため、選択したフレームワークの<a href="https://www.twitter.com/kristoferbaxter/status/908144931125858304">ネットワーク転送コスト、パース/コンパイル時間、ランタイムコストを徹底的に検証</a>（※訳注：原文指定URL消失）しなければなりません。
幸運なことに、過去数年間で、ブラウザによるスクリプトのパースとコンパイルの速度は大幅に改善しています。
しかし、JavaScriptの実行は依然として主要なボトルネックとなっているため、スクリプトの実行時間とネットワークによく注意すれば大きな効果があるでしょう。</p>
<p>Tim Kadlecは、モダンなフレームワークのパフォーマンスについて素晴らしい調査を実施しており、その内容を"<a href="https://timkadlec.com/remembers/2020-04-21-the-cost-of-javascript-frameworks/">JavaScript frameworks have a cost</a>"という記事にまとめています。
私たちはスタンドアロンのフレームワークの影響についてよく議論しますが、Timが述べているとおり、<strong>実際には複数のフレームワークを利用する</strong>ことは珍しくありません。
例えば、モダンなフレームワークにゆっくりと移行しつつある旧バージョンのjQueryと、旧バージョンのAngularを利用したいくつかの古いアプリケーションを併用しているかもしれません。
そのため、JavaScriptバイト数とCPU実行時間の<strong>累積コスト</strong>を調査する方が合理的です。
この累積コストによって、たとえハイエンド端末でも、ぎりぎり利用できるレベルのユーザ体験までたちまち落ち込んでしまう可能性があります。</p>
<p>一般に、モダンなフレームワークは、<strong>あまり高性能でない端末を重視していません</strong>。
そのため、スマートフォンとデスクトップにおけるユーザ体験は、パフォーマンスの面で劇的に異なることがよくあります。
調査によれば、ReactやAngularを利用したサイトは、他のサイトよりもCPU時間が長い傾向があります（当然ながら、必ずしもReactがVue.jsよりもCPUにとって高コストという意味ではありません）。</p>
<p>Timによれば、一つ明確に言えるのは、「サイトのビルドにフレームワークを使用する場合、たとえ最善のシナリオであっても、<strong>初期のパフォーマンス</strong>に関するトレードオフが発生する」ということです。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f892dfcd-f690-40b5-ad33-218a33cc85b3/cost-of-frameworks-cpu-mobile-only.png">
<img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/876d32d5-0a68-4a08-b3f1-d4c103729cfa/cost-of-frameworks-bytes-desktop.png">
<em>モバイル端末のスクリプト関連のCPU時間と、デスクトップ端末のJavaScriptバイト数。一般に、ReactやAngularを利用しているサイトは、他のサイトよりもCPU時間が長い傾向があります。しかし、これはサイトをビルドする方法によって変わります。<a href="https://timkadlec.com/remembers/2020-04-21-the-cost-of-javascript-frameworks/">Tim Kadlecの調査</a>より。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/876d32d5-0a68-4a08-b3f1-d4c103729cfa/cost-of-frameworks-bytes-desktop.png">プレビューを拡大</a>）</em></p>
<h3>13. フレームワークと依存関係を評価する。</h3>
<p>現在、<a href="https://twitter.com/jaffathecake/status/923805333268639744">あらゆるプロジェクトがフレームワークを必要とするわけでも、シングルページアプリケーションのあらゆるページがフレームワークの読み込みを必要とするわけでもありません</a>。
Netflixの場合、「React、複数のライブラリ、対応するアプリのコードをクライアントサイドから削除したところ、JavaScriptの総容量を200KB以上削減し、ログアウト後のホームページにおける<a href="https://www.youtube.com/watch?t=11m32s&#x26;v=V8oTJ8OZ5S0&#x26;feature=youtu.be">NetflixのTime To Interactiveを50％以上減らすことができました</a>」。
同社のチームは、ユーザがランディングページで消費する時間を利用して、ユーザが次にアクセスする可能性が高いページのReactを先読みするようにしました（<a href="https://jakearchibald.com/2017/netflix-and-react/">詳細はこちら</a>）。</p>
<p>それでは、クリティカルなページから既存のフレームワークを完全に削除した場合はどうなるでしょうか。
Gatsbyでは、<a href="https://www.npmjs.com/package/gatsby-plugin-no-javascript">gatsby-plugin-no-javascript</a>によって、Gatsbyが作成したすべてのJavaScriptファイルを静的HTMLファイルから削除できます。
Vercelでは、<a href="https://github.com/vercel/next.js/pull/11949">特定のページについて、本番環境のランタイムJavaScriptを無効化できます</a>（実験的な機能です）。</p>
<p>フレームワークを選択すると、少なくとも数年間はそのフレームワークを使い続けます。
そのため、フレームワークを使用する必要がある場合は、<a href="https://www.youtube.com/watch?v=6I_GwgoGm1w">十分な情報に基づき</a>、<a href="https://medium.com/%40ZombieCodeKill/choosing-a-javascript-framework-535745d0ab90#.2op7rjakk">よく考えて</a>選択しなければなりません。これは私たちが重視する主要なパフォーマンス指標に関して特に当てはまります。</p>
<p>データによれば、フレームワークは、デフォルトではとても高コストです。
<a href="https://twitter.com/hdjirdeh/status/1280731085379211265">Reactページの58.6％には1MB超のJavaScriptが含まれており</a>、Vue.jsのページ読み込みのFirst Contentful Paintが1.5秒未満である割合は36％です。
<a href="https://blog.uncommon.is/the-baseline-costs-of-javascript-frameworks-f768e2865d4a">Ankur Sethiの調査</a>によれば、「Reactアプリケーションは、どんなに最適化しても、インドの平均的なスマートフォンでは<strong>読み込みが約1.1秒より速くならない</strong>でしょう。
Angularアプリは、起動まで常に2.7秒以上かかります。Vueアプリのユーザは、利用を始められるまで1秒以上待つ必要があります」。
いずれにせよ、インドはあなたの主要なターゲット市場ではないかもしれません。
しかし、最適ではないネットワーク環境からサイトにアクセスするユーザは、同様の体験をするでしょう。</p>
<p>もちろん、SPAを高速化することは可能ですが、最初から速いわけではありません。
そのため、SPAを高速化し、それを維持し続けるための時間と労力を考慮する必要があります。
おそらく、初めはパフォーマンスコストの基準を低めに設定する方が簡単でしょう。</p>
<p><strong>それでは、どのようにフレームワークを選択すれば良いのでしょうか</strong>。
選択肢を選ぶ前に、少なくとも容量と初期実行時間の合計コストについて考えると良いでしょう。
<a href="https://github.com/developit/preact">Preact</a>、<a href="https://github.com/infernojs/inferno">Inferno</a>、<a href="https://vuejs.org/">Vue</a>、<a href="https://svelte.technology/">Svelte</a>、<a href="https://www.smashingmagazine.com/2020/03/introduction-alpinejs-javascript-framework/">Alpine</a>、<a href="https://github.com/Polymer/polymer">Polymer</a>などのコストが軽い選択肢でも、十分役割を果たします。
基準となる容量が、アプリケーションのコードの制約を定めることとなります。</p>
<p>Seb Markbågeが<a href="https://twitter.com/sebmarkbage/status/829733454119989248">述べている</a>とおり、フレームワークのスタートアップコストを測定する良い方法の1つは、<strong>まず画面をレンダリングし、次にそれを削除し、またレンダリングする</strong>ことです。
それによって、フレームワークがどのように拡大するかが分かります。
最初のレンダリングは、コンパイルが遅いコードのウォームアップとしての役割を果たします。
これらのコードは、拡大する際にツリー全体にメリットをもたらします。
2回目のレンダリングは基本的に、ページの複雑性が増す場合に、ページにおけるコードの再利用がパフォーマンス特性にどのような影響を与えるかをエミュレートするものです。</p>
<p>Sacha Greifの<a href="https://medium.freecodecamp.org/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library-3908c4ed3f49">12項目からなるスコアリングシステム</a>では、例えば機能、アクセシビリティ、安定性、パフォーマンス、<strong>パッケージのエコシステム</strong>、コミュニティ、学習曲線、ドキュメント、ツール、実績、チーム、互換性、セキュリティなどを調査することで、候補（あるいはJavaScriptライブラリ全般）を評価することまで可能です。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6c1d426d-cf12-43de-a926-cea743ac1bf3/perf-track-opt.png">
<em><a href="https://perf-track.web.app/">Perf Track</a>は、フレームワークのパフォーマンスを広範囲にわたって追跡します。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6c1d426d-cf12-43de-a926-cea743ac1bf3/perf-track-opt.png">プレビューを拡大</a>）</em></p>
<p>長い時間をかけてWebで収集されたデータに頼ることもできます。
例えば、<a href="https://perf-track.web.app/">Perf Track</a>は広範囲にわたってフレームワークのパフォーマンスを追跡しており、Angular、React、Vue、Polymer、Preact、Ember、Svelte、AMPでビルドしたWebサイトのオリジンの<strong>Core Web Vitals</strong>スコアの合計値を明らかにしています。
Gatsby、Next.js、Create React Appや、Nuxt.js（Vue）、Sapper（Svelte）でビルドしたWebサイトを指定し、比較することも可能です。</p>
<p>手始めに、アプリケーションにとって<strong>適切なデフォルトのフレームワーク</strong>を選ぶことから始めると良いでしょう。
<a href="https://gatsbyjs.org/">Gatsby</a>（React）、<a href="https://nextjs.org/">Next.js</a>（React）、<a href="https://vuepress.vuejs.org/">Vuepress</a>（Vue）、<a href="https://github.com/developit/preact-cli">Preact CLI</a>、<a href="https://github.com/Polymer/pwa-starter-kit">PWA Starter Kit</a>は、平均的なモバイルハードウェアにおいて初期設定で高速な読み込みを実現できるため、デフォルトとしてちょうど良い存在です。
また、<a href="https://web.dev/learn/#frameworks">web.devによるReactとAngularのためのフレームワークごとのパフォーマンスガイド</a>も見てみましょう（Phillipに感謝します）。</p>
<p>シングルページアプリケーションを丸ごとビルドするときは、少し目新しいアプローチを実践できるかもしれません。
<a href="https://github.com/turbolinks/turbolinks">Turbolinks</a>は15KBのJavaScriptライブラリで、画面のレンダリングにJSONではなくHTMLを使用します。
リンク先にアクセスすると、ページ全体を読み込むコストを発生させることなく、Turbolinksがページを自動的に取得し、 <code class="language-text">&lt;body&gt;</code> 要素を置き換え、 <code class="language-text">&lt;head&gt;</code> 要素をマージします。
<a href="https://twitter.com/dhh/status/1341420143239450624">詳細を手早く知りたい人はこちら</a>、<a href="https://hotwire.dev/">Turbolinksの完全なドキュメントについてはこちら（Hotwire）</a>をご確認ください。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fb9e201e-6247-4cf2-911f-ab968623981c/09-high-sell-phones-front-end-performance-checklist-2020.jpg">
<em>最も売れているスマートフォンのCPUと演算性能（画像の出典：<a href="https://speakerdeck.com/addyosmani/the-cost-of-javascript-in-2019">Addy Osmani</a>）（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/fb9e201e-6247-4cf2-911f-ab968623981c/09-high-sell-phones-front-end-performance-checklist-2020.jpg">プレビューを拡大</a>）</em></p>
<h3>14. クライアントサイドレンダリングか、サーバサイドレンダリングか？答えは両方。</h3>
<p>これはとても熱い議論が交わされるテーマです。
究極的なアプローチは、一種の<a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/">段階的な起動</a>を導入することでしょう。
つまり、サーバサイドレンダリングを使用してFirst Contentful Paintを高速化する一方、必要最低限のJavaScriptを導入し、Time To InteractiveがFirst Contentful Paintと乖離しないようにします。
JavaScriptがFCPよりも遅すぎる場合、ブラウザは、そのJavaScriptをパース、コンパイル、実行する間に<a href="https://davidea.st/articles/measuring-server-side-rendering-performance-is-tricky">メインスレッドをロック</a>するため、<a href="https://philipwalton.com/articles/why-web-developers-need-to-care-about-interactivity/">サイトやアプリケーションのインタラクティブ性を低下させる</a>こととなります。</p>
<p>これを避けるには、<strong>関数の実行を個別の非同期タスクに常に分割</strong>し、可能な場合は<code class="language-text">requestIdleCallback</code>を使用しましょう。
Webpackの<a href="https://developers.google.com/web/updates/2017/11/dynamic-import">動的な<code class="language-text">import()</code>サポート</a>を利用してUIの一部の読み込みを遅延させることで、読み込み、パース、コンパイルのコストを、ユーザが本当に必要になるまで回避できないか検討してみましょう（Addyに感謝します）。</p>
<p>上記のとおり、Time To Interactive（TTI）は、ナビゲーションの時点とインタラクションが可能になる時点までの間の時間を表します。
厳密には、この指標は、最初のコンテンツのレンダリング後、<strong>所要時間が50ミリ秒を超える</strong>JavaScriptタスク（ロングタスク）が存在しない状態が初めて5秒間続いた時点として定義されます。
50ミリ秒を超えるタスクが発生すると、5秒間の計測はやり直しです。
その結果、ブラウザが初めてインタラクティブになったかと思えば、すぐにインタラクティブでなくなり、最終的にはインタラクティブな状態に戻るという状況が起きます。</p>
<p>インタラクティブな状態に達すると、必要に応じて、あるいは時間が許す限り、アプリの本質的でない部分を起動することができます。
残念ながら、<a href="https://aerotwist.com/blog/when-everything-is-important-nothing-is/#which-to-use-progressive-booting">Paul Lewisが指摘したとおり</a>、フレームワークは通常、開発者にも分かる単純な優先順位の概念を持っていません。
そのため、ほとんどのライブラリとフレームワークでは、段階的な起動を導入するのは簡単ではありません。</p>
<p>それでも、私たちは段階的な起動に近づいています。最近はいくつかの選択肢を検討できるようになりました。
Houssein DjirdehとJason Millerの<a href="https://www.youtube.com/watch?v=k-A2VfuUROg">Rendering on the Web</a>という講演と、JasonとAddyの<a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web">モダンなフロントエンドアーキテクチャ</a>に関する記事は、こうした選択肢の全体像が分かる素晴らしい内容です。
以下の概要は、彼らの優れた成果に基づくものです。</p>
<ul>
<li>
<p><strong>フルサーバサイドレンダリング（SSR）</strong></p>
<p>WordPressなどの古典的なSSRでは、すべてのリクエストは完全にサーバ上で処理されています。
リクエストされたコンテンツは、完成したHTMLページとして返送され、ブラウザはそれをすぐにレンダリングすることができます。
そのため、SSRアプリは、例えばDOM APIをあまり活用できません。
First Contentful PaintとTime To Interactiveのギャップは通常は小さく、HTMLがブラウザに送信された時点ですぐにページをレンダリングできます。</p>
<p>ブラウザが応答を得る前に処理が行われるため、データを取得し、クライアント側でテンプレートを作成するための追加的なラウンドトリップの必要はありません。
しかし、<strong>サーバのシンクタイム</strong>、ひいてはTime To First Byteが<strong>長くなり</strong>、モダンなアプリケーションのレスポンシブでリッチな機能は活用できません。</p>
</li>
<li>
<p><strong>静的レンダリング</strong></p>
<p>プロダクトはシングルページアプリケーションとしてビルドされますが、ビルドのステップの一環として、すべてのページが最小限のJavaScriptによって静的HTMLへとプリレンダリングされます。
このことは、静的レンダリングでは、<strong>あり得るすべてのURL</strong>に対して個別のHTMLファイルを事前に生成することを意味しますが、これは多くのアプリケーションにとって可能ではありません。
しかし、ページのHTMLをすぐに生成する必要はないため、一貫して高速なTime To First Byteを実現できます。
したがって、ランディングページを速く表示し、その後のページのSPAフレームワークを先読みすることが可能です。
<a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">Netflixはこのアプローチを採用し</a>、読み込みとTime To Interactiveを50％削減しています。</p>
</li>
<li>
<p><strong>サーバサイドレンダリングと（リ）ハイドレーション（ユニバーサルレンダリング、SSR + CSR）</strong></p>
<p>SSRとCSRの両方のアプローチの良いとこ取りを目指すことも可能です。
ハイドレーションを利用する場合、サーバから返送されるHTMLページには、クライアントサイドの完全なアプリケーションを読み込むスクリプトも含まれています。
それによって、（SSRのように）高速なFirst Contentful Paintを実現し、それから（リ）ハイドレーションによるレンダリングを続けるのが理想です。
残念なことに、こうしたケースはまれです。
たいてい、ページの準備は整っているように見えるのに、ユーザの入力には応答できず、レイジクリックや離脱につながっています。</p>
<p>Reactでは、<a href="https://alligator.io/react/server-side-rendering/">ExpressなどのNodeサーバで<code class="language-text">ReactDOMServer</code>モジュールを使用</a>し、トップレベルのコンポーネントを静的なHTML文字列としてレンダリングするために<code class="language-text">renderToString</code>メソッドを呼び出すことができます。</p>
<p>Vue.jsでは、<a href="https://ssr.vuejs.org/">vue-server-rendererを使用</a>し、<code class="language-text">renderToString</code>でVueインスタンスをHTMLにレンダリングすることが可能です。
Angularでは、<a href="https://angular.io/guide/universal">@nguniversalを使用</a>し、クライアントのリクエストを、サーバによって完全にレンダリングされたHTMLページに変換できます。
<a href="https://nextjs.org/">Next.js</a>（React）や<a href="https://nuxtjs.org/">Nuxt.js</a>（Vue）では、完全なサーバサイドレンダリング体験を最初から実現可能です。</p>
<p>このアプローチにはデメリットがあります。クライアントサイドアプリの完全な柔軟性を実現しつつ、高速なサーバサイドレンダリングを提供できる一方で、First Contentful PaintとTime To Interactiveの<strong>ギャップが拡大</strong>し、First Input Delayが増加するのです。
<a href="https://addyosmani.com/blog/rehydration/">リハイドレーションはコストがとても大きくなります</a>。
この戦略だけでは、Time To Interactiveが大幅に遅くなるため、通常は十分ではありません。</p>
</li>
<li>
<p><strong>ストリーミングサーバサイドレンダリングとプログレッシブハイドレーション（SSR + CSR）</strong></p>
<p>Time To InteractiveとFirst Contentful Paintのギャップを最小限にするために、複数のリクエストを同時にレンダリングし、<strong>コンテンツが生成されるたびにチャンクとして送信</strong>します。
そのため、ブラウザにコンテンツを送信する前に完全なHTML文字列を待つ必要がなく、Time To First Byteが改善されます。</p>
<p>Reactでは、renderToString()の代わりに<a href="https://reactjs.org/docs/react-dom-server.html#rendertonodestream">renderToNodeStream()</a>を使用することで、応答をパイプし、HTMLをチャンクで送信できます。
Vueでは、<a href="https://ssr.vuejs.org/guide/streaming.html">renderToStream()</a>によるパイプとストリームが可能です。
React Suspenseでは、同じ目的に<a href="https://medium.com/maxime-heckel/asynchronous-rendering-with-react-c323cda68f41">非同期レンダリング</a>を使用できるでしょう。</p>
<p>クライアントサイドでは、アプリケーション全体を一度に起動するのではなく、<strong>コンポーネントを段階的に起動します</strong>。
まずアプリケーションのセクションをコード分割によって独立したスクリプトに分割し、次にそれを（優先順位に従って）徐々にハイドレートします。
つまり、クリティカルなコンポーネントを先にハイドレートし、残りは後でハイドレートすることができます。
クライアントサイドとサーバサイドのレンダリングの役割は、コンポーネントごとに異なる形で定義することが可能です。
また、コンポーネントが表示されるまで、またはそれがユーザとのインタラクションに必要になるまで、あるいはブラウザがアイドル状態になるまで、一部のコンポーネントの<strong>ハイドレーションを遅らせる</strong>こともできます。</p>
<p>Vueについては、Markus Oberlehnerが、<a href="https://markus.oberlehner.net/blog/how-to-drastically-reduce-estimated-input-latency-and-time-to-interactive-of-ssr-vue-applications/">ユーザとのインタラクションに応じたハイドレーション</a>と<a href="https://github.com/maoberlehner/vue-lazy-hydration">vue-lazy-hydration</a>を使用してSSRアプリのTime To Interactiveを削減するためのガイドを公表しています。
vue-lazy-hydrationは、コンポーネントの表示や特定のユーザインタラクションに応じたハイドレーションを可能にする初期段階のプラグインです。
Angularチームは、<a href="https://github.com/vikerman/ivy-universal">Ivy Universal</a>を使用してプログレッシブハイドレーションに取り組んでいます。
<a href="https://medium.com/%40luke_schmuke/how-we-achieved-the-best-web-performance-with-partial-hydration-20fab9c808d5">PreactとNext.jsでパーシャルハイドレーションを実装する</a>こともできます。</p>
</li>
<li>
<p><a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#trisomorphic"><strong>トライソモルフィックレンダリング</strong></a></p>
<p>サービスワーカーを導入している場合、初期やJS以外のナビゲーションには<strong>ストリーミングサーバレンダリング</strong>を使用し、それらがインストールされた後に、サービスワーカーがナビゲーションのためのHTMLレンダリングに取りかかるようにすることができます。
この場合、サービスワーカーはコンテンツをプリレンダリングし、同一セッション内の新規ビューをレンダリングするためのSPAスタイルのナビゲーションを有効にします。
サーバ、クライアントページ、サービスワーカーの間で同じテンプレートやルーティングコードを共有できる場合に効果的です。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d1c78c47-f803-4923-96ff-99c6a4a14cbb/08-trisomorphic-front-end-performance-checklist-2020.png">
<em>トライソモルフィックレンダリングでは、サーバ、DOM、サービスワーカーの3カ所のどこでも同じコードをレンダリングします。（画像の出典：<a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#trisomorphic">Google Developers</a>）（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d1c78c47-f803-4923-96ff-99c6a4a14cbb/08-trisomorphic-front-end-performance-checklist-2020.png">プレビューを拡大</a>）</em></p>
</li>
<li>
<p><strong>CSRとプリレンダリング</strong></p>
<p>プリレンダリングはサーバサイドレンダリングに似ていますが、サーバでページを動的にレンダリングするのではなく、ビルドの際にアプリケーションを静的HTMLへレンダリングします。
静的なページは、クライアントサイドのJavaScriptがあまり存在しなくても完全にインタラクティブとなりますが、<strong>プリレンダリングの仕組みは異なっています</strong>。
基本的に、プリレンダリングは、ビルド時にクライアントサイドアプリケーションの初期状態を静的HTMLとして取得します。
一方で、ページをインタラクティブにするにはアプリケーションをクライアント側で起動する必要があります。</p>
<p>Next.jsでは、アプリを静的HTMLにプリレンダリングすることで、<a href="https://nextjs.org/docs/advanced-features/static-html-export">静的HTMLエクスポート</a>を使用できます。
Reactを使用したオープンソースの静的サイトジェネレータである<a href="https://www.gatsbyjs.org/">Gatsby</a>では、<code class="language-text">renderToString</code>メソッドの代わりに<code class="language-text">renderToStaticMarkup</code>メソッドをビルド時に使用しています。
シンプルな静的ページには不要なDOM属性を使わず、メインのJSチャンクをプリロードし、将来のルートをプリフェッチします。</p>
<p>Vueでは、同じ目的を達成するために<a href="https://vuepress.vuejs.org/">Vuepress</a>を使用可能です。
<a href="https://github.com/GoogleChromeLabs/prerender-loader">Webpackではprerender-loader</a>も使用できます。
Naviも<a href="https://frontarm.com/navi/en/guides/static-rendering/">静的レンダリング</a>を提供しています。</p>
<p>その結果、Time To First ByteとFirst Contentful Paintが改善し、両者のギャップが縮小します。
コンテンツが大きく変化すると予想される場合、このアプローチは使用できません。
また、すべてのページを生成するには、事前にすべてのURLを把握する必要があります。
一部のコンポーネントはプリレンダリングを使用してレンダリングできることもありますが、動的な要素が必要な場合は、コンテンツを取得するためにアプリに頼らなければなりません。</p>
</li>
<li>
<p><strong>フルクライアントサイドレンダリング（CSR）</strong></p>
<p>すべてのロジック、レンダリング、起動がクライアント側で実施されます。
そのため、通常はTime To InteractiveとFirst Contentful Paintの間に膨大なギャップが発生します。
結果として、一部をレンダリングするだけでもクライアント側でアプリ全体を起動する必要があるため、アプリケーションが<strong>遅く感じることがよくあります</strong>。
JavaScriptにはパフォーマンスコストがあるため、アプリケーションに応じてJavaScriptの量が増加すると、その影響を抑えるために、積極的なコード分割とJavaScriptの遅延が絶対に必要になります。
こうしたケースでは、インタラクティブ性があまり必要とされない場合に備え、通常は<strong>サーバサイドレンダリング</strong>を採用する方が良いアプローチとなるでしょう。
それが不可能な場合は、<a href="https://developers.google.com/web/fundamentals/architecture/app-shell">App Shellモデル</a>の使用を検討してみましょう。</p>
<p>一般に、<a href="https://itnext.io/server-side-rendering-with-react-redux-and-react-router-fa5b67d4965e">SSRはCSRよりも高速です</a>。しかし、世の中の多くのアプリは、依然としてCSRを導入していることがよくあります。</p>
</li>
</ul>
<p>結局、クライアントサイドとサーバサイドのどちらが良いのでしょうか。一般に、<strong>完全なクライアントサイドのフレームワークを使用するのは、それが絶対に必要なページだけに制限する</strong>のが良いでしょう。高度なアプリケーションでは、サーバサイドのレンダリングのみに頼るのも良い考えではありません。サーバレンダリングとクライアントレンダリングのどちらも、不完全だと悲惨なことになります。
CSRとSSRのどちらが好みであるにせよ、重要なピクセルは可能な限り早くレンダリングし、レンダリングとTime To Interactiveのギャップは最小限になるようにしましょう。ページがあまり変化しない場合はプリレンダリングを検討し、可能ならばフレームワークの起動を遅らせてみてください。サーバサイドレンダリングでは<strong>HTMLをチャンクでストリーム</strong>し、クライアントサイドレンダリングでは<strong>プログレッシブハイドレーション</strong>を実装しましょう。そして、表示やインタラクションのタイミングで、あるいはアイドルタイムの間にハイドレーションを実施し、両者の良いとこ取りをしましょう。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e8d2728f-ab3c-4b56-a265-e6c6d456e600/03-jason-front-end-performance-checklist-2020.png">
<em>クライアントサイドとサーバサイドのレンダリングの選択肢をスペクトルで表しています。また、Google I/OでJasonとHousseinが<a href="https://www.youtube.com/watch?v=k-A2VfuUROg">アプリケーションのアーキテクチャによるパフォーマンスへの影響</a>について議論した内容もチェックしてみましょう。（画像の出典：<a href="https://twitter.com/_developit/status/1093223382223605762">Jason Miller</a>）（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e8d2728f-ab3c-4b56-a265-e6c6d456e600/03-jason-front-end-performance-checklist-2020.png">プレビューを拡大</a>）</em></p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f7b675e3-6338-40ea-b7a1-5a07ee6e52cc/08-progressive-hydration-front-end-performance-checklist-2020.png">
<em>AirBnBはプログレッシブハイドレーションの実験を実施しています。不要なコンポーネントを遅らせ、ユーザインタラクション（スクロール）に応じて、またはアイドルタイムの間に読み込んでいます。これにより、TTIが改善することがテストで判明しています。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f7b675e3-6338-40ea-b7a1-5a07ee6e52cc/08-progressive-hydration-front-end-performance-checklist-2020.png">プレビューを拡大</a>）</em></p>
<h3>15. どれだけのコンテンツを静的な状態で提供できるか？</h3>
<p>開発しているのが大規模なアプリケーションであるにせよ、小規模なサイトであるにせよ、どのコンテンツなら、実行時に動的に生成するのではなく<strong>CDN（<a href="https://jamstack.org/">JAM Stack</a>）から静的に提供</strong>できるかを検討することには価値があります。
無数のプロダクトとフィルタや、数多くのカスタマイズの選択肢があったとしても、クリティカルなランディングページを静的に提供し、あなたが選んだフレームワークからそれらのページを分離したいと思うかもしれません。</p>
<p>世の中には多くの<a href="https://jamstack.org/generators/">静的サイトジェネレータ</a>があり、ジェネレータが生成するページは通常、<a href="https://www.11ty.dev/speedlify/">とても高速です</a>。
リクエスト時にサーバやクライアントでページビューを生成するのではなく、事前にプリビルドするコンテンツが多いほど、優れたパフォーマンスを実現できます。</p>
<p>Markus Oberlehnerは、<a href="https://markus.oberlehner.net/blog/building-partially-hydrated-progressively-enhanced-static-websites-with-isomorphic-preact-and-eleventy/">Building Partially Hydrated, Progressively Enhanced Static Websites</a>という記事で、プログレッシブエンハンスメントを実現し、JavaScriptのバンドル容量を最小限にしつつ、静的サイトジェネレータとSPAを使用してWebサイトを構築する方法を説明しています。
Markusはツールとして<strong>EleventyとPreact</strong>を使用しており、ツールの設定、パーシャルハイドレーションの追加、遅延ハイドレーション、クライアントエントリファイル、Preact向けのBabelの設定、RollupによるPreactのバンドルについて、始めから終わりまで解説しています。</p>
<p>最近は大規模サイトでJAMStackが使用されるようになったことで、パフォーマンスに関して新たに検討すべき問題が出てきました。
その問題とは<strong>ビルド時間</strong>です。
実際、新たなデプロイのたびに無数のページをビルドするのには数分間かかる可能性があります。
そのため、ビルド時間を60倍改善する<a href="https://www.gatsbyjs.com/blog/2020-04-22-announcing-incremental-builds/">Gatsbyのインクリメンタルビルド</a>を利用すると良いでしょう。
WordPress、Contentful、Drupal、Netlify CMSなどの一般的なCMSソリューションとのインテグレーション機能もあります。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/93501951-ccc7-48be-8f01-f148cbfa6c75/incremental-static-regeneration.png">
<em>Next.jsによるインクリメンタルな静的サイト再生成。（画像の出典：<a href="https://www.prisma.io/blog/jamstack-with-nextjs-prisma-jamstackN3XT">Prisma.io</a>）（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/93501951-ccc7-48be-8f01-f148cbfa6c75/incremental-static-regeneration.png">プレビューを拡大</a>）</em></p>
<p>また、Next.jsは<a href="https://nextjs.org/blog/next-9-5#stable-incremental-static-regeneration">事前のインクリメンタルな静的サイト生成</a>機能を発表しました。
この機能では、トラフィックの流入に伴い、バックグラウンドで再レンダリングを行うことで、ランタイムに新たな静的ページを追加し、既存のページがすでにビルドされた後も更新できるようになります。</p>
<p>もっとコストが軽いアプローチが必要な場合はどうすべきでしょうか。
Nicola Goutayは、<a href="https://www.youtube.com/watch?v=taOyVmLgym4">Eleventy, Alpine and Tailwind: towards a lightweight Jamstack</a>という講演で、CSR、SSRや両者の中間にあるものの違いや、コストが軽いアプローチを使用する方法を説明しています。
また、<a href="https://github.com/orbit-love/orbit-web">GitHubリポジトリ</a>ではアプローチの実践方法も紹介しています。</p>
<h3>16. PRPLパターンとアプリケーションシェルアーキテクチャの使用を検討する。</h3>
<p>フレームワークによって、パフォーマンスに与える影響は違っており、異なる最適化戦略が必要とされます。
そのため、自分が使用するフレームワークの仕組みはすべて明確に理解しなければなりません。
Webアプリを開発するときは、<a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPLパターン</a>と<a href="https://developers.google.com/web/updates/2015/11/app-shell">アプリケーションシェルアーキテクチャ</a>について検討しましょう。
考え方はとても単純です。
初期ルートが高速にレンダリングされるように、インタラクティブな状態を実現するために必要最小限のコードをプッシュし、サービスワーカーを使用したリソースのキャッシングとプリキャッシングを行います。
その後、必要なルートの非同期的な遅延読み込みを実施します。</p>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/bb4716e5-d25b-4b80-b468-f28d07bae685/app-build-components-dibweb-c-scalew-879-opt.png">
<em><a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">PRPL</a>は、クリティカルなリソースのプッシュ（Pushing）、初期ルートのレンダリング（Rendering）、残りのルートのプリキャッシング（Pre-caching）、残りのルートの必要に応じた遅延読み込み（Lazy-loading）の頭文字を表します。</em>
<img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_auto/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6423db84-4717-4aeb-9174-7ae96bf4f3aa/appshell-1-o0t8qd-c-scalew-799-opt.jpg">
<a href="https://developers.google.com/web/updates/2015/11/app-shell">アプリケーションシェル</a>とは、ユーザインタフェースの機能に必要な最小限のHTML、CSS、JavaScriptです。</p>
<h3>17. APIのパフォーマンスを最適化しているか？</h3>
<p>APIは、アプリケーションがエンドポイントを通じて内部やサードパーティのアプリケーションにデータを提供するための通信チャネルです。
<a href="https://www.smashingmagazine.com/2012/10/designing-javascript-apis-usability/">APIのデザインとビルド</a>をするときは、サーバとサードパーティのリクエストの間の通信を可能にする妥当なプロトコルが必要です。
<a href="https://www.smashingmagazine.com/2018/01/understanding-using-rest-api/">Representational State Transfer</a>（<a href="https://web.archive.org/web/20130116005443/https:/tomayko.com/writings/rest-to-my-wife">REST</a>）は、そのようなプロトコルの中で、定評ある合理的な選択肢です。
RESTでは、パフォーマンスと信頼性が高いスケーラブルな方法でコンテンツをアクセス可能にするために、開発者が従うべき一連の制約を定めています。
RESTの制約に従うWebサービスは、RESTfulなWebサービスと呼ばれます。</p>
<p>古き良きHTTPリクエストと同様に、APIからデータが取得される場合、サーバの応答の遅れはエンドユーザにも波及し、そのため<strong>レンダリングが遅延</strong>します。
リソースが何らかのデータをAPIから取得する場合、対応するエンドポイントからデータをリクエストする必要があります。
コメント、および各コメントの筆者の写真が付属している記事など、複数のリソースからデータをレンダリングするコンポーネントは、レンダリングが可能になる前に、すべてのデータを取得するためにサーバとの間で複数回のラウンドトリップが必要になるかもしれません。
さらに、RESTを通じて返されるデータの量は、コンポーネントのレンダリングに必要な量を超えていることがよくあります。</p>
<p>多くのリソースがAPIからのデータを必要とする場合、APIがパフォーマンスのボトルネックとなりかねません。</p>
<p><a href="https://graphql.org/">GraphQL</a>は、こうした問題の有効な解決策となります。
GraphQLはいわば、API向けのクエリ言語であり、データ用に定義した型システムを使用してクエリを実行するためのサーバサイドのランタイムです。
RESTとは異なり、GraphQLは1度のリクエストですべてのデータを取得できます。
返されるデータは必要なちょうどの量となっており、RESTでよくある過大なデータや過少なデータの取得は起きません。</p>
<p>さらに、GraphQLはスキーマ（データの構造に関するメタデータ）を使用しているため、好きな構造にデータを組織することが可能です。
例えば、<a href="https://medium.com/%40wmdmark/how-graphql-replaces-redux-3fff8289221d">GraphQLなら、状態管理を処理するためのJavaScriptコードを削除</a>することで、以前よりもクリーンなアプリケーションコードを生成し、クライアント側での実行を高速化できます。</p>
<p>GraphQLを始めたい場合や、パフォーマンスに関する問題に直面している場合は、以下の記事が良い参考になるかもしれません。</p>
<ul>
<li><a href="https://www.smashingmagazine.com/2018/01/graphql-primer-new-api-part-1/">A GraphQL Primer: Why We Need A New Kind Of API</a>（Eric Baer著）</li>
<li><a href="https://www.smashingmagazine.com/2018/01/graphql-primer-new-api-part-2/">A GraphQL Primer: The Evolution Of API Design</a>（Eric Baer著）</li>
<li><a href="https://blog.logrocket.com/designing-graphql-server-optimal-performance/">Designing a GraphQL server for optimal performance</a>（Leonardo Losoviz著）</li>
<li><a href="https://medium.com/%40wtr/graphql-performance-explained-cb4b43412fb4">GraphQL performance explained</a>（Wojciech Trocki著）</li>
</ul>
<p><img src="https://res.cloudinary.com/indysigner/image/fetch/f_auto,q_80/w_2000/https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5fda8d85-1151-4d0b-b2f6-da354ebae345/redux-rest-apollo-graphql.png">
<em>RESTとGraphQLの差を現した図。左側はRedux + REST、右側はApollo + GraphQLとの対話を表しています。（画像の出典：<a href="https://web.archive.org/web/20180324125829/https:/hackernoon.com/how-graphql-replaces-redux-3fff8289221d?gi=47fd50e442aa">Hacker Noon</a>）（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5fda8d85-1151-4d0b-b2f6-da354ebae345/redux-rest-apollo-graphql.png">プレビューを拡大</a>）</em></p>
<h3>18. AMPとInstant Articlesのどちらを使用するか？</h3>
<p>組織の優先課題と戦略に応じて、Googleの<a href="https://www.ampproject.org/">AMP</a>、Facebookの<a href="https://www.facebook.com/formedia/solutions/instant-articles">Instant Articles</a>（※訳注：原文指定URL消失）、あるいはAppleの<a href="https://developer.apple.com/news-publisher/">Apple News</a>の使用を検討すると良いかもしれません。
これらがなくても優れたパフォーマンスを実現することはできますが、AMPは堅固なパフォーマンスフレームワークと無料のコンテンツデリバリネットワーク（CDN）を提供します。
一方、Instant ArticlesはFacebook上の表示とパフォーマンスを改善します。</p>
<p>こうした技術には、<strong>パフォーマンスが保証される</strong>というユーザにとって明確なメリットがあるように思われます。
ですから、場合によっては、サイズが膨大な可能性がある「通常の」ページよりも、AMP、Apple News、Instant Articlesのページへのリンクの方が好まれることさえあるでしょう。
大量のコンテンツを搭載し、多くのサードパーティコンテンツを扱うWebサイトにとって、こうした選択肢は、レンダリング時間を劇的に高速化するのに役立つ可能性があります。</p>
<p><a href="https://timkadlec.com/remembers/2018-03-19-how-fast-is-amp-really/">しかし、必ずしもそうとは限りません</a>。
Tim Kadlecによれば、例えば「AMPドキュメントは他のドキュメントよりも高速な傾向がありますが、それは必ずしもページのパフォーマンスが高いということを意味しません。
AMPは、パフォーマンスの観点で特に大きな違いをもたらすものではないのです」。</p>
<p>Webサイトの所有者にとってのメリットは明確です。
こうしたフォーマットは、各プラットフォーム上で見つけやすく、<a href="https://ethanmarcotte.com/wrote/ampersand/">検索エンジンにおいて見やすくなります</a>。</p>
<p>少なくとも、以前まではそうでした。
AMPはトップストーリーに表示されるための<a href="https://developers.google.com/search/blog/2020/05/evaluating-page-experience">必要条件ではなくなった</a>ため、パブリッシャは<a href="https://searchengineland.com/will-publishers-drop-amp-when-its-no-longer-a-requirement-for-top-stories-335612">AMPから離れ</a>、従来の方式に回帰する可能性があります（Barryに感謝します）。</p>
<p>それでも、AMPをPWAのデータソースとして再利用することで、<a href="https://www.smashingmagazine.com/2016/12/progressive-web-amps/">プログレッシブWeb AMP</a>を構築することも可能です。
デメリットはあるでしょうか。
当然ながら、クローズドプラットフォームでの表示のために、開発者は異なるバージョンのコンテンツを生成・維持する必要があります。
Instant ArticlesとApple Newsの場合は、そのバージョンには<a href="https://www.w3.org/blog/TAG/2017/07/27/distributed-and-syndicated-content-whats-wrong-with-this-picture/">実際のURLが存在しないこととなります</a>（AddyとJeremyに感謝します）。</p>
<h3>19. CDNを賢く選ぶ。</h3>
<p>上記のとおり、データが動的である度合いによっては、コンテンツの一部を<a href="https://www.staticgen.com/">静的サイトジェネレータ</a>に「アウトソース」できるかもしれません。
これをCDNにプッシュし、そこから静的なバージョンのコンテンツを提供すれば、サーバへのリクエストを回避することが可能です。
もっと言えば、こうしたジェネレータの一部は、実際には<a href="https://tomdale.net/2017/09/compilers-are-the-new-frameworks/">Webサイトのコンパイラ</a>であり、最初から多くの自動最適化機能が提供されています。
コンパイラが徐々に最適化を進めるため、コンパイルの出力も時とともに小さく、高速になります。</p>
<p>注目すべき点として、CDNは動的なコンテンツも提供（およびオフロード）することができます。
ですから、CDNを静的なアセットに限定する必要はありません。
利用しているCDNが圧縮と変換（例：エッジでの画像の最適化とサイズ変更）を行っているか、CDNが<a href="https://www.filamentgroup.com/lab/servers-workers.html">サーバワーカー</a>、<a href="https://www.youtube.com/watch?v=W-tBI_n0m_w">A/Bテスト</a>（CDNのエッジ（サーバがユーザと最も近い部分）でページの静的な部分と動的な部分を組み立てるエッジ処理を含む）などのタスクに対応しているかをダブルチェックしましょう。
また、<a href="https://blog.cloudflare.com/the-quicening/">利用しているCDNがHTTP over QUIC（HTTP/3）</a>をサポートしているか確認しましょう。</p>
<p>Katie Hempeniusは<a href="https://web.dev/content-delivery-networks/">CDNの素晴らしいガイド</a>を執筆しており、<strong>優れたCDNの選び方</strong>、それを微調整する方法、CDNを評価するときに留意が必要なあらゆる細かい事項に関する情報を提供しています。
一般に、コンテンツは可能な限り積極的にキャッシュし、Brotli、TLS 1.3、HTTP/2、HTTP/3などのCDNのパフォーマンス関連機能を有効化すると良いでしょう。</p>
<p><strong>注記</strong>：Patrick MeenanとAndy Daviesの調査によれば、<code class="language-text">HTTP/2における優先度の制御</code>は、<a href="https://github.com/andydavies/http2-prioritization-issues#cdns--cloud-hosting-services">多くのCDNでは実質的に機能していない</a>ため、CDNを選択するときは気を付けましょう。
Patrickは、自らの講演で<a href="https://youtu.be/sgjxuhFQktE?t=2626">HTTP/2における優先度</a>の制御について詳しく説明しています（Barryに感謝します）。</p>
<p><img src="https://archive.smashing.media/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/647c043f-c4f7-4d6f-ad28-31ca1828352b/cdnperf-preview.png">
<em><a href="https://www.cdnperf.com/">CDNPerf</a>は、毎日3億件のテストを収集・分析することにより、CDNのクエリの速度を測定します。（<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/647c043f-c4f7-4d6f-ad28-31ca1828352b/cdnperf-preview.png">プレビューを拡大</a>）</em></p>
<p>CDNを選ぶときは、以下の<strong>比較サイト</strong>で、機能の詳細を確認することができます。</p>
<ul>
<li><a href="https://cdncomparison.com/">CDN Comparison</a>は、Cloudfront、Azure、KeyCDN、Fastly、Verizon、Stackpach、Akamaiなどの数多くのCDNの比較表です。</li>
<li><a href="https://www.cdnperf.com/">CDN Perf</a>は、毎日3億件のテストを収集・分析することにより、CDNのクエリの速度を測定します。すべてのテスト結果は世界中のユーザのRUMデータに基づいています。<a href="https://www.dnsperf.com/">DNS Performance Comparison</a>と<a href="https://www.cloudperf.com/">Cloud Peformance Comparison</a>も確認してみましょう。</li>
<li><a href="https://www.cdnplanet.com/guides/">CDN Planet Guides</a>では、Serve Stale、Purge、Origin Shield、Prefetch、Compressionなどの個別のトピックに関して、CDNの概要を説明しています。</li>
<li><a href="https://almanac.httparchive.org/en/2019/cdn#cdn-adoption-and-usage">Web Almanac:CDN Adoption and Usage</a>は、上位のCDNプロバイダ、そのRTTとTLSの管理、TLSネゴシエーションタイム、HTTP/2の導入などに関する情報を提供します（残念ながら、データは2019年以降のものに限られます）。</li>
</ul>
<p>＜中編に続く＞</p>]]></content:encoded></item><item><title><![CDATA[2022年のCSS]]></title><description><![CDATA[写真： Jr Korpa on Unsplash Intro：2021年はこれまでCSSにとって盛りだくさんな一年でした。
CSSワーキンググループはCSSの仕様にさまざまな変更を加え、既存機能を改…]]></description><link>https://postd.cc/css-in-2022/</link><guid isPermaLink="false">https://postd.cc/css-in-2022/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[CSS]]></category><pubDate>Thu, 27 Apr 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p><em>写真： <a href="https://unsplash.com/@jrkorpa">Jr Korpa</a> on <a href="https://unsplash.com/s/photos/future">Unsplash</a></em></p>
<p><strong>Intro</strong>：2021年はこれまでCSSにとって盛りだくさんな一年でした。
CSSワーキンググループはCSSの仕様にさまざまな変更を加え、既存機能を改良するとともに多くの新機能を追加しました。
一部のブラウザには、すでに実験的に実装されているものもあります。</p>
<p>ブラウザベンダーは、新機能のサポートだけでなく、<a href="https://web.dev/compat2021/">開発者を悩ませるブラウザの互換性に関する5大問題</a>（<a href="https://wpt.fyi/compat2021?feature=summary">#compat2021</a>）の解決にも注力しています。</p>
<p><strong>2021年もそろそろ終わりに近づいているので、今回は2022年に実装されそうなCSS機能を紹介したいと思います。</strong></p>
<p><em>(※訳注：翻訳元の記事は2021年12月27日公開)</em></p>
<h2>目次</h2>
<ul>
<li><a href="#01">はじめに</a></li>
<li>
<p><a href="#02">注目の新機能（クロスブラウザ対応）</a></p>
<ul>
<li><a href="#03">コンテナクエリ</a></li>
<li><a href="#04">カスケードレイヤー</a></li>
<li><a href="#05">カラー関数</a></li>
<li><a href="#06">新しいビューポート単位</a></li>
<li><a href="#07">:has()擬似クラス</a></li>
<li><a href="#08">overscroll-behavior</a></li>
<li><a href="#09">サブグリッド</a></li>
<li><a href="#10">accent-color</a></li>
<li><a href="#11">メディアクエリの範囲指定</a></li>
</ul>
</li>
<li>
<p><a href="#12">今後期待の新機能（実験的実装／シングルブラウザ対応）</a></p>
<ul>
<li><a href="#13">ネスト（入れ子）</a></li>
<li><a href="#14">@scope</a></li>
<li><a href="#15">@when / @else</a></li>
</ul>
</li>
<li>
<p><a href="#16">現状維持が濃厚な期待の新機能</a></p>
<ul>
<li><a href="#17">スクロール連動型アニメーション</a></li>
<li><a href="#18">@property (😭)</a></li>
</ul>
</li>
<li><a href="#19">気になるSafariの動向</a></li>
<li><a href="#20">おわりに</a></li>
</ul>
<h2><a href="#01">#</a>はじめに<a name="01"></a></h2>
<p>誤解のないよう言っておきますが、この記事で紹介するリストは、筆者の<strong>個人的</strong>な予想です。
独自の情報や内部情報も、未来を映し出す水晶玉もありません。
あるのは、予想の根拠となる公開ソースだけです。
<a href="https://github.com/w3c/csswg-drafts/">CSSワーキンググループのIssue Tracker</a>を注視し、さまざまなブラウザベンダーをフォローすることで、このリストを作成するのに十分な情報を得ています。</p>
<p>これはあくまでも予想なので間違っている可能性もありますが、自信はかなりあります。
最終的にはほとんどの予想が的中していることでしょう。🙂</p>
<p>なお、このリストでは全く新しい機能やまだ一部のブラウザしか対応していない機能のみ紹介しています。
<a href="https://www.bram.us/2021/03/26/css-logical-properties-are-the-future-of-the-web-i18n/">論理値や論理プロパティ</a>、<a href="https://brm.us/aspect-ratio"><code class="language-text">aspect-ratio</code></a>、<a href="https://www.bram.us/2020/04/27/colors-in-css-hello-space-separated-functional-color-notations/">スペース区切りのカラー関数表記</a>などの機能が含まれていないのはそのためです。
これらも比較的新しい機能であり、まだ一般的には使用されていませんが、ほとんどのブラウザがすでに対応しています。</p>
<h2><a href="#02">#</a>注目の新機能（クロスブラウザ対応）<a name="02"></a></h2>
<p><strong>以下の機能については、2022年中にすべてのブラウザが対応すると確信しています</strong>。
一部のブラウザにはすでに搭載されている機能もあり、残りのブラウザも順次対応していくと思われます。
2022年は以下のCSS機能を学ぶと有益でしょう。</p>
<h3><a href="#03">#</a>コンテナクエリ<a name="03"></a></h3>
<p><em>（※訳注：2023年4月現在、全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/03/container-queries.png"></p>
<p>コンテナクエリ—<a href="https://drafts.csswg.org/css-contain-3/">css-contain-3</a>の一部を使用することで、作者はコンテナのサイズまたは見た目（スタイル）に応じて要素をスタイリングすることができます。
コンテナのサイズを基準としたコンテナクエリは<code class="language-text">@media</code>クエリと似ていますが、ビューポートではなく親コンテナのサイズが評価基準となる点が異なります。
コンテナのスタイルを基準としたコンテナクエリについては、別のCSSプロパティの計算値に応じてスタイルを条件付きで適用します。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">main, aside</span> <span class="token punctuation">{</span>
  <span class="token property">container</span><span class="token punctuation">:</span> inline-size<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.media-object</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template</span><span class="token punctuation">:</span> <span class="token string">'img'</span> auto <span class="token string">'content'</span> auto / 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token atrule"><span class="token rule">@container</span> <span class="token punctuation">(</span>inline-size > 45em<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token selector">.media-object</span> <span class="token punctuation">{</span>
    <span class="token property">grid-template</span><span class="token punctuation">:</span> <span class="token string">'img content'</span> auto / auto 1fr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>詳しくはこちらもご覧ください。<a href="https://brm.us/container-queries">CSS Container Queries: A First Look + Demo →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Blink/Chromium：Issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1145970">#1145970</a></em></li>
<li><em>Gecko/Firefox：Issue <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1744221">#1744221</a></em></li>
<li><em>WebKit/Safari：Issue <a href="https://bugs.webkit.org/show_bug.cgi?id=229659">#229659</a></em></li>
</ul></div></div>
<h3><a href="#04">#</a>カスケードレイヤー<a name="04"></a></h3>
<p><em>（※訳注：2023年4月現在、全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/09/css-cascade-cascade-layers-champ-bramus-560x315.png"></p>
<p>カスケードレイヤーを使用すると、同一オリジンルールのカスケード順序を適切に制御できます。
そのために、<code class="language-text">@layer</code>ルールを使用してスタイルをレイヤー化します。
カスケードにおけるレイヤーの順序は、詳細度（Specificity）と記述の順番（Order of Appearance）よりも上位に位置します。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@import</span><span class="token punctuation">(</span>reset.css<span class="token punctuation">)</span> <span class="token function">layer</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">;</span></span> <span class="token comment">/* 1st layer */</span>

<span class="token atrule"><span class="token rule">@layer</span> base</span> <span class="token punctuation">{</span> <span class="token comment">/* 2nd layer */</span>
  <span class="token selector">form input</span> <span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> inherit<span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token atrule"><span class="token rule">@layer</span> theme</span> <span class="token punctuation">{</span> <span class="token comment">/* 3rd layer */</span>
  <span class="token selector">input</span> <span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 2rem<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>カスケードレイヤーはChromium 99とFirefox 97でサポートされます。
Safari TP 133でもサポートされており（フィーチャーフラグを使用）、2022年の第1四半期にはリリースされると予想されます。</p>
<p>詳しくはこちらもご覧ください。<a href="https://brm.us/at-layer">The Future of CSS: Cascade Layers (CSS @layer) →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Chromium：Issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1095765">#1095765</a></em></li>
<li><em>Firefox：Issue <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1699215">#1699215</a></em></li>
<li><em>Safari：Issue <a href="https://bugs.webkit.org/show_bug.cgi?id=220779">#220779</a></em></li>
</ul></div></div>
<h3><a href="#05">#</a>カラー関数<a name="05"></a></h3>
<p><em>（※訳注：2023年4月現在、全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/04/css-color-level-5-560x348.png"></p>
<p><a href="https://www.w3.org/TR/css-color-5/">css-color-5仕様</a>は、色の使用についての細かい機能をいくつか提供します。
<code class="language-text">color-mix()</code>、<code class="language-text">color-contrast()</code>という2つの新しい関数を追加したほか、相対カラー構文を使用して既存の関数を拡張しています。</p>
<ul>
<li><code class="language-text">color-mix()</code>関数を使用すると、任意の色空間において2つの色を混ぜることができます。</li>
</ul>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.text-primary-dark</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">color-mix</span><span class="token punctuation">(</span><span class="token function">var</span><span class="token punctuation">(</span>--theme-primary<span class="token punctuation">)</span><span class="token punctuation">,</span> black 10%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token selector">.text-primary-darker</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">color-mix</span><span class="token punctuation">(</span><span class="token function">var</span><span class="token punctuation">(</span>--theme-primary<span class="token punctuation">)</span><span class="token punctuation">,</span> black 20%<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<ul>
<li><code class="language-text">color-contrast()</code>関数を使用すると、特定のベースカラーと比較したコントラストが基準値以上の色の中からベストな色を選ぶことができます。</li>
</ul>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* Compares wheat against tan, sienna, and #d2691e */</span>
<span class="token comment">/* Sienna will be selected as it has a contstast of 4.273 against wheat, which exceeds the threshold of AA-large (3) */</span>
<span class="token function">color-contrast</span><span class="token punctuation">(</span>wheat vs tan<span class="token punctuation">,</span> sienna<span class="token punctuation">,</span> #d2691e to AA-large<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<ul>
<li>相対カラー構文を用いることで、どの色でも操作でき、任意のフォーマットに変換できます。</li>
</ul>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">:root</span> <span class="token punctuation">{</span>
  <span class="token property">--color</span><span class="token punctuation">:</span> #ff0000<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.selector</span> <span class="token punctuation">{</span>
  <span class="token comment">/* change the transparency */</span>
  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>from <span class="token function">var</span><span class="token punctuation">(</span>--color<span class="token punctuation">)</span> h s l / .5<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">/* change the hue */</span>
  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>from <span class="token function">var</span><span class="token punctuation">(</span>--color<span class="token punctuation">)</span> <span class="token function">calc</span><span class="token punctuation">(</span>h + 180deg<span class="token punctuation">)</span> s l<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">/* change the saturation */</span>
  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">hsl</span><span class="token punctuation">(</span>from <span class="token function">var</span><span class="token punctuation">(</span>--color<span class="token punctuation">)</span> h <span class="token function">calc</span><span class="token punctuation">(</span>s + 5%<span class="token punctuation">)</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これらの関数は、通常CSSプリプロセッサから提供されています。WebKit/Safariではすでにサポートされています。
詳しくはこちらもご覧ください。</p>
<ul>
<li><a href="https://www.bram.us/2021/04/28/create-a-color-theme-with-css-relative-color-syntax-css-color-mix-and-css-color-contrast/">Create a color theme with CSS Relative Color Syntax, CSS color-mix(), and CSS color-contrast() →</a></li>
<li><a href="https://www.bram.us/2021/11/26/dynamic-color-manipulation-with-css-relative-colors/">Dynamic Color Manipulation with CSS Relative Colors →</a></li>
</ul>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Chromium：Issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1152772">#1152772</a>、<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1152772">#1092638</a>、<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1274133">#1274133</a></em></li>
<li><em>Firefox：メタ <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1679227">Issue #1679227</a></em></li>
<li><em>Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=222530">Issue #222530</a>、<a href="https://bugs.webkit.org/show_bug.cgi?id=222258">#222258</a>、<a href="https://bugs.webkit.org/show_bug.cgi?id=221880">#221880</a></em></li>
</ul></div></div>
<h3><a href="#06">#</a>新しいビューポート単位<a name="06"></a></h3>
<p><em>（※訳注：2023年4月現在、全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/07/viewports-teaser-560x373.png"></p>
<p>ビューポートのvh単位を使用する際、<a href="https://www.bram.us/2020/05/06/100vh-in-safari-on-ios/">iOSのSafariで不具合が生じる極めて厄介なバグが、かなり前から存在します</a>。
コンテナを<code class="language-text">100vh</code>に設定すると、要素が若干高くなりすぎてしまうのです。
これは、MobileSafariが<code class="language-text">100vh</code>を計算する際にUIの一部を無視してしまうことが原因です。</p>
<p>CSSワーキンググループは、css-values-4仕様においてvh単位には変更を加えず、ビューポートの新しい定義とそれに伴う<a href="https://www.w3.org/TR/css-values-4/#viewport-relative-lengths">新しいビューポート相対長</a>をいくつか導入しました。</p>
<ul>
<li><code class="language-text">svh</code>/<code class="language-text">svw</code>：スモールビューポートの高さ／幅の1%</li>
<li><code class="language-text">lvh</code>/<code class="language-text">lvw</code>：ラージビューポートの高さ／幅の1%</li>
<li><code class="language-text">dvh</code>/<code class="language-text">dvw</code>：ダイナミックビューポートの高さ／幅の1%</li>
</ul>
<p>ほかにも、<code class="language-text">svi</code>/<code class="language-text">svb</code>などの論理変数が利用可能です。</p>
<p>詳しくはこちらもご覧ください。<a href="http://brm.us/viewport-units">The Large, Small, and Dynamic Viewports →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Blink/Chromium：Issue <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1093055">#1093055</a></em></li>
<li><em>Gecko/Firefox：Issue <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1610815">#1610815</a></em></li>
<li><em>WebKit/Safari：Issue <a href="https://bugs.webkit.org/show_bug.cgi?id=219287">#219287</a></em></li>
</ul></div></div>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>同じ仕様で、<a href="https://www.w3.org/TR/css-values-4/#math">計算で使用できる新しい数学関数</a>のログも導入されています。ぜひチェックしてみてください。</em></p></div></div>
<h3><a href="#07">#</a>:has()擬似クラス<a name="07"></a></h3>
<p><em>（※訳注：2023年4月現在、全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/12/forms-css-has.css-560x310.png"></p>
<p>CSSのリレーショナル擬似クラス<code class="language-text">:has()</code>は、<a href="https://drafts.csswg.org/selectors-4/#has-pseudo">selectors-4</a>の一部です。
これは、<code class="language-text">:has()</code>に指定された追加セレクタのいずれかと一致した場合のみ要素がマッチするため、要素をより細かく選択することを可能にします。
しばしば「親セレクタ」と呼ばれますが、機能はそれだけに留まりません。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* Matches &lt;a> elements that contain an &lt;img> child */</span>
<span class="token selector">a:has(img)</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span>

<span class="token comment">/* Matches &lt;a> elements that directly contain an &lt;img> child */</span>
<span class="token selector">a:has(> img)</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span>

<span class="token comment">/* Matches &lt;section> elements that don’t contain any heading elements: */</span>
<span class="token property">section</span><span class="token punctuation">:</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token punctuation">:</span><span class="token function">has</span><span class="token punctuation">(</span>h1<span class="token punctuation">,</span> h2<span class="token punctuation">,</span> h3<span class="token punctuation">,</span> h4<span class="token punctuation">,</span> h5<span class="token punctuation">,</span> h6<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">/* Matches &lt;h1> elements only if they have a &lt;p> element directly following them */</span>
<span class="token selector">h1:has(+ p)</span> <span class="token punctuation">{</span> … <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>詳しくはこちらもご覧ください。<a href="https://brm.us/css-has">The CSS :has() selector is way more than a “Parent Selector” →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Blink/Chromium：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=669058">Issue #669058</a></em></li>
<li><em>Gecko/Firefox：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=418039">Issue #418039</a></em></li>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=227702">Issue #227702</a></em></li>
</ul></div></div>
<h3><a href="#08">#</a>Overscroll-behavior<a name="08"></a></h3>
<p>CSSの<code class="language-text">overscroll-behavior</code>プロパティを使用すると、コンテナを”<em>オーバースクロール</em>” する際にデフォルトの挙動をオーバーライドできます。
これにより、Pull-to-Refreshのジェスチャーが実施された場合に完全にリロードされないようにしたり、rubber banding（※）を無効化したり、スクロールを一つのレイヤー内に収めたりすることが可能です。
<em>（※訳注：スクロール領域の限界を超えてスクロールした時に、ゴムのように引き戻されるような効果）</em></p>
<p class="codepen" data-height="300" data-default-tab="html,result" data-slug-hash="ZEzmzxj" data-user="aaroniker" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;">
  <span>See the Pen <a href="https://codepen.io/aaroniker/pen/ZEzmzxj">
  overscroll-behavior: contain</a> by Aaron Iker (<a href="https://codepen.io/aaroniker">@aaroniker</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://cpwebassets.codepen.io/assets/embed/ei.js"></script>
<p>Firefox（バージョン36）とChromium（バージョン63）ではかなり前からサポートされています。Safariでもようやくサポートの動きが見られます。</p>
<p>詳しくはこちらもご覧ください。<a href="https://www.bram.us/2017/12/10/customizing-pull-to-refresh-and-overflow-effects-with-css-overscroll-behavior/">Customizing Pull-to-Refresh and Overflow Effects with CSS <code class="language-text">overscroll-behavior</code></a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=176454">Issue #176454</a></em></li>
</ul></div></div>
<h3><a href="#09">#</a>サブグリッド<a name="09"></a></h3>
<p><em>（※訳注：2023年4月現在、SafariとFirefoxでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/12/subgrid-560x341.png"></p>
<p>グリッドを入れ子にする際、入れ子のグリッドアイテムをメイングリッドに沿って整列させるのは容易ではありません。
そこで役立つのがサブグリッドです。
<code class="language-text">grid-template-columns</code>または<code class="language-text">grid-template-rows</code>を<code class="language-text">subgrid</code>に設定すると、親グリッドに沿って整列します。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">.grid</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>9<span class="token punctuation">,</span> 1fr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> <span class="token function">repeat</span><span class="token punctuation">(</span>4<span class="token punctuation">,</span> <span class="token function">minmax</span><span class="token punctuation">(</span>100px<span class="token punctuation">,</span> auto<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.item</span> <span class="token punctuation">{</span>
  <span class="token property">display</span><span class="token punctuation">:</span> grid<span class="token punctuation">;</span>
  <span class="token property">grid-column</span><span class="token punctuation">:</span> 2 / 7<span class="token punctuation">;</span>
  <span class="token property">grid-row</span><span class="token punctuation">:</span> 2 / 4<span class="token punctuation">;</span>
  <span class="token property">grid-template-columns</span><span class="token punctuation">:</span> subgrid<span class="token punctuation">;</span>
  <span class="token property">grid-template-rows</span><span class="token punctuation">:</span> subgrid<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">.subitem</span> <span class="token punctuation">{</span>
  <span class="token property">grid-column</span><span class="token punctuation">:</span> 3 / 6<span class="token punctuation">;</span>
  <span class="token property">grid-row</span><span class="token punctuation">:</span> 1 / 3<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Firefoxではすでにサポートされています。Chromiumでもサポートに向けた作業が進められています。</p>
<p>詳しくはこちらもご覧ください。<a href="https://www.bram.us/2021/11/04/practical-css-subgrid-video-tutorials/">Practical CSS Subgrid Video Tutorials →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Blink/Chromium：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=618969">Issue #618969</a></em></li>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=202115">Issue #202115</a></em></li>
</ul></div></div>
<h3><a href="#10">#</a>accent-color<a name="10"></a></h3>
<p><em>（※訳注：2023年4月現在、全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/08/accent-color-560x383.png"></p>
<p><code class="language-text">accent-color</code>は<a href="https://www.w3.org/TR/css-ui-4/#widget-accent">css-ui-4</a>の一部です。</p>
<blockquote>
<p>CSSのUI仕様に規定されるaccent-colorは、CSSに1行追加するだけで要素を色付けできるため、自社ブランドを要素に組み込むことができ、カスタマイズに要する労力を削減することができます。</p>
</blockquote>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">form</span> <span class="token punctuation">{</span>
  <span class="token property">accent-color</span><span class="token punctuation">:</span> hotpink<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>accent-colorを使用すると、<a href="https://www.bram.us/2021/12/10/checkbox-rasterizer/">チェックボックスを使用したピクセルアートを作成することもできます。🙃</a></p>
<p>Chromium 93以上とFirefox 92以上でサポートされています。</p>
<p>詳しくはこちらもご覧ください。<a href="https://web.dev/accent-color/">CSS <code class="language-text">accent-color</code> →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=227587">Issue #227587</a></em></li>
</ul></div></div>
<h3><a href="#11">#</a>メディアクエリの範囲指定<a name="11"></a></h3>
<p><em>（※訳注：2023年4月現在、全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/10/media-query-range-context-560x400.png"></p>
<p><a href="https://www.w3.org/TR/mediaqueries-4/">mediaqueries-4</a>で新たに追加された仕様により、通常の数学で用いるような比較演算子を使用したMedia Query Ranges構文を用いて特定のメディアクエリを書き直すことができます。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* Old Way */</span>
<span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 750px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
	…
<span class="token punctuation">}</span>
<span class="token comment">/* New Way */</span>
<span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span>width &lt;= 750px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
	…
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Safariでの対応に向けた積極的な動きは確認できていないのですが、これに関しては筆者が間違っていると信じたいですね。</p>
<p>詳しくはこちらもご覧ください。<a href="https://brm.us/media-query-ranges">Media Queries Level 4: Media Query Range Contex →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=180234">Issue #180234</a></em></li>
</ul></div></div>
<h2><a href="#12">#</a>今後期待の新機能（実験的実装／シングルブラウザ対応）<a name="12"></a></h2>
<p>以下の機能については、すべてのブラウザでサポートされるのは2023年以降になりそうな予感がしています。
一部のブラウザではサポートされる可能性が高そうですが、フィーチャーフラグを使用した実装がメインになると思います。
これらに時間を費やす場合、すべてのブラウザがサポートし、すべてのユーザがブラウザをアップデートするまでは、一部のブラウザでしか使用できないことを理解する必要があります。</p>
<h3><a href="#13">#</a>ネスト（入れ子）<a name="13"></a></h3>
<p><em>（※訳注：2023年4月現在、Firefoxを除く全モダンブラウザでサポートされています。（ただし Safari はTechnology Preview版(16.5)でのみサポート））</em></p>
<p>この夏、スタイルルールの入れ子を可能にするモジュールである<a href="https://www.w3.org/TR/css-nesting-1/">css-nesting-1</a>のFirst Public Working Draftが公開されました。</p>
<details>
<summary>Working Draft（WD）とは何か？</summary>
<p><em>Working Draft（WD）成熟度レベルは、W3C勧告行程の最初の公式フェーズであり、W3C仕様の設計フェーズとみなされます。この段階では、CSSワーキンググループがモジュールの内容を調査、改訂します。
WDの最初に公開されるバージョンは、First Public Working Draftと呼ばれ、ここからWDフェーズが実行されます。
続いて、候補勧告（Candidate Recommendation; CR）になり、最終的には勧告（Recommendation; REC）になります。
これらの3つの段階の間には、最終草案（Last Call Working Draft; LCWD）と提案された勧告案（Proposed Recommendation; PR）という2つの移行段階があります。</em></p>
<p><em>勧告行程は以下のようになります：</em>
<img src="https://www.bram.us/wordpress/wp-content/uploads/2020/11/W3C-recommendation-track.png"></p>
<p><em>詳しくはこちらもご覧ください。<a href="http://fantasai.inkedblade.net/weblog/2011/inside-csswg/process">An Inside View of the CSS Working Group at W3C →</a></em></p>
</details>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token selector">table.colortable</span> <span class="token punctuation">{</span>
  <span class="token selector">&amp; td</span> <span class="token punctuation">{</span>
    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token selector">;
    &amp;.c</span> <span class="token punctuation">{</span> <span class="token property">text-transform</span><span class="token punctuation">:</span> uppercase <span class="token punctuation">}</span>
    <span class="token selector">&amp;:first-child, &amp;:first-child + td</span> <span class="token punctuation">{</span> <span class="token property">border</span><span class="token punctuation">:</span> 1px solid black <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token selector">&amp; th</span> <span class="token punctuation">{</span>
    <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>
    <span class="token property">background</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
    <span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token atrule"><span class="token rule">@nest</span> footer &amp;</span> <span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 0.8em<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>この機能がCSSに追加されたのは画期的なことであり、できれば上で紹介した注目の新機能に入れたいと思っていました。
しかし残念ながら、2022年中にサポートされるのはChromiumのみ（場合によってはもう1社）になると予想しています。
この点については筆者の予想が外れていることを期待しましょう</strong>。
あるいは、プリプロセッサの拡張機能により、2022年中に使用可能になる道が開けるかもしれません。</p>
<p>詳しくはこちらもご覧ください。<a href="https://brm.us/css-nesting">The future of CSS: Nesting Selectors →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Blink/Chromium：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1095675">Issue #1095675</a></em></li>
<li><em>Gecko/Firefox：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1648037">Issue #1648037</a></em></li>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=223497">Issue #223497</a></em></li>
</ul></div></div>
<h3><a href="#14">#</a>@scope<a name="14"></a></h3>
<p><em>（※訳注：2023年4月現在、これをサポートしているモダンブラウザはまだありません）</em></p>
<p><a href="https://www.bram.us/2021/12/27/css-in-2022/#the-hotlist--cascade-layers">カスケードレイヤー</a>を導入した<a href="https://drafts.csswg.org/css-cascade-5/">css-cascade-5</a>がリリースされ、<a href="https://drafts.csswg.org/css-cascade-6/">css-cascade-6</a>に向けた作業がすでに始まっています。
次の仕様では、カスケードにスコーピング機能が導入され、スタイルをDOMツリーの一部にスコーピングできるようになります。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>dark-theme<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>plum<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>light-theme<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>also plum???<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* When .light-theme and .dark-theme get nested, you may not get the expected result */</span>
<span class="token selector">.light-theme a</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> purple<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token selector">.dark-theme a</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> plum<span class="token punctuation">;</span> <span class="token punctuation">}</span>


<span class="token comment">/* By scoping, we can fix this, as the a elements will be styled by their nearest scope */</span>
<span class="token atrule"><span class="token rule">@scope</span> <span class="token punctuation">(</span>.light-scheme<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token selector">a</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> darkmagenta<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token atrule"><span class="token rule">@scope</span> <span class="token punctuation">(</span>.dark-scheme<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token selector">a</span> <span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> plum<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>また、スコープリミット（下限値）を定義することもできます。</p>
<p><strong>現時点では、これ以上掘り下げるのは時期尚早です。筆者の予想では、2022年中にChromiumが実験的に実装するのではないかと思います。</strong></p>
<h3><a href="#15">#</a>@when/@else<a name="15"></a></h3>
<p><em>（※訳注：2023年4月現在、これをサポートしているモダンブラウザはまだありません）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/12/css-conditional-5.css-560x404.png"></p>
<p>2021年末の12月21日、<a href="https://www.w3.org/TR/css-conditional-5/">css-conditional-5</a>仕様のFirst Public Working Draftが公開されました。</p>
<details>
<summary>Working Draft（WD）とは何か？</summary>
<p><em>Working Draft（WD）成熟度レベルは、W3C勧告行程の最初の公式フェーズであり、W3C仕様の設計フェーズとみなされます。この段階では、CSSワーキンググループがモジュールの内容を調査、改訂します。
WDの最初に公開されるバージョンは、First Public Working Draftと呼ばれ、ここからWDフェーズが実行されます。
続いて、候補勧告（Candidate Recommendation; CR）になり、最終的には勧告（Recommendation; REC）になります。
これらの3つの段階の間には、最終草案（Last Call Working Draft; LCWD）と提案された勧告案（Proposed Recommendation; PR）という2つの移行段階があります。</em></p>
<p><em>勧告行程は以下のようになります：</em>
<img src="https://www.bram.us/wordpress/wp-content/uploads/2020/11/W3C-recommendation-track.png"></p>
<p><em>詳しくはこちらもご覧ください。<a href="http://fantasai.inkedblade.net/weblog/2011/inside-csswg/process">An Inside View of the CSS Working Group at W3C →</a></em></p>
</details>
<blockquote>
<p>CSS Conditional 4の機能を含め、拡張し、一般化した条件ルール<code class="language-text">@when</code>と連鎖した条件ルール<code class="language-text">@else</code>を追加し、<code class="language-text">@supports</code>ルールで使用されるsupportsクエリ構文にフォント処理クエリを導入します。</p>
</blockquote>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token atrule"><span class="token rule">@when</span> <span class="token function">media</span><span class="token punctuation">(</span>width >= 400px<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token function">media</span><span class="token punctuation">(</span><span class="token property">pointer</span><span class="token punctuation">:</span> fine<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/* A */</span>
<span class="token punctuation">}</span> <span class="token atrule"><span class="token rule">@else</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token property">caret-color</span><span class="token punctuation">:</span> pink<span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">double-rainbow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/* B */</span>
<span class="token punctuation">}</span> <span class="token atrule"><span class="token rule">@else</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/* C */</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>筆者が思うに素晴らしい機能追加です。<strong>しかし、どのベンダーにも対応する兆しが見えないため（ホリデーシーズンだからかもしれませんが）、2022年中にすべてのブラウザがこの機能を搭載することはないと予想し、このリストに加えています。</strong></p>
<p>詳しくはこちらもご覧ください。<a href="https://css-tricks.com/proposal-for-css-when/">Proposal for CSS @when →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Blink/Chromium：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1282896">Issue #1282896</a></em></li>
<li><em>Gecko/Firefox：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1747727">Issue #1747727</a></em></li>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=234701">Issue #234701</a></em></li>
</ul></div></div>
<h2><a href="#16">#</a>現状維持が濃厚な期待の新機能<a name="16"></a></h2>
<p>残念ながら、以下の機能については2022年中あまり動きが見られないと思われます。
これらの機能は非常に有益ではあるのですが、実際に使用するにはより多くのブラウザが対応する必要があります。</p>
<h3><a href="#17">#</a>スクロール連動型アニメーション<a name="17"></a></h3>
<p><em>（※訳注：2023年4月現在、これをサポートしているモダンブラウザはまだありません。）</em></p>
<p><a href="https://drafts.csswg.org/scroll-animations-1/">scroll-animations-1 specification</a>が提供する<code class="language-text">@scroll-timeline</code>ルールと<code class="language-text">animation-timeline</code>プロパティを使用することで、CSSアニメーションをスクロールコンテナのスクロールオフセットに連動させることができます。
コンテナの中を上下にスクロールすると、連動したアニメーションがそれに合わせて進んだり戻ったりします。</p>
<div class="gatsby-highlight" data-language="css"><pre style="counter-reset: linenumber NaN" class="language-css line-numbers"><code class="language-css"><span class="token comment">/* (1) Define Keyframes */</span>
<span class="token atrule"><span class="token rule">@keyframes</span> adjust-progressbar</span> <span class="token punctuation">{</span>
    <span class="token selector">from</span> <span class="token punctuation">{</span>
        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token selector">to</span> <span class="token punctuation">{</span>
        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">scaleX</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token comment">/* (2) Define a ScrollTimeline */</span>
<span class="token atrule"><span class="token rule">@scroll-timeline</span> scroll-in-document</span> <span class="token punctuation">{</span>
  <span class="token property">source</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
  <span class="token property">orientation</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>
  <span class="token property">scroll-offsets</span><span class="token punctuation">:</span> 0<span class="token punctuation">,</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">/* (3) Attach the Animation + set the ScrollTimeline as the driver for the Animation */</span>
<span class="token selector">#progressbar</span> <span class="token punctuation">{</span>
    <span class="token property">animation</span><span class="token punctuation">:</span> 1s linear forwards adjust-progressbar<span class="token punctuation">;</span>
    <span class="token property">animation-timeline</span><span class="token punctuation">:</span> scroll-in-document<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>スクロール連動型アニメーションは、現在Chromiumしかサポートしていません（フィーチャーフラグを使用）。
Gecko/Firefoxは、すでに構文解析機能は追加していますが、実際のレンダリングにはまだ対応していません。
筆者はスクロール連動型アニメーションの熱烈な支持者であり、このテーマについて多数の記事を執筆していますが、<strong><a href="https://github.com/w3c/csswg-drafts/issues/6674">現状構文に関する議論が行われているため、</a>開発は停滞すると思われます。</strong></p>
<p>詳しくはこちらもご覧ください。</p>
<ul>
<li><a href="https://brm.us/scroll-linked-animations-pt1">Part 1: Introduction + Basic Scroll-Linked Animations →</a></li>
<li><a href="https://brm.us/scroll-linked-animations-pt2">Part 2: Scroll-Linked Animations with Element-based offsets →</a></li>
<li><a href="https://brm.us/scroll-linked-animations-pt3">Part 3: Practical Use-Cases →</a></li>
<li><a href="https://brm.us/scroll-linked-animations-pt4">Part 4: Scroll-Linked Animations With the Web Animations API (WAAPI) →</a></li>
</ul>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Blink/Chromium：<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1023424">Issue #1023424</a></em></li>
<li><em>Gecko/Firefox：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1676780">Issue #1676780</a></em></li>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=222295">Issue #222295</a></em></li>
</ul></div></div>
<h3><a href="#18">#</a>@property (😭)<a name="18"></a></h3>
<p><em>（訳注：2023年4月現在、Firefoxを除く全モダンブラウザでサポートされています。）</em></p>
<p><img src="https://www.bram.us/wordpress/wp-content/uploads/2021/12/at-property.css-560x446.png"></p>
<p>CSS Properties and Values APIは「CSS Houdini」の一部です。
このAPIが提供する<code class="language-text">@property</code>を使用することで、CSSカスタムプロパティを登録し、特定のタイプ（構文）と初期値を設定し、継承機能を制御できます。</p>
<details>
<summary>🎩Houdiniはまるで魔法のようです。</summary>
<p><em>HoudiniはCSSエンジンの一部を公開する低レベルAPIのセットです。開発者がブラウザのレンダリングエンジンのスタイリングとレイアウトプロセスにフックすることで、CSSを拡張できるようになります。
また、開発者がCSSとしてコードを書くことができるように、CSSオブジェクトモデル（CSSOM）への直接アクセスを提供するAPIグループでもあります。これにより、ブラウザでネイティブに実装されるのを待つことなく、新しいCSS機能も作成できます。</em></p>
</details>
<p>本当に魔法のように便利なので、Houdiniという名前がついています。
試してみるなら、こちらの<a href="https://www.bram.us/2018/06/01/demystifying-the-future-of-css-with-sparkles-of-js/">ページ</a>と<a href="https://www.bram.us/2020/12/11/extending-css-with-houdini/">ビデオ</a>をお勧めします。</p>
<p><strong>Houdini、とりわけProperties and Values APIの部分がすべてのブラウザに搭載されることを願ってやみませんが、関連するWebKitとGeckoのバグはここ数か月（数年！）全く動きがないため、残念ながら現状維持になると思います。😭</strong></p>
<p>詳しくはこちらもご覧ください。<a href="https://web.dev/at-property/">@property: giving superpowers to CSS variables →</a></p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>関連するIssue：</em></p><ul>
<li><em>Gecko/Firefox：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1273706">Issue #1273706</a></em></li>
<li><em>WebKit/Safari：<a href="https://bugs.webkit.org/show_bug.cgi?id=189692">Issue #189692</a></em></li>
</ul></div></div>
<h2><a href="#19">#</a>気になるSafariの動向<a name="19"></a></h2>
<p>昨年多くの批判にさらされたSafariは、しばしば「新しいIE6」と呼ばれています。
筆者自身もそのように言っていた一人ですが、現在は少し考えを改めています。</p>
<p>Safariの開発チームは最近多くの成果を上げており（カラー関数、<code class="language-text">:has()擬似クラス</code>、カスケードレイヤーなど）、その他にも複数のポジションで積極的に採用を進めています。
2022年中にSafariが「巻き返し」に成功したとしても、驚くことはないでしょう。</p>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p><em>☝️それでも、あいにく<a href="https://www.bram.us/2021/09/13/chrome-is-the-new-safari-and-so-are-edge-and-firefox/">WebKitがiOS</a>を独占する状況については何も変わりません。この状況については、筆者同様Safariの関係者も好ましく思っていないはずです。おそらく、上層部の決定なのでしょう。</em></p></div></div>
<h2><a href="#20">#</a>おわりに<a name="20"></a></h2>
<p>ここで紹介したように、2022年には多数の機能がCSSに追加されると予想されます。
特に注目している機能や、ここで触れなかった機能についてコメントのある方は、<a href="https://www.bram.us/2021/12/27/css-in-2022/#%E5%9B%9E%E7%AD%94">こちら</a>からご連絡いただくか、<a href="https://twitter.com/bramus">Twitter</a>でメッセージを送っていただければと思います。🙂</p>
<p>発表ツイートのいずれかをリツイートし、ぜひこの記事の内容の拡散にご協力ください。</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">🔥 CSS Features to start learning, as I expect them to ship in all browsers in 2022:<br><br>1. Container Queries<br>2. Cascade Layers<br>3. Color Functions<br>4. Viewport Units<br>5. :has()<br>6. Overscroll Behaviour<br>7. Subgrid<br>8. Accent Color<br>9. Media Query Ranges</p>&mdash; Bramus (@bramus) <a href="https://twitter.com/bramus/status/1475583226165055501?ref_src=twsrc%5Etfw">December 27, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">With 2021 coming to an end, let&#39;s take a look at what we can expect from CSS and browsers in 2022.<br><br>🔗 <a href="https://t.co/CsTn4nvyG7">https://t.co/CsTn4nvyG7</a><br><br>🏷 <a href="https://twitter.com/hashtag/css?src=hash&amp;ref_src=twsrc%5Etfw">#css</a> <a href="https://t.co/rxlspa4gw2">pic.twitter.com/rxlspa4gw2</a></p>&mdash; Bram.us (@bramusblog) <a href="https://twitter.com/bramusblog/status/1475511382997090306?ref_src=twsrc%5Etfw">December 27, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<hr>
<div class="admonition admonition-none alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg></svg></span>none</h5></div><div class="admonition-content"><p>🔥<em>気に入っていただけましたか？最新情報を受け取りたいですか？以下の方法でどうぞ:</em></p><ul>
<li><em><a href="https://twitter.com/bramus">Follow @bramus on Twitter</a></em></li>
<li><em><a href="https://front-end.social/@bramus">Follow @bramus on Mastodon</a></em></li>
<li><em><a href="https://twitter.com/bramusblog">Follow @bramusblog on Twitter</a></em></li>
<li><em><a href="https://bram.us/feed">Follow bram.us using RSS</a></em></li>
</ul></div></div>]]></content:encoded></item><item><title><![CDATA[WebAssemblyに注目]]></title><description><![CDATA[WebAssemblyは今、転換点にあります。今後数年間で、コンテナ化からプラグインシステムやサーバレス・コンピューティング・プラットフォームに至るまで、IT業界全体でWebAssemblyの導入が…]]></description><link>https://postd.cc/pay-attention-to-web-assembly/</link><guid isPermaLink="false">https://postd.cc/pay-attention-to-web-assembly/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[プログラミング言語]]></category><pubDate>Thu, 30 Mar 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>WebAssemblyは今、転換点にあります。今後数年間で、コンテナ化からプラグインシステムやサーバレス・コンピューティング・プラットフォームに至るまで、IT業界全体でWebAssemblyの導入が増えると筆者は予想しています。この記事では、WebAssemblyとは何か、なぜそれが重要なテクノロジーであるのか、現在はどのような分野で利用されているかを説明します。また、WebAssemblyが大きな影響をもたらす可能性がある用途や、WebAssemblyの将来に関する予測も紹介します。</p>
<h2>WebAssemblyとは何か</h2>
<p>WebAssembly（Wasm）とは、さまざまなプログラミング言語と多様な実行環境の間に位置する中間層です。30以上の異なるプログラミング言語で書かれたコードを.wasmファイルにコンパイルし、そのファイルをブラウザ、サーバ、あるいは自動車でも実行できます。</p>
<p>「WebAssembly」という名前は誤解を招きます。WebAssemblyは元々、Webでのコードの実行を高速化するために開発されましたが、今ではブラウザ以外のさまざまな環境でも実行できます。さらに、WebAssemblyはアセンブリではなく、アセンブリより若干高水準なバイトコードです。</p>
<p>WebAssemblyの解説とその歴史の説明については、数多くの記事が書かれています。ですから、ここでは優れた入門記事をいくつか紹介するにとどめたいと思います。</p>
<ul>
<li><a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/">A cartoon intro to WebAssembly - Mozilla Hacks - the Web developer blog</a></li>
<li><a href="https://nickymeuleman.netlify.app/blog/webassembly">WebAssembly. Scary name, exciting applications. | Nicky blogs</a></li>
<li><a href="https://desiatov.com/why-webassembly/">How WebAssembly changes software distribution | Max Desiatov</a></li>
</ul>
<h2>WebAssemblyの長所</h2>
<p>WebAssemblyが優れているのは、以下の5つの特徴があるためです。</p>
<ul>
<li><strong>ポータブル</strong>：Wasmのバイトコードのバイナリ形式は標準化されています。このことは、Wasmを実行可能なあらゆるランタイムがどんなWasmコードでも実行できることを意味します<a href="#01">1</a>。これはJavaの「write once, run anywhere」（一度書けばどこでも実行できる）というスローガンと似ています。ブラウザに関しては、<a href="https://caniuse.com/wasm">95%のユーザのブラウザ</a>でWebAssemblyを実行でき、残り5%もwasm2jsコンパイラを利用すれば対応できます。サーバに関しては、<a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a>や<a href="https://github.com/wasmerio/wasmer">Wasmer</a>などのランタイムがあります。リソースが限られているIoT端末でも、<a href="https://github.com/bytecodealliance/wasm-micro-runtime">WAMR</a>を利用すればWasmコードを実行可能です<a href="#02">2</a>。</li>
<li><strong>普遍性</strong>：多くのプログラミング言語をWasmにコンパイルできます。Wasmがサポートしている言語には、C、C++、Rustなどのシステム言語だけでなく、Go、Python、Rubyなどのガベージコレクション機能を導入している高水準言語も含まれます<a href="#03">3</a>。Wasmにコンパイルできるプログラミング言語の一覧は<a href="https://github.com/appcypher/awesome-wasm-langs">こちら</a>です。</li>
<li><strong>“ニアネイティブパフォーマンス”</strong>：Wasmは「ニアネイティブパフォーマンス」（ネイティブに近いパフォーマンス）を<a href="https://developer.mozilla.org/en-US/docs/WebAssembly">実現するとよく言われます</a>。実際には、Wasmはほとんどの状況でJavaScriptより高速で、特に演算の負荷が大きいワークロードでその傾向が顕著です。また、Wasmは平均で<a href="https://www.usenix.org/conference/atc19/presentation/jangda">ネイティブコード</a>より1.45～1.55倍遅いものの、<a href="https://00f.net/2021/02/22/webassembly-runtimes-benchmarks/">ランタイムによって</a>結果は異なります。</li>
<li><strong>高速な起動時間</strong>：Wasmのコールドスタート時間は、それ自体が一つのカテゴリを構成するほど重要です。サーバ上では、WasmはDockerのコンテナと比べて10～100倍<a href="https://repositum.tuwien.at/bitstream/20.500.12708/17598/1/Gackstatter%20Philipp%20-%202021%20-%20A%20WebAssembly%20Container%20Runtime%20for%20Serverless%20Edge...pdf">高速なコールドスタート</a>時間を実現できます。これはWasmがすべてのコンテナについて新たなOSプロセスを作成する必要がないためです。ブラウザでは、Wasmのデコードと機械語への変換はJavaScriptのパース、解釈、最適化よりも高速であるため、WasmコードはJavaScriptよりも速く最大のパフォーマンスで実行を開始できます<a href="#04">4</a>。</li>
<li><strong>安全性</strong>：WebAssemblyはWebを念頭に置いていたため、セキュリティを重視して設計されました。Wasmランタイムで実行されるコードは、メモリがサンドボックス化され、機能が制約されています。これはコードが明示的に許可されていることしか実行できないことを意味します<a href="#05">5</a>。Wasmコードはサンドボックス化されていますが、システムレベルのインタフェースやハードウェア機能など、下層のシステムへのアクセスも依然として許可されています。</li>
</ul>
<h2>WebAssemblyの便利な利用法</h2>
<h3>JavaScriptの高速化</h3>
<p>Wasmとその前身であるasm.jsが開発された元々の動機は、Web上でのクライアントサイドのコードを高速化することでした。Wasmがこの分野で優れていることを示す事例は数多く存在します。</p>
<ul>
<li>例えば、デザインツールのFigmaの中心的なプログラムはC++で書かれ、WebAssemblyにコンパイルされています。Figmaの開発者は、C++で書かれたプログラムには<a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">パフォーマンスとユーザビリティの面</a>で大きなメリットがあり、それを<a href="https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/">WebAssemblyにコンパイルする</a>ことによって読み込み時間を3分の1に削減し、ダウンロードするファイルの容量を劇的に縮小できると述べています。</li>
<li>パスワードマネージャの1Passwordでは、Wasmへの転換によって、フォームが多いサイトでの動作が最大で<a href="https://blog.1password.com/1password-x-may-2019-update/">13～39倍高速化</a>しました。また、WasmがJavaScriptよりもパフォーマンスが<a href="https://developers.google.com/web/updates/2019/02/hotpath-with-wasm">安定している</a>という点は、レイテンシの影響を受けやすいアプリケーションにとって重要です<a href="#06">6</a>。</li>
</ul>
<h3>プログラミング言語の相互運用性</h3>
<p>WebAssemblyはプログラミング言語の境界を簡単に越えることを可能にします。通常、ライブラリとフレームワークは1つの言語のみで書かれているため、完全に書き換えない限り、そのコードを別の言語で利用するのは困難です。WebAssemblyでは、別の言語で書かれたコードの実行を簡単にすることができます。<strong>これにより、コードを一から書き直すのではなく再利用することが可能になります。</strong></p>
<p>現在、この機能は主にアプリケーションをWebに移植するために利用されています。以下に例を紹介します。</p>
<ul>
<li>Figmaは、一部のグラフィックアルゴリズムについて、Skiaという低水準のC++ライブラリを利用しています。自社でアルゴリズムを開発したり、それをJavaScriptに移植したりはしていません<a href="#07">7</a>。</li>
<li>筆者のお気に入りのチェスサーバであるlichess.orgは、世界クラスのチェスエンジンであるStockfishをユーザのブラウザで実行しており、サーバサイドでStockfishを実行することによる演算負荷を回避しています。</li>
<li><a href="https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6">Google Earth</a>と<a href="https://web.dev/ps-on-the-web/">Adobe Photoshop</a>はWasmを利用してC++のコードベースをWebに移植しています。</li>
</ul>
<p>アプリケーションのWeb移植はWasmを利用するうえで最も簡単な出発点となっており、<a href="https://paulbutler.org/2020/the-webassembly-app-gap/">その傾向は今後も続く</a>と予想されます。しかし、Wasmの相互運用性はブラウザに限られません。Wasmはプラットフォームや端末を越えてコードを実行するのにも利用されています。</p>
<ul>
<li><a href="https://platform.uno/">Uno Platform</a>は、単一のアプリケーションを開発し、それをWindows、macOS、iOS、Android、Linux、ブラウザで実行できるUIプラットフォームです。このプラットフォームは、アプリケーションがC#とXAMLで書かれており、かなりWindows中心に設計されているようです。また、レガシーアプリケーションを新たなプラットフォームに移植するために必要な労力を減らすことを目的とした活用例が非常に多いのも特徴です。</li>
<li><a href="https://www.amazon.science/blog/how-prime-video-updates-its-app-for-more-than-8-000-device-types">Amazon Prime</a>、<a href="https://medium.com/disney-streaming/introducing-the-disney-application-development-kit-adk-ad85ca139073">Disney+</a>、<a href="https://www.youtube.com/watch?v=28paRXqI-Gk">BBC</a>はいずれも自社の動画配信プラットフォームでWebAssemblyを利用しています。例えば、Amazon Primeでは、新機能を膨大な種類の端末に対応させつつ、問題ないパフォーマンスを維持するためにWebAssemblyが活用されています。</li>
</ul>
<p>WebAssemblyは、アプリケーションの移植以外にも、サーバサイドでの言語間の橋渡しとしても役立ちます。残念ながら、この用途の活用例はまだ多くありません。なぜなら、OSとの通信に利用されるインタフェース（<a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">Web Assembly System Interface</a>、略称WASI）や言語の境界を越えて機能するインタフェース（<a href="https://github.com/WebAssembly/component-model">Wasm Component Model</a>）は依然として開発途上であり、必要な成熟度に達していないためです。</p>
<h3>プラグインシステム</h3>
<p>ほとんどのアプリケーションは、ある程度の成熟度に達すると、エンドユーザによる拡張性が必要になります。従来のアプリケーションは、設定項目を大量に増やしたり、複雑なドメイン固有言語（DSL）を開発したりしてきましたが、管理がとても面倒になることや、開発者がよく知らない言語での作業を強いられることが常でした。</p>
<p>例を考えてみましょう。NGINXなどのシステムでリクエストのフィルタリング規則を設定するとします。そのためには、システム管理者は、なじみのない独自の設定言語で望ましいロジックを宣言型で実装しなければなりません。NGINXの開発者があらかじめ設定したマッチング演算子やフィルタリング演算子は、普段は役立ちますが、システム管理者が望む挙動を実装するうえで大きな妨げとなることがよくあります。また、利用できるツールが少ないので、問題が生じたときのデバッグはストレスがたまるでしょう。</p>
<p>一部の比較的新しいアプリケーションは異なるアプローチを採用しています。そのアプローチとは、インタフェースの標準的なセットを提供し、Wasmランタイムを組み込んだうえで、必要なカスタムロジックを実装するためのWasmバイナリはエンドユーザに提供させるものです。これにより、エンドユーザにとってはるかに柔軟でなじみのあるインタフェースが実現されます。エンドユーザは、自分が選んだ言語で、複雑なビジネスロジックを自由に実装できます。この機能は、他の言語ではセキュリティ上の懸念により不可能でしたが、Wasmではユーザが提供するコードをランタイムがサンドボックス化することによって実現しています。</p>
<p>現在の活用例を見てみましょう。</p>
<ul>
<li>元々Lyftによって開発され、現在では業界全体で利用されているEnvoyプロキシは、拡張機能をWasmで開発し、ランタイムで動的に<a href="https://github.com/proxy-wasm/spec/blob/master/docs/WebAssembly-in-Envoy.md">読み込む</a>ことを可能にしています。Envoyを基に開発されたサービスメッシュのIstioにも同様の機能があります。</li>
<li>Kafkaの代わりとして使用されているRedpandaでは、ユーザがWasmを利用して、独自の<a href="https://vectorized.io/blog/wasm-architecture/">ストリーミングデータ変換プログラム</a>を書くことができます。</li>
<li>Open Policy Agentでは<a href="https://www.openpolicyagent.org/docs/latest/wasm/">Wasmを利用</a>してポリシーを定義できます。</li>
<li>Minecraftサーバの<a href="https://github.com/feather-rs/feather">Feather</a>は、サンドボックス内でのプラグインの実行にWebAssemblyを利用しています。</li>
</ul>
<h3>サンドボックス化機能の組み込み</h3>
<p>WebAssemblyを他のアプリケーションに組み込むというアイデアは、プラグインシステム以外にとっても有用です。実際、サードパーティライブラリ全体のサンドボックス化や、ファーストパーティコード向けのセキュリティ層の構築に利用できます。</p>
<p>Firefoxはこの分野で<a href="https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/">先頭に立っており</a>、スペルチェックや画像のデコードなどに利用するサードパーティライブラリのバグから自らを守っています。Wasmは、「<a href="https://hacks.mozilla.org/2020/02/securing-firefox-with-webassembly/">汚染レイヤ</a>」を提供するRLBoxというツールと組み合わせることで、強引なプロセス隔離に頼ることなく、こうしたライブラリの脆弱性からシステムを保護します。Firefoxの場合、Wasmバイナリを最終リリースに搭載してすらいません。Wasmへのコンパイルと別の言語へのトランスパイルというプロセスによって、RLBoxとともに、必要なセキュリティを確保しているのです。</p>
<p>このアプローチは一部の重大な脆弱性の悪用を防止できるかもしれません。攻撃者は通常、複数の脆弱性を組み合わせて利用するため、こうした中間的なセキュリティ層は今後の安全性向上にとても役に立つでしょう。</p>
<h3>コンテナ化</h3>
<p>Dockerの創業者であるSolomon Hykesは、よく引用されている<a href="https://twitter.com/solomonstre/status/1111004913222324225?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1111004913222324225%7Ctwgr%5E%7Ctwcon%5Es1_&#x26;ref_url=https%3A%2F%2Fnickymeuleman.netlify.app%2Fblog%2Fwebassemblysecurity">ツイート</a>で、WebAssemblyの重要性を次のように強調しています。</p>
<blockquote>
<p>WASMとWASIが2008年に存在していたらDockerを開発する必要はなかった。それくらい重要な存在だ。サーバサイドのWebAssemblyはコンピューティングの未来だ。</p>
</blockquote>
<p>Wasmがコンテナ化の未来を示していると考えるのには<a href="https://kubesphere.io/blogs/will-cloud-native-webassembly-replace-docker_/">十分な理由</a>があります。<strong>Dockerと比べて、Wasmはコールドスタート時間が10～100倍高速で、メモリの使用量が少なく、機能の制約による優れたセキュリティモデルを採用しています</strong>。コンテナではなくWasmモジュールが演算とデプロイの標準的な単位となれば、拡張性とセキュリティは向上するでしょう。</p>
<p>こうした変化は突然起きるものではありません。したがって、Wasmベースのコンテナ化は、完全にDockerを代替するのではなく、既存のオーケストレーションシステムに統合される可能性が高いでしょう。</p>
<p>筆者は今後数年間でこの分野の動きがとても盛んになると予想します。既にいくつかのプロジェクトがいち早く動き始めています。</p>
<ul>
<li>Microsoft AzureのDeis Labsは<a href="https://krustlet.dev/">Krustlet</a>を開発しました。これは既存のKubernetesクラスタでWasmワークロードを実行する方法の一つです。</li>
<li>Deis Labsは、Wasmを中心とするPaaS（platform-as-a-service）の<a href="https://github.com/deislabs/hippo">Hippo</a>もリリースしました。筆者は<a href="https://github.com/fermyon">Fermyon</a>がこのテクノロジーの商用化を目指しているのではないかと推測します。</li>
<li><a href="https://cosmonic.com/">Cosmonic</a>は、<a href="https://github.com/wasmCloud/wasmCloud">wasmCloud</a>プロジェクトにおいて、分散システム向けにWasmコンテナ化とアクターモデルを結合するプラットフォーム兼オーケストレーション層を構築しています。</li>
<li><a href="https://github.com/lunatic-solutions/lunatic">Lunatic</a>プラットフォームもアクターモデルを採用しており、単一のWebAssemblyランタイムプロセス上で複数の軽量なコンテナを実行するための最高のサポート機能を搭載しているとみられます。</li>
<li><a href="https://suborbital.dev/">Suborbital</a>の<a href="https://github.com/suborbital/atmo">Atmo</a>もプラットフォーム兼オーケストレーションシステムですが、サーバレスのワークロードに比較的大きな重点を置いています。
### FaaS/サーバレスプラットフォーム
FaaS（function-as-a-service）プラットフォームは、ユーザ提供コードを高速かつ安全に実行する必要があります。サーバレスプラットフォームは、コードを短期間実行するために利用されることが多いため、起動時間が特に重要な指標となります。<strong>Wasmは超高速なコールドスタートと幅広い言語のサポートにより、サーバレスのワークロードにとって優れた選択肢となっています</strong><a href="#08">8</a>。</li>
</ul>
<p><a href="https://blog.cloudflare.com/webassembly-on-cloudflare-workers/">Cloudflare Workers</a>とFastly <a href="https://www.fastly.com/blog/how-compute-edge-is-tackling-the-most-frustrating-aspects-of-serverless">Compute@Edge</a>が提供するCDNエッジ・コンピューティング・プラットフォームには既にWebAssemblyの実行機能が搭載されています。Fastlyは、市場の他のサービスよりも起動時間が100倍速いと主張しており、その高速化の理由をWebAssemblyベースのコンパイラとランタイムにあるとしています。NetlifyとVercelもこの分野の製品を開発中です。</p>
<p>主要なクラウドプロバイダが構築したサーバレスプラットフォームも後れを取ってはいません。AWS Lambdaは数カ月前（※訳注：翻訳元の記事は2022年1月31日公開）にWebAssemblyサーバレス関数をローンチしており、GCPとAzureもこれに続くと予想されます。</p>
<h3>ブロックチェーン</h3>
<p>EthereumやSolanaなどのプラットフォームは、ブロックチェーン上で実行できる「スマートコントラクト」と呼ばれるコードをユーザが書くための仕組みを提供します。Ethereumは完全な独自システムを構築しており、コンパイル済みバイトコードのバイナリ表現であるSolidityという言語や、サンドボックスでコードを実行するためのEthereum Virtual Machineを作成しています。Solanaは一部既存のイノベーションを再利用することを選択しており、LLVMコンパイラインフラを利用して、C、C++やRustのコードをバイナリ形式のBerkeley Packet Filterバイトコードの一種にコンパイルします。しかし、Solanaも依然としてSealevelという独自のランタイムを開発しています。</p>
<p>WebAssemblyはこうしたインフラの大部分を既に提供しています。ユーザは、任意の言語でコードを書き、コンパイラインフラによってWasmバイトコードを作成し、無数の高性能なランタイムを利用できます。</p>
<p>しかし、EthereumとSolanaが既にこうしたインフラを構築しているならば、WebAssemblyはどんな価値を提供できるのでしょうか？実際には、主な付加価値はエコシステム関連にあります。例えば、Ethereumはスマートコントラクトを書くための独自言語を持っていますが、これは他言語で書かれたライブラリや共通関数をすべて活用することはできないという意味です。SolanaはRustエコシステムを利用できるため、その点ではEthereumをわずかに上回っています。<strong>WebAssemblyの技術的な課題が克服されれば、現在よりはるかに多くの人がスマートコントラクトを開発し、既に使い慣れたライブラリやツールを利用できるようになるでしょう</strong>。</p>
<p>このように考えているのは決して筆者だけではありません。例えば、Polkadotネットワークはランタイムとして<a href="https://eos.io/news/eos-virtual-machine-a-high-performance-blockchain-webassembly-interpreter/">WebAssemblyベースの仮想マシン</a>を使用しています。EOS仮想マシンも<a href="https://eos.io/news/eos-virtual-machine-a-high-performance-blockchain-webassembly-interpreter/">WebAssemblyがベース</a>です。<a href="https://cosmwasm.com/">CosmWasm</a>は複数のブロックチェーンで機能するスマートコントラクトの構築にWebAssemblyを使用しています。Ethereum Virtual MachineをWebAssemblyの一部のみで代替する「<a href="https://github.com/ewasm/design">eWASM</a>」という案もありましたが、これは立ち消えになったようです。Wasmerランタイムは、明確にブロックチェーン向けに構築された「シングルパス」コンパイラモードを提供します。一方、WasmEdgeは、Ethereumとの互換性があるスマートコントラクト実行エンジンを搭載していると主張しています。</p>
<h2>予測と展望</h2>
<h3>新たなアプリケーションアーキテクチャ</h3>
<p>Dockerが仮想マシンを完全に代替できなかったように、WasmもDockerを完全には代替できません。例えば、仮想マシンがカスタムOSカーネルを実行できるのに対して、Dockerのコンテナでは実行できません。同様に、Wasmのコンテナは、x86の256ビットAVX命令などの一部の特殊なCPU命令を利用できないため<a href="#09">9</a>、アプリケーションによってはDockerと同等のパフォーマンスを発揮することが不可能です。</p>
<p>筆者の見解では、DockerではサポートされているがWasmではサポートされていないワークロードの差は、現時点ではDockerと仮想マシンの同様の差よりも大きいと考えられます。しかし、Wasmはまだ発展途上のテクノロジーであるため、対応可能なワークロードの種類は増えていくでしょう。Dockerの台頭はマイクロサービスアーキテクチャの台頭と密接に連動していました。これにより、仮想マシンに適したモノリシックなアプリケーションはDockerのコンテナに適したマイクロサービスに置き換えられていきました。<strong>いずれはWebAssembly の独自機能を活用した新たなアプリケーションアーキテクチャが登場するでしょう</strong>。</p>
<p>コンウェイの法則によれば、アプリケーションのアーキテクチャは、そのアプリケーションを設計した組織のコミュニケーション構造を反映します。コンピューティングの歴史上すべての新しい「リファレンスアーキテクチャ」は、人と人の間で必要な調整の量を減らしてきました。メインフレームから仮想マシンやDockerのコンテナまで、デプロイ可能なユニットを生産するために必要な人間の数は徐々に減少しています。これは、システムをどんどん小さいコンポーネントに分解し、それらのコンポーネントを構築する作業者が、明確に定義されたインタフェースを参照しながら個別に作業できるようにすることによって実現されました。マイクロサービスがモノリシックなアプリケーションを複数の独立したサービスに分解する一方、<strong>WebAssemblyはマイクロサービスをさらに小さいコンポーネントに分解しやすくしています</strong><a href="#10">10</a>。</p>
<p>これはどのような結果を生むでしょうか？いくつかの可能性を紹介します。</p>
<ul>
<li>アプリケーションを中核的なビジネスロジックと他のシステムとの連携に必要なグルーコードに分割した場合、通常はビジネスロジックが他の部分よりかなり小さくなります。グルーコードのインタフェースを、それが提供する機能の実装から分離すれば、ビジネスロジック中心のアプリケーションを構築し、残りを外部の機能プロバイダに任せることが可能になります。これと、長く蚊帳の外に置かれていた<a href="https://www.brianstorti.com/the-actor-model/">アクターモデル</a>を組み合わせたものが<a href="https://github.com/wasmCloud/wasmCloud">wasmCloud</a>のアプローチの本質です。</li>
<li>もう一つの可能性は、サーバレスアーキテクチャがマイクロサービスを超える次のステップになるというものです。ほとんどのサービスはステートフルな部分とステートレスな部分に分割でき、ステートレスな部分は任意に拡張可能なサーバレス関数として実行できます。この場合、WebAssemblyは、こうしたサーバレス関数にとって便利で簡単に拡張可能なランタイムとして機能します。</li>
<li>WebAssemblyはサードパーティの依存関係についての見方を変えるかもしれません。モダンなコードはサードパーティのライブラリに大きく依存しており<a href="#11">11</a>、そうした依存関係のほとんどは十分に何度も調査されることがありません。最近の<a href="https://en.wikipedia.org/wiki/Log4Shell">Log4jの脆弱性</a>のようなソフトウェアのサプライチェーンの問題が明らかになるにつれて、人々はサードパーティライブラリのセキュリティを真剣に考えるようになると筆者は予想しています。Firefoxのように、WasmとRLBoxを利用して特定のライブラリを隔離するアプローチはいっそう広まっていくでしょう。パフォーマンス上の制約を克服できれば、同一のWasmランタイム内の機能が制約された別個のコンテナにサードパーティライブラリを隔離することも可能かもしれません<a href="#12">12</a>。</li>
</ul>
<h3>ブラウンフィールドへのデプロイ</h3>
<p>Wasmはいずれ何らかの形でDockerと相互運用できるようになる必要があります。今後2～3年は、Wasmの主な用途は後方互換性の要件が少ないグリーンフィールド（※訳注）へのデプロイとなるため、相互運用性が絶対に必要というわけではありません。しかし、最終的には、Wasmが（特に法人向け環境で）コンテナ化をめぐる競争に完全に勝利するには、ブラウンフィールド（※訳注）へのデプロイが簡単であることが必要です。
（※訳注：本翻訳は既存の投資用語を参照した表現として解釈します。「グリーンフィールド」既存環境による制約がない、新規開発できる環境。「ブラウンフィールド」既に既存のシステム等が動作している、制約つきの環境。）</p>
<p>考えられる結末の一つは、DockerがWasmランタイムを統合することです。これはあり得そうな話ですが、Wasmは今後、十分に差別化され、完全に別個のツールとして利用することが妥当になると筆者は予想しています。その代わり、<strong>DockerとWasmのコンテナはオーケストレーション層で統合されるでしょう</strong>。</p>
<p>KubernetesがWasmベースの実行を効果的に統合できるか、あるいは新たなオーケストレーションシステムが登場するかは、あまりはっきりしません。一方では、Kubernetesは現在、オーケストレーションに関して他の追随を許さない王者です。その勢いは驚異的で、Wasmによるコンテナ化の推進派はそれに乗じるのが賢明でしょう。MicrosoftのエンジニアはKubernetesとWasmが統合されるという未来に投資しており、<a href="https://github.com/krustlet/krustlet">Krustlet</a>を開発しています。これはKubernetesでWasmのワークロードを実行できるようにするものです。他方、WasmのコードはDockerのコンテナとは要件が異なるとみられるため、Kubernetesとは相性が良くない可能性があります。例えば、Wasmによるサードパーティライブラリの隔離を採用している場合、コンテナ間の通信のために共有メモリを設定するのが便利ですが、これはKubernetesでは困難でしょう。いずれはこうしたWasmネイティブのオーケストレータが懸け橋となり、Dockerからの移行やDockerとの統合が簡単になるはずです。</p>
<p>筆者はこれからWasmオーケストレータの波が来ることを期待していますが、Kubernetesは十分に定着しているため、すぐに廃れはしないでしょう。

### 標準化されたサーバレス/エッジフレームワーク</p>
<p>ほとんどのサーバレスプロバイダはルートやラムダ関数を定義するための独自のフレームワークを定めています。例えば、Cloudflareは独自の「cf」という型を定め、コードのスキャフォールディングを設定するためにwranglerというCLIツールを提供しています。Fastlyにはキャッシュとのインタラクションとロギングのための一連の独自インタフェースがあり、AWS Lambdaにも同様の設定が存在します。KubernetesのFissionフレームワークは、さまざまな言語を統合するための独自ライブラリを持っています。一部のプラットフォームは、ユーザにDockerのコンテナを提供させ、プラットフォームが実行のみをすれば良いようにすることで、この問題を回避しようとしています。<a href="https://knative.dev/docs/">Knative</a>と<a href="https://fly.io/">Fly.io</a>はどちらもこのアプローチを採用しています。しかし、これらはコールドスタート時間の影響を軽減するために「ワーカープールを温めておく」問題をユーザに転嫁しなければなりません。</p>
<p>現在は標準化されたサーバレス関数の定義とデプロイ仕様を構築するチャンスがあります。人気の<a href="https://github.com/serverless/serverless">Serverless Framework</a>は、デプロイの抽象化にはそれなりに役立ちますが、依然としてプロバイダ固有の詳細な部分は関数の実装に委ねられています。こうした詳細部分が抽象化されれば、すぐにマルチクラウドのデプロイは大幅に簡単になり、このフレームワークははるかに強力になるでしょう。いずれはサーバレスにおけるTerraformのような存在になるかもしれません<a href="#13">13</a>。</p>
<h3>パッケージ管理</h3>
<p>あらゆるプログラミング言語には、その言語を取り巻くエコシステムが存在します。ほとんどのモダンな言語は一元的なパッケージレジストリを利用しており、PythonにはPyPI、Node.jsにはnpm、Rustにはcrates.ioがあります。こうしたレジストリやそれに付属するツールとワークフローは、高品質なエコシステムの開発や開発者の作業の効率化にとって重要です。</p>
<p>Wasmの場合、<a href="https://wapm.io/">WebAssembly Package Manager</a>（WAPM）がこの需要を満たすはずでした。しかし、実際にはプロジェクトはほとんど休止しているようです。この記事の執筆時点（※訳注：翻訳元の記事は2022年1月31日公開）で、<a href="https://web.archive.org/web/20211229050050/https://wapm.io/">過去2カ月</a>に更新されたパッケージは3つにとどまっています。問題は、パッケージがお互いに依存すると想定されているのに対し、WAPMが相互依存関係のないスタンドアロンのWasmバイナリでしか機能しないことです。開発者にとって他の選択肢はWasmモジュールをnpmに公開することですが、npmは言語をまたぐ相互運用性を促進するものではないため、当然ながらJavaScriptやAssemblyScriptを越えるWasmエコシステムを構築するうえで理想的とは言えません。</p>
<p>問題の原因は、実際にはWAPMやnpmではなく、WebAssembly自体が粗削りな点にあります。</p>
<blockquote>
<p>現在、意味のあるWebAssemblyアプリケーションを書き、それがランタイムや言語の境界を越える相互運用性を持つようにするには、多大な労力が求められます。また、基本的でないデータ型（文字列や構造体など）のやり取りにはポインタの演算と低水準なメモリの操作が必要です。</p>
<p><a href="https://radu-matei.com/blog/intro-wasm-components/">― Introduction to WebAssembly components | radu’s blog</a></p>
</blockquote>
<p>これこそ、まさにWebAssembly Component Modelが解決しようとしている問題です。WasmコンポーネントはWebAssembly Interfaceフォーマットを標準化し、こうしたインタフェースの実装・利用の両方のための<a href="https://github.com/bytecodealliance/wit-bindgen">コードジェネレータ</a>を提供します。つまり、Wasmでランタイムと言語の壁を乗り越えるのが簡単になるのです。</p>
<p>WebAssemblyには高品質なパッケージマネージャを構築する大きな機会があります。このパッケージマネージャは、Wasmモジュールを他の言語から利用するためのバインディングを生成するのにWasmコンポーネントのcodegenを利用すべきでしょう。このツールが十分に優れていれば、言語をまたぐ開発がとても簡単になり、サーバサイドのWebAssemblyエコシステムの可能性を本当の意味で広げる可能性があります。Wasmパッケージレジストリは、他のパッケージレジストリと連携し、適切に生成されたバインディングとともにパッケージをPyPI、npm、crates.ioに自動的に公開することもできるかもしれません。</p>
<h2>終わりに</h2>
<p>ここまで読んできた方は、「WebAssemblyがそんなに優れているなら、なぜ広く使われていないのか？」と考えていることでしょう。その理由をいくつか挙げたいと思います。</p>
<ul>
<li>WebAssemblyはマーケティングがうまくありません。WebAssemblyはWeb限定でもアセンブリでもなく、名前が実体とかけ離れています。WebAssemblyは主にWeb開発者向けにマーケティングと宣伝が行われていますが、実際のポテンシャルは<a href="https://blog.bitsrc.io/whats-wrong-with-web-assembly-3b9abb671ec2">ブラウザを越えたところ</a>にあります。本当の力が明らかになるのは、C++とRustの開発者がWasmの持つポテンシャルに一斉に気づき始めたときでしょう。</li>
<li>WebAssemblyは依然として標準化されていません。例えば、WebAssembly System Interfaceには正式に標準化されていない無数の拡張機能がありますが、さまざまなランタイムがこうした拡張機能の一部を実装しています。ユニバーサルポータビリティという目標も完全には実現されていません。</li>
<li>言語間のインタラクション機能が不便です。ユーザが実際にさまざまな言語でWasmを使用し始めるには、クリティカルマスに相当する数の言語について、WebAssemblyコンポーネントと優れたコードジェネレータが必要です。</li>
<li>開発者体験に大きな改善の余地があります。<a href="https://thenewstack.io/the-pain-of-debugging-webassembly/">デバッグをはじめ</a>とするツールや、パッケージマネージャ、ビルドシステム、IDEとの統合性が改善されることが理想です。</li>
<li>こういうことは言いたくないのですが、WebAssemblyのライブラリ隔離機能が正当に評価されるには、Log4Shellと同様の規模の深刻なソフトウェア・サプライチェーン・インシデントがあと何回か起きる必要があるでしょう。</li>
</ul>
<p>WebAssemblyは名だたる数々のサービスで導入されており、さまざまな用途に利用できますが、IT業界全体では一部で散発的に使われているにすぎません。筆者の友人の中でWebAssemblyを知っている数少ない人たちは、基本的にはWebAssemblyをとても面白いと考えているものの、まだ十分に成熟していないため開発には利用していません。しかし、こうした課題の多くに対して積極的な取り組みが行われており、今後1～2年で問題ない状態に達するでしょう。ですから、<strong>私たちは現在、WebAssemblyの利用、エコシステム、コミュニティが爆発的に拡大する瀬戸際にあると思われます</strong>。</p>
<p><em><a href="https://news.ycombinator.com/item?id=30155295">Hacker News</a>での議論にぜひご参加ください。また、<a href="https://harshal.sheth.io/about">筆者へのご意見も歓迎します</a>。この記事の初期の草案に対するフィードバックをくれたNihar Sheth、Mohak Jain、Andrew Sun、Michelle Fangに感謝します。</em></p>
<h3>注記</h3>
<ol>
<li><a name="01"></a>実際には若干微妙な部分があります。WasmにはWeb APIとWebAssembly System Interface（WASI）APIという2つの<a href="https://v8.dev/blog/emscripten-standalone-wasm">標準的なAPI</a>が存在します。また、WebAssemblyは急速に進化しているため、例えばスレッディングのように、広く実装されているが正式には標準化されていない実験的機能が数多くあります。それ以外にも、Wasmが別のアプリケーションに組み込まれる場合、そのアプリケーションが独自のAPIを提供するかもしれません。したがって、Wasmコードが実行されるのは、そのランタイムが対応しているAPIと機能のみを使用する場合に限られますが、これは十分に妥当な想定と言えます。↩</li>
<li><a name="02"></a>なぜかは分かりませんが、WebAssemblyのランタイムの名前はすべて「wa」で始まるようです。他にも<a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a>、<a href="https://github.com/WAVM/WAVM">WAVM</a>、<a href="https://github.com/wasm3/wasm3">wasm3</a>があります。数少ない例外の一つが<a href="https://github.com/wasmx/fizzy">Fizzy</a>ですが、このプロジェクトもwasmxという組織によってホストされています。↩</li>
<li><a name="03"></a>ただし、PythonやRubyなどのインタプリタ型言語やGoなどのランタイムが複雑な言語は、Wasmで実行しても良いパフォーマンスを生まないでしょう。↩</li>
<li><a name="04"></a>Firefoxでは、Wasmへのコンパイルはネットワークによるパケットの送信よりも実際に<a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">速くなります</a>。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">WebAssembly.instantiateStreaming</a>メソッドにより、ファイルのダウンロード完了前からコンパイルのプロセスを開始できるため、Wasmコードの実行開始前のレイテンシはごくわずかしか増加しません。↩</li>
<li><a name="05"></a>ただし、それでも小さな欠点は残っています。機能ベースの許可システムは依然として粒度が非常に高いわけではなく、ほとんどのWasmランタイムはSpectreのようなサイドチャネル攻撃を防止できないため、追加的な戦略が必要になります。CloudflareのKenton Vardaは、自社の脅威モデルと、脅威を軽減するために実装した対策について、<a href="https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/">詳細な記事</a>を執筆しています。↩</li>
<li><a name="06"></a>WasmはJavaScriptの「ファストパス」から逸脱した場合に生じる脱最適化の問題を回避できるため、JavaScriptの最高のパフォーマンスと同等以上のパフォーマンスで安定して高速にコードを実行できます。面白いことに、実はJavaScriptをWebAssemblyにコンパイルして元のコードの代わりに実行するだけで、ブラウザでJavaScriptの実行を高速化することが可能です。Lin Clarkはその方法とそれがうまくいく理由について、<a href="https://www.youtube.com/watch?v=CRaMls9oVBw">素晴らしい講演</a>を実施しています。↩</li>
<li><a name="07"></a>数年前にFigmaの技術リーダーとの個人的な会話で聞いた情報です。Google ChromeやFirefoxなどの多くのブラウザは既に内部でSkiaを利用しています。しかし、こうしたブラウザはSkia APIを直接は公開していないため、アプリケーションは低速なブラウザDOMやSVGインタフェースを利用しなければなりません。Figmaはこうした低速なレイヤを回避し、ブラウザのキャンバス要素に直接描画しますが、依然としてアプリケーションへの<a href="https://skia.org/docs/user/modules/canvaskit/">組み込み</a>を通じてSkiaの一部の機能を利用しています。↩</li>
<li><a name="08"></a>他にも注目すべき選択肢があります。例えば、AWS Lambdaは軽量な<a href="https://firecracker-microvm.github.io/">Firecracker microVM</a>を利用しています。両者を直接比較すると、<a href="https://arxiv.org/ftp/arxiv/papers/2010/2010.07115.pdf">WebAssemblyのパフォーマンスの方が少し優れています</a>。↩</li>
<li><a name="09"></a>WebAssemblyによる128ビット型のSIMDのサポートは、現在は実験的な段階にありますが、多くのブラウザとランタイムに実装されています。「ロングSIMD」のサポートは引き続き<a href="https://github.com/WebAssembly/design/blob/5b2c607fe173c813214afde33e0ea82d33dd0983/FutureFeatures.md#long-simd">今後の課題</a>と言えます。↩</li>
<li><a name="10"></a>この主張に対する反論は、「マイクロサービスを分解できるからといって、実際に分解するとは限らない」というものです。これは確かにもっともな批判であり、実はモノリスとマイクロサービスの関係にも当てはまります。例えば、「マイクロサービスを本番環境で始めるべきではない――モノリスは君の友人だ」という<a href="https://arnoldgalovics.com/microservices-in-production/">最近の記事</a>は<a href="https://news.ycombinator.com/item?id=29576352">大きな議論</a>を呼びました。それでも、マイクロサービスアーキテクチャは、適切な状況で導入すればとてつもなく有効で、生産性を大幅に高めます。筆者はWebAssembly中心のアーキテクチャにも同じことが言えると予想しています。ただし、WebAssemblyに適した状況がどれだけ存在するかはあまりはっきりしません。↩</li>
<li><a name="11"></a>この問題はとても有名で、<a href="https://www.reddit.com/r/ProgrammerHumor/comments/992u1p/dependencies_101/">これ</a>に<a href="https://xkcd.com/2347/">関する</a><a href="https://www.reddit.com/r/ProgrammerHumor/comments/6s0wov/heaviest_objects_in_the_universe/">ミーム</a>が存在するほどです。↩</li>
<li><a name="12"></a>誰かがこうしたサービスを提供する企業を設立すべきでしょう。最近Log4jの脆弱性が判明したことで、ソフトウェアのサプライチェーンは現在、最も重要な問題となっています。さらに、ほとんどの既存企業は依存関係の隔離よりも検証に重点を置いているようです。↩</li>
<li><a name="13"></a>これは最適な比較対象ではないかもしれません。なぜなら、Terraformがデプロイやクラウドプロバイダとのインタラクションのみを抽象化するのに対し、このフレームワークはコード層でも機能するからです。↩</li>
</ol>]]></content:encoded></item><item><title><![CDATA[Miško HeveryのQwik記事シリーズ]]></title><description><![CDATA[POSTDでは、DEV Communityで公開されているQwikシリーズ の翻訳記事を公開予定です。 翻訳記事の更新に合わせてこのページも更新されていきます。 シリーズ記事一覧 Qwikの紹介 –…]]></description><link>https://postd.cc/series-qwik/</link><guid isPermaLink="false">https://postd.cc/series-qwik/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:01:00 GMT</pubDate><content:encoded><![CDATA[<p>POSTDでは、DEV Communityで公開されている<a href="https://dev.to/mhevery/series/13467">Qwikシリーズ</a> の翻訳記事を公開予定です。</p>
<p>翻訳記事の更新に合わせてこのページも更新されていきます。</p>
<h2>シリーズ記事一覧</h2>
<ol>
<li><a href="/a-first-look-at-qwik-the-html-first-framework/">Qwikの紹介 – HTMLファーストのフレームワーク</a></li>
<li><a href="/death-by-closure-and-how-qwik-solves-it/">クロージャによる死（とQwikによる解決方法）</a></li>
<li><a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣</a></li>
<li><a href="/qwik-the-answer-to-optimal-fine-grained-lazy-loading/">Qwik：最適できめ細かい遅延読み込みを実現</a></li>
<li><a href="/how-to-score-100-on-google-pagespeed-insights-on-mobile/">モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには</a></li>
<li><a href="/your-bundler-is-doing-it-wrong/">既存のバンドラの手法は間違っている</a></li>
<li><a href="/how-we-cut-99-of-our-javascript-with-qwik-partytown/">QwikとPartytownでJavaScriptを99%削減する方法</a></li>
<li><a href="/introducing-qwik-starters-get-up-and-running-with-qwik-now/">Qwikスターターの紹介 – 今すぐQwikを起動・実行してみよう</a></li>
</ol>]]></content:encoded></item><item><title><![CDATA[Qwikスターターの紹介 – 今すぐQwikを起動・実行してみよう]]></title><description><![CDATA[コードを書いて新たな発見をするほど楽しいことはありません。
ついにの登場です。
どんなサイズでもリーンで高パフォーマンスなWebアプリを開発するための新たな方法をお試しください。
builder.i…]]></description><link>https://postd.cc/introducing-qwik-starters-get-up-and-running-with-qwik-now/</link><guid isPermaLink="false">https://postd.cc/introducing-qwik-starters-get-up-and-running-with-qwik-now/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:00:02 GMT</pubDate><content:encoded><![CDATA[<p>コードを書いて新たな発見をするほど楽しいことはありません。
ついに<code class="language-text">npm init qwik</code>の登場です。
どんなサイズでもリーンで高パフォーマンスなWebアプリを開発するための新たな方法をお試しください。
<a href="https://www.builder.io/">builder.io</a>のサイトも同じ技術で開発されており、<a href="https://www.builder.io/blog/how-we-cut-99-percent-js-with-qwik-and-partytown">PageSpeed Insights</a>で100点中100点を獲得しています。</p>
<p>QwikスターターCLIは、Qwikを試しに直接体験してみて、他のフレームワークとの違いを深く理解するためのシンプルなスターターです。

このCLIに含まれている例は次の4つで、近い将来に拡張される予定です。</p>
<ul>
<li><code class="language-text">starter</code>：基本的なHello Worldプログラム。</li>
<li><code class="language-text">starter-builder</code>：基本的なHello Worldプログラムをbuilder.ioの<a href="https://www.builder.io/c/docs/qwik-api">Qwik API</a>と統合したもの。</li>
<li><code class="language-text">starter-partytown</code>：基本的なHello Worldプログラム。<a href="https://github.com/BuilderIO/partytown">Partytown</a>を利用して、Web Workerで重いタスクを実行できることを明らかにします。</li>
<li><code class="language-text">todo</code>：古典的な<a href="https://todomvc.com/">TodoMVC</a>アプリケーション。</li>
</ul>
<h2>基本的なスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-starter
✔ Select a starter › Starter
✔ Select a server › Express

⭐️ Success! Project saved in qwik-starter directory

📟 Next steps:
   cd qwik-starter
   npm install
   npm start

> (cd qwik-starter; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--pTKj8XhI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F17ab71fc12be4fbb9a8b19415998995f%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-starter">StackBlitz</a>で試す</p>
<h2>Builder Qwik APIを利用するスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-builder
✔ Select a starter › Starter Builder
✔ Select a server › Express

⭐️ Success! Project saved in qwik-builder directory

📟 Next steps:
   cd qwik-builder
   npm install
   npm start

> (cd qwik-builder; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--pLn7Tx8D--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F8c4425a663a84a41a85555f53f2665fc%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-todo-builder">StackBlitz</a>で試す</p>
<h2>Partytownを利用するスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-partytown
✔ Select a starter › Starter Partytown
✔ Select a server › Express

⭐️ Success! Project saved in qwik-partytown directory

📟 Next steps:
   cd qwik-partytown
   npm install
   npm start

> (cd qwik-partytown; npm install; npm start) </span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Z3-eRBUs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F135effed7c724979b0fe246bd9cc20ac%3Fformat%3Dwebp%26width%3D2000"></p>
<h2>古典的なTodoMVC</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-todo
✔ Select a starter › Todo
✔ Select a server › Express

⭐️ Success! Project saved in qwik-todo directory

📟 Next steps:
   cd qwik-todo
   npm install
   npm start

> (cd qwik-todo; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--jlVYtU6n--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252Fc7c0ea671c4547ecb2cd7da50843b97f%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</p>
<h2>プロファイラで解析</h2>
<p>開発ツールを開き、上記の例をすべてプロファイラで解析してみてください。
メインスレッドでほとんど時間がかかっていないのが分かるでしょう。</p>
<p>皆さんのコーディングが楽しくなることを願っています。ぜひフィードバックをお寄せください。</p>
<ul>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[QwikとPartytownでJavaScriptを99%削減する方法]]></title><description><![CDATA[うれしいことに、builder.ioのホームページは今やモバイル端末でもPageSpeed Insightsで100点中100点をとれるようになりました。
これはQwikを導入したおかげです。 Qw…]]></description><link>https://postd.cc/how-we-cut-99-of-our-javascript-with-qwik-partytown/</link><guid isPermaLink="false">https://postd.cc/how-we-cut-99-of-our-javascript-with-qwik-partytown/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>うれしいことに、<a href="http://builder.io/">builder.io</a>のホームページは今やモバイル端末でも<a href="https://pagespeed.web.dev/report?url=https%3A%2F%2Fbuilder.io%2F">PageSpeed Insights</a>で100点中100点をとれるようになりました。
これは<a href="https://github.com/builderio/qwik">Qwik</a>を導入したおかげです。</p>
<p><a href="https://github.com/builderio/qwik">Qwik</a>はアプリケーションの規模に関係なく高いパフォーマンスを実現します。
上記のスコアは、以下の優れた技術によって達成されました。</p>
<ul>
<li><a href="https://github.com/builderio/qwik">Qwik</a>で提供されるページの起動に必要なJavaScriptは1KB未満</li>
<li>ホームページは画面上の領域のコンテンツに必要なHTMLのみを送信</li>
<li><a href="https://github.com/BuilderIO/partytown">Partytown</a>を利用し、すべてのサードパーティスクリプトをWeb Workerに移動</li>
<li><a href="https://builder.io/">builder.io</a>の視覚的なノーコードエディタを利用してサイトを作成</li>
</ul>
<p>Qwikは、数百のコンポーネントや数MBのコンテンツを有する大規模なサイトでも高速なパフォーマンスを実現します。
また、クライアントコンポーネントに移動できるインタラクティブなサーバーサイドコンポーネントも提供します。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aDEN_dzQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mfuty5116bna9h6xyawr.png"></p>
<h2>過去のスコア</h2>
<p>当社のストーリーはここから始まりました。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--CzQUpHAt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ol56o66cw8gpxsbxaixr.png"></p>
<p>注目すべき点は、サイトのパフォーマンスが平均的であることです。
GoogleのPageSpeed Insightsは、モバイル端末において、ページの読み込みが開始されてから、ユーザーがリンクをクリックして反応が返ってくるまでの時間を7.6秒と推定していました。
これは優れたユーザー体験とは言えません。
さらに、GoogleはPageSpeed InsightsのスコアをSEOランキングに反映しています。</p>
<p>スコアがいまひとつである理由は、サイトの起動時に大量のJavaScriptを実行する必要があるためです。
現在は静的サイトでも、メニューやインタラクティブコンテンツに加え、Google Tag Manager、Intercom、CRMサービスといったサードパーティの解析スクリプトを追加するために、多くのJavaScriptを搭載しています。</p>
<p>JavaScriptサイトの速度を遅くする主な要因は、サイト自体とサードパーティスクリプトの2つです。</p>
<p>低速化の第1の原因はフレームワークです。
現代のフレームワークは優れた開発者体験を提供し、Webサイトのインタラクティブ性を高めます。
しかし、その代わりに大規模なJavaScriptをダウンロードする必要があるうえに、サーバーで生成されたHTMLと、フレームワークが予測するDOMを照合しなければならないため、起動時間が遅くなります。
このプロセスは差分検出や再ハイドレーションと呼ばれており、あらゆるフレームワーク（Qwikを除く）はこの宿命から逃れられません。
差分検出や再ハイドレーションで重要なのは、フレームワークがリスナーをDOMにアタッチし、サイトをインタラクティブにする部分です。
これが理由で、差分検出や再ハイドレーションは可能な限り早くしなければなりません。
そうしないと、サイトが機能しなくなります（メニューやチャットウィジェットがないサイトを想像してみてください）。</p>
<p>低速化の第2の原因はサードパーティスクリプトです。
確かに、現実にはPageSpeed Insightsのスコアが良いデモサイトや「新築」のWebサイトが数多くありますが、ほとんどの場合、スコアが良い理由はサードパーティスクリプトがまだ搭載されていないからです。
当社のサイトに搭載されているサードパーティスクリプトをいくつか紹介します。</p>
<ul>
<li>Google Tag Manager：現在のあらゆるサイトにとって必須の存在です。利用状況に関する統計データを収集し、サイトの使われ方や、どう改善すれば良いかについて、マーケティング上の知見を得るために利用されます。Google Tag Managerは最初に実行され、PageSpeed Insightsにおけるサイトの基準タイム以上のCPU処理時間を単独で消費するため、スコアが低下します。</li>
<li>Intercom：顧客がサイトで開発者とリアルタイムでチャットし、質問をしたり、詳しい情報を聞いたりすることができます。</li>
<li>Twitter：当社の製品に関する感想はTwitterウィジェットに表示されます。ウィジェットを利用するにはTwitterのJavaScriptを読み込む必要があります。</li>
</ul>
<p>これらのスクリプトはすべて、サイトが読み込まれた時点で即座に実行され、上記の差分検出や再ハイドレーションのステップのためにCPUを奪い合うので、ユーザー体験が悪化します。</p>
<p>問題は開発者がこうした状況をほとんどコントロールできないことです。
マーケティングチームが必要とする解析機能やユーザーサービス機能を追加するには、サードパーティスクリプトを利用しなければなりません。
また、サイトの起動時に時間のかかる差分検出が求められる既存のフレームワークを利用する必要もあります。
開発者がコントロールできる部分は多くありません。
これが業界の現状であり、そのため標準的なアプローチでは誰もあまり良い結果を出せません。</p>
<p>QwikとPartytownは、この問題の解決を目指しています。</p>
<h2>現在のスコア</h2>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aDEN_dzQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mfuty5116bna9h6xyawr.png"></p>
<table>
<thead>
<tr>
<th>指標</th>
<th>前</th>
<th>後</th>
<th>単位</th>
<th>%</th>
</tr>
</thead>
<tbody>
<tr>
<td>パフォーマンススコア</td>
<td>52</td>
<td>100</td>
<td>秒</td>
<td>92%</td>
</tr>
<tr>
<td>First Contentful Paint</td>
<td>3.4</td>
<td>1.1</td>
<td>秒</td>
<td>309%</td>
</tr>
<tr>
<td>Speed Index</td>
<td>3.4</td>
<td>1.1</td>
<td>秒</td>
<td>309%</td>
</tr>
<tr>
<td>Largest Contentful Paint（LCP）</td>
<td>3.8</td>
<td>1.2</td>
<td>秒</td>
<td>316%</td>
</tr>
<tr>
<td>Time to Interactive（TTI）</td>
<td>7.6</td>
<td>1.4</td>
<td>秒</td>
<td>543%</td>
</tr>
<tr>
<td>TTI – LCP（差）</td>
<td>3.8</td>
<td>0.3</td>
<td>秒</td>
<td>1,266%</td>
</tr>
<tr>
<td>Total Blocking Time</td>
<td>1,300</td>
<td>40</td>
<td>ミリ秒</td>
<td>3,250%</td>
</tr>
<tr>
<td>Cumulative Layout Shift</td>
<td>0</td>
<td>0</td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
<p>この数値はモバイル端末のものです。
モバイル端末はデスクトップに比べて、優れたパフォーマンスを達成するためのハードルがはるかに高くなります。</p>
<p>上記の表は、当社が現在、QwikとPartytownでどれだけのスコアを達成したかを示しています。
これは非常に大きな改善と言えます。
Time to Interactiveは7.6秒から1.2秒へ、Total Blocking Timeは1.3秒から40ミリ秒へ短縮されています。
JavaScriptの実行時間を短縮できた直接の要因は、フレームワークについてはQwik、サードパーティスクリプトについてはPartytownです。</p>
<p> <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ky-SejuS--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/66w9x8saqkumy3nttv4d.png"></p>
<p>上記はQwikとPartytownを導入する前のパフォーマンスの解析結果です（モバイル端末のエミュレート）。</p>
<ul>
<li>ページの読み込みには1.8秒かかっています。</li>
<li>メインスレッドは、ほとんどの時間、「差分検出」（DOMリスナーを設置する場所を探す作業）で非常にビジーな状態です。</li>
<li>上記の結果、多くのフレームが落ちています。</li>
<li>メインスレッドが「差分検出」でビジーになる前に、JavaScriptコードを読み込むためのカスケードが生じています。</li>
</ul>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--NFv_raDZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4940z1i5ar81b1kq3340.png"></p>
<p>ここで、従来の起動時のパフォーマンスと、QwikとPartytownを導入した後のパフォーマンスを比較してみましょう。</p>
<ul>
<li>JavaScriptはダウンロードしていません。</li>
<li>ページの読み込みにかかった時間は0.5秒です。</li>
<li>メインスレッドは、ほぼアイドル状態です。</li>
<li>フレームはほとんど落ちていません。</li>
<li>Partytownの読み込みは後回しにされています。</li>
<li>サードパーティスクリプトは（メインスレッドではなく）Web Workerで実行されています。</li>
</ul>
<p>過去と現在のパフォーマンスには明らかな違いがあります。</p>
<p>重要なことは、QwikやPartytownのアルゴリズムが特別に優れているわけではないということです。
QwikやPartytownはほとんどのJavaScriptをメインスレッドから移動させて負担を軽減しており、それによってページを高速に読み込んでいます。
ただし、Qwikでは、たとえJavaScriptがほぼ存在しなくても、ページは完全にインタラクティブな状態に維持されます。
Qwikは「良いとこ取り」が可能なのです。JavaScriptのサイズを見てみましょう。</p>
<table>
<thead>
<tr>
<th>指標</th>
<th>最小化</th>
<th>圧縮</th>
</tr>
</thead>
<tbody>
<tr>
<td>ベースライン（メインスレッドのJavaScript）</td>
<td>1,800KB</td>
<td>326KB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Qwik + Partytown (Main Thread JS)</strong>*</td>
<td>3.5KB</td>
<td>2.5KB</td>
</tr>
<tr>
<td>-->パート：Qwikloader</td>
<td>.5KB</td>
<td>1KB</td>
</tr>
<tr>
<td>-->パート：Partytown confg</td>
<td>.5KB</td>
<td>1KB</td>
</tr>
<tr>
<td>-->パート：Partytown</td>
<td>2.5KB</td>
<td>1.5KB</td>
</tr>
<tr>
<td>===サイズの改善===</td>
<td>51,429%</td>
<td>13,000%</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Web WorkerのサードパーティJavaScript</td>
<td>219KB</td>
<td>82KB</td>
</tr>
<tr>
<td>-->パート：Zoominfo</td>
<td>1.5KB</td>
<td>1.3KB</td>
</tr>
<tr>
<td>-->パート：Google Tag Manager</td>
<td>167KB</td>
<td>60KB</td>
</tr>
<tr>
<td>-->パート：Google Analytics</td>
<td>50KB</td>
<td>21KB</td>
</tr>
<tr>
<td>-->パート：site-tracking</td>
<td>217KB</td>
<td>64KB</td>
</tr>
</tbody>
</table>
<p>メインスレッドのJavaScriptを1.8MBから3.5KBに縮小できました。これは素晴らしい成果です。</p>
<p>元のサイトのJavaScriptは1.8MBで、うち219KBは開発者がコントロールできないサードパーティスクリプトでした。
つまり、サイト自体のJavaScriptは1.6MBで、そこには再ハイドレーションが必要なフレームワーク、テンプレート、スタイリングが含まれます。
標準的なフレームワークを利用する場合、サイトはコンテンツを2回ダウンロードすることになります。
1回目はHTMLとして、2回目はJavaScriptとしてのダウンロードです。
二重のダウンロードが1.6MBのコードの主な要因です（圧縮すると大幅に減って244KBになるため、サイトのテンプレートであると分かります）。</p>
<p>こちらを基準として、QwikとPartytownを利用した場合の3.5KBと比較してみましょう（圧縮すると2.5KB）。
再度強調しますが、QwikとPartytownを利用すれば、メインスレッドで実行する必要があるJavaScriptはわずか3.5KBになります。
メインスレッドの仕事がないので、サイトの読み込みはとても高速になります。
もう1つのポイントは、どんなにサイトが複雑化しても3.5KBのサイズは変わらず、いわば「固定費」であることです。</p>
<p>サードパーティコードの実行に関する問題はまだ残っていますが、これらのコードはメインスレッドより優先順位が低いWeb Workerのスレッドに再配置されています。
サードパーティコードは全体でも220KBで、メインスレッドのパフォーマンスに影響を及ぼさずに役割を果たすことができます。</p>
<p>さらに、もう1つポイントがあります。先ほど述べたとおり、既存のフレームワークはサイトを2回ダウンロードする必要があります。
1回目はHTMLとして、2回目はJavaScriptとしてのダウンロードで、JavaScriptのサイズは1.6MBです。
このような場合にQwikは威力を発揮します。
Qwikは1.6MBのJavaScriptを複数の異なるチャンクに分割します。
そして、Qwikはユーザーインタラクションがあったときだけ、JavaScript全体の一部だけをダウンロードします。
Qwikはコンポーネントを順不同に、かつ遅延して再ハイドレーションできます。
そのため、ユーザーがページ上で何らかのインタラクションをするまで、JavaScriptはまったく必要ありません。
さらに、ハイドレーションがコンポーネントごとに独立しているため、ユーザーのインタラクション時にJavaScriptのごく一部をダウンロード・実行するだけで、インタラクトされたコンポーネントのみをハイドレートできます。</p>
<p>つまり、メリットは以下の2つです。</p>
<ol>
<li>ページの起動時に何もする必要がない。</li>
<li>再ハイドレーションの必要があるときでも、範囲を限定し、（ページ全体ではなく）1つのコンポーネントだけを再ハイドレートできる。</li>
</ol>
<p>最後に注目しておきたいのは、ページの大部分は静的なのでその部分のコンポーネントがハイドレートされることはなく、JavaScriptもまったくダウンロードされないという点です。</p>
<h2>Qwikとは？</h2>
<p>QwikはTime to Interactiveに焦点を当てた新しいタイプのWebフレームワークです。
Qwikには、サーバーで実行を開始し、HTMLへシリアライズし、クライアントに送信できるというResumability（再開性）があります。
クライアント側では、qwikloader.js（クライアント側で実行される1KB未満のJavaScript）がアイドル状態でユーザーのインタラクションを待っています。
ユーザーがインタラクトすると、Qwikはサーバーが処理を中断したところから実行を再開できます。
QwikにはResumabilityがあるので、起動時に差分検出をする必要がなく、ユーザーがインタラクトしたコンポーネントのみをハイドレートすればよいのです。
Qwikはサーバーでコンポーネントを作成し、それをクライアントへシームレスに移動できます。
これらすべてのプロセスによって、上記のとおり、アプリケーションは即座に利用可能になります。</p>
<h2>画面外領域のコンテンツを遅延読み込み</h2>
<p>QwikはすべてのステートをDOMに保持します。
これはQwik自体がステートレスであるという意味です。
ステートレス属性によって、画面外領域のコンテンツを遅延読み込みできます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o48jE9q6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/565yei3n8jydkkvs81yr.gif"> </p>
<p>上記は既存のフレームワークではとても困難ですが、Qwikなら朝飯前です。</p>
<h2>Partytownとは？</h2>
<p>PartytownはサードパーティスクリプトをWeb Workerに再配置できます。
サードパーティスクリプトは、サイトのTime to Interactiveを遅くする最大の原因になっていることがよくあります。</p>
<h2>次はどうなる？</h2>
<p>私たちは、Qwikを皆さんに早く届けるために尽力しています。
Qwikによってどんなに素晴らしいサイトを開発できるか、皆さん自身の目で確かめてください。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[既存のバンドラの手法は間違っている]]></title><description><![CDATA[最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、…]]></description><link>https://postd.cc/your-bundler-is-doing-it-wrong/</link><guid isPermaLink="false">https://postd.cc/your-bundler-is-doing-it-wrong/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、遅延読み込みをする場所とタイミングを決定します。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> chunk <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-chunk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>someSymbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>開発者は以下を行う必要があります。</p>
<ul>
<li>コードのどの部分が遅延読み込みに適しているかを判断します。</li>
<li>既存のアプリケーションワークフローとの互換性がある方法で遅延読み込みを実行します（遅延読み込みは本質的に非同期ですが、遅延読み込みを実行するための理想的な関数は同期型の可能性があるため、遅延読み込みコードを設置できる場所は限られます）。</li>
<li><code class="language-text">./my-chunk</code>にチャンク名を割り当てます。バンドラがチャンクに割り当てる名前や、チャンクを1つのアプリケーションにまとめる方法に影響を及ぼします。</li>
<li>何をチャンクに含めるかを判断します（例えば、<code class="language-text">symbolA</code>と<code class="language-text">symbolB</code>は同じチャンクに含めるべきか、別のチャンクに分けるべきか？）。</li>
</ul>
<p>ここで問題なのは、開発者はソースコードを書いている時点では、遅延読み込みするコードの選択が適切であるか、チャンクに適切なシンボルが存在するかが分からないということです。
この点は、アプリケーションを実際にデプロイし、現実に利用状況を観察してみないとはっきりしません。
例えば、設定ページはほとんどアクセスされないので、メインバンドルから除くべきかもしれません。
あるいは、通知セクションを遅延読み込みにしたところ、実際はユーザが最もよくアクセスするページだったため、ユーザ体験がかえって悪化している可能性もあります。</p>
<p>さらに悪いことに、ひとたび開発者が選択をすると、バンドラがそれを補うためにできることはほんの少しです。
バンドラは、まさに開発者が求めることをしなければなりません。
バンドラにもっと自由を与えるには、まったく新しい方法で問題を見る必要があります。</p>
<p>ポイントは、コードを書いている時点では最終的なバンドルがどうなるかが分からないため、どこにdynamic importを挿入すべきかを判断するための十分な情報がないことです。
一方、チャンクの理想的な姿を判断するための十分なデータが集まったときには、ソースコードはすでに書き上がっています。
さかのぼってdynamic importを挿入するのは、大きな手間になるかもしれません（あるいは、過剰な遅延読み込みによって、アプリを細かく分割しすぎる恐れもあります）。</p>
<p>私たちが求めているのは、チャンクの理想的な数を判断し、現実のユーザによるアプリケーションの利用状況に基づいてチャンク間でコードを移動できることです。
これを実行する際に、さかのぼってソースコードをリファクタリングする必要がないことが望ましいでしょう。
チャンクのレイアウトは、コードとしてコードベースに組み込むのではなく、設定情報としてバンドラに移すべきです。</p>
<p>さらに複雑なことに、最近のフレームワークはすべて同期方式のレンダリングパイプラインを採用しています。
そのため、非同期方式のdynamic importをアプリケーションに挿入するのがとても難しくなります。</p>
<p>最適な遅延読み込み戦略を追求するなら、上記の問題を解決する必要があります。</p>
<h2>Qwikの登場</h2>
<p>コンポーネントはQwikアプリケーションの基本的な構成要素です。
Qwikはコンポーネントを3つの部分に分割することを求めます。</p>
<ol>
<li><strong>ビュー</strong>：コンポーネントのビジュアル部分をレンダリングするJSXコードが含まれます。</li>
<li><strong>ステート</strong>ファクトリー：コンポーネントの新たなステートを作成するコードが含まれます。</li>
<li>イベント<strong>ハンドラ</strong>：コンポーネントの挙動やユーザとのインタラクションに利用されるコードが含まれます。</li>
</ol>
<h2>なぜコンポーネントを3つの部分に分割するのか？</h2>
<p>ほとんどのフレームワークは、ビュー、ステート、ハンドラのコードを1つにまとめています。
以下は、この働きを解説するために用意した擬似フレームワークのコードです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> <span class="token punctuation">{</span>step<span class="token operator">?</span><span class="token operator">:</span>number<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> step <span class="token operator">=</span> props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">-</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">-</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">+</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
 )
}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントのビュー、ステート、ハンドラがすべて一緒になっているのに注目してください。
これはそれらのすべて（ビュー、ステート、ハンドラ）を同時にダウンロード、パース、実行しなければならないことを意味します。
そのため、遅延読み込みはかなり制限されます。</p>
<p>ここで挙げた程度の例では大きな問題にならないかもしれませんが、上記のコードがもっと複雑になって、何KBものコードを一度にダウンロード、パース、実行する必要がある場合を想像してみてください。
その場合、ビュー、ステート、ハンドラを何としても一緒に読み込ませようとするのは良くないかもしれません。
それがなぜ問題なのかを、ユーザのよくある利用パターンを通して見ていきましょう。</p>
<p><strong>ユーザがコンポーネントをクリックしてインタラクトする：</strong></p>
<ul>
<li>一部の<code class="language-text">handler</code>だけが必要：ダウンロードしなければならないのは、トリガーされた特定のハンドラのみです。その他のハンドラはすべて不要です。</li>
<li><code class="language-text">view</code>は<strong>不要</strong>：ハンドラによる再レンダリングが行われない可能性や、異なるコンポーネントの再レンダリングが行われる可能性があるので、ビューは不要かもしれません。</li>
<li><code class="language-text">state factory</code>は<strong>不要</strong>：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>コンポーネントのステートが変更される：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は不要：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>親が新たなコンポーネントを作成する：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は必要：コンポーネントが作成されるため、ステートを初期化するためのコードは必要です。</li>
</ul>
<p>上記の例は、それぞれのケースで必要なのがビュー、ステート、ハンドラ情報の一部のみであることを示しています。
問題は、3つの異なる情報がすべて一緒に埋め込まれているのに対し、それらがコンポーネントのライフサイクルにおいて異なるタイミングでしか利用されないことです。
最適なパフォーマンスを達成するには、コンポーネントに求められる役割に基づき、コンポーネントを部分ごとにダウンロード・実行する方法が必要です。
上記のコードでは、ご覧のとおり、コンポーネントを永久に分離できません。</p>
<h2>分割は簡単</h2>
<p>Qwikは、当面のタスクに必要なコードだけをダウンロード・実行することでこの問題を解決します。
上記の例のコードはシンプルですが、現実のコードはずっと複雑であることを忘れないでください。
さらに、コードが複雑になるとimportが増えることが多く（import自身もimportを必要とします）、コンポーネントのコードは一段と増加します。
この状況を「ツール」で解決することはできません。
コンポーネントをパーツ単位に分割し、必要に応じて遅延読み込みできるようにするための静的解析ツールを作成するのは不可能です。
開発者は、対応する部分ごとにコンポーネントを分割し、きめ細かい遅延読み込みを可能にしなければなりません。</p>
<p>そのために、Qwikはマーカー関数の<code class="language-text">qrlView</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を導入しています。</p>
<p>ファイル：<code class="language-text">my-counter.tsx</code></p>
<div class="gatsby-highlight" data-language="tsx"><pre style="counter-reset: linenumber NaN" class="language-tsx line-numbers"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>
 QComponent<span class="token punctuation">,</span>
 qComponent<span class="token punctuation">,</span>
 qrlView<span class="token punctuation">,</span>
 qrlHandler<span class="token punctuation">,</span>
 qrlState
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントの型を宣言し、プロパティとステートの形態を定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Counter</span> <span class="token operator">=</span> QComponent<span class="token operator">&lt;</span><span class="token punctuation">{</span> step<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
                                   <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのステートファクトリーを宣言します。</span>
<span class="token comment">//これはステートを初期化するために新たなコンポーネントが作成される際に利用されます。</span>
<span class="token comment">//（再ハイドレーションでは利用されません。）</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlState</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのレンダリングに利用されるコンポーネントのビューを定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlView</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのビューは、挙動を記述するハンドラを必要とする場合があります。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update
   <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlHandler</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token punctuation">,</span> <span class="token punctuation">{</span>direction<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
       <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//最後にすべてを1つのコンポーネントにまとめます。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qComponent</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> CounterState<span class="token punctuation">,</span>
 view<span class="token operator">:</span> CounterView<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>上記のコードは他のフレームワークに比べて冗長です。
しかし、コンポーネントを部分ごとに明確に分割するという手間をかけることで、きめ細かい遅延読み込みが可能になるというメリットが生まれます。</p>
<ul>
<li>開発者体験の観点から見て、コンポーネント当たりのオーバーヘッドはあまり変わらないことを忘れないでください。コンポーネントの複雑性が高まるにつれて、オーバーヘッドの増加は大きな問題ではなくなります。</li>
<li>この方式のメリットは、ツールによってコンポーネントを自由に複数のチャンクにパッケージ化し、必要に応じて遅延読み込みできる点です。</li>
</ul>
<h2>裏側で何が起きているのか</h2>
<p><code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>、<code class="language-text">qrlView</code>はいずれもQwik Optimizerのマーカーであり、自身への参照をQRLに変換する必要があることをツールに伝達します。
その結果、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">my-counter.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>qComponent<span class="token punctuation">,</span> qrlView<span class="token punctuation">,</span> qrlHandler<span class="token punctuation">,</span> qrlState<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token function">qComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> <span class="token string">'/chunk-abc#CounterState'</span><span class="token punctuation">,</span> <span class="token comment">// &lt;&lt;===注目</span>
 view<span class="token operator">:</span> <span class="token string">'/chunk-cde#CounterView'</span><span class="token punctuation">,</span>   <span class="token comment">// &lt;&lt;===注目</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ソースファイルの変換に加え、Optimizerはビュー、ステート、ハンドラ間の静的参照をすべて削除します。
QwikはRollupのためのエントリーポイントファイルも作成します。
これらのエントリーポイントは上記のQRLに対応します。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> Counter_update <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterView <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>重要なのは、いくつのエントリーファイルを作成するか、どのエクスポートをどのエントリーファイルと結びつけるかに関して、Qwikに大きな自由がある点です。
これは開発者が遅延読み込みする部分とそうでない部分の境界をまったく指定しないことによります。
その代わり、Qwikは、コードベースにたくさんの遅延読み込み境界（原文: lazy load boundaries）を導入するようにコードを書くよう開発者を導きます。
これによりQwikは、実際のアプリケーションの利用状況に基づき、最適なファイル配分を実現できます。
例えば、小規模なアプリケーションの場合はファイルを1つ作成し、アプリケーションの規模が大きくなるにつれて、エントリーファイルを増やすことができます。
また、特定の機能がめったに利用されない場合、その機能だけを単独のバンドルにすることもできます。</p>
<p>Rollupがエントリーファイルを処理すると、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlHandler<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlView<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>注目してほしいのは、Rollupがファイルの内容を展開してエントリーファイルにまとめ、不要なコードを削除し、理想的なサイズのバンドルを作成している点です。</p>
<h2>制約</h2>
<p>ツールが<code class="language-text">qComponent</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を移動できるようにするため、これらのメソッドの利用は制約されています（すべての有効なJavaScriptプログラムが有効なQwikプログラムとは限りません）。
その制約とは、すべてのマーカー関数が<code class="language-text">export</code>の対象となるトップレベル関数でなければならないというものです。</p>
<p>無効なコードの例は次のとおりです。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> someFn <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./some-place'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//トップレベルではないので無効</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">someFn</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//有効なimportなので問題なし</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>ツールにとっての選択肢</h2>
<p>アプリケーションを小さいファイルに分割しすぎて、ダウンロードのパフォーマンスに悪影響を与えてしまうのは、あり得ないことではありません（むしろ、とてもよくあることです）。
そのため、ツールではファイルをマージしてバンドルにすることを選択できます。
これは理想的な挙動と言えます。
アプリケーション全体の規模が比較的小さい（50KB未満の）場合、数百個ものファイルに分割するのは生産的ではないでしょう。</p>
<p>コード構造がきめ細かければ、ツールは常に、バンドルを大きくする（そして少なくする）ことを選択できます。
しかし、その逆は正しくありません。
コード構造が粗ければ、ツールがコードを分割するためにできることは何もありません。
Qwikは、開発者がアプリケーションを可能な限り小さいチャンクに分割し、ツールを利用して最適なバンドルのチャンクを発見する助けになります。
このように、Qwikはあらゆるサイズのアプリケーションに最適なパフォーマンスを提供できます。</p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには]]></title><description><![CDATA[Google PageSpeed InsightsはWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いス…]]></description><link>https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</link><guid isPermaLink="false">https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p><a href="https://developers.google.com/speed/pagespeed/">Google PageSpeed Insights</a>はWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いスコアが必要不可欠です。</p>
<p>私たちは、モバイルサイトのPageSpeed Insightsスコアを100点にするために何が必要かを探ってきました。
この取り組みを始めたとき、デスクトップサイトのスコアはすでに100点でした。
しかし、現代のeコマースの主流はモバイルコマースであり、モバイルサイトでは60点台半ばのスコアしか獲得できていませんでした。
このブログ記事では、モバイルサイトでも100点を取るための方法を共有します。
多くの企業がデスクトップサイトで100点を獲得していますが、モバイルサイトで100点を取れることは滅多にありません。
それでは始めましょう。</p>
<p>Builder.ioは標準的なNext.jsサイトです。
サイト自体がBuilderコンテンツプラットフォームで実行されているため、画像サイズや事前読み込みなど、コンテンツに関するあらゆるベストプラクティスはすでに守られているはずです。
それでもスコアはわずか60点台にとどまっていました。なぜでしょうか？</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0DMRzttv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iy8vyp90ed82l4kmhshx.png"></p>
<p>その理由を探るために、スコアの内訳を見てみましょう。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--eTUcudeP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aeaoni0mhgjyttr3utm5.png"></p>
<p>問題は以下の2つに分解できます。</p>
<ul>
<li>Total Blocking Time（TBT）とTime to Interactive（TTI）：JavaScriptによるページ上のブロッキング時間が長すぎる。</li>
<li>First Contentful Paint（FCP）とLargest Contentful Paint（LCP）：モバイルブラウザにとって、レンダリングが必要なページ上のコンテンツが多すぎる。</li>
</ul>
<p>そのため、以下を目指す必要があります。</p>
<ol>
<li>JavaScriptの量を減らす。</li>
<li>初回のレンダリング時のコンテンツ量を減らす。</li>
</ol>
<h2>なぜJavaScriptの量が増えるのか？</h2>
<p>私たちのホームページはほとんど静的なページです。
なぜJavaScriptが必要なのでしょうか？それはホームページがNext.jsサイトであり、つまりReactアプリケーションであるからです（ドラッグ&#x26;ドロップエディタによる出力をReactに変換するために<a href="https://github.com/BuilderIO/mitosis">Mitosis</a>を使用しています）。
サイトの大部分は静的ですが、JavaScriptが必要な要素が3つあります。</p>
<ol>
<li>ナビゲーションシステム：メニューにはインタラクティブ性が必要であり、したがってJavaScriptも必要。また、デスクトップとモバイル端末では異なるメニューが使用されている。</li>
<li>チャット用のウィジェットを読み込む必要がある。</li>
<li>Google Analyticsが必要。</li>
</ol>
<p>それぞれ詳しく見ていきましょう。</p>
<h2>アプリケーションのブートストラップ</h2>
<p>サイトはほとんど静的であるとはいえ、それでもアプリケーションです。
メニューを有効にするにはアプリケーションをブートストラップする必要があります。
具体的には、フレームワークは再ハイドレーションを実行する中でテンプレートをDOMと比較し、すべてのDOMリスナーをインストールする必要があります。
このプロセスによって、既存のフレームワークは<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable（再生型）</a>になります。
つまり、たとえページの95％が静的であっても、フレームワークはすべてのテンプレートをダウンロードし、リスナーが存在するかを判断するためにテンプレートを再実行しなければなりません。
これが意味するのは、最初にHTMLとして、次にJavaScriptのJSXとして、サイトが合計2回ダウンロードされるということです。</p>
<p>さらに悪いことに、再ハイドレーションのプロセスは低速です。
フレームワークはDOMの各ノードにアクセスし、仮想DOMとの差分を検出しなければならず、それに時間がかかります。
また、再ハイドレーションのプロセスはDOMリスナーのインストールと同じプロセスなので、遅延させることができません。
再ハイドレーションが遅延すると、メニューは動作しません。</p>
<p>上記は既存のあらゆるフレームワークの根本的な限界を説明したものです。
お分かりのとおり、こうしたフレームワークはすべて<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable</a>です。
これは、既存のどんなフレームワークも、現実のモバイルサイトで100点を取れないという意味でもあります。
PageSpeed Insightsが想定しているモバイルサイトのHTMLとJavaScriptのコード量はごくわずかであり、それに対して現実のコードがあまりに多すぎるのです。</p>
<p>私たちは問題を根本的に考え直す必要があります。
サイトの大部分は静的なので、その部分のJavaScriptを再ダウンロードしたり、不要な部分の再ハイドレーションに時間をかけたりすべきではありません。
このような場面でこそ、<a href="https://github.com/builderio/qwik">Qwik</a>が真の意味で輝きます。
Qwikは<a href="https://github.com/builderio/qwik">replayableではなくresumable（再開型）</a>で、それがあらゆる違いを生み出します。
結果として、Qwikでは以下が不要になります。</p>
<ol>
<li>ページを読み込むときのブートストラップ</li>
<li>リスナーをどこに入れるべきか判断するためにDOMを探索すること</li>
<li>メニューを動かすためにJavaScriptをダウンロード・実行すること</li>
</ol>
<p>これらはすべて、サイトの読み込みを実行するためのJavaScriptをほとんど必要とせず、それでもサイトのインタラクティブ性を完全に維持できることを意味します。</p>
<h2>Intercom</h2>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--On4okiXm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/v8v1uurp49y7nlkh7fr3.png"></p>
<p>Intercomは、私たちのサイトで実行されているサードパーティウィジェットで、私たちとお客様のインタラクションを可能にします。
このウィジェットをインストールする標準的な方法は、例えば以下のように、JavaScriptをHTMLに少しだけ追記することです。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">async</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://widget.intercom.io/widget/abcd1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">defer</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
<span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span><span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、上記のコードには2つの問題があります。</p>
<ol>
<li>ダウンロードと実行が必要なJavaScriptが増え、TBTとTTIに悪影響を及ぼす。</li>
<li>レイアウトシフトが発生し、CLSに悪影響を及ぼす可能性がある。その原因は、最初にウィジェット以外のUIがレンダリングされ、その後にJavaScriptのダウンロードと実行によってUIがウィジェットとともに再びレンダリングされるためである。
Qwikはそれら両方の問題を同時に解決します。</li>
</ol>
<p>まず、QwikはIntercomがウィジェットのレンダリングに使用するDOMを取得します。
次に、そのDOMが以下のように実際のページに挿入されます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app<span class="token punctuation">"</span></span> <span class="token attr-name">aria-live</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>polite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-launcher intercom-launcher<span class="token punctuation">"</span></span>
    <span class="token attr-name">role</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span>
    <span class="token attr-name">tabIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{0}</span>
    <span class="token attr-name">arial-abel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Open Intercom Messenger<span class="token punctuation">"</span></span>
    <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>ui:boot_intercom<span class="token punctuation">'</span></span>
  <span class="token punctuation">></span></span>
    ...
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-style<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">...</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この方法のメリットは、ウィジェットがアプリケーションの残りの部分と同時に即座にレンダリングされることです。
ブラウザがIntercomのJavaScriptをダウンロードし、ウィジェットの作成を実行している間、遅延や画面のちらつきは発生しません。
その結果、ユーザ体験が改善され、Webサイトのブートストラップが高速化されます（モバイル端末の通信量も節約できます）。</p>
<p>ただし、ウィジェットがクリックされたことを検知する方法や、ユーザのインタラクションに応じてウィジェットのモックアップを実際のIntercomウィジェットに置き換える何らかのコードは依然として必要です。
これは<code class="language-text">on:click=&quot;ui:boot_intercom&quot;</code>属性によって実現できます。
この属性は、ユーザがウィジェットのモックアップをクリックした場合に、Qwikに<code class="language-text">boot_intercom.js</code>をダウンロードさせるものです。</p>
<p><code class="language-text">boot_intercom.js</code>の内容</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'https://widget.intercom.io/widget/abcd1234'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> container <span class="token operator">=</span> element<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 <span class="token keyword">const</span> body <span class="token operator">=</span> container<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'show'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このファイルは、実際のIntercomウィジェットをダウンロードし、モックアップを削除し、Intercomをブートストラップします。
こうした作業はすべて勝手に行われ、ユーザはウィジェットが入れ替わったことにまったく気づきません。</p>
<h2>Google Analytics</h2>
<p>これまで私たちはJavaScriptの遅延読み込みに取り組み、Webサイトのパフォーマンスを順調に改善してきました。
しかし、アナリティクスは別物です。
なぜなら、アナリティクスを遅延させることはできず、ただちにブートストラップが必要だからです。
アナリティクスをブートストラップするだけで、モバイルサイトのPageSpeed Insightsスコアで100点を取るのは難しくなります。
この問題を解決するために、<a href="https://github.com/adamdbradley/partytown">PartyTown</a>を利用して、Web WorkerでGoogle Analyticsを実行します。
詳しくは今後の記事で説明します。</p>
<h2>JavaScriptの遅延</h2>
<p>上記の処理は、Webサイトがダウンロード・実行しなければならないJavaScriptの量を約1KBに減らします。
実行にかかる時間はわずか1ミリ秒で、ほとんどゼロと言ってよいでしょう。
このようにJavaScriptを最小限にすることで、TBTとTTIのスコアが完璧になります。</p>
<h2>HTMLの遅延</h2>
<p>しかし、JavaScriptがほとんど存在しなくても、画面上の領域をレンダリングするためにクライアントに送信するHTMLの量を修正しない限り、依然としてモバイルサイトで100点は取れません。
FCPとLCPを改善するには、とにかくHTMLを最小限に減らさなければなりません。
それを実現する方法は、画面上の領域のHTMLのみを送信することです。</p>
<p>これは目新しいアイデアではありませんが、実行するのは骨が折れます。
アプリケーションを画面上の領域と画面外の領域に簡単に分割する方法がないため、既存のフレームワークでは困難です。
ここでは仮想DOMも役に立ちません。
たとえ表示されるのがほんの一部だとしても、アプリケーションは仮想DOM全体を生成するからです。
フレームワークは、サイトの一部が欠けていると再ハイドレーション時にサイト全体を再生成するため、初回のブートストラップ時の作業がさらに増えます。</p>
<p>理想的には、画面外の領域のHTMLは送信せず、画面上の領域のメニューシステムは完全にインタラクティブな状態に維持したいところです。
しかし実際には、現実のサイトでそのようなベストプラクティスが見られないことから分かるように、実現するのは困難です。難しすぎるので誰もやらないのです。</p>
<p>QwikはDOM主体であり、それがすべての違いを生み出しています。
まずページ全体がサーバでレンダリングされます。
その後、ページの中で送信する必要がない部分が特定され、削除されます。
ユーザのスクロールに応じて、残りの部分が遅れてダウンロードされ、ページに挿入されます。
QwikはステートレスでDOM主体のフレームワークであるため、この種のDOMの操作による影響を受けません。</p>
<p>これは私たちのサーバで、サイトの画面外の領域で遅延読み込みを実現している実際のコードです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">async</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vmSandbox<span class="token punctuation">.</span><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'./server-index'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ServerIndexModule<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serverIndex</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> lazyNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'section[lazyload=true]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> lazyHTML <span class="token operator">=</span> lazyNode<span class="token punctuation">.</span>innerHTML<span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
      <span class="token punctuation">(</span>lazyNode <span class="token keyword">as</span> HTMLElement<span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'999em'</span><span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'on:document:scroll'</span><span class="token punctuation">,</span> <span class="token string">'ui:/lazy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>transpiledEsmFiles<span class="token punctuation">[</span><span class="token string">'lazy.js'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        export default (element) => {
          element.removeAttribute('on:document:scroll');
          element.style.height = null;
          element.innerHTML = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>lazyHTML<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
        };</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コードは簡潔で的確ですが、既存のどのフレームワークでも実現するのは困難でしょう。</p>
<p>以下は、画面外の領域を遅延読み込みするようにした実際のサイトです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o48jE9q6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/565yei3n8jydkkvs81yr.gif"></p>
<p>当初、ページは画面外のコンテンツを読み込んでいません。
ユーザがスクロールすると、すぐにコンテンツが追加されます。
ほとんど一瞬でコンテンツが追加されるのは、複雑なコードを実行する必要がなく、高速で単純な<code class="language-text">innerHTML</code>だけで済むためです。</p>
<h2>実際に試す</h2>
<p>こちらのページを実際に体験してみてください：<a href="https://www.builder.io/?render=qwik">https://www.builder.io/?render=qwik</a> （<a href="https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.builder.io%2F%3Frender%3Dqwik">PageSpeed Insights</a>のスコアもご覧ください）。
アナリティクスについてはまだ説明していませんが、近いうちに記事を投稿する予定です。</p>
<p>サイトは気に入っていただけましたか？
私たちは、お客様のサイトが超高速に利用できるものとなるように、Builder.ioのすべてのお客様にQwikを提供したいと考えています。
これは今まで見たことがないほど高速なプラットフォームになるはずです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Ii5M-zIi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2rgulo7ew94yp06dyevs.png"></p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwik：最適できめ細かい遅延読み込みを実現]]></title><description><![CDATA[Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけ…]]></description><link>https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</link><guid isPermaLink="false">https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけでなく、アプリケーションが続く限り行われます。
言い換えると、Qwikはきめ細かい遅延読み込みを追求しているのです。
「きめ細かい」とは、ユーザのアクションを処理するのに直接必要なコードのみがダウンロードされるという意味です。
この記事では、きめ細かい遅延読み込みを実現するために解決すべき技術的課題について探っていきます。</p>
<h2>リスナーをシリアライズ</h2>
<p>最も明確に解決すべき課題は初回のページ読み込みです。
この点に関しては、「<a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に</a>」で対応策をすでに取り上げました。
ポイントは、イベントの名称とアクションをURLとしてシリアライズし、DOMの属性として保持することです。その後、最上位のグローバルなイベントハンドラがイベントをリッスンし、そのイベントに関連するコードをダウンロードできます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>このコードは、初回のページ読み込みで（1KBのローダを除いて）JavaScriptを一切読み込むことなく、上記の処理を実現します。
これにより初回読み込み時のTime to Interactiveの目標を達成できますが、新たな問題が生まれます。
私たちは、ユーザとの初回のインタラクション時にアプリケーション全体をダウンロードしたり、ブートストラップしたりしたくはありません。
それでは初回の読み込み時から初回のインタラクション時へ問題を先送りするだけになってしまいます（それどころか、ユーザとの初回のインタラクション時に大きなレイテンシが生じるので、状況は悪化しています）。</p>
<p>この問題は、ユーザとの1回のインタラクションで、アプリケーション全体のダウンロードやブートストラップが行われないようにすれば解決です。
その代わり、インタラクションの処理に直接必要なコードやコンポーネントのみのダウンロード、ブートストラップ、再ハイドレーションを行えばよいのです。
そのため、きめ細かい遅延読み込みが必要になります。</p>
<p>これはイベントをHTMLやDOMへシリアライズすればすべて実現できます。
そうしなければ、テンプレートの読み込みを遅延させるのは不可能でしょう。
なぜなら、フレームワークはイベントの場所を特定するためにテンプレートをダウンロードする必要があるからです。</p>
<h2>非同期かつアウトオブオーダー方式によるコンポーネントのハイドレーション</h2>
<p>初回のインタラクションによるアプリケーション全体のダウンロードやブートストラップを避けるには、コンポーネントを非同期かつアウトオブオーダー方式で再ハイドレートする必要があります。</p>
<p>ここでいう非同期とは、レンダリングシステムがレンダリングを一時停止してコンポーネントのテンプレートを非同期にダウンロードし、それからレンダリングのプロセスを再開できるという意味です。
レンダリングプロセスがすべて完全な同期方式である既存のフレームワークとはとても対照的です。
レンダリングが同期方式である場合、非同期の遅延読み込みを挿入する余地はありません。その結果、すべてのテンプレートをレンダリングの呼び出し前に準備する必要があります。</p>
<p>既存の再ハイドレーション戦略にはもう1つ問題があります。
それは再ハイドレーションがルートコンポーネントから始まり、ルート以下のすべてのコンポーネントを同期方式で再ハイドレートすることです。
そのため、すべてのコンポーネントを同時に再ハイドレートしなければならず、あらゆるコンポーネントのダウンロードを強いられます。
その結果、初回のインタラクション時の処理時間が長くなります。
アウトオブオーダー方式のハイドレーションとは、各コンポーネントを他のコンポーネントとは独立して任意の順番で再ハイドレートできるという意味です。
これにより、Qwikはリクエストの処理に必要な最小限のコンポーネントのみを再ハイドレートすることが可能になります。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./path/MyComponent_template<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ... some content ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のケースでは、<code class="language-text">&lt;div&gt;</code>は<code class="language-text">MyComponent_template.ts</code>と紐づけられたコンポーネントを表しています。
Qwikは、コンポーネントを再レンダリングする必要があると判断した場合のみテンプレートをダウンロードするため、ダウンロードがさらに遅延されます。</p>
<p>再ハイドレーションがアウトオブオーダー方式でなければ、フレームワークはすべてのテンプレートを一度にダウンロードし、再ハイドレートしなければなりません。
その結果、初回のインタラクション時に、ダウンロードと実行による大きな負荷がかかります。</p>
<h2>レンダリングをイベントハンドラから分離</h2>
<p>Qwikに関して考慮が欠かせないポイントは、既存のあらゆるレンダリングシステムがイベントリスナーをテンプレートに埋め込んでいることです。
そのため、コンポーネントを再レンダリング（または再ハイドレート）する必要があるときに、ブラウザはすべてのリスナーを必要性にかかわらずダウンロードしなければなりません。
リスナーは複雑なコードに紐づいていることが多いので、ダウンロードされるコード量はさらに増加します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded eagerly
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikはイベントハンドラをテンプレートのコードから分離します。これはリスナーとテンプレートを別々に、必要に応じてダウンロードできることを意味します。</p>
<p><code class="language-text">MyComponent_template.ts</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token function">MyComponent_template</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded lazily
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">MyComponent_onClick.ts</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>イベントハンドラをテンプレートから分離しなければ、フレームワークはコンポーネントの再レンダリングに必要な量よりはるかに多くのコードをダウンロードしなければなりません。
さらに、イベントハンドラは複雑で、他の依存関係を持っていることが多いため、ダウンロードが必要なコード量は増加します。</p>
<h2>コンポーネントのステートのシリアライズ</h2>
<p>コンポーネントを再ハイドレートするプロセスの最も重要な部分は、コンポーネントのステートを復元することです。
既存のフレームワークにはステートをシリアライズする方法がありません。
コンポーネントのステートがどこにあるかを確定するための標準的な方法が存在しないからです。</p>
<p>Qwikはコンポーネントをいくつかの部分に分解します。</p>
<ul>
<li><em>props</em>：コンポーネントの単なるプロパティ。DOMに反映される。例えば<code class="language-text">&lt;counter min=&quot;0&quot; max=&quot;100&quot;/&gt;</code>のpropsは<code class="language-text">{min: 0, max: 100}</code>。</li>
<li><em>state</em>：コンポーネントの内部ステート。DOMにシリアライズできる。</li>
<li><em>transient state</em>：追加的なステートで、コンポーネントによるキャッシュは可能だが、シリアライズは不可能なものを指す。この情報は再計算する必要がある（例：コンポーネントとサーバが通信している間の一時的なプロミス）。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Conter_template<span class="token punctuation">"</span></span>
     <span class="token attr-name">:.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>{count: 42}<span class="token punctuation">'</span></span>
     <span class="token attr-name">min</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">max</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_incremente<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  42
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_decrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントがステートをシリアライズできない場合、特定のコンポーネントを独立に再ハイドレートするのは不可能でしょう（コンポーネントはどこでステートを取得するというのでしょうか？）。
その結果、フレームワークは、ステートの計算やダウンロードのための追加コードをサーバからダウンロードしなければなりません。
Qwikはこうした問題のすべてを<a href="/html-first-javascript-last-the-secret-to-web-speed/">DOM内にステートをシリアライズする</a>ことで回避します。</p>
<h2>アプリや共有ステートのシリアライズ</h2>
<p>コンポーネント内のみで有効なコンポーネントステートに加え、複数のコンポーネントで利用されるアプリケーションステートも存在します。
これもDOM内にシリアライズする必要があります。共有ステートは以下に分解できます。</p>
<ul>
<li><em>key</em>：あるステートをただ1つに特定するID。コンポーネント内でステートを参照するために利用される。</li>
<li><em>state</em>：複数のコンポーネントで共有されるステート。DOM内にシリアライズできる。</li>
<li><em>transient state</em>：アプリケーションによるキャッシュは可能だが、シリアライズは不可能な追加ステート。この情報は再計算が可能でなければならない。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span>
     <span class="token attr-name">:item:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Item<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>789</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Shoe<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>43.21<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>987</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Sock<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>12.34<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>アプリケーションのステートをシリアライズすることで、コンポーネントが同じ情報を複数の場所でレンダリングし、他のコンポーネントとコミュニケーションできます。
フレームワークが共有ステートを把握・管理しないと、フレームワークがステートの変更を認識できないため、コンポーネントの独立したハイドレーションが不可能になります（例えば、AngularとReactにはレンダリング関数に紐づけられた明確なステート管理機能がありません。その結果、アプリケーションのステートが変更されたときにアプリケーション全体を再レンダリングする以外に妥当な方法がなく、きめ細かい遅延読み込みが困難です）。</p>
<h2>アプリのステートとコンポーネントの間のリアクティブな関係</h2>
<p>ステートを把握するフレームワークの真のメリットは、フレームワークがステートとコンポーネントの関係を認識できる点にあります。
これが重要なのは、任意のステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要があるか把握できるためです。
あるいは、それ以上に重要なのは、ステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要がないかを把握できることでしょう。
例えば、ショッピングカートに商品を追加するときは、ショッピングカート内の商品の個数を表示するコンポーネントのみを再レンダリングすべきですが、これはページ全体のごく一部でしかありません。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Unrelated<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./ShoppingCart<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$cart<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   2 items
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AddItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>buy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikの目標は再ハイドレートするコンポーネントの数を最小限にすることです。
ユーザが<code class="language-text">&lt;button&gt;</code>をクリックすると、Qwikは<code class="language-text">./AddItem</code>をダウンロードし、<code class="language-text">cart:432</code>のアプリケーションステートを更新します。
さらにQwikは、<code class="language-text">bind:cart:432</code>を持つコンポーネントが、そのステートを利用している唯一のコンポーネントであり、したがって再ハイドレーションと再レンダリングが必要な唯一のコンポーネントであると判断します。
Qwikはページ上のほとんどのコンポーネントを除外できるため、きめ細かい遅延読み込みを維持できます。
どのコンポーネントがどのステートと関係しているかを把握できるという点は、他のフレームワークには存在しないとても重要な特徴です。
この特徴によって、アプリケーションの起動時やライフサイクル全体を通じたきめ細かい遅延読み込みが可能になります。</p>
<h2>コンポーネントの分離</h2>
<p>これまでQwikがどのようにコードのきめ細かい遅延読み込みをサポートするか説明してきました。
上記の仕組みがすべて機能するのは、Qwikがアプリケーション内のデータフローを認識しているからです。
Qwikはこの情報を、再ハイドレートする必要がないコンポーネントを取り除き、必要なコンポーネントのみを再ハイドレートするために利用します。
これが暗に意味するのは、Qwikがコンポーネントと他のコンポーネントの通信を認識する必要があるということです。
コンポーネントは他のコンポーネントと秘密の会話をしてはならないのです。</p>
<p>コンポーネントがステートを取得したことをQwikが把握できない場合、Qwikは、ステートが変更されたときにそのコンポーネントの再ハイドレーションや再レンダリングが必要であることを認識できません。
そのため、コンポーネントは自身の依存関係のリストをプロパティに明記する必要があります。</p>
<p>この明確なリストがないと、フレームワークは、ステートが変更された時点ですべてを再レンダリングしなければなりません。
その結果、アプリケーション全体のダウンロードとブートストラップが行われることになります。</p>
<h2>結論</h2>
<p>Webアプリケーションが遅延読み込みに対応した構造となるように、開発のアプローチを変える必要がある点は数多くあります。
ポイントは、現在のフレームワークはこの問題を解決する助けにならず、ときには悪化させるという点です（例えば、ページ全体の再ハイドレーション、同期方式のレンダリングなど）。
Qwikはきめ細かい遅延読み込みを実現し、どんなに大規模で複雑であっても1秒未満で読み込めるサイトやアプリを開発できます。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣]]></title><description><![CDATA[すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJ…]]></description><link>https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</link><guid isPermaLink="false">https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJavaScriptヒープに保持します。<a href="https://github.com/builderio/qwik">Qwik</a>のユニークな点は、ステートが属性としてDOMに保持されることです（リファレンスもクロージャもシリアライズして送受信するのは不可能ですが、文字列であるDOM属性なら可能です。これがresumability(再開性）のカギとなります）。</p>
<p>DOMにステートを保持することには、以下のように多くのユニークなメリットがあります。</p>
<ol>
<li>DOMはシリアライズの形式としてHTMLを使用します。ステートを文字列属性としてDOMに保持することで、アプリケーションをいつでもHTMLにシリアライズできます。HTMLを送信し、別のクライアントでDOMにデシリアライズすることが可能になります。デシリアライズされたDOMは、そこから再開できます。</li>
<li>各コンポーネントを他のコンポーネントとは独立して再開できます。このアウトオブオーダー方式の再ハイドレーションによって、アプリケーション全体の一部のみを再ハイドレートすることが可能であり、ユーザのアクションに応じてダウンロードしなければならないコード量が制限されます。これは従来のフレームワークとは全く異なる点です。</li>
<li>Qwikはステートレスなフレームワークです（アプリケーションのステートはすべて文字列としてDOMに保持されます）。ステートレスなコードはシリアライズ、送受信、再開が簡単です。各コンポーネントを独立に再ハイドレートすることも可能になります。</li>
<li>アプリケーションを（初回のレンダリング時だけでなく）いつでも何度でもシリアライズできます。</li>
</ol>
<p>例として、シンプルなCounterコンポーネントと、ステートのシリアライズの仕組みを見てみましょう（これはサーバサイドでレンダリングされたHTMLの出力結果であり、必ずしも開発者がこのようなコードを書くわけではありません）。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">::app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AppState<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">app-state:</span>1234</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{count: 321}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name">::.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{countStep: 5}<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span>app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state:1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_increment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
    321.
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_decrrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<ul>
<li><code class="language-text">::app-state</code>（アプリケーションステートのコード）：アプリケーションステートの変更コードをダウンロードできるURLを指します。ステートの更新コードは、ステートを変更する必要がある場合のみダウンロードされます。</li>
<li><code class="language-text">app-state:1234</code>（アプリケーションステートのインスタンス）：特定のアプリケーションのインスタンスへのポインタ。ステートをシリアライズすることで、アプリケーションはステートの再構築をやり直すのではなく、中断した所から再開できます。</li>
<li><code class="language-text">decl:template</code>（テンプレートの宣言）：コンポーネントのテンプレートをダウンロードできるURLを指します。コンポーネントのステートが変更され、再レンダリングする必要があるとQwikが判断するまで、テンプレートはダウンロードされません。</li>
<li><code class="language-text">on:q-render</code>（コンポーネントのレンダリングのスケジュール設定）：フレームワークは再レンダリングが必要なコンポーネントを追跡しなければなりません。これは通常、無効化されたコンポーネントの内部リストを保存することで行われます。Qwikでは、無効化されたコンポーネントのリストは、属性としてDOMに保存されます。その後、コンポーネントは<code class="language-text">q-render</code>イベントのブロードキャストを待ちます。</li>
<li><code class="language-text">::.=&quot;{countStep: 5}&quot;</code>（コンポーネントのインスタンスの内部ステート）：コンポーネントは、再ハイドレーション後も内部ステートを保持しなければならない場合があります。このステートはDOMに保持できます。コンポーネントは、再ハイドレートされた時点で、再開に必要なすべてのステートを保持しています。ステートの再構築は不要です。</li>
<li><code class="language-text">bind:app-state=&quot;state:1234&quot;</code>（共有アプリケーションステートへのリファレンス）：複数のコンポーネントが同じ共有アプリケーションステートを参照できるようにします。</li>
</ul>
<h2><code class="language-text">querySelectorAll</code>は強い味方</h2>
<p>フレームワークの一般的な役割の1つは、アプリケーションのステートが変更されたときに、どのコンポーネントの再レンダリングが必要か特定することです。
この作業が発生する理由はいくつかあります。
例えば、コンポーネントが明確に無効とされる場合や（<code class="language-text">markDirty()</code>）、アプリケーションの共有ステートの変更によりコンポーネントが暗黙に無効とされる場合などです。</p>
<p>上記の例では、<code class="language-text">count</code>が<code class="language-text">app-state:1234</code>をキーとしてアプリケーションステートに保持されています。
ステートが更新された場合、そのアプリケーションステートに依存するコンポーネントは無効化（再レンダリングのキュー）が必要です。
フレームワークはどのように更新すべきコンポーネントを把握するのでしょうか？</p>
<p>ほとんどのフレームワークの場合、その答えは、単純にルートコンポーネントからアプリケーション全体を再レンダリングすることです。
この戦略は、コンポーネントのテンプレートすべてをダウンロードする必要があるという残念な結果を生み、ユーザとのインタラクションのレイテンシに悪影響を及ぼします。</p>
<p>一部のフレームワークはリアクティブで、任意のステートが変更された場合に再レンダリングが必要なコンポーネントを追跡しています。
しかし、これはテンプレートを囲い込むクロージャの形式で記録されます（<a href="/death-by-closure-and-how-qwik-solves-it/">「クロージャによる死」</a>を参照）。
その結果、リアクティブな接続が初期化されるアプリケーションのブートストラップ時に、すべてのテンプレートをダウンロードしなければなりません。</p>
<p>Qwikはコンポーネントレベルでリアクティブです。
そのため、ルートからレンダリングを開始する必要はありません。
しかし、Qwikはリアクティブなリスナーをクロージャの形式で保持するのではなく、属性の形式でDOMに保持しているので、レンダリングを途中から再開できます。</p>
<p><code class="language-text">count</code>が更新されると、Qwikは以下の<code class="language-text">querySelectorAll</code>を実行し、どのコンポーネントを無効化する必要があるかを内部で判断します。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'bind\\:app-state\\:1234'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>markDirty<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>上記のクエリによって、Qwikはどのコンポーネントがステートに依存しているかを判断し、各コンポーネント上で<code class="language-text">markDirty()</code>を呼び出します。
<code class="language-text">markDirty()</code>はコンポーネントを無効化し、そのコンポーネントを再レンダリングが必要なコンポーネントのキューに追加します。
これは<code class="language-text">markDirty</code>の複数の呼び出しを1つのレンダリングパスに連結することで行われます。
レンダリングパスは<code class="language-text">requestAnimationFrame</code>を利用してスケジュールを設定します。
しかし、ほとんどのフレームワークとは異なり、Qwikはこのキューも属性としてDOMに保持します。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">requestAnimationFrame</code>はレンダリングのスケジュール設定に利用されます。
これは論理的に考えれば、コンポーネントが待っている<code class="language-text">q-render</code>イベントを<code class="language-text">requestAnimationFrame</code>がブロードキャストすることを意味します。
ここで再び<code class="language-text">querySelectorAll</code>の出番です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'on\\:q-render'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>jsxRender<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ブラウザにはブロードキャストイベント（イベントのバブリングの逆）が存在しませんが、<code class="language-text">querySelectorAll</code>を利用すれば、イベントのブロードキャストを受け取るべきコンポーネントをすべて特定できます。
さらに、<code class="language-text">jsxRender</code>関数を利用してUIを再レンダリングします。</p>
<p>ポイントは、Qwikがどの時点でもDOMの外部でステートを保持する必要がない点です。
あらゆるステートは属性としてDOMに保持され、自動的にHTMLにシリアライズされます。
つまり、いつでもアプリケーションのスナップショットをHTMLとして保存し、それを送信したり、デシリアライズしたりできるということです。アプリケーションは途中から自動的に再開されます。</p>
<p>Qwikはステートレスであり、それこそがQwikアプリケーションにresumableがある理由です。</p>
<h2>メリット</h2>
<p>アプリケーションがresumableであることは、フレームワークのステートのすべてをDOMエレメントに保持する明確なメリットです。
しかし、一見しただけでは分かりにくい、他のメリットもあります。</p>
<p>そのメリットとは、ビューポートの外側にあるコンポーネントのレンダリングをスキップできることです。
コンポーネントのレンダリングが必要かを判断するために<code class="language-text">q-render</code>イベントをブロードキャストすると、コンポーネントが表示されているかどうかを判断し、非表示コンポーネントのレンダリングを簡単にスキップできます。
また、レンダリングをスキップすれば、テンプレートなどのコードを一切ダウンロードする必要がありません。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0C5MyDdy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l7y32eh60iarvc277zl9.png"></p>
<p>ステートレスのもう1つのメリットは、アプリケーションが実行されている間にHTMLの遅延読み込みが可能であることです。
例えば、サーバは最初に表示される画面のレンダリングに必要なHTMLを送信する一方で、画面に表示されていない部分のHTMLをスキップできます。
ユーザは最初の画面でインタラクションを開始し、アプリケーションを使用することが可能です。
ユーザがスクロールし始めた時点で、アプリケーションは他のHTMLを読み込み、それをDOMの末尾に<code class="language-text">innerHTML</code>で挿入します。
Qwikはステートレスであるため、すでに実行されているアプリケーションに何の問題も発生させずに追加のHTMLを挿入できます。
Qwikが新たなHTMLを認識するのはインタラクションが行われたときであり、その時点までHTMLのハイドレーションは遅延されます。
こうしたユースケースは、現行世代のフレームワークで実現するのがとても難しいものです。</p>
<p>私たちはQwikの未来と、それが切り開くユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item></channel></rss>