<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア]]></title><description><![CDATA[POSTD は、ニジボックスが運営する、エンジニアに向けたキュレーションメディアです。ニジボックスはWebサービスの企画、制作、開発、運用を一貫して担うリクルートの100%子会社です。 リクルートグループのオンラインサービスをはじめ、様々な業種・業界・業態のサービス開発を行っております。]]></description><link>https://postd.cc</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 14 Oct 2022 06:32:05 GMT</lastBuildDate><language>ja</language><atom:link href="https://postd.cc/feed/" rel="self" type="application/rss+xml"/><image><title>POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア</title><link>https://postd.cc</link></image><item><title><![CDATA[人材マネジメント🤯]]></title><description><![CDATA[初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いてお…]]></description><link>https://postd.cc/managing-people/</link><guid isPermaLink="false">https://postd.cc/managing-people/</guid><category><![CDATA[キャリア・働き方]]></category><category><![CDATA[開発組織]]></category><pubDate>Fri, 14 Oct 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いておく価値があるでしょう。</p>
<p>筆者は小規模なチームやスタートアップ企業のマネージャーのためにこの記事を書きました。
ほとんどのアドバイスは、大規模な企業のマネジメントには当てはまらないのではないかと思います。
なお、急成長している企業に入社する人への全般的なアドバイスについては<a href="https://klinger.io/posts/joining-hypergrowth-startups-%F0%9F%98%AC">こちら</a>をご覧ください。</p>
<p><strong>筆者について</strong></p>
<ul>
<li>
<p>中・小規模のエンジニアリングチームを数チーム管理した経験あり</p>
<ul>
<li><a href="https://beondeck.com/">On Deck</a>のCTO</li>
<li>CoinListの元エンジニアリング担当VP</li>
<li>AngelListの元リモート責任者</li>
<li>Product Huntの元CTO</li>
</ul>
</li>
</ul>
<p><strong>それでは始めましょう。</strong></p>
<h2>マネージャーはすべての失敗に責任を負う</h2>
<p>分かります……とても前向きなスタートですよね👀</p>
<ul>
<li>チームを怒る意味は全くありません</li>
<li>
<p>あなたはプロセスと人材に責任を負います</p>
<ul>
<li>あなたは常にチームより多くの情報を持っていたはずです</li>
</ul>
</li>
<li>
<p>失敗に至るプロセスを生んだのはあなたです</p>
<ul>
<li>あるいは、誤った人材を採用した（または解雇しなかった）のもあなたです</li>
</ul>
</li>
<li>結局、すべてはあなたの責任です</li>
</ul>
<h2>プロセスを管理し、人を導く</h2>
<ul>
<li>
<p>なぜかは分かりませんが、多くの人にとって、「人材のマネジメント」とは部下の仕事をコントロールしなければならないという意味になるようです</p>
<ul>
<li>彼らはマイクロマネジメントに陥り、目標やスケジュールだけでなく、仕事のやり方まで管理しています</li>
<li>あなたがマイクロマネジメントをする時間があるなら、大抵の場合、あなたの代わりにもっと人件費が安くて能力が低い人を採用し、その人に仕事をさせれば良いのです</li>
</ul>
</li>
<li>
<p>筆者が思うに、こうした行動は、マネージャの役割に関する誤解に起因しています</p>
<ul>
<li>あなたの仕事は人を管理することではありません</li>
<li>しかし、プロセスを管理し、人を導くことができます</li>
</ul>
</li>
<li>マネージャーは、仕事をどのように行うべきか、各メンバーの権限の範囲はどこからどこまでか、どのようにキャリアを形成するか、そしてこれらすべてをどのように議論し、変更できるかに関して、プロセスを管理します</li>
<li>
<p>さらに、手本を示し、共感することで人を導きます</p>
<ul>
<li>メンバーは目標、不安やモチベーションを持っています。仕事以外に問題を抱えていることもよくあります</li>
<li>仮に相手が逆の立場だったら、どう行動してほしいかを考えて行動しましょう</li>
</ul>
</li>
</ul>
<h2>プロセスとは期待を明確にしたもの</h2>
<ul>
<li>
<p>多くの人は「プロセス」に関する責任をなんとか逃れようとしています</p>
<ul>
<li>そのため「プロセスは多過ぎない方が良い」などと言います</li>
<li>筆者の私見では、これも誤解です</li>
</ul>
</li>
<li>
<p>プロセスとは、人々の行動を複雑な鎖のように結びつけ、膨大な手間を負わせるものではありません</p>
<ul>
<li>プロセスとは期待を明確にしたものです</li>
<li>例えば、「誰も作業を邪魔されないように、毎朝全員で〇〇をする」のようにシンプルなものでも構いません</li>
<li>少数のとても明確なプロセスを定め、それが守られるようにしましょう</li>
</ul>
</li>
</ul>
<h2>意思決定と意見</h2>
<ul>
<li>
<p>あらゆる議論、プロジェクト、問題や状況において、誰が意思決定するのかを明確にする必要があります</p>
<ul>
<li>他の人は意見を付け加えるにすぎません</li>
<li>理想的には、その後にフォローアップする（あるいはその仕事のリーダーとなる）人が意思決定をすべきです</li>
<li>それ以外は全員、意見を追加するだけです</li>
<li>「地位」や給与が高い人も例外ではありません</li>
</ul>
</li>
<li>
<p>マネージャーは意思決定を急に止めるためのハンドブレーキを握っています</p>
<ul>
<li>この力は文字どおりハンドブレーキのように扱いましょう</li>
<li>自動車の運転を想像してください。車を止めなければならないのに、ドライバーが反応しなければ、ハンドブレーキを引く必要があります。その結果、反動でダメージが生じるでしょう</li>
<li>絶対に必要なときにのみハンドブレーキを引き、その後に状況をどう修正するか議論します</li>
</ul>
</li>
<li>
<p>採用は意思決定スキルの優劣に基づいて判断します</p>
<ul>
<li>解雇も意思決定スキルの優劣に基づいて判断します</li>
<li>優れた意思決定スキルには他人の意見を聞くことが含まれます</li>
<li>疑問に思う場合は、意思決定者を最初から信頼できるか考えてみてください</li>
</ul>
</li>
</ul>
<h2>当事者意識</h2>
<ul>
<li>
<p>従業員が問題に対して完全な当事者意識を持つようにするのは困難です</p>
<ul>
<li>しかし、それが目標です</li>
<li>それがふさわしくない従業員なら解雇もできます</li>
</ul>
</li>
<li>
<p>フィードバックを提供し、支援しましょう</p>
<ul>
<li>従業員を信頼し、失敗を認めてください（損害を許容できる範囲で）</li>
<li>失敗を「従業員のレベルアップ」と捉えましょう</li>
</ul>
</li>
<li>
<p>最悪なのは、あなたが何度も介入し、従業員が仕事と自分を無関係と感じるようになることです</p>
<ul>
<li>彼らは当事者意識を持たず、言われたことをするだけのドローンになってしまいます</li>
<li>それがあなたの目的なら、人件費が安くて能力が低い人を採用すれば良いでしょう</li>
</ul>
</li>
</ul>
<h2>堂々巡りを避ける</h2>
<ul>
<li>
<p>プロセスを定めるときは、堂々巡りを避けましょう</p>
<ul>
<li>例えば、何かについてフィードバックを提供するときは、相手が言われたとおりにするか、あるいはそれができない理由を答えるだろうと考えてください</li>
<li>承認されることを期待してはいけません</li>
<li>誰もそんなことをしている暇はありません</li>
</ul>
</li>
</ul>
<h2>信頼</h2>
<ul>
<li>
<p>自分が神経質になっているのは、他人の仕事と自分の不安のどちらが原因かを常によく考えましょう</p>
<ul>
<li>他人があなたの感情の面倒を見る必要があるでしょうか？</li>
</ul>
</li>
<li>
<p>物事がうまくいっているときは、人を信頼するのは簡単です</p>
<ul>
<li>本当に難しいのは、物事がうまくいかないときです</li>
<li>状況に対するいら立ちと、人に対するいら立ちを常に区別しましょう</li>
</ul>
</li>
<li>
<p>「距離を置け」と言っているのではありません</p>
<ul>
<li>輪に加わり、目標を定め、意見を表明すべきですが、課題への対処はチームに任せるべきです。ただし、必要に応じてハンドブレーキを使いましょう</li>
</ul>
</li>
</ul>
<h2>率直な共有を通じて信頼を築く</h2>
<ul>
<li>
<p>従業員があなたの仕事を信頼するようになるための最も簡単な方法は、何も要求されなくても、成果を率直に共有することです</p>
<ul>
<li>従業員が探すだろうと思う場所に、すべてを利用可能な状態で置いておきましょう</li>
<li>従業員からの要求を待ってはなりません。ほとんどの従業員は要求をしないからです</li>
</ul>
</li>
</ul>
<h2>信頼は0か1ではない</h2>
<ul>
<li>
<p>私たちは信頼を0か1と考えがちです</p>
<ul>
<li>誰かを信頼するか、信頼しないかのどちらかということです</li>
</ul>
</li>
<li>
<p>しかし、これは正しくありません</p>
<ul>
<li>時とともに、信頼する人や、その人の何をどのように信頼するかは変わります</li>
</ul>
</li>
<li>
<p>信頼はシステム化できるものだと考えましょう</p>
<ul>
<li>例えば、チームの新しいメンバーにはどのような信頼を与えますか？</li>
<li>最初の数週間や1か月はどのような仕事をすることを求めますか？</li>
</ul>
</li>
</ul>
<h2>自律と放任を混同しない</h2>
<ul>
<li>筆者は、人材を採用した後は「好きなようにさせている」という創業者によく会います</li>
<li>これは原則としては正しいものの、従業員の成功を支援する責任から解放されることにはなりません</li>
</ul>
<h2>多層的な意思決定</h2>
<ul>
<li>
<p>会社では、さまざまな階層の人々が、仕事をするうえでお互いに頼りあっています</p>
<ul>
<li>CEOがプロダクトマネージャーの優先順位を認識していなければ、彼らは仕事ができません</li>
</ul>
</li>
<li>
<p>自分の仕事を社内の他人に押し付けてはなりません</p>
<ul>
<li>自分の仕事より楽しそうだからという理由だけで、他人の仕事に踏み込むこともやめましょう</li>
</ul>
</li>
</ul>
<h2>乱射型マネジメントを避ける</h2>
<ul>
<li>
<p>ミーティングで自分の意見やアイデアを手当たり次第にぶつけてはなりません</p>
<ul>
<li>あなたは経緯を十分に理解していない可能性が高く、大抵の場合、課題を最後までフォローする当事者になることはないからです</li>
</ul>
</li>
<li>
<p>単なる意見であって、意思決定ではないことを明確にしてください</p>
<ul>
<li>ただし、「創業者（またはマネージャー）の意見」がほとんどの従業員にとって大きな力を持つことを理解しましょう</li>
<li>一般的に非同期コミュニケーションでは声の「ニュアンス」が伝わりにくいため、<a href="https://klinger.io/posts/fyi-how-founders-can-avoid-drive-by-management">fyi（for your opinion 訳注：ご参考までに）タグ</a>を利用しましょう</li>
</ul>
</li>
</ul>
<p>ところで、筆者はこれを乱射型マネジメントと呼んでいます。なぜなら、グループで議論しているところにマネージャーがやってきて、銃を乱射するように要求、変更指示、アイデアを投げかけ、混乱、パニック、カオスを生み出した後、悲惨な状況を残して去っていくからです。</p>
<h2>フィードバックを提供する</h2>
<ul>
<li>人×文脈 = 成果</li>
<li>
<p>筆者の経験では、優れた人材でも、環境が悪いと不十分な成果しか出せないことがあります</p>
<ul>
<li>一方、とても平凡な人材でも、環境が素晴らしければチーム全体を上回る成果をあげることもあります</li>
</ul>
</li>
<li>
<p>フィードバックをする際、通常はその人自身よりも経緯について客観的に議論するほうが簡単です</p>
<ul>
<li>現在の問題の原因となったのはどのような状況ですか？</li>
<li>何が変わりましたか？現在何が必要とされていますか？</li>
</ul>
</li>
<li>
<p>若手エンジニアが仕事について行けていない場合</p>
<ul>
<li>それはエンジニア自身の責任ですか？それとも、チームは今の時点では、現在、若手が仕事を覚えるための役に立っていないのでしょうか？</li>
<li>すぐに問題になることはありませんが、いずれは解決するか、能力不足を受け入れる（解雇する）ことが必要です</li>
</ul>
</li>
<li>
<p>本番環境で大きなインシデントが発生した場合</p>
<ul>
<li>そもそも、なぜそのような事態が起きたのですか？</li>
<li>エンジニアリングチームは何に注目していましたか？</li>
<li>問題を回避するためのプロセスは導入されていましたか？</li>
<li>プロセスを導入する必要はありますか？</li>
<li>インシデントを起こした従業員に責任はありません</li>
<li>チーム全体が他の優先課題に注目していたからです</li>
<li>
<p>それは適切な理由（リリースへのプレッシャーなど）によるものでしたか？</p>
<ul>
<li>それとも不適切な理由（知識の不足など）によるものでしたか？</li>
</ul>
</li>
</ul>
</li>
<li>
<p>あなたが採用した人材は、モチベーションが高く、最善を尽くそうとしていると常に想定しましょう</p>
<ul>
<li>そうでない人材は解雇しましょう</li>
</ul>
</li>
</ul>
<h2>解雇は決してサプライズであってはならない</h2>
<ul>
<li>
<p>従業員にとって、解雇は決してサプライズであってはなりません</p>
<ul>
<li>状況が変わり、新たな要件が生じたことを伝える必要があります</li>
</ul>
</li>
<li>
<p>通常、従業員を解雇する理由は状況の変化です</p>
<ul>
<li>例えば、会社が変化したとき、</li>
<li>役職に求められるものが変化したときや、</li>
<li>誤った採用基準を定めていたことに気づいたときです</li>
<li>大抵の場合、責任は従業員よりもあなたにあります</li>
</ul>
</li>
<li>
<p>従業員は、自分の努力が新たな要件に足りるものであってほしいと願うかもしれません</p>
<ul>
<li>それでも、あなたが彼らを解雇しようとするときは理解を示すでしょう</li>
</ul>
</li>
</ul>
<h2>解雇を先延ばししない</h2>
<ul>
<li>従業員を解雇すると決定したら、すぐに行動しましょう</li>
<li>
<p>従業員をゾンビのような状態で雇い続けていることはよくあります</p>
<ul>
<li>「彼を解雇すべきだ」</li>
<li>そう思っても解雇しないのです</li>
<li>従業員のためになりません</li>
<li>
<p>従業員はおそらく今の環境に満足していないでしょう</p>
<ul>
<li>評価が低く、</li>
<li>良い仕事もできないからです</li>
</ul>
</li>
<li>
<p>大抵の場合、あなたが解雇を避けるのは自分のためです</p>
<ul>
<li>なぜなら、誰かを解雇するのは良い気分ではないからです</li>
<li>自分の感情や未来を、従業員の感情や未来より気にすることはやめるべきです</li>
</ul>
</li>
</ul>
</li>
<li>
<p>面談を設定し、解雇を伝えます</p>
<ul>
<li>最初に余計なおしゃべりをするのはやめましょう</li>
<li>本題を率直に切り出し、次のステップを明確にしましょう</li>
<li>必ず真剣な事実として伝えます</li>
<li>解雇を伝えるときには、あなたの感情や問題は重要ではないことを忘れないでください</li>
</ul>
</li>
<li>
<p>その後、従業員が新たな仕事を探せるように支援します</p>
<ul>
<li>従業員はかつてキャリアをあなたに委ねたのですから、その信頼を維持しましょう</li>
</ul>
</li>
<li>
<p>最後に：一部の国では、従業員を解雇するのに月によっては数日かかる場合もあります</p>
<ul>
<li>どちらにせよ、解雇のプロセスを主体的に管理し、あなたを信頼している人に敬意を持って接するようにしましょう</li>
<li>彼らはあなたのチームにキャリアを委ねたのです</li>
<li>ほとんどの場合、従業員が去るのは自らの責任ではなく、状況の変化によるものです</li>
<li>彼らが自分に適した新しい仕事を見つけられるように支援しましょう</li>
</ul>
</li>
</ul>
<h2>明確 > 不明確</h2>
<ul>
<li>
<p>ミーティング後の明確な意思決定</p>
<ul>
<li>明確な意思決定がなされていない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>明確な責任者</p>
<ul>
<li>明確な責任者がいない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>全員の意見を聞く</p>
<ul>
<li>誰が意思決定するかを明確にしましょう</li>
<li>意思決定の内容も明確にします</li>
</ul>
</li>
<li>などなど</li>
</ul>
<h2>ベストプラクティス：「現実は正しい」という認識から始める</h2>
<ul>
<li>
<p>チームやプロセスの中でベストプラクティスや変化を求めるときは、まずは既存の自然に生まれたものに必ず注目しましょう</p>
<ul>
<li>優れた人材を採用していれば、通常は彼らが自然と解決策を探し始めています</li>
<li>その解決策は適切でしょうか？もしそうなら明確にしましょう</li>
<li>「現実は正しい」という認識が重要です</li>
<li>もし適切でないなら、それを変える方法について議論しましょう</li>
</ul>
</li>
</ul>
<h2>会社は数カ月ごとにリファクタリングされるものと考える</h2>
<ul>
<li>
<p>急成長しているスタートアップ企業は、3～6カ月ごとに事業の進め方を社内でリファクタリングする必要があります</p>
<ul>
<li>現在必要な最低限の変化のみに取り組みましょう</li>
</ul>
</li>
<li>
<p>決定的な最終バージョンは存在しません</p>
<ul>
<li>あなたは会社のプロセスに対して常に不満を感じ続けるでしょう</li>
<li>伸び悩みに直面しない限り、成長痛は続くはずです</li>
</ul>
</li>
<li>
<p>コードをリファクタリングするときと同じ原則を適用しましょう</p>
<ul>
<li>以下の点に気を付けてください</li>
<li>まずは小規模な隔離された環境でテストする</li>
<li>ピアレビューを行う</li>
<li>すべてを一度に変えようとしない</li>
<li>オーバーエンジニアリングを回避する</li>
<li>などなど</li>
</ul>
</li>
</ul>
<h2>燃え尽き症候群</h2>
<ul>
<li>よくある誤解は、燃え尽き症候群は働き過ぎが原因というものです</li>
<li>
<p>実際の原因は、仕事をコントロールできない、自分が影響を与えられていないと感じることです</p>
<ul>
<li>仕事がほとんどないにもかかわらず、従業員（あるいは自分）が燃え尽きる場合があることを忘れないでください</li>
</ul>
</li>
<li>
<p>従業員が自らの影響をコントロールできるようにするには、どうすれば良いのでしょうか？</p>
<ul>
<li>どうすれば従業員と周囲の混沌とした状況の間に境界線を引けるのでしょうか？</li>
</ul>
</li>
</ul>
<h2>混乱を生み出す人間はそれに気づきにくい</h2>
<ul>
<li>
<p>創業者のよくある不満は、チームが変化について来られないというものです</p>
<ul>
<li>創業者は、大抵は変化に至る背景をよく理解し、変化の前段階を把握しています。また最も重要な点として、創業者は変化をコントロールできます</li>
<li>従業員はそうではありません</li>
</ul>
</li>
</ul>
<h2>自分の部下よりもマネージャーに多くのことを要求すべし</h2>
<ul>
<li>
<p>基本的に、失敗はチームの責任ではなく、マネージャーの責任です</p>
<ul>
<li>物事に関する率直な意見をマネージャーと個人的に共有しましょう</li>
</ul>
</li>
<li>基本的に、マネージャーが意思決定できるように信頼すべきです</li>
<li>
<p>マネージャーは結果に対する説明責任を負います</p>
<ul>
<li>すべての失敗に責任があります</li>
<li>しかし、成功はマネージャーの手柄ではありません</li>
<li>成功はチームの手柄です</li>
</ul>
</li>
<li>
<p>マネージャーは、可能なときはいつでも、成功を一人占めするのではなくチームにスポットライトを当てるべきです</p>
<ul>
<li>ポイントは簡単です。チームに与える権限を増やすとともに、チームが輝くための方法を増やしましょう</li>
</ul>
</li>
</ul>
<p>気分が明るくなるような結論ですね😬</p>
<p>とにかく……この記事が誰かの役に立つことを願っています🙏</p>
<p>当然、筆者が見逃していることも数多くあるでしょう。ですから、<a href="https://twitter.com/andreasklinger">twitter</a>でお気軽にご質問ください。また、この記事を改善するためのアイデアがあれば、<a href="https://github.com/andreasklinger/klinger-io">プルリクエストをお送りください</a>。</p>
<p>この記事が気に入ったら<a href="https://twitter.com/intent/tweet?text=Managing%20People%20an%20article%20by%20%40andreasklinger%3A%20https%3A%2F%2Fklinger.io%2Fposts%2Fmanaging-people-%25F0%259F%25A4%25AF">シェアしていただけると幸いです</a>。</p>
<p>追伸：<a href="https://www.notion.so/odteam/Product-Engineer-Playbook-859b2c4c95f849788554f1749d038c6f">筆者のチーム</a>は人材を募集中です</p>]]></content:encoded></item><item><title><![CDATA[変化するフロントエンドエンジニアの役割。「モダンフロントエンド」開発組織のつくりかた]]></title><description><![CDATA[POSTD読者の皆さんはじめまして、本メディアでキュレーターを担当させていただいている古川陽介と申します。
株式会社ニジボックスでデベロップメント室室長を務める他、株式会社リクルートでプロダクト開発…]]></description><link>https://postd.cc/postdev-furukawa/</link><guid isPermaLink="false">https://postd.cc/postdev-furukawa/</guid><category><![CDATA[キャリア・働き方]]></category><category><![CDATA[開発組織]]></category><pubDate>Mon, 12 Sep 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<div style="padding: 1rem;">
  <img style="width: 50px; height: 50px;" src="https://lp.nijibox.jp/wp-content/themes/nijibox-lp/assets/lp-assets/postdev/images/speaker_yosuke_furukawa.jpg" alt="古川陽介" >
  <span>by <a href="https://twitter.com/yosuke_furukawa">古川陽介</a></span>
</div>
<p>POSTD読者の皆さんはじめまして、本メディアでキュレーターを担当させていただいている古川陽介と申します。
株式会社ニジボックスでデベロップメント室室長を務める他、株式会社リクルートでプロダクト開発部署のマネージャーも兼務しています。
また、Japan Node.js Associationの代表理事として、Node.js の普及を目指す活動なども行っています。</p>
<p>私が普段の仕事や活動の中で強く感じているのは、フロントエンドエンジニアの役割が大きな変換点を迎えているということです。
端的に表現するとスマートフォンの登場をきっかけとしたデバイスの多様化によって、フロントエンドエンジニアの領域が拡大したと言うことになると思います。</p>
<p>パフォーマンスや開発の生産性を著しく上昇させる、ReactやVueを駆使したモダンフロントエンド開発と、それを実現するための組織構築は、今後のサービスやプロダクト開発において、ビジネスを加速させる上で欠かせないものだと考えています。
この記事では、主に開発組織の構築に焦点をあてて、私たちエンジニアがこれから進むべき道について考察していきたいと思います。</p>
<h2>私がエンジニアの組織作りに興味を持ったきっかけ</h2>
<p>キャリアの中で初めてマネジメントをすることになった2017年、私は大いに悩んでいました。</p>
<p>リクルートでエンジニア組織のマネージャーとなり、最初は本当に右も左も分からない状態でした。
「マネージャーとして何をすればよいのか？」「どうメンバーを育成していけばよいのか？」そんな悩みが尽きない日々を送っていたのです。</p>
<p>そんなある日、一冊の本に出会います。
株式会社レクター取締役の広木大地さんが著した『エンジニアリング組織論への招待』。
この本には、まさに当時の私が求めていた「どうエンジニアを成長させるか」「どうエンジニア組織を作るか」「不確実性に対応するための組織設計」といった、私の問いに対する答えが明解に記されていたのです。
この本を何度も繰り返し読み込むにつれ、組織作りの奥深さ、面白さに強く惹かれるようになりました。</p>
<p>同時期さらにもう1つ、組織作りに興味を持つきっかけとなる出会いがありました。
株式会社一休CTOの伊藤直也さんです。
彼は、CTOという立場ながら今でも現役バリバリでコードを書いていて、かつ組織作りも並行し、ビジネスの拡大を目的として事業を進めていくスーパーマンです。
理想的なマネジメントのスタイルとして彼に憧れを抱くとともに、強い開発組織を志す想いが自分の中で高まっていくのを感じていました。</p>
<h2>メンバーが成長を遂げ、大規模カンファレンスに登壇した日</h2>
<p>手探りでマネジメントや組織作りに取り組む中で、また広木大地さんの書籍や伊藤直也さんのスタイルに影響を受け、そのエッセンスを取り入れながら試行錯誤してきたことで、徐々に結果が出てくるようになりました。</p>
<p>結果が出てくると、ますます「組織」というものに対する興味が強くなります。
それにさらに拍車をかけたのが、「メンバーの成長」を目の当たりにした瞬間です。</p>
<p>入社当時は、まだエンジニアとしておぼつかなかったあるメンバーが、数年後、グループ全体の大規模カンファレンスに登壇したことがあります。
数万人を超えるグループ従業員の中から登壇者として選ばれるのはたったの数人。
彼の成長をずっとそばで見てきた私にとって、これほど嬉しいことはありませんでした。
彼がカンファレンスに登壇した日、仲間の成長という、私がそれまでに体験したことのない喜びを感じました。</p>
<p>また、チーム内の誰かのポジティブな行動や実績に対して、「次は私も挑戦してみよう」といった化学反応が生まれることもあります。
その化学反応によって、チームや組織はさらに強くなっていくと思います。
組織が強くなれば、新しく人が集まることもありますし、会社の成長にもつながります。
このようなダイナミズムは、組織作りの醍醐味と言えるでしょう。</p>
<h2>【10/1（土）開催】モダンフロントエンド×組織論がテーマのオンラインイベント「Post Dev」</h2>
<p>繰り返しになりますが、私の実体験からも「開発組織」は今後の重要なキーワードになると考えています。
モダンフロントエンド技術と開発組織の成長。
この2つの要素がうまくクロスオーバーすることで、エンジニアはさらに進化し、ビジネスが加速すると確信しています。</p>
<p>そんな、フロントエンドの未来に向けたヒントをより多くの方と共有したいという想いで、この度2022/10/1（土）に「Post Dev」というオンラインイベントを開催する運びとなりました。</p>
<p>私が大きな影響を受けた伊藤直也さん、広木大地さんをはじめ、国内外のエキスパートを登壇者としてお招きしています。
例えば、「State Of JavaScript」（JavaScriptの現状調査）で知られるSacha GreifさんからはJavaScriptの最新トレンドと今後の展望を、MicrosoftのTomomi ImuraさんからはVS Code開発を、ICSの池田泰延さんからはCSSの最新トレンドを語っていただく予定です。
※イベント詳細は<a href="https://lp.nijibox.jp/cp/postdev/">こちらのページ</a>をご覧ください。</p>
<p>今回イベントを企画するにあたって、技術的な話と組織という2つのテーマをあえて掛け合わせました。
コンテンツを全て見ていただくと、「今」と「これからすべきこと」が全体像として把握いただけるように設計しています。
「フロントエンドの新たなる可能性」を今後皆さんと一緒に追求していけるような機会となると良いなと思っています。</p>
<h2>これからのエンジニアがやるべき“2種類のアウトプット”</h2>
<p>最後に、一エンジニアという視点に立って、その役割が変化する時代においてやるべき“2種類のアウトプット”というお話で締めくくりたいと思います。</p>
<p>1つ目は、プロダクト開発そのものを意味するアウトプットです。
皆さんやっていることだとは思いますが、デバイスやサービスの多様化・複雑化に対応するため、継続的に技術を日々磨いていくことはとても大切だと考えています。
また、技術の追求はエンジニアごとのユニークな価値がもっとも発揮される行為だと思います。
ぜひ、ご自身を信頼し知的好奇心の誘うままに「道」を極めていただきたいです。</p>
<p>そしてもう１つは、ご自分が追求してきた体験に基づいたストーリーを言語化し、外へ発信する意味でのアウトプットです。
自らの試みをアウトプットすることによって、コミュニティー全体の研究水準が上がり、最終的に業界全体の技術進歩にもつながっていくと思います。
また、発表者の観点としても、技術への理解がより深められるメリットも見逃せません。
私自身、多くのイベント・カンファレンスへの登壇や記事の執筆を通して、技術面での成長も実感しています。</p>
<p>アウトプットをするためには、インプットが必要です。
ぜひ、今回の「POST Dev」でも良質なインプットをしてください。
きっと、私が一冊の本によって受けた雷のような衝撃を、尊敬すべきエキスパートたちとの出会いから生まれた高揚感を、皆さんも体験できるはずです。</p>]]></content:encoded></item><item><title><![CDATA[モダンWebにおけるキャッシングのための新HTTP標準]]></title><description><![CDATA[一般ユーザー向けの大規模なWebサイトや、モダンWeb上で動作するWebアプリケーションを運営する場合、CDNなどのキャッシングサービスによって静的コンテンツをキャッシュすることが極めて重要です。 …]]></description><link>https://postd.cc/status-targeted-caching-headers/</link><guid isPermaLink="false">https://postd.cc/status-targeted-caching-headers/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[HTTP]]></category><category><![CDATA[キャッシング]]></category><pubDate>Wed, 31 Aug 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>一般ユーザー向けの大規模なWebサイトや、モダンWeb上で動作するWebアプリケーションを運営する場合、CDNなどのキャッシングサービスによって静的コンテンツをキャッシュすることが極めて重要です。</p>
<p>しかしこうしたサービスは、非常に複雑で分かりにくいものです。</p>
<p>幸い、IETF（Internet Engineering Task Force）のHTTPワーキンググループがこの状況を改善すべく、HTTPの新標準策定に取り組んでいます。
最近、同ワーキンググループでは、キャッシングのデバッグとキャッシュ設定の管理を容易にすることを目的とした、HTTPヘッダに関する2つの新標準案の発表に向けて活発な動きがありました。</p>
<p>このことが何を意味し、どのように機能するのか、そしてWeb制作に携わる開発者全てがなぜ注目すべきなのかについて見ていきます。</p>
<h2>新標準</h2>
<p>この記事で取り上げる標準案は以下の2つです。</p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache-header/">Cache-Statusヘッダ</a></li>
<li><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-targeted-cache-control/">Targeted Cache-Controlヘッダ</a></li>
</ul>
<p>これらはHTTP標準を改訂し、CDNを活用した現在のWebに対応したものにすることを目的としており、Fastly、Akamai、Cloudflareといった人気の高いCDNが用いている既存の手法を取り入れた仕様を提供します。
ここに挙げた企業はいずれも自ら標準の策定に携わっています。</p>
<p>どちらの標準案も比較的新しい仕様です。Cache-Statusは2021年に複数回にわたるレビューが行われており、現在は（8月以降）最終レビューと正式なRFCとしての発表を待っているところです。
一方、Targeted Cache-Controlヘッダは現在標準案として採用されていますが、最後のフィードバックを募っているところです。
どちらもIETFの支持を得ており、既に多くの議論が行われています。
今後大きな変更が行われる可能性は低いものの、どちらもまだ新しいため、現時点ではまだ幅広いサポートは期待できないでしょう。</p>
<h2>キャッシングが重要な理由</h2>
<p>ユーザ向けの注目度の高いWebアプリケーションを運営する場合、キャッシュとCDNはエンドユーザに優れたパフォーマンスを妥当なコストで提供するうえで不可欠です。
キャッシュとCDNはWebサーバの手前でリバースプロキシの役割を果たし、以下を保証します。</p>
<ul>
<li>コンテンツのキャッシング。全ての訪問者から直接バックエンドサーバに対して静的コンテンツのリクエストが行われないようにし、リクエストの頻度を減らすため。</li>
<li>トラフィックの急増に耐えうるコンテンツデリバリ。静的キャッシュはアプリケーションサーバよりも規模の拡大がはるかに容易であるため。</li>
<li>コンテンツリクエストのバッチ処理。1000件のキャッシュミスが同時に発生しても、バックエンドサーバへのリクエストが1件で済むようにするため。</li>
<li>コンテンツの物理的分散。ユーザの所在地にかかわらず、レスポンスが迅速に届くようにするため。</li>
</ul>
<p>注目度の高いWebサイトを運営するなら、モダンWebにコンテンツをホスティングするうえでこれら全てが必須となります。
ネットが広く普及している今、トラフィックの急増とレイテンシの問題はネット利用者の増加に伴い解決が困難になる一方です。</p>
<p>Troy Huntが、自身が運営する人気サイト「Pwned Passwords」について執筆した、<a href="https://www.troyhunt.com/serverless-to-the-max-doing-big-things-for-small-dollars-with-cloudflare-workers-and-azure-functions/">キャッシングの仕組みを詳しく説明した記事</a>が参考になります。
記事では以下の具体例が紹介されています。</p>
<ul>
<li>毎週彼のドメインから477.6GBのサブリソースが配信されている</li>
<li>そのうち476.7GBはキャッシュから配信されている（キャッシュヒット率99.8%）</li>
<li>同サイトのAPIには毎週3240万件のクエリが送信されている</li>
<li>そのうち3230万件はキャッシュから配信されている（キャッシュ率99.6%）</li>
<li>残りのAPIエンドポイントは、Azureのサーバレス関数が対処する</li>
</ul>
<p>このサイトのホスティング（1日数百万件ものパスワードチェック）に要する費用は、1日3セント程度です。
これだけのトラフィックを全て自前のサーバで処理した場合、膨大なコストがかかります。
合理的なキャッシングの仕組みを構築すれば、迅速かつ効果的に、安く処理できます。これは大きな問題です。</p>
<h2>解決すべき問題は何か</h2>
<p>これは結構なことなのですが、キャッシング設定の構築とデバッグは容易ではありません。</p>
<p>主な問題は、一定の規模になるとほとんどの場合、任意のリクエストパスに多数のキャッシングレイヤーが関与することです。
ほとんどの構成では、独自のキャッシング機能が組み込まれた何らかのロードバランサ、APIゲートウェイ、リバースプロキシがバックエンドサーバの手前に配置され、さらにその前には広く分散された低レイテンシ拠点からエンドユーザにこのコンテンツを提供するグローバルCDNがあります。
さらに、バックエンドサーバ自体も内部の結果をキャッシュする場合があり、企業やプロバイダが独自のキャッシングプロキシを運用していることもあり、多くのクライアント（特にWebブラウザ）が独自のキャッシング機能を備えています（こうしたクライアントにも、Service Workerなどのキャッシングレイヤーがさらに備わっている場合もあり、一層複雑にしています）。</p>
<p>各レイヤーには異なるキャッシング構成が求められます。
例えば、ブラウザはユーザ固有のデータをキャッシュできる場合がありますが、CDNがこうしたデータをキャッシュできてはいけません。
また、新しいコンテンツができるだけ早くエンドユーザに見えるようにするため全てのレイヤーのキャッシュに適用されなくてはいけません。</p>
<p>これらのレイヤーと、各レイヤー独自の構成がどう作用し合うのかを予測するのも複雑であり、さまざまな形で好ましくない結果につながる可能性があります。</p>
<ul>
<li>コンテンツが一切キャッシュされず、トラフィックがバックエンドサーバに過剰な負荷をかける。</li>
<li>コンテンツはキャッシュされるが、分散CDNではない下位のレイヤーに限定される。</li>
<li>古いレスポンスが想定よりも長くキャッシュに保持され、コンテンツのアップデートを困難にする。</li>
<li>キャッシュから間違ったレスポンスが配信され、ドイツのユーザにフランス語のコンテンツが提供されたり、ひどいケースでは未認証のユーザにログインコンテンツが提供されたりする。</li>
<li>リクエストがCDNを全く通らず、バックエンドまたはリバースプロキシから直接配信される。</li>
<li>WebサイトまたはAPIのキャッシングが一貫して行われず、古いデータと新しいデータが混在した全く役に立たないデータが読み出される。</li>
</ul>
<p>これはかなりひどい状態です。</p>
<p>多くのキャッシュ設定が、リクエストやレスポンスのメタデータ自体（Cache-Controlヘッダなど）の中に存在することが、事態を一層悪くしています。
これは正確な設定を実現するうえでは非常に効果的ですが、設定自体がこれらのレイヤーを通過して、途中でキャッシュされる可能性があることも意味します。</p>
<p>知らず知らずのうちに誤って「これを永久にキャッシュする」というレスポンスをキャッシュした場合、極めて面倒なことになってしまいます。
全てのレイヤーのキャッシュを強制的に無効化して問題を解決するのは、想像するより難しいことです。</p>
<p><img src="https://imgs.xkcd.com/comics/refresh_types.png">
<em>ピッタリのXKCDは常に存在する（訳注: XKCD とはアメリカの風刺系web漫画サイト）</em></p>
<h2>Cache-Statusはどう役立つか？</h2>
<p>明確な問題の1つは、キャッシングシステム内のトレーサビリティです。
レスポンスはどこから来たのか？なぜそのレスポンスが送信されたのか？</p>
<p>そのレスポンスはキャッシュから返されたのか、それともサーバから送信されたのか？
キャッシュから返された場合、どのキャッシュか？
それはあとどれくらい有効か？
キャッシュから返されたのではない場合、それはなぜか？
その新しいレスポンスは後で使用するために保存されたものか？</p>
<p><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-cache-header/">Cache-Statusレスポンスヘッダ</a>は、これら全ての情報がレスポンス自体に含まれるようにし、リクエストを見た全てのCDNおよびその他のキャッシュを1つの一貫した形式で提供するための構造を提供します。
ヘッダは以下のようなものになります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: OriginCache; hit; ttl=1100, &quot;CDN Company Here&quot;; fwd=uri-miss;</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<h3>Cache-Statusヘッダの形式</h3>
<p>ヘッダの形式は以下になります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: CacheName; param; param=value; param..., CacheName2; param; param...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>キャッシュのリストであり、それぞれゼロ以上のステータスパラメータを持ちます。
キャッシュはレスポンス順に並びます。
最初のキャッシュがオリジンサーバに最も近く、最後のキャッシュがクライアントに最も近いものです。</p>
<p>レスポンスがこのヘッダとともにキャッシュされると、その後のレスポンスでもそれが保持されます。
しかし、今回のレスポンスがどこに保存され、前回のレスポンスがどこから来たのかを右側のパラメータ値から判断することも可能です。</p>
<p>パラメータ付きのキャッシュはカンマで区切られ、パラメータ自体はセミコロンで区切られます（現在は標準化されている<a href="https://datatracker.ietf.org/doc/rfc8941/">構造化ヘッダRFC</a>のsf-listとsf-item構文）。
キャッシュ名は、スペースなど本来無効な文字が含まれる場合は引用符で囲まれることがあります。</p>
<h3>Cache-Statusヘッダパラメータ</h3>
<p>各キャッシュの挙動を説明するため、いくつかのパラメータと値を定義します。</p>
<ul>
<li><code class="language-text">hit</code> - リクエストが上流に送られることなく、レスポンスはこのキャッシュから返されます</li>
<li>
<p><code class="language-text">fwd=&lt;reason&gt;</code> - これが設定されている場合、リクエストが次の上流レイヤーに送信されています。これには次のような理由が付いてきます。</p>
<ul>
<li><code class="language-text">fwd=bypass</code> - キャッシュはこのリクエストを処理しないよう構成されている</li>
<li><code class="language-text">fwd=method</code> - 使用したHTTPメソッドにより、リクエストを転送する必要がある</li>
<li><code class="language-text">fwd=uri-miss</code> - リクエストURIと一致するキャッシュデータはなかった</li>
<li><code class="language-text">fwd=vary-miss</code> - URIと一致するキャッシュデータはあったが、Varyヘッダに含まれるヘッダが一致しなかった</li>
<li><code class="language-text">fwd=miss</code> - 一致するキャッシュデータはなかった（理由が不明な場合など、他の理由による）</li>
<li><code class="language-text">fwd=stale</code> - 一致するキャッシュデータはあったが、古い（stale）データである</li>
<li><code class="language-text">fwd=partial</code> - 一致するキャッシュデータはあったが、レスポンスの一部に対してのみ（前回のリクエストがRangeヘッダを使用したなど）</li>
<li><code class="language-text">fwd=request</code> - リクエストがキャッシュされていないデータを要求した（Cache-Controlヘッダで）</li>
</ul>
</li>
<li><code class="language-text">fwd-status=&lt;status&gt;</code> - fwdが設定されている場合、次のホップから受け取ったレスポンスステータスです</li>
<li><code class="language-text">stored</code> - fwdが設定されている場合、このキャッシュが受信したレスポンスを後で使用するために保管したかどうかを示します</li>
<li><code class="language-text">collapsed</code> - fwdが設定されている場合、リクエストが他のリクエストと一緒に畳まれているかどうかを示します（同等のリクエストが既に処理中のため、複製されていない）</li>
<li><code class="language-text">ttl=&lt;ttl&gt;</code> - このキャッシュがこのレスポンスをあとどれくらい（秒数）「fresh」（鮮度が高い）と見なすか</li>
<li><code class="language-text">key</code> - このキャッシュのレスポンスのキー（実装固有）</li>
<li><code class="language-text">detail</code> - 追加の実装固有情報のための自由形式フィールド</li>
</ul>
<p>これらを使用することで、以下のようなレスポンスヘッダを解釈できます。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status: ExampleCache; hit; ttl=30; key=/abc</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>これは、ExampleCacheがリクエストを受信し、キャッシュの中（key / abcの下）にレスポンスがあったのでそれを返し、そこから30秒間はそのキャッシュを返し続けることを意味します。</p>
<p>以下のようなもっと複雑な例も検討してみましょう。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Status:
    Nginx; hit,
    Cloudflare; fwd=stale; fwd-status=304; collapsed; ttl=300,
    BrowserCache; fwd=vary-miss; fwd-status=200; stored</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p><em>（可読性を上げるために改行しています）</em></p>
<p>これは、ブラウザがリクエストを送信したが、Varyヘッダに含まれるヘッダが一致しなかったため、同じURIで保持するキャッシュレスポンスを使用しなかったことを意味します。</p>
<p>リクエストは次にCloudflareが受信し、Cloudflareは一致するレスポンスをキャッシュしていましたが（<code class="language-text">Nginx; hit</code>というレスポンス。Nginxのキャッシュから読み出されたレスポンスであることを意味する）、そのレスポンスは古くなっています。</p>
<p>これに対処するため、CloudflareはNginxにレスポンスを再検証するようリクエストを送信し、Nginxは304（変更なし）レスポンスをCloudflareに返して既存のキャッシュレスポンスがまだ有効であることを伝えています。
送信されたリクエストは折り畳まれており、同じコンテンツについて同時に複数のリクエストがCloudflareに届いたが、上流に送信されたリクエストは1つだけであることを意味します。
Cloudflareは次の5分間、再検証されたデータを提供し続けます。</p>
<p>有益な情報がたくさん含まれています。
注意深く読み解くことで、このヘッダだけでもレスポンスのコンテンツがどこから来たのか、リクエストパス全体に沿って現在どのようにキャッシュされているのかが正確に分かります。</p>
<p>（キャッシング構成のデバッグに不慣れな人には、上記は手ごわそうに聞こえるかもしれませんが、これらの情報が1カ所にまとめられていることで、同じ情報を一から導き出すより何倍も負担が軽減されます。）</p>
<h3>Cache-Statusの実践</h3>
<p>これは全く新しい概念ではありませんが、全てのキャッシュを1カ所にまとめることで、一貫したデータの単一の供給源を提供することに本当のメリットがあります。</p>
<p>現在、各キャッシュプロバイダがさまざまな（それぞれ微妙に一致しない）ヘッダを使用しており、Nginxの<a href="https://support.cpanel.net/hc/en-us/articles/4402904983703-How-to-add-the-X-Cache-Status-header-to-NGINX-to-assist-with-optimizing-and-troubleshooting-cache-settings">X-Cache-Status</a>、Cloudflareの<a href="https://developers.cloudflare.com/cache/about/default-cache-behavior#cloudflare-cache-responses">CF-Cache-Status</a>、Fastlyの<a href="https://developer.fastly.com/reference/http/http-headers/X-Served-By/">X-Served-By</a>や<a href="https://developer.fastly.com/reference/http/http-headers/X-Cache/">X-Cache</a>などがあります。それぞれ、ここに含めることができる情報の一部を提供しており、今後は徐々にCache-Statusに置き換わっていくことが望まれます。
現在、ほとんどの主要コンポーネントとプロバイダはデフォルトでCache-Statusを搭載していませんが、Fastly、Akamai、Facebookなど多数の企業が標準化プロセスに関わっているため、多くのWebサービスやツールに採用される日はそう遠くないと思います。
実際、<a href="https://github.com/squid-cache/squid/commit/5fdc549054b11eb8bbc7e9640d6d071fa1ef742b">Squid</a>の組み込みサポートや<a href="https://github.com/caddyserver/cache-handler#readme">Caddyのキャッシングハンドラー</a>、<a href="https://gist.github.com/mnot/74ba8ed638a3d85659aa2868b9240d50">Fastlyのドロップインレシピ</a>など、既に進展が見られています。
2021年8月にRFCの発表があったばかりなのでまだかなり新しいですが、今後も引き続きサポートが広がっていくことを期待しています。
CDNまたはキャッシングコンポーネントの開発者は、ユーザのデバッグを支援するためにCache-Statusを採用することをお勧めします（これらのサービスを使っているのであれば、Cache-Statusの導入を求めることをお勧めします）。</p>
<h2>Targeted Cache-Controlのメリット</h2>
<p>既存の<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control">Cache-Controlヘッダ</a>は、キャッシングがこれほど複雑化する前（1999年）に設計されたものです。
当時はIE 4.5がリリースされたばかりで、RIMが最初のBlackberryの発売準備を進めており、インタラクティブWebページの第一波を表す「Web 2.0」という言葉が生まれた時代でした。
テラバイト単位のデータをキャッシュするためにマルチレイヤーCDNアーキテクチャを構成することは大きなテーマではなかったのです。</p>
<p>時代は変わりました。</p>
<p>1999年に定義されたCache-Controlヘッダはリクエスト／レスポンスヘッダであり、リクエスト（どのようなキャッシュレスポンスを受け入れるか）とレスポンス（このレスポンスを今後どのようにキャッシュするか）に関するさまざまなキャッシングパラメータを定義できます。</p>
<p>ここではリクエストの構成については特に注目していませんが、レスポンスキャッシュの構成は非常に重要です。
レスポンスのCache-Controlは現在、以下のようにレスポンスの処理方法をキャッシュに伝えるディレクティブのリストによって定義されます。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Cache-Control: max-age=600, stale-while-revalidate=300, private</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>これは、「このコンテンツを10分間キャッシュし、次に、これを再検証する間、古いコンテンツを最大5分間配信する。ただし、これはプライベート（シングルユーザのブラウザなど）キャッシュでのみ行う」という意味です。</p>
<p>ここで設定されたルールは、同じリクエストを処理する全てのキャッシュが同様に従わなくてはならず、ツールとしてはやや粒度が粗いと言えます。
制御ルールの対象をエンドユーザのキャッシュに制限することは可能であり（<code class="language-text">private</code>を使用）、過去には、共有されたキャッシュ（CDNなど）にしか適用されないいくつかの重複したディレクティブ（<code class="language-text">s-maxage</code>や<code class="language-text">proxy-revalidate</code>など）を追加していましたが、それ以上の精度や柔軟性を望むことはできません。
これはつまり、以下のことは行えないことを意味します。</p>
<ul>
<li>ブラウザとCDNで、stale-while-revalidateに異なる時間を設定する</li>
<li>レスポンスに対し、内部のキャッシングロードバランサにおける全てのリクエストで再検証が必要だが、CDNでは不要とのフラグを付ける</li>
<li>CDNでのキャッシングは有効にしつつ、外部の共有キャッシュ（エンタープライズプロキシなど）にはコンテンツをキャッシュしないよう伝える</li>
</ul>
<p>これでは、多くの高度なユースケースに対応できません。
ほとんどのキャッシングコンポーネントでは、これに対処するためにコンポーネント内のルールを定義するための構成オプションが用意されていますが、これはこれで柔軟性に欠け、レスポンスに応じて異なるルールを構成するのが難しくなります。</p>
<p><a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-targeted-cache-control/">Targeted Cache-Control</a>は、全てのキャッシュではなく特定のキャッシュのみを対象としたCache-Controlのディレクティブを設定するための新しいヘッダを定義することで、この問題の解決を図るものです。</p>
<h3>Targeted Cache-Controlの仕組み</h3>
<p>Targeted Cache-Controlを使用するには、サーバが以下のような形式のレスポンスヘッダを設定する必要があります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">&lt;Target&gt;-Cache-Control: param, param=value, param...</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ヘッダのプレフィックスには、これを適用する特定の対象が入ります。
構文は、<a href="https://datatracker.ietf.org/doc/rfc8941/">Structured Fields</a>の標準形式を使用するため、厳密にはCache-Controlが使用する構文とは若干異なりますが、実質的にはほとんど同じです。</p>
<p>ここで使用する対象には、固有のサービスやコンポーネントの名前、あるいはキャッシュクラスなどが入ります。
仕様で定義する対象は1つだけ（<code class="language-text">CDN-Cache-Control</code>。全ての分散CDNキャッシュに適用し、他のキャッシュには適用しない）ですが、後から他のクラスを定義することもできます。
将来的には、<code class="language-text">Client-Cache-Control</code>がHTTPクライアントにおけるキャッシングのみを対象にルールを設定し、<code class="language-text">ISP-</code>がインターネットサービスプロバイダ、<code class="language-text">Organization-</code>が企業組織のキャッシュを対象とする、といったことも可能です。</p>
<p>これらのヘッダを使用するには、それをサポートする各キャッシュがマッチする対象のリストを優先順に定義（固定またはユーザ定義）します。他により具体的なマッチがなければ、最初にマッチした<code class="language-text">&lt;target&gt;-Cache-Control</code>ヘッダまたは通常の<code class="language-text">Cache-Control</code>ヘッダ（あれば）を使用します。</p>
<p>全体として、既存のキャッシングの仕組みに既になじみがある場合、かなりシンプルで使いやすいと感じるでしょう。Targetedヘッダは特定の対象とマッチし、キャッシングのルールは対象に応じて自由に設定でき、ベストマッチが優先されます。以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">Client-Cache-Control: must-revalidate
CDN-Cache-Control: max-age=600, stale-after-revalidate=300
Squid-Cache-Control: max-age=60
Cache-Control: no-store</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>これは以下のような意味になります。</p>
<ul>
<li>エンドクライアント（少なくとも、筆者が考案した<code class="language-text">Client-Cache-Control</code>ヘッダを認識するもの）は、このコンテンツをキャッシュできるが、使用する前に毎回再検証しなくてはならない</li>
<li>全てのCDNがコンテンツを10分間キャッシュでき、次に、これを再検証する間、古いレスポンスをさらに5分間使用できる</li>
<li>Squid（キャッシング機能を備えたリバースプロキシ）は、コンテンツを60秒間だけキャッシュできる（<code class="language-text">stale-while-revalidate</code>指示はないため、古い間は暗黙的に使用できない）</li>
<li>Targeted Cache-Control指示を理解できないものは、このコンテンツをキャッシュしてはならない</li>
</ul>
<h3>Targeted Cache-Controlの実践</h3>
<p>Cache-Statusよりも新しく、標準化プロセスの早い段階にあるため、まだ変更が加わる可能性があります。フィードバックがある場合、<a href="https://github.com/httpwg/http-extensions/blob/main/draft-ietf-httpbis-targeted-cache-control.md">ここから</a>GitHubにアクセスして仕様書を入手し、同じレポジトリ内で問題を報告（または<a href="https://datatracker.ietf.org/wg/httpbis/about/">ワーキンググループのメーリングリスト</a>にメッセージを送信）し、意見を述べることができます。
とは言え、仕様書自体はFastly、Akamai、Cloudflareの代表者が執筆しているため、業界のサポートは既に十分得られており、作業はもうかなり進んでいるため、大きな変更が加えられる可能性は低いと思われます。</p>
<p>現状、<a href="https://blog.cloudflare.com/cdn-cache-control/">Cloudflare</a>と<a href="https://www.akamai.com/blog/news/targeted-cache-control">Akamai</a>が既にサポートしているため、これらのキャッシュを使用する場合、今から<code class="language-text">CDN-Cache-Control</code>、<code class="language-text">Akamai-Cache-Control</code>、<code class="language-text">Cloudflare-CDN-Cache-Control</code>を使用した正確な構成を開始できます。今後他の多くのツールやサービスについても同様のサポートが行われる可能性が高いため、引き続き注目してください。</p>
<h2>今後の展望</h2>
<p>2021年、キャッシングは依然として複雑ですが、Cache-StatusとTargeted Cache-Controlが急速に成熟しており、これらによって構成とデバッグはかなり容易になると見られます。キャッシングに携わっている方は注目する価値があります。</p>
<p>IETFが最近取り組んでいるHTTP標準は2つだけですが、Webの発展に寄与したい方や今後登場する予定の標準について知りたい方は、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/">Rate-Limitingヘッダ</a>、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-proxy-status/">Proxy-Status</a>、<a href="https://datatracker.ietf.org/doc/draft-ietf-httpbis-digest-headers/">HTTPメッセージダイジェスト</a>、<a href="https://datatracker.ietf.org/doc/rfc8942/">HTTPクライアントヒント</a>など他にも多数あるのでチェックしてみてください。
HTTPは発展途上の標準であり、今後も続々登場します。
これらのいずれかに興味のある方は、<a href="https://datatracker.ietf.org/wg/httpbis/about/">ワーキンググループのメーリングリスト</a>に参加し、新たな開発情報をチェックしたり意見を共有したりすることをお勧めします。</p>
<p><em>HTTPリクエスト、キャッシング、エラーのテストやデバッグをご希望の方は、<a href="https://httptoolkit.tech/">HTTP Toolkit</a>でHTTPの傍受、調査、模擬をお試しください。</em></p>
<p><em>10か月前(※訳注：2022年8月の翻訳記事公開時点)に<a href="https://twitter.com/pimterry">Tim Perry</a>が公開</em></p>]]></content:encoded></item><item><title><![CDATA[React Server Componentsの仕組み：詳細ガイド]]></title><description><![CDATA[React Server Components（RSC）は、ページの読み込みパフォーマンスやバンドルサイズのほか、Reactアプリケーションの書き方に近い将来大きな影響を与えることになる、素晴らしい…]]></description><link>https://postd.cc/how-react-server-components-work/</link><guid isPermaLink="false">https://postd.cc/how-react-server-components-work/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[React]]></category><pubDate>Wed, 27 Jul 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>React Server Components（RSC）は、ページの読み込みパフォーマンスやバンドルサイズのほか、Reactアプリケーションの書き方に近い将来大きな影響を与えることになる、素晴らしい新機能です。
Plasmicでは、<a href="https://plasmic.app/">Reactのビジュアルビルダー</a>を開発しており、Reactのパフォーマンスには大きな関心を持もっています。
当社のクライアントの多くは、Plasmicを使用して高いパフォーマンスが求められるマーケティングサイトやECサイトを構築しています。
したがって、RSCはまだReact 18の初期実験機能ですが、Plasmicではその仕組みを詳しく調べています。
このブログ記事では、これまでに分かったことを紹介したいと思います。
Plasmicのメンバーによる<a href="https://www.reddit.com/r/reactjs/comments/s8r0ve/how_react_server_components_work_an_indepth_guide/">ツイートまとめ</a>もご覧ください。</p>
<ul class="toc-for-article">
    <li><a href="#01">React Server Componentsとは何か</a></li>
    <li><a href="#02">サーバサイドレンダリングとの違いは？</a></li>
    <li><a href="#03">RSCを使うメリット</a></li>
    <li><a href="#04">RSCの全体像</a></li>
    <li><a href="#05">サーバコンポーネントとクライアントコンポーネントの分断</a></li>
    <li>
        <a href="#06">RSCレンダリングの流れ</a>
        <ul>
            <li><a href="#07">1. サーバがレンダリングリクエストを受け取る</a></li>
            <li><a href="#08">2. サーバがルートコンポーネント要素をJSON形式にシリアライズ</a></li>
            <li><a href="#09">3. ブラウザがReactツリーを再構築</a></li>
            <li><a href="#10">Suspenseとの互換性は問題ないか？</a></li>
        </ul>
    </li>
    <li>
        <a href="#11">RSCワイヤーフォーマット</a>
        <ul>
            <li><a href="#12">RSCフォーマットを使う</a></li>
            <li><a href="#13">単にプレーンHTMLを出力すればよいのでは？</a></li>
            <li><a href="#14">クライアントコンポーネントからデータを取得するだけよりもメリットがある？</a></li>
            <li><a href="#15">サーバサイドレンダリングはどうなる？</a></li>
        </ul>
    </li>
    <li><a href="#16">サーバコンポーネントがレンダリングしているコンテンツのアップデート</a></li>
    <li><a href="#17">RSCにメタフレームワークを使うべき理由</a></li>
    <li><a href="#18">RSCは実用化の準備ができているのか？</a></li>
</ul>
<h2>React Server Componentsとは何か<a name="01"></a></h2>
<p>React Server Components（RSC）は、サーバとクライアント（ブラウザ）が連携してReactアプリケーションのレンダリングを行うことを可能にします。
Webページを表示する際にレンダリングされる一般的なReact要素ツリーは、通常異なるReactコンポーネントがさらに多くのReactコンポーネントをレンダリングする構成になっています。
RSCは、このツリーを構成する一部のコンポーネントが<em>サーバによって</em>レンダリングされ、他のコンポーネントが<em>ブラウザによって</em>レンダリングされることを可能にします。🤯</p>
<p>これはReactチームによる概略図です。
最終的なゴールは、オレンジのコンポーネントはサーバ側でレンダリングされ、青のコンポーネントはクライアント側でレンダリングされるようなReactツリーです。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components.png"></p>
<h2>サーバサイドレンダリングとの違いは？<a name="02"></a></h2>
<p><strong>RSCはサーバサイドレンダリング（SSR）ではありません</strong>。
どちらも名前に「サーバ」が含まれ、どちらもサーバ上で動いているので少し混乱しますね。
しかし、両者はそれぞれ独立した直交する機能であると理解した方がずっと分かりやすいでしょう。
RSCはSSRを必要とせず、その逆もまたしかりです。
SSRは、Reactツリーを生HTMLにレンダリングするための環境をシミュレーションします。
<em>サーバコンポーネントとクライアントコンポーネントを区別せず、どちらも同じようにレンダリングします。</em></p>
<p>SSRとRSCを組み合わせ、サーバコンポーネントでサーバサイドレンダリングを行い、ブラウザ上で適切にハイドレーションすることも可能です。
両者を併用する方法については、後日別の記事で詳しく話したいと思います。</p>
<p>SSRについてはひとまず無視し、RSCだけにフォーカスしましょう。</p>
<h2>RSCを使うメリット<a name="03"></a></h2>
<p>RSC以前のReactコンポーネントはすべてクライアントコンポーネントであり、ブラウザ上で実行されます。
Reactページにアクセスすると、ブラウザは必要なReactコンポーネントすべてのコードをダウンロードし、React要素ツリーを構築してDOMにレンダリングします（SSRを使用している場合は、DOMをハイドレーションします）。
これらの処理がブラウザ上で行われることで React アプリケーションはインタラクティブに（イベントハンドラをインストールし、ステートを追跡し、イベントに応じてReactツリーに変更を加え、DOMを効率的にアップデートできるように）なります。
では、サーバ上でレンダリングを行うメリットは何でしょうか。
ブラウザよりサーバ上でレンダリングを行った方がよい理由はいくつかあります。</p>
<ul>
<li>サーバは、データベース、GraphQLエンドポイント、ファイルシステムなどのデータソースにもっとダイレクトにアクセスできます。パブリックAPIエンドポイントを経由することなく、必要なデータを直接取得でき、通常データソースに近い場所に配置されているため、ブラウザよりも素早くデータを取得できます。</li>
<li>サーバは、たとえばマークダウンをHTMLに変換してレンダリングするためのnpmパッケージなどの「重い」コードモジュールを手軽に利用できます。それは、これらの依存関係を使用するたびにダウンロードする必要がないからです。ブラウザの場合、使用するコードをすべてJavaScriptのバンドルとしてダウンロードする必要があります。</li>
</ul>
<p>要するに、<strong>RSCはサーバとブラウザが互いに得意な処理を行えるようにするのです</strong>。
サーバコンポーネントはデータの取得とコンテンツのレンダリング、クライアントコンポーネントはステートフルなインタラクティビティに注力できるため、ページの読み込み速度が速くなるほか、JavaScriptのバンドルサイズが小さくなり、ユーザ体験が改善されます。</p>
<h2>RSCの全体像<a name="04"></a></h2>
<p>では、まずその仕組みについて直感的に理解することから始めましょう。</p>
<p>筆者の子供たちはカップケーキのデコレーションは<em>大好き</em>なのですが、焼くことに関してはさほど興味を示しません。
カップケーキを一から作らせ、デコレーションまでさせるのは、きっと（かわいらしい）悪夢のような経験になるでしょう。
小麦粉と砂糖、バターを用意し、オーブンの使用を許可し、さまざまな取扱説明書を延々と読んで聞かせなくてはいけません。
そんなことをしていては、丸一日かかってしまいます。
しかし筆者ならば、オーブンで焼く作業をずっと速く行えます。
一部の作業を事前に行っておけば（原材料をそのまま渡すのではなく、カップケーキを焼き、アイシングを作り、それらを渡す）、子供たちは楽しいデコレーションにもっと早く取り掛かれます。
さらに良いことに、子供たちがオーブンを使用することについて心配する必要がありません。
素晴らしい！</p>
<p><img src="https://www.plasmic.app/blog/static/images/cake.jpg"></p>
<p>RSCの目的は、この役割分担を可能にすることです。
サーバが得意な作業は事前にサーバに行わせてから、残りの作業をブラウザに引き継ぐのです。
そうすることで、サーバがブラウザに渡すデータ量も減らすことができます。
袋いっぱいの小麦粉とオーブンに比べ、小さなカップケーキ12個の方がはるかに効率的に運べます。</p>
<p>一部のコンポーネントはサーバ側で、残りはクライアント側でレンダリングされるようなページのReactツリーを想像してみてください。
RSCのハイレベルな戦略を簡略化すると以下のような形になります。
サーバは、いつも通りサーバコンポーネントをレンダリングし、Reactコンポーネントを<code class="language-text">div</code>や<code class="language-text">p</code>などのネイティブHTML要素に変換します。
しかし、ブラウザ上でレンダリングされるクライアントコンポーネントに遭遇すると、代わりにプレースホルダを出力します。
サーバは、プレースホルダーに適切なクライアントコンポーネントとpropsを適用するように指示を加えます。
ブラウザはこの出力を受け取り、クライアントコンポーネントで穴埋めを行います。
これで完成です。</p>
<p><strong>実際の仕組みはそんなに単純ではありません</strong>。
詳細については後ほど話しますが、まずは全体像を頭に入れておくと有益です。</p>
<h2>サーバコンポーネントとクライアントコンポーネントの分断<a name="05"></a></h2>
<p>ところで、サーバコンポーネントとは何でしょうか。
サーバ用とクライアント用のコンポーネントはどのようにして区別するのでしょうか。</p>
<p>Reactチームでは、コンポーネントが記述されたファイルの拡張子を基に定義しています。
<code class="language-text">.server.jsx</code>で終わるファイルにはサーバコンポーネント、<code class="language-text">.client.jsx</code>で終わるファイルにはクライアントコンポーネントが含まれています。
これらいずれの拡張子ももたないファイルには、サーバ用としてもクライアント用としても使用できるコンポーネントが含まれています。</p>
<p>これは実用的な定義であり、人間にとってもバンドラーにとっても区別が容易です。
特にバンドラーにとっては、ファイル名を調べることでクライアントコンポーネントを区別し、処理方法を変えられるようになりました。
後述しますが、バンドラーはRSCが適切に機能する上で重要な役割を果たします。</p>
<p>サーバコンポーネントはサーバ上で、クライアントコンポーネントはクライアント上で実行されるため、それぞれできることにさまざまな制限があります。
その中でも最も重要なのが、<strong>クライアントコンポーネントはサーバコンポーネントをインポートできない</strong>ということです。
それは、サーバコンポーネントはブラウザ上で実行できず、ブラウザ上では機能しないコードが含まれる可能性があるためです。
クライアントコンポーネントがサーバコンポーネントに依存する場合、不正な依存関係がブラウザバンドルに入り込んでしまうことになります。
つまり、以下のようなクライアントコンポーネントは不正ということになってしまうため、この最後の点は難題になり得ます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// ClientComponent.client.jsx</span>
<span class="token comment">// 悪い例:</span>
<span class="token keyword">import</span> ServerComponent <span class="token keyword">from</span> <span class="token string">'./ServerComponent.server'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">ClientComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ServerComponent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、クライアントコンポーネントがサーバコンポーネントをインポートできず、サーバコンポーネントのインスタンスを生成できないのであれば、どうすれば以下のようにサーバコンポーネントとクライアントコンポーネントが交互に配置されたReactツリーができるのでしょうか。またどうすれば、クライアントコンポーネント（青い丸）の下にサーバコンポーネント（オレンジ色の丸）を配置できるのでしょうか。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components.png"></p>
<p>クライアントコンポーネントからサーバコンポーネントをインポートしてレンダリングすることはできませんが、コンポジションは使用できます。
つまり、クライアントコンポーネントは単なる不透明な<code class="language-text">ReactNode</code>であるpropsを取り込むことはでき、<code class="language-text">ReactNode</code>がサーバコンポーネントによってレンダリングされることも可能です。
以下に例を挙げます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// ClientComponent.client.jsx</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">ClientComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> children <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">Hello from client land</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// ServerComponent.server.jsx</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">ServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">Hello from server land</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span>

<span class="token comment">// OuterServerComponentはクライアントコンポーネントも</span>
<span class="token comment">// サーバーコンポーネントもインスタンス化することができ、</span>
<span class="token comment">// ClientComponentのchildrenとして&lt;ServerComponent/>を渡します。</span>
<span class="token keyword">import</span> ClientComponent <span class="token keyword">from</span> <span class="token string">'./ClientComponent.client'</span>
<span class="token keyword">import</span> ServerComponent <span class="token keyword">from</span> <span class="token string">'./ServerComponent.server'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">OuterServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ServerComponent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この制限は、RSCを有効に活用するためのコンポーネントの配置を検討する上で大きな影響があります。</p>
<h2>RSCレンダリングの流れ<a name="06"></a></h2>
<p>それでは、Reactサーバコンポーネントをレンダリングするときに実際何が起こるのか、肝心な部分を詳しく見ていきましょう。
ここで説明することをすべて理解しなくてもサーバコンポーネントは使えますが、仕組みについて直感的な理解は得られると思います。</p>
<h3>1. サーバがレンダリングリクエストを受け取る<a name="07"></a></h3>
<p>レンダリングの一部はサーバが行わなくてはならないため、RSCを使用する場合、ページのレンダリングは必ずサーバで始まります。
その際、APIコールによってReactコンポーネントのレンダリングが開始します。
この「ルート」コンポーネントは必ずサーバコンポーネントであり、他のサーバコンポーネントまたはクライアントコンポーネントをレンダリングする場合もあります。
サーバは、リクエストに含まれる情報をもとに、使用するサーバコンポーネントとpropsを判断します。
このリクエストは、通常特定のURLでページリクエストの形で届きますが、Shopify Hydrogenはより<a href="https://shopify.dev/custom-storefronts/hydrogen/framework/server-state">きめ細かい方法</a>を使用しており、Reactチームの公式デモでは<a href="https://github.com/reactjs/server-components-demo/blob/main/server/api.server.js">raw実装</a>を行っています。</p>
<h3>2. サーバがルートコンポーネント要素をJSON形式にシリアライズ<a name="08"></a></h3>
<p>ここでの最終目的は、最初のルートサーバコンポーネントをHTMLのタグとクライアントコンポーネントのプレースホルダで構成されるツリーとしてレンダリングすることです。
次に、そのツリーをシリアライズしてブラウザに送ります。
ブラウザ側では、受け取ったデータをデシリアライズし、プレースホルダを実際のクライアントコンポーネントに置き換え、最終結果をレンダリングします。</p>
<p>上の例に沿って見てみましょう。
<code class="language-text">&lt;OuterServerComponent/&gt;</code>をレンダリングしたい場合、<code class="language-text">JSON.stringify(&lt;OuterServerComponent /&gt;)</code>を実行すればシリアライズされた要素ツリーが得られるでしょうか？</p>
<p>惜しいですが、少し違います。😅
React要素とは実際のところどういうものだったか、思い出してみてください。
<code class="language-text">type</code>というフィールドに文字列または関数をとるオブジェクトです。
<code class="language-text">type</code> には、文字列なら<code class="language-text">&quot;div&quot;</code>のようなhtmlのタグ名が、関数ならReactコンポーネントのインスタンスが入ります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// &lt;div>oh my&lt;/div> を返す場合</span>
<span class="token operator">></span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> <span class="token string">"div"</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>

<span class="token comment">// &lt;MyComponent>oh my&lt;/MyComponent> を返す場合</span>
<span class="token operator">></span> <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>children<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token operator">></span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span> children<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> MyComponent   <span class="token comment">// MyComponent 関数への参照 function</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span> children<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">type</code>にHTMLタグではなくコンポーネントを指定した場合、typeフィールドはコンポーネントとして定義した関数（訳注: 原文ではcomponent function。本記事では、以降「コンポーネント関数」と訳します）を参照します。
しかし、関数はJSON 形式にシリアライズできません。</p>
<p>すべての要素をJSON文字列に適切に変換するために、Reactはこれらのコンポーネント関数の参照に適切に対処する特別な<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter">置換関数</a>を<code class="language-text">JSON.stringify()</code>に渡します。
そのa関数は、<a href="https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L368">ReactFlightServer.jsにあるresolveModelToJSON()</a>です。</p>
<p>具体的には、シリアライズ対象のReact要素に対して以下の処理を行います。</p>
<ul>
<li>HTMLのbaseタグ（<code class="language-text">type</code>フィールドには、「<code class="language-text">div</code>」のような文字列が入ります）の場合、すでにシリアライズ可能です。特別な処理は必要ありません。</li>
<li>サーバコンポーネントの要素の場合、サーバコンポーネント関数（<code class="language-text">type</code>フィールドに格納されている）とそのpropsを呼び出し、その結果をシリアライズします。これは実質的にサーバーコンポーネントのレンダリングに相当します。つまり、全てのサーバーコンポーネントをただのHTMLタグに変換するのです。</li>
<li>クライアントコンポーネントの場合も、すでにシリアライズ可能です。<code class="language-text">type</code>フィールドはすでにコンポーネント関数ではなく、モジュール参照オブジェクトを指し示しています。このモジュール参照オブジェクトとは一体何なのでしょう。</li>
</ul>
<h4>「モジュール参照」オブジェクトとは何か</h4>
<p>RSCでは、React要素の<code class="language-text">type</code>フィールドに「モジュール参照」と呼ばれる新しい値を導入できます。
コンポーネント関数の代わりに、コンポーネント関数へのシリアライズ可能な「参照」を渡すのです。
例えば、<code class="language-text">ClientComponent</code>という要素は以下のような形を取ることができます。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token punctuation">{</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// type フィールドが、実際のコンポーネント関数の代わりに参照オブジェクトを持つようになりました</span>
  type<span class="token operator">:</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>module<span class="token punctuation">.</span>reference<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// ClientComponent は以下のファイルから default export されます</span>
    name<span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>
    <span class="token comment">// ClientComponent を default export しているファイルのパス</span>
    filename<span class="token operator">:</span> <span class="token string">"./src/ClientComponent.client.js"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span> children<span class="token operator">:</span> <span class="token string">"oh my"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、このマジックのような処理はどこで行われているのでしょうか。
クライアントコンポーネント関数への参照は、どこでシリアライズ可能な「モジュール参照」オブジェクトに変換されているのでしょうか。</p>
<p>なんと、この手品のような処理はバンドラーが行なっているのです。
Reactチームは、webpack向けの公式RSCサポートを、<code class="language-text">react-server-dom-webpack</code>で<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackNodeLoader.js">webpackローダ</a>または<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightWebpackNodeRegister.js">node-register</a>として公開しています。
サーバコンポーネントが<code class="language-text">*.client.jsx</code>ファイルから何かをインポートする際、実際のインポート対象を取得する代わりに、そのファイル名とエクスポート名が含まれたモジュール参照オブジェクトだけを取得しています。
クライアントコンポーネント関数が、サーバ上に構築されるReactツリーの一部に組み込まれることはありません。</p>
<p><a href="#08">このセクションの冒頭で</a><code class="language-text">&lt;OuterServerComponent /&gt;</code>をシリアライズしようとした例を思い出してください。
最終的には以下のようなJSONツリーになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token punctuation">{</span>
  <span class="token comment">//「モジュール参照」を持つ ClientComponent のプレースホルダー</span>
  $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
  type<span class="token operator">:</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>module<span class="token punctuation">.</span>reference<span class="token punctuation">)</span><span class="token punctuation">,</span>
    name<span class="token operator">:</span> <span class="token string">"default"</span><span class="token punctuation">,</span>
    filename<span class="token operator">:</span> <span class="token string">"./src/ClientComponent.client.js"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ClientComponent に渡される children（ここでは &lt;ServerComponent />）</span>
    children<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// ServerComponentは html タグに直でレンダリングされます。</span>
      <span class="token comment">// ServerComponent への参照が一切なく、直でspanをレンダリングしていることに注目してください。</span>
      $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>react<span class="token punctuation">.</span>element<span class="token punctuation">)</span><span class="token punctuation">,</span>
      type<span class="token operator">:</span> <span class="token string">"span"</span><span class="token punctuation">,</span>
      props<span class="token operator">:</span> <span class="token punctuation">{</span>
        children<span class="token operator">:</span> <span class="token string">"Hello from server land"</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h4>シリアライズ可能なReactツリー</h4>
<p>このプロセスの終わりには、サーバ上に以下のようなReactツリーができていることが望まれます。
これをブラウザに送信して「仕上げ」を行います。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components-placeholders.png"></p>
<p><strong>propsはすべてシリアライズ可能であること</strong></p>
<p>Reactツリー全体をJSON形式にシリアライズするため、クライアントコンポーネントまたはHTMLのbaseタグに渡すpropsもすべてシリアライズ可能でなくてはなりません。
これはつまり、サーバコンポーネントからイベントハンドラをpropsとして渡すことはできないということです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// 悪い例: サーバーコンポーネントは props として子孫コンポーネントに関数を渡すことができません。なぜなら関数はシリアライズできないからです。</span>
<span class="token keyword">function</span> <span class="token function">SomeServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'OHHAI'</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">Click me!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、1つ留意すべき点として、RSCプロセスの際にクライアントコンポーネントに遭遇しても、決してクライアントコンポーネント関数を呼び出したり、クライアントコンポーネントに「降りて行く」ことはありません。
したがって、別のクライアントコンポーネントのインスタンスを生成するクライアントコンポーネントがある場合、以下のようになります。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">SomeServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent1</span></span><span class="token punctuation">></span></span><span class="token plain-text">Hello world!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent1</span></span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">ClientComponent1</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>children<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// クライアントからクライアントコンポーネントに props として関数を渡すのは可</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent2</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent2</span></span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このRSC JSONツリーには、<code class="language-text">ClientComponent2</code>は一切出てきません。
その代わり、<code class="language-text">ClientComponent1</code>のモジュール参照とpropsをもつ要素だけがあります。
そのため、<code class="language-text">ClientComponent1</code>がpropsとしてイベントハンドラを<code class="language-text">ClientComponent2</code>に渡すのは、全く正常なことです。</p>
<h3>3. ブラウザがReactツリーを再構築<a name="09"></a></h3>
<p>ブラウザは、サーバからJSON出力を受け取ったら、ブラウザ上でレンダリングするReactツリーの再構築を開始しなくてはいけません。
<code class="language-text">type</code>がモジュール参照である要素に遭遇した場合、実際のクライアントコンポーネント関数への参照に置き換える必要があります。
この作業には、再びバンドラーの助けが必要になります。
バンドラーを用いてサーバ上でクライアントコンポーネント関数をモジュール参照に置き換えたように、今度はバンドラーを用いてブラウザ上でモジュール参照を実際のクライアントコンポーネント関数に置き換えます。
再構築されたReactツリーは以下のようになります。異なる点は、ネイティブのタグとクライアントコンポーネントが置き換わっていることだけです。</p>
<p><img src="https://www.plasmic.app/blog/static/images/react-server-components-client.png"></p>
<p>あとは、いつも通りこのツリーをレンダリングし、DOMにコミットするだけです。</p>
<h3>Suspenseとの互換性は問題ないか？<a name="10"></a></h3>
<p>問題ありません。
Suspenseは、上で述べたすべてのステップで欠かせない役割を果たします。</p>
<p>Suspenseはそれ自体が壮大なテーマであり、それ単体でブログ記事1本分に相当するものなので、この記事ではあえて軽く触れるだけに留めています。
ごく簡単に説明すると、Suspenseは何か準備ができていないもの（データのフェッチ、コンポーネントの遅延インポートなど）を必要とする際、ReactコンポーネントからPromiseをスローすることを可能にします。
それらのPromiseは、Suspenseの境界でキャッチされます。
Suspenseサブツリーのレンダリング時にPromiseがスローされると、ReactはPromiseが解決されるまでサブツリーのレンダリングを停止し、再度トライします。</p>
<p>RSC出力を生成するためにサーバ上でサーバコンポーネント関数を呼び出すと、それらの関数が必要なデータを取得する際にPromiseを返す場合があります。
<a href="https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L416">スローされたPromiseに遭遇</a>すると、プレースホルダを出力します。
Promiseが解決すると、再びサーバコンポーネント関数を呼び出し、成功すれば完成したチャンクを出力します。
RSC出力ストリームを作成しているのであり、Promiseがスローされると停止し、解決すると追加のチャンクをストリーミングします。</p>
<p>同様に、ブラウザ上では上の<code class="language-text">fetch()</code>コールからRSC JSON出力ストリームを作成します。
このプロセスも、出力の中にSuspenseのプレースホルダがあり（サーバがスローされたPromiseに遭遇している）、ストリーム内にまだプレースホルダのコンテンツを見つけていない（<a href="https://github.com/facebook/react/blob/main/packages/react-client/src/ReactFlightClientStream.js">詳細はこちら</a>）場合、Promiseをスローすることになるかもしれません。
あるいは、クライアントコンポーネントのモジュール参照に遭遇したものの、まだブラウザ上にクライアントコンポーネント関数が読み込まれていない場合も、Promiseをスローする可能性があります。
その場合、バンドラーのランタイムが動的に<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightClientWebpackBundlerConfig.js">必要なチャンクを取得</a>する必要があります。</p>
<p>Suspenseのおかげで、サーバコンポーネントがデータを取得する間にサーバはRSC出力をストリーミングし、ブラウザは受け取ったデータから徐々にレンダリングし、必要になったクライアントコンポーネントバンドルを動的に取得します。</p>
<h2>RSCワイヤーフォーマット<a name="11"></a></h2>
<p>具体的にサーバは何を出力しているのでしょうか。
「JSON」と「ストリーム」の文字を見て疑念を抱いたのであれば、それは正しい反応です。
では、サーバはブラウザにどのようなデータをストリーミングしているのでしょうか。</p>
<p>IDがタグ付けされたJSONの塊が各行に一つ追加された、単純なフォーマットです。
以下は、<code class="language-text">&lt;OuterServerComponent/&gt;</code>の例のRSC出力です。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">M1:{&quot;id&quot;:&quot;./src/ClientComponent.client.js&quot;,&quot;chunks&quot;:[&quot;client1&quot;],&quot;name&quot;:&quot;&quot;}
J0:[&quot;$&quot;,&quot;@1&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;span&quot;,null,{&quot;children&quot;:&quot;Hello from server land&quot;}]}]</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>上のスニペットでは、<code class="language-text">M</code>で始まる行はクライアントコンポーネントのモジュール参照を定義しており、クライアントバンドルの中からコンポーネント関数を検索するのに必要な情報が含まれています。
<code class="language-text">J</code>で始まる行は、実際のReact要素ツリーを定義しており、<code class="language-text">M</code>行で定義されたクライアントコンポーネントを参照する<code class="language-text">@1</code>などが含まれます。</p>
<p>このフォーマットは非常にストリーミングしやすく、クライアントは1行読み終えるとすぐにJSONのスニペットを解析して処理を進めることができます。
サーバがレンダリング中にSuspense境界に遭遇した場合、各チャンクが解決される度たびにそれと一致する複数の<code class="language-text">J</code>行が出てきます。</p>
<p>もう少し興味深い例を見てみましょう。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token comment">// Tweets.server.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> fetch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-fetch'</span> <span class="token comment">// React の Suspense 対応した fetch()</span>
                                    
<span class="token keyword">import</span> Tweet <span class="token keyword">from</span> <span class="token string">'./Tweet.client'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Tweets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> tweets <span class="token operator">=</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/tweets</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>tweets<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">tweet</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Tweet</span></span> <span class="token attr-name">tweet</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>tweet<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Tweet.client.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">Tweet</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> tweet <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Written by </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>tweet<span class="token punctuation">.</span>username<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>tweet<span class="token punctuation">.</span>body<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span>

<span class="token comment">// OuterServerComponent.server.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">OuterServerComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ServerComponent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token string">'Loading tweets...'</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Tweets</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ClientComponent</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この場合、RSCストリームはどのように見えるでしょうか。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">M1:{&quot;id&quot;:&quot;./src/ClientComponent.client.js&quot;,&quot;chunks&quot;:[&quot;client1&quot;],&quot;name&quot;:&quot;&quot;}
S2:&quot;react.suspense&quot;
J0:[&quot;$&quot;,&quot;@1&quot;,null,{&quot;children&quot;:[[&quot;$&quot;,&quot;span&quot;,null,{&quot;children&quot;:&quot;Hello from server land&quot;}],[&quot;$&quot;,&quot;$2&quot;,null,{&quot;fallback&quot;:&quot;Loading tweets...&quot;,&quot;children&quot;:&quot;@3&quot;}]]}]
M4:{&quot;id&quot;:&quot;./src/Tweet.client.js&quot;,&quot;chunks&quot;:[&quot;client8&quot;],&quot;name&quot;:&quot;&quot;}
J3:[&quot;$&quot;,&quot;ul&quot;,null,{&quot;children&quot;:[[&quot;$&quot;,&quot;li&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;@4&quot;,null,{&quot;tweet&quot;:{...}}}]}],[&quot;$&quot;,&quot;li&quot;,null,{&quot;children&quot;:[&quot;$&quot;,&quot;@4&quot;,null,{&quot;tweet&quot;:{...}}}]}]]}]</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">J0</code>行には新たな子が追加されています。
<code class="language-text">children</code>が参照<code class="language-text">@3</code>を指している新しい<code class="language-text">Suspense</code>境界です。
興味深いことに、この時点ではまだ<code class="language-text">@3</code>は定義されていません。
サーバはツイートの読み込みを完了すると、<code class="language-text">M4</code>と<code class="language-text">J3</code>の行を出力します。
前者は<code class="language-text">Tweet.client.js</code>コンポーネントへのモジュール参照を定義し、後者は<code class="language-text">@3</code>を置き換えるべき別のReact要素ツリーを定義します（ここでも、<code class="language-text">J3</code>のchildrenは<code class="language-text">M4</code>で定義された<code class="language-text">Tweet</code>コンポーネントを参照しています）。</p>
<p>バンドラーが<code class="language-text">ClientComponent</code>と<code class="language-text">Tweet</code>を二つの異なるバンドルに自動的に入れており、それによってブラウザが<code class="language-text">Tweet</code>バンドルのダウンロードを遅らせることができる点も、ここで述べておくべきでしょう。</p>
<h3>RSCフォーマットを使う<a name="12"></a></h3>
<p>このRSCストリームをブラウザ上で実際のReact要素に変換するにはどうすればよいのでしょうか。
<code class="language-text">react-server-dom-webpack</code>には、RSCレスポンスを用いてReact要素ツリーを再構築する<a href="https://github.com/facebook/react/blob/main/packages/react-server-dom-webpack/src/ReactFlightDOMClient.js">エントリーポイント</a>があります。
以下はルートクライアントコンポーネントを簡略化した例です。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> createFromFetch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-server-dom-webpack'</span>
<span class="token keyword">function</span> <span class="token function">ClientRootComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// RSC API のエンドポイントから fetch() を実行します。</span>
  <span class="token comment">// react-server-dom-webpack はフェッチした結果を受け取り、</span>
  <span class="token comment">// React の要素ツリーを再構築することができます。</span>
  <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token function">createFromFetch</span><span class="token punctuation">(</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/rsc?...'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Suspense</span></span> <span class="token attr-name">fallback</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">null</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>response<span class="token punctuation">.</span><span class="token function">readRoot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">/* Returns a React element! */</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Suspense</span></span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">react-server-dom-webpack</code>に、APIエンドポイントからのRSCレスポンスを読むよう指示します。
次に、<code class="language-text">response.readRoot()</code>が、レスポンスストリームが処理されると更新されるReact要素を返します。
ストリームがまだ読まれる前に、直ちにPromiseがスローされます。
これは、まだコンテンツが用意できていないからです。
最初の<code class="language-text">J0</code>が処理されると、対応するReact要素ツリーが作成され、返されたPromiseが解決されます。
Reactはレンダリングを再開しますが、まだ準備ができていない<code class="language-text">@3</code>の参照に遭遇すると、新たなPromiseがスローされます。
そのPromiseは<code class="language-text">J3</code>を読んだ時点で解決され、Reactは再びレンダリングを開始し、今回は完了します。
したがって、RSCレスポンスをストリーミングしながら、Suspense境界によって定義されたチャンク単位で要素ツリーの更新とレンダリングを完了するまで継続します。</p>
<h3>単にプレーンHTMLを出力すればよいのでは？<a name="13"></a></h3>
<p>なぜ全く新しいワイヤーフォーマットを発明する必要があるのでしょうか。
クライアント側における目的は、React要素ツリーを再構築することです。
HTMLは、解析しなければReact要素を作成できないため、この目的はHTMLよりもこのフォーマットから行う方がずっと簡単に果たせます。
React要素ツリーを再構築することで、DOMへのコミットを最小限に留めつつReactツリーへのその後の変更をマージできるようになるため、これは重要なプロセスです。</p>
<h3>クライアントコンポーネントからデータを取得するだけよりもメリットがある？<a name="14"></a></h3>
<p>このコンテンツを取得するために、どちらにしてもサーバにAPIリクエストを送信する必要があるのであれば、現在のようにリクエストを送信してデータだけを取得し、クライアント側ですべてのレンダリングを行うよりも、RSCを使った方が本当によいのでしょうか。</p>
<p>最終的には、何をレンダリングして画面上に表示するのかによります。
RSCでは、ユーザに向けて表示されるコンテンツに直接マッピングされる、非正規化された「処理済み」のデータを受け取ります。
したがって、取得するデータの一部だけをレンダリングしたい場合や、レンダリング自体に大量のJavaScriptが必要なため、ブラウザへのダウンロードを避けたい場合はメリットがあります。
さらに、レンダリングを行うために複数回データを取得する必要があり、ウォーターフォールにおいてそれぞれ互いに依存し合う場合、ブラウザよりもデータのレイテンシがはるかに低いサーバ上でデータを取得した方がよいでしょう。</p>
<h3>サーバサイドレンダリングはどうなる？<a name="15"></a></h3>
<p>SSRがどうなるのか気になる方が多いのはよく分かります。
React 18ではSSRとRSCの併用が可能なため、サーバ上でHTMLを生成し、ブラウザ上でRSCを用いてHTMLをハイドレーションすることが可能です。
このテーマについてはまた別の機会に詳しく話したいと思います。</p>
<h2>サーバコンポーネントがレンダリングしているコンテンツのアップデート<a name="16"></a></h2>
<p>ある製品のページから別の製品のページに切り替えたい場合など、サーバコンポーネントに新しいコンテンツをレンダリングさせる必要がある場合はどうすればよいでしょうか。</p>
<p>この場合も、レンダリングはサーバ側で行われるため、新しいコンテンツをRSCワイヤーフォーマットで取得するためにはサーバに新たなAPIコールを行う必要があります。
よいニュースは、ブラウザが新しいコンテンツを受け取ると、クライアントコンポーネントにステートハンドラとイベントハンドラを保持しつつ、新しいReact要素ツリーを構築し、前のReactツリーとの差分を取るための通常の差分検出処理を行い、DOMに対する必要最小限のアップデートを判断できるという点です。
クライアントコンポーネントにとっては、このアップデートはすべてブラウザ上で行われた場合と比べても何ら違いがありません。</p>
<p>現時点では、Reactツリー全体をルートサーバコンポーネントから再レンダリングする必要がありますが、将来的にはこれをサブツリーに対して行えるようになるかもしれません。</p>
<h2>RSCにメタフレームワークを使うべき理由<a name="17"></a></h2>
<p>Reactチームは、RSCは当初プレーンなReactプロジェクトで直接使用するのではなく、Next.jsやShopify Hydrogenのように<a href="https://github.com/josephsavona/rfcs/blob/server-components/text/0000-server-components.md#adoption-strategy">メタフレームワーク経由での導入</a>を意図していると述べています。
これはなぜでしょうか。
メタフレームワークにはどのようなメリットがあるのでしょうか。</p>
<p>メタフレームワークの使用は必須ではありませんが、作業が楽になります。
メタフレームワークが提供するラッパーや抽象化は使いやすいため、サーバ上でRSCストリームを生成し、ブラウザ上で消費することを考える必要がありません。
また、メタフレームワークはサーバサイドレンダリングもサポートしており、サーバコンポーネントを使用している場合にサーバが生成したHTMLを適切にハイドレーションできるよう、必要な<a href="https://github.com/Shopify/hydrogen/issues/250">作業</a>を<a href="https://github.com/vercel/next.js/issues/30994">実施</a>しています。</p>
<p>上で説明したように、クライアントコンポーネントを適切に送信し、ブラウザ上で使用するためにはバンドラーの助けも必要です。
webpackインテグレーションはすでにあり、現在はShopifyが<a href="https://github.com/facebook/react/pull/22952">viteへのインテグレーション</a>に取り組んでいます。
RSCに必要なプラグインの多くはパブリックnpmパッケージとして公開されていないため、これらのプラグインはReactリポジトリの一部でなくてはいけません。
しかし、一度開発されれば、メタフレームワークなしでこれらのプラグインを使用できるようになるはずです。</p>
<h2>RSCは実用化の準備ができているのか？<a name="18"></a></h2>
<p>RSCは、現在<a href="https://nextjs.org/docs/advanced-features/react-18">Next.jsの実験的な機能</a>として提供されており、<a href="https://hydrogen.shopify.dev/">Shopify Hydrogenの現在の開発者プレビュー</a>段階にありますが、どちらもまだ本番環境で使用できる状態ではありません。
今後のブログ記事では、これらのフレームワークがそれぞれRSCをどのように使用しているのか詳しく説明したいと思います。</p>
<p>しかし、RSCが今後のReactを大きく左右する存在であることは間違いありません。RSCは、ページの読み込み速度向上、JavaScriptバンドルの軽量化、Time To Interactive（TTI）の短縮という課題に対するReactの答えであり、Reactを使用して複数ページのアプリケーションを構築する方法に関するより包括的なテーゼです。未完成ではあるものの、注目すべき時が近づいています。</p>
<p><em>この記事の草案をレビューしてくれた<a href="https://twitter.com/Nutlope">Hassan</a>と<a href="https://twitter.com/jplhomer">Josh</a>に感謝します。</em></p>]]></content:encoded></item><item><title><![CDATA[tscをGoに移植]]></title><description><![CDATA[筆者はTypeScript型チェッカーtscをRustではなく、Goに移植しようと思います。拡張可能なRustプラットフォームSWCの作者の発言としては、奇妙に聞こえるかもしれません。理由を説明した…]]></description><link>https://postd.cc/tsc-go/</link><guid isPermaLink="false">https://postd.cc/tsc-go/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[TypeScript]]></category><category><![CDATA[Go言語]]></category><category><![CDATA[tsc]]></category><category><![CDATA[SWC]]></category><pubDate>Mon, 13 Jun 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>筆者はTypeScript型チェッカー<strong>tsc</strong>をRustではなく、Goに移植しようと思います。拡張可能なRustプラットフォーム<a href="https://swc.rs/">SWC</a>の作者の発言としては、奇妙に聞こえるかもしれません。理由を説明したいと思います。</p>
<h2>なぜtscを移植するのか</h2>
<p>TypeScriptの普及が進むにつれて、大規模プロジェクトではあるジレンマに直面しています。<strong>型チェックは、ワークフローの中で最も時間がかかるプロセスの一つになっているのです</strong>。開発者は、イテレーションのサイクルを遅らせることなく、型安全を保証することを望んでいます。
<strong>tsc</strong>（TypeScript Compiler）は、型の妥当性をチェックし、コードをJavaScriptにコンパイルします。コードの量が多いほど、コンパイルには時間がかかります。中規模から大規模のTypeScriptプロジェクトでは、このコンパイルに膨大な時間がかかります。開発者はワークフローのトランスパイル部分をSWCに置き換えることができますが、それでも型チェックはボトルネックとなっています。</p>
<h2>型チェッカーとは何か</h2>
<p>型チェッカーは、実行前にプログラムを検証し、関数呼び出しや変数割り当ての値が正しいことを確認します。また、いたるところで型を指定することがないよう、可能な限り変数の型を推測します。型チェックは、自信を持って開発を行い、エラーをなくし、大規模なコードベースのリファクタリングをよりスムーズに行うことを可能にします。</p>
<h2>なぜRustではないのか</h2>
<p>筆者は<strong>tsc</strong>をRustで書き直そうと試みました。最初はサイドプロジェクトとして取り組み、大いに楽しみました。<strong>tsc</strong>のソースコードを見ずに型チェックのロジックを作り直す作業を開始しました。
筆者が書き直したRust版の初期テストでは、<strong>型チェックのスピードがtscの62倍に改善されていました</strong>。SWCとtscのコンパイル時間を測定するため、公式TypeScriptコンパイラの<strong>コンフォーマンス（適合性）</strong>テストスイートを使用しました。結果は以下の通りです（8スレッド使用）：</p>
<ul>
<li><strong>tsc</strong>：133.2秒</li>
<li>Rustリライト版：<strong>2.13秒（62倍速い）</strong></li>
</ul>
<p>最終的に、<strong>tsc</strong>のような巨大プロジェクトを書き直すのは、継続するのが極めて難しいことを悟りました。しかし、パフォーマンスの向上はかなりのものだったため、別の方法として完全なリライトではなく移植を試してみることにしたのです。そこで、TypeScriptのソースコードを見始めました。
<strong>tsc</strong>は共有の可変性を多く使い、<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">ガベージコレクション</a>に依存する部分が多くあります。筆者はRustの支持者であり、信者ですが、このプロジェクトに合ったツールではないと感じます。このプロジェクトでRustを使用するには、<a href="https://doc.rust-lang.org/std/keyword.unsafe.html">unsafe</a>を使用しなければならない場面が多すぎました。
<strong>tsc</strong>は共有の可変性に依存しており、周期的な可変参照を持っています。Rustはこの挙動を防ぐよう設計されています。同じデータに対し二つの参照を持つこと（共有の可変性）は、Rustでは定義されていない挙動です。
どの言語を選ぶかは、好みではなく作業によって決めるべきです。筆者はRustを好みますが、このプロジェクトのためにGoとZigを試し、Goを使うことにしました。</p>
<h2>オープンソース化するのか</h2>
<p><strong>tsc</strong>をGoに移植する作業は、Vercelがスポンサーとして資金を提供しています。将来的にはオープンソース化する予定です。この新バージョンの<strong>tsc</strong>をSWCとともに使用するためのブリッジも作成します。
型チェックのサポートを得て、SWCはJavaScriptとTypeScriptのツールチェーン全体のパフォーマンス向上に取り組んでいます。</p>
<ul>
<li>✅トランスパイル（Babelの代替）</li>
<li>🚧型チェック（<strong>tsc</strong>の代替）</li>
<li>🚧最小化（Terserの代替）</li>
<li>🚧バンドリング（webpackの代替）</li>
</ul>
<p>プロジェクトの最新情報については、<a href="https://twitter.com/kdy1dev">Twitterをフォローしてください</a>。</p>]]></content:encoded></item><item><title><![CDATA[Next.jsアプリのローカライゼーション]]></title><description><![CDATA[クイックサマリー ‐ 国際化ルーティングは、厳密にはNext.jsの新機能ではありません。（v.10以降搭載されています。）この記事では、この機能のメリットだけではなく、こうした機能を利用して最高の…]]></description><link>https://postd.cc/localizing-your-nextjs-app/</link><guid isPermaLink="false">https://postd.cc/localizing-your-nextjs-app/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[Next.js]]></category><category><![CDATA[UX]]></category><pubDate>Mon, 16 May 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>クイックサマリー ‐ 国際化ルーティングは、厳密にはNext.jsの新機能ではありません。（<a href="https://nextjs.org/blog/next-10">v.10</a>以降搭載されています。）この記事では、この機能のメリットだけではなく、こうした機能を利用して最高のユーザ体験と円滑な開発者体験を実現する方法についても見ていきます。自己文書化コードやバンドルサイズの削減、さらにはランタイムエラーではなくコンパイル時エラーに興味のある方は、是非このまま読み進めてください。
開発中のアプリにおいて、ロケール（または国、あるいは両方）ごとにルートを設定したい場合、Next.jsで簡単に対応できるようになりました。プロジェクトのrootディレクトリにnext.config.jsがない場合、新たに作成してください。このスニペットからコピーしても構いません。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token comment">/** @type {import('next').NextConfig} */</span>
 
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  reactStrictMode<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  i18n<span class="token operator">:</span> <span class="token punctuation">{</span>
    locales<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'en'</span><span class="token punctuation">,</span> <span class="token string">'gc'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    defaultLocale<span class="token operator">:</span> <span class="token string">'en'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><em>注記：1行目はTSサーバ（TypeScriptプロジェクトに参画している場合、またはVSCodeを使用している場合）を許可するためのもので、構成オブジェクトでサポートされる属性です。必須ではありませんが良い機能です。</em></p>
<p><code class="language-text">i18n</code>オブジェクトの中にプロパティが2つあります。</p>
<ul>
<li><code class="language-text">locales</code>
開発中のアプリがサポートする全ロケールのリスト。文字列の配列。</li>
<li><code class="language-text">defaultLocale</code>
メインrootのロケール。ユーザ設定がない場合やrootが強制的に設定される場合のデフォルト設定。</li>
</ul>
<p>これらのプロパティ値がルートを決定するため、あまり凝りすぎない方が良いでしょう。<a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">ロケールコード</a>や<a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes">国コード</a>を使用して有効な属性値を作成し、すぐに<code class="language-text">url</code>が作成されるため小文字を使用しましょう。</p>
<p>アプリが複数のロケールに対応したら、Next.jsで認識しておくべきことが最後に1つあります。全てのロケールに全てのルートが存在し、これらが同一であることをフレームワークは認識しています。特定のロケールに移動したい場合、Linkコンポーネントに<code class="language-text">locale props</code>を設定する必要があります。これを行わないと、ブラウザの<code class="language-text">Accept-Language</code>ヘッダに基づきデフォルトに戻ります。</p>
<div class="gatsby-highlight" data-language="tsx"><pre style="counter-reset: linenumber NaN" class="language-tsx line-numbers"><code class="language-tsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Link</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/<span class="token punctuation">"</span></span> <span class="token attr-name">locale</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>de<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">&lt;a>Home page in German</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Link</span></span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>最終的には、ユーザが選択したロケールに従い、適切なルートに転送するアンカーを記述するのが良いでしょう。これは、Next.jsから<code class="language-text">useRouter</code>カスタムフックを使用することで容易に行うことができ、objectが返され、選択した<code class="language-text">locale</code>が<code class="language-text">key</code>となります。</p>
<div class="gatsby-highlight" data-language="typescript"><pre style="counter-reset: linenumber NaN" class="language-typescript line-numbers"><code class="language-typescript"><span class="token keyword">import</span> <span class="token keyword">type</span> <span class="token punctuation">{</span> <span class="token constant">FC</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> Link <span class="token keyword">from</span> <span class="token string">'next/link'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'next/router'</span>

<span class="token keyword">const</span> Anchor<span class="token operator">:</span> <span class="token constant">FC</span><span class="token operator">&lt;</span><span class="token punctuation">{</span> href<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> href<span class="token punctuation">,</span> children <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> locale <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Link href<span class="token operator">=</span><span class="token punctuation">{</span>href<span class="token punctuation">}</span> locale<span class="token operator">=</span><span class="token punctuation">{</span>locale<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>a<span class="token operator">></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Next.jsはこれで国際化の準備が整い、以下を行うようになります。</p>
<ul>
<li>Next.jsの機能を使用し、リクエストの<code class="language-text">Accepted-Languages</code>ヘッダからユーザが指定したロケールを取得する</li>
<li>上で作成した<code class="language-text">Anchor</code>コンポーネントを使用し、ユーザが指定したルートに常にユーザを転送する</li>
<li>必要に応じてデフォルト言語に戻る</li>
</ul>
<p>最後に行うべきことは、翻訳を確実に扱えるようにすることです。現時点では、ルーティングは問題なく機能しているものの、各ページのコンテンツを調整する方法がありません。</p>
<h2>ディクショナリの作成</h2>
<p>翻訳管理サービスを使用している場合でも、他の方法でテキストを入手している場合でも、最終的に欲しいのはJavaScriptがランタイム中に処理するJSONオブジェクトです。Next.jsは3つの異なるランタイムを提供します。</p>
<ul>
<li>クライアントサイド</li>
<li>サーバサイド</li>
<li>コンパイル時</li>
</ul>
<p>これについては一旦置いておきましょう。まずはデータを構造化する必要があります。</p>
<p>翻訳の対象となるデータは、周辺のツールに応じてさまざまな形態を取りますが、最終的にはロケール、キー、値に絞られます。したがって、まずはこれらから見ていきます。筆者のロケールは、英語の<code class="language-text">en</code>とポルトガル語の<code class="language-text">pt</code>です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  en<span class="token operator">:</span> <span class="token punctuation">{</span>
    hello<span class="token operator">:</span> <span class="token string">'hello world'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  pt<span class="token operator">:</span> <span class="token punctuation">{</span>
    hello<span class="token operator">:</span> <span class="token string">'oi mundo'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>翻訳カスタムフック</h2>
<p>ロケールが決まったら、次は翻訳カスタムフックを作成します。</p>
<div class="gatsby-highlight" data-language="typescript"><pre style="counter-reset: linenumber NaN" class="language-typescript line-numbers"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> useRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'next/router'</span>
<span class="token keyword">import</span> dictionary <span class="token keyword">from</span> <span class="token string">'./dictionary'</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useTranslation</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> locales <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> defaultLocale<span class="token punctuation">,</span> <span class="token operator">...</span>nextRouter<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> locale <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>nextRouter<span class="token punctuation">.</span>locale <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> nextRouter<span class="token punctuation">.</span>locale
    <span class="token operator">:</span> defaultLocale
  
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">translate</span><span class="token operator">:</span> <span class="token punctuation">(</span>term<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> translation <span class="token operator">=</span> dictionary<span class="token punctuation">[</span>locale<span class="token punctuation">]</span><span class="token punctuation">[</span>term<span class="token punctuation">]</span>

      <span class="token keyword">return</span> <span class="token function">Boolean</span><span class="token punctuation">(</span>translation<span class="token punctuation">)</span> <span class="token operator">?</span> translation <span class="token operator">:</span> term
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>上の内容を細かく見ていきましょう。</p>
<ol>
<li><code class="language-text">useRouter</code>は、利用可能な全ロケール、デフォルトのロケール、現在のロケールを取得するために使用します。</li>
<li>これらを取得したら、有効なロケールがあるかを確認し、なければデフォルトのロケールにフォールバックします。</li>
<li>次に、<code class="language-text">translate</code>メソッドを返します。<code class="language-text">term</code>とディクショナリからのフェッチを指定されたロケールに届けます。値がない場合、再度翻訳<code class="language-text">term</code>を返します。</li>
</ol>
<p>これで、Next.jsアプリは少なくとも一般的で初歩的なケースを翻訳する準備が整いました。ここでは完璧な翻訳ライブラリを構築しようとしているわけではありません。我々のカスタムフックには、挿入句、複数形、性別などの<strong>重要な要素が多数</strong>欠けています。</p>
<h2>スケーリングの時間</h2>
<p>カスタムフックの要素の欠如は、直ちに必要でなければ許容できます。実際に必要になってから実装することはいつでも可能であり、その方が良い場合もあります。しかし、現行の戦略において懸念される根本的問題が1つあります。それは、Next.jsの同型要素を活用していないことです。</p>
<p>ローカライズされたアプリの規模拡大において最も好ましくないのは、翻訳作業そのものを管理しないことです。これまでに何度も起こっていることなので、ある程度は予測できます。問題は、ブラウザに送信される無数のディクショナリの肥大化に対処することであり、ディクショナリはアプリで対応が求められる言語数とともに増えていく一方です。これは、エンドユーザにとって使い物にならないデータとなることが多く、言語を切り替える際に新しいキーや値をフェッチする必要がある場合にパフォーマンスに影響を及ぼします。ユーザ体験について1つの大きな真理があるとしたら、それは、ユーザの行動を全て予期することはできないということです。</p>
<p>ユーザが言語を切り替えるのか、いつ切り替えるのか、追加のキーを必要とするのか、いつ必要なのかを予想することはできません。理想を言えば、特定のルートにデータが読み込まれたときに、アプリに全ての翻訳が用意されていることがベストです。現時点では、ページのレンダリング結果と状態の考え得るバリエーションに基づき、ディクショナリのチャンクを分割する必要があります。非常に気の遠くなるような話です。</p>
<h2>サーバサイド・プリレンダリング</h2>
<p>では、拡張性に関する新規要件を整理しましょう。</p>
<ol>
<li>クライアントサイドに送るデータは最小限に留める</li>
<li>ユーザインタラクションに基づく追加のリクエストは避ける</li>
<li>既に翻訳済みの最初のレンダリングをユーザに送る</li>
</ol>
<p>Next.jsページの<code class="language-text">getStaticProps</code>メソッドのお陰で、コンパイラの構成に一切踏み込むことなくこれを実現できます。この特殊なサーバレス関数にディクショナリ全体をインポートし、各キーの翻訳を保持する特殊オブジェクトのリストをページに送ります。</p>
<h2>SSR翻訳の設定</h2>
<p>アプリに話を戻しますが、新しいメソッドを作成します。<code class="language-text">/utils</code>や<code class="language-text">/helpers</code>といったディレクトリを設定し、その中のどこかに以下を置きます。</p>
<div class="gatsby-highlight" data-language="typescript"><pre style="counter-reset: linenumber NaN" class="language-typescript line-numbers"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">ssrI18n</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> dictionary<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>dictionary<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>keySet<span class="token punctuation">,</span> locale<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      keySet<span class="token punctuation">[</span>locale<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dictionary<span class="token punctuation">[</span>locale <span class="token keyword">as</span> <span class="token keyword">keyof</span> <span class="token keyword">typeof</span> dictionary<span class="token punctuation">]</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> keySet
    <span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>細かく見ていきましょう。</p>
<ol>
<li>翻訳<code class="language-text">key</code>または<code class="language-text">term</code>と<code class="language-text">dictionary</code>を取得する</li>
<li><code class="language-text">dictionary</code>オブジェクトをその<code class="language-text">key</code>の配列に変換する</li>
<li>ディクショナリの各キーは<code class="language-text">locale</code>であるため、<code class="language-text">key</code>の名前を用いてオブジェクトを作成し、各<code class="language-text">locale</code>はその特定の言語の値となります。</li>
</ol>
<p>そのメソッドの出力例は以下のような形になります。</p>
<div class="gatsby-highlight" data-language="typescript"><pre style="counter-reset: linenumber NaN" class="language-typescript line-numbers"><code class="language-typescript"><span class="token punctuation">{</span>
  <span class="token string">'hello'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'en'</span><span class="token operator">:</span> <span class="token string">'Hello World'</span><span class="token punctuation">,</span>
    <span class="token string">'pt'</span><span class="token operator">:</span> <span class="token string">'Oi Mundo'</span><span class="token punctuation">,</span>
    <span class="token string">'de'</span><span class="token operator">:</span> <span class="token string">'Hallo Welt'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>では、Next.jsページに移動しましょう。</p>
<div class="gatsby-highlight" data-language="tsx"><pre style="counter-reset: linenumber NaN" class="language-tsx line-numbers"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> ssrI18n <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../utils/ssrI18n'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">DICTIONARY</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../dictionary'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'next/router'</span>

<span class="token keyword">const</span> <span class="token function-variable function">Home</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> hello <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token function">useRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> i18nLocale <span class="token operator">=</span> <span class="token function">getLocale</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">className</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">.</span>title<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>hello<span class="token punctuation">[</span>i18nLocale<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">getStaticProps</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    hello<span class="token operator">:</span> <span class="token function">ssrI18n</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token constant">DICTIONARY</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// add another entry to each translation key</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これで終わりです！ページには各言語で必要な翻訳しか送られません。逆に、途中で言語を切り替えても外部にリクエストは送られないため、非常に迅速です。</p>
<h2>設定を全て省略する</h2>
<p>このままでも十分素晴らしいですが、まだまだ改善の余地があります。開発者の皆さん注目です。ブートストラップが多く使われているにもかかわらず、依然としてタイプミスがないことを前提としています。翻訳されたアプリを使用したことのある人なら、タイプミスを含むキーがどこかに紛れ込んでいるものだということをご存じでしょう。したがって、TypeScriptによる安全なタイピングを翻訳手法にもたらすことができます。
この設定を省略し、TypeScriptの安全性と自動補完を手に入れるには、<a href="https://github.com/atilafassina/next-g11n">next-g11n</a>を使用できます。これは、上記で行ったのと全く同じことを行う小さなライブラリですが、型といくつかのオプション機能が追加されます。</p>
<h2>まとめ</h2>
<p>この記事が、<a href="https://nextjs.org/docs/advanced-features/i18n-routing">Next.jsの国際化ルーティング</a>がグローバル化に向けてアプリにどのようなメリットをもたらし、現在のWebにおけるローカライズされたアプリで最高のユーザ体験を提供するということが何を意味するのかについて、知見を深める一助となれば幸いです。是非以下のコメント欄からご意見やご感想をお聞かせください。<a href="https://atila.io/twitter">ツイート</a>も歓迎いたします。</p>]]></content:encoded></item><item><title><![CDATA[あまり知られていないPostgreSQLの機能]]></title><description><![CDATA[あなたが知らない既存機能があるかもしれません！ マイクロソフト社は2006年、Microsoft Officeの新バージョンで追加してほしい機能について、顧客調査を実施しました。驚いたことに、ユーザ…]]></description><link>https://postd.cc/postgresql-unknown-features/</link><guid isPermaLink="false">https://postd.cc/postgresql-unknown-features/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[PostgreSQL]]></category><pubDate>Mon, 18 Apr 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<style>
    .toc-for-article {
        clear: both;
        box-shadow: 0 9px 30px -5px rgb(50 50 83 / 25%), 0 8px 8px -12px rgb(0 0 0 / 20%), 0 -6px 16px -6px rgb(0 0 0 / 3%);
        border-radius: 11px;
        padding: 2em;
        background-color: #fff;
        margin: 1.25em 0 3em;
        columns: 2;

    }
</style>
<p>あなたが知らない既存機能があるかもしれません！</p>
<p>マイクロソフト社は2006年、Microsoft Officeの新バージョンで追加してほしい機能について、顧客調査を実施しました。驚いたことに、ユーザが希望した機能の90%以上はすでに実装されており、その存在が知られていないだけであることが判明しました。機能の「見つけにくさ」の問題の解決策として同社が考案したのが、現在のMicrosoft Office製品でおなじみの「リボンUI」です。</p>
<p>この問題はOfficeに限ったものではありません。日々使用するツールの機能をすべて把握している人はほとんどいません。PostgreSQLのように大規模なツールであればなおさらです。数週間前にPostgreSQL 14がリリースされたばかりなので、この機会にPostgreSQLのあまり知られていない機能に注目してみたいと思います。</p>
<p><strong>この記事では、PostgreSQLのあまり知られていない機能を紹介します。</strong></p>
<div style="margin: 0 auto; text-align: center;">
<img src="https://hakibenita.com/images/00-postgresql-unknown-features.png" style="height: 350px; width: 270px;">
<br>Illustration by <a href="https://www.instagram.com/_wrightdesign/">Eleanor Wright</a>
</div>
<h3>目次</h3>
<ul class="toc-for-article">
    <li><a href="#01">UPSERTにおいて更新、挿入された行数の取得</a></li>
    <li><a href="#02">特定の列の権限付与</a></li>
    <li><a href="#03">複数パターンに対するマッチング</a></li>
    <li><a href="#04">シーケンスを進めることなく現在値を確認する</a></li>
    <li><a href="#05">複数行のSQLで\COPYを使用する</a></li>
    <li><a href="#06">自動生成キーの値の設定を防ぐ</a></li>
    <li><a href="#07">ピボットテーブルを作成するもう2つの方法</a></li>
    <li><a href="#08">ドル引用</a></li>
    <li><a href="#09">データベースオブジェクトに関するコメント</a></li>
    <li><a href="#10">データベースごとに個別の履歴ファイルを維持する</a></li>
    <li><a href="#11">大文字の予約語の自動補完</a></li>
    <li><a href="#12">スリープ時間の指定</a></li>
    <li><a href="#13">サブクエリを使用せず、グループの最初または最後の行を取得する</a></li>
    <li><a href="#14">拡張機能なしでUUIDを生成する</a></li>
    <li><a href="#15">再現可能なランダムデータの生成</a></li>
    <li><a href="#16">直ちに検証することなく制約を追加する</a></li>
    <li><a href="#17">PostgreSQLにおけるシノニム</a></li>
    <li><a href="#18">重複レンジを探す</a></li>
</ul>
<h2>UPSERTにおいて更新、挿入された行数の取得 <a name="01"></a></h2>
<p>INSERT ON CONFLICTは、Extract(抽出) Transform(変換) Load(読み込み) プロセスでは特に便利なコマンドであり、Oracleの「MERGE」に相当し、「UPSERT」（UPDATEとINSERTを組み合わせた造語）とも呼ばれます。INSERT文のON CONFLICT句を使用することで、キー列に重複がある場合の処理をデータベースに指示できます。</p>
<p>以下は従業員テーブルのデータを同期するためのクエリの例です。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">WITH</span> new_employees <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'George'</span><span class="token punctuation">,</span> <span class="token string">'Sales'</span><span class="token punctuation">,</span>    <span class="token string">'Manager'</span><span class="token punctuation">,</span>   <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Jane'</span><span class="token punctuation">,</span>   <span class="token string">'R&amp;D'</span><span class="token punctuation">,</span>      <span class="token string">'Developer'</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> t<span class="token punctuation">(</span>
         <span class="token keyword">name</span><span class="token punctuation">,</span>      department<span class="token punctuation">,</span> role<span class="token punctuation">,</span>       salary
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees <span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">,</span> department<span class="token punctuation">,</span> role<span class="token punctuation">,</span> salary<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token keyword">name</span><span class="token punctuation">,</span> department<span class="token punctuation">,</span> role<span class="token punctuation">,</span> salary
<span class="token keyword">FROM</span> new_employees
<span class="token keyword">ON</span> CONFLICT <span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">)</span> <span class="token keyword">DO</span> <span class="token keyword">UPDATE</span> <span class="token keyword">SET</span>
    department <span class="token operator">=</span> EXCLUDED<span class="token punctuation">.</span>department<span class="token punctuation">,</span>
    role <span class="token operator">=</span> EXCLUDED<span class="token punctuation">.</span>role<span class="token punctuation">,</span>
    salary <span class="token operator">=</span> EXCLUDED<span class="token punctuation">.</span>salary
<span class="token keyword">RETURNING</span> <span class="token operator">*</span><span class="token punctuation">;</span>

  <span class="token keyword">name</span>  │ department │   role    │ salary
────────┼────────────┼───────────┼────────
 George │ Sales      │ Manager   │   <span class="token number">1000</span>
 Jane   │ R<span class="token operator">&amp;</span>D        │ Developer │   <span class="token number">1200</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">2</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このクエリは、新しい従業員データをテーブルに挿入します。追加しようとした従業員の名前がすでに存在する場合、データを挿入する代わりにその行が更新されます。</p>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>RETURNING *</h5></div><div class="admonition-content"><p><a href="https://hakibenita.com/sql-tricks-application-dba#implement-complete-processes-using-with-and-returning">WITHとRETURNINGを使用して完全なプロセスを実行する方法</a>はこちらをご覧ください。</p></div></div>
<p>上記コマンドの出力INSERT 0 2から、影響のある従業員が2名いることが分かります。では、挿入された行数と更新された行数はいくつでしょうか。この出力からは判断できません。</p>
<p>筆者が同様のクエリを使用したETLプロセスのロギングを改善する方法を探していた際、<a href="https://stackoverflow.com/a/39204667/2000875">Stack Overflowで投稿された質問に対する回答</a>に、これと全く同じ問題に対する有効な解決策を偶然見つけました。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">WITH</span> new_employees <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'George'</span><span class="token punctuation">,</span> <span class="token string">'Sales'</span><span class="token punctuation">,</span>    <span class="token string">'Manager'</span><span class="token punctuation">,</span>   <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Jane'</span><span class="token punctuation">,</span>   <span class="token string">'R&amp;D'</span><span class="token punctuation">,</span>      <span class="token string">'Developer'</span><span class="token punctuation">,</span> <span class="token number">1200</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> t<span class="token punctuation">(</span>
         <span class="token keyword">name</span><span class="token punctuation">,</span>      department<span class="token punctuation">,</span> role<span class="token punctuation">,</span>       salary
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> employees <span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">,</span> department<span class="token punctuation">,</span> role<span class="token punctuation">,</span> salary<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token keyword">name</span><span class="token punctuation">,</span> department<span class="token punctuation">,</span> role<span class="token punctuation">,</span> salary
<span class="token keyword">FROM</span> new_employees
<span class="token keyword">ON</span> CONFLICT <span class="token punctuation">(</span><span class="token keyword">name</span><span class="token punctuation">)</span> <span class="token keyword">DO</span> <span class="token keyword">UPDATE</span> <span class="token keyword">SET</span>
    department <span class="token operator">=</span> EXCLUDED<span class="token punctuation">.</span>department<span class="token punctuation">,</span>
    role <span class="token operator">=</span> EXCLUDED<span class="token punctuation">.</span>role<span class="token punctuation">,</span>
    salary <span class="token operator">=</span> EXCLUDED<span class="token punctuation">.</span>salary
<span class="token keyword">RETURNING</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>xmax <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> inserted<span class="token punctuation">;</span>

  <span class="token keyword">name</span>  │ department │   role    │ salary │ inserted
────────┼────────────┼───────────┼────────┼──────────
 Jane   │ R<span class="token operator">&amp;</span>D        │ Developer │   <span class="token number">1200</span> │ t
 George │ Sales      │ Manager   │   <span class="token number">1000</span> │ f
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">2</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>RETURNING句の違いに注目してください。こちらの例では、xmaxという特殊な列を使用して挿入された行数を計算するinsertedという計算済みフィールドが含まれています。コマンドによって返されたデータから、「Jane」の行が新たに挿入されたものの、「George」はすでにテーブルに存在したため、その行は更新されたことが分かります。</p>
<p>xmax列は、<a href="https://www.postgresql.org/docs/current/ddl-system-columns.html">特殊なシステム列</a>です。</p>
<p>削除トランザクションの識別情報（トランザクションID）です。削除されていない行ではゼロです。
PostgreSQLでは、行が更新されると古いバージョンが削除され、xmaxに削除トランザクションのIDが保持されます。行が挿入されると、古い行の削除は行われないため、xmaxの値は0になります。この解決策では、この挙動を賢く利用して更新された行と挿入された行を区別しています。</p>
<hr>
<h2>特定の列の権限付与 <a name="02"></a></h2>
<p>認証情報、パスワード、個人を特定できる情報などのセンシティブ情報を含むユーザテーブルがあるとします。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> users <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span><span class="token punctuation">,</span>
    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    personal_id <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    password_hash <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>

db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'haki'</span><span class="token punctuation">,</span> <span class="token string">'12222227'</span><span class="token punctuation">,</span> <span class="token string">'super-secret-hash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">1</span> <span class="token number">0</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このテーブルは、アナリストなど組織内のさまざまな人が、データにアクセスして随時レポートを作成するために使用します。アナリストにアクセスを許可するため、データベースに特別ユーザを追加します。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">USER</span> analyst<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">USER</span>

db<span class="token operator">=</span># <span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> users <span class="token keyword">TO</span> analyst<span class="token punctuation">;</span>
<span class="token keyword">GRANT</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>現在、データベース「db」にユーザ「analyst」として接続されています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \<span class="token keyword">connect</span> db analyst
You are now connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"analyst"</span><span class="token punctuation">.</span>

db<span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>
 id │ username │ personal_id │   password_hash
────┼──────────┼─────────────┼───────────────────
  <span class="token number">1</span> │ haki     │ <span class="token number">12222227</span>    │ super<span class="token operator">-</span>secret<span class="token operator">-</span><span class="token keyword">hash</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>前に述べたように、アナリストはレポートを作成し、分析を行うためにユーザデータにアクセスしますが、センシティブ情報や個人を特定できる情報にアクセスできることは望ましくありません。</p>
<p>ユーザがテーブル内でアクセスできるデータを詳細に制御するため、PostgreSQLでは特定の列のみを対象に権限を付与できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \<span class="token keyword">connect</span> db postgres
You are now connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"postgres"</span><span class="token punctuation">.</span>

db<span class="token operator">=</span># <span class="token keyword">REVOKE</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> users <span class="token keyword">FROM</span> analyst<span class="token punctuation">;</span>
<span class="token keyword">REVOKE</span>

db<span class="token operator">=</span># <span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> username<span class="token punctuation">)</span> <span class="token keyword">ON</span> users <span class="token keyword">TO</span> analyst<span class="token punctuation">;</span>
<span class="token keyword">GRANT</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>テーブル上の既存の選択権限を取り消した後、id列とusername列のみを対象として、analystに選択権限を付与しました。これで、analystはこれら以外の列にはアクセスできなくなります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \<span class="token keyword">connect</span> db analyst
You are now connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"analyst"</span><span class="token punctuation">.</span>

db<span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>
ERROR:  permission denied <span class="token keyword">for</span> <span class="token keyword">table</span> users

db<span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> username<span class="token punctuation">,</span> personal_id <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>
ERROR:  permission denied <span class="token keyword">for</span> <span class="token keyword">table</span> users

db<span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> username <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>
 id │ username
────┼──────────
  <span class="token number">1</span> │ haki</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ユーザ「analyst」が制限された列に明示的、あるいは「*」を使用して黙示的にアクセスしようとすると、「permission denied」エラーが返されます。</p>
<hr>
<h2>複数パターンに対するマッチング <a name="03"></a></h2>
<p>SQLでは、パターンマッチングをよく使用します。以下は「gmail.com」のメールアカウントを保有するユーザを検索するクエリの例です。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span> email <span class="token operator">LIKE</span> <span class="token string">'%@gmail.com'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>このクエリは、ワイルドカード「%」を使用し、メールアドレスが「@gmail.com」で終わるユーザを検索します。では、同じクエリの中で「yahoo.com」のメールアカウントを保有するユーザも検索したい場合はどうすればよいでしょうか。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span>
    email <span class="token operator">LIKE</span> <span class="token string">'%@gmail.com'</span>
    <span class="token operator">OR</span> email <span class="token operator">LIKE</span> <span class="token string">'%@yahoo.com'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>いずれかのパターンに対するマッチングを行うには、OR条件を指定する方法があります。しかし、PostgreSQLでは、複数パターンに対してマッチングを行う方法は他にもあります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span> email SIMILAR <span class="token keyword">TO</span> <span class="token string">'%@gmail.com|%@yahoo.com'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p><a href="https://www.postgresql.org/docs/current/functions-matching.html#FUNCTIONS-SIMILARTO-REGEXP">SIMILAR TO</a>演算子を使用することで、単純なクエリにより複数パターンとのマッチングを行うことができます。</p>
<p>regexpを使用して複数パターンとのマッチングを行う方法もあります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span> email <span class="token operator">~</span> <span class="token string">'@gmail\.com$|@yahoo\.com$'</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>regexpを使用する際には注意が必要です。ピリオド（.）は任意の文字にマッチするため、gmail.comやyahoo.comに含まれるピリオドとマッチングするには、「.」のようにエスケープ文字を追加する必要があります。</p>
<p>筆者がこの情報を<a href="https://twitter.com/be_haki/status/1435859174538293248?s=20">Twitterに</a>投稿したところ、いくつかの興味深い反応が得られました。Pythonに対応したPostgreSQLドライバであるpsycopgの公式アカウントから届いた<a href="https://twitter.com/psycopg/status/1435926642388516866?s=20">コメント</a>は、別の方法を提案しました。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span> email <span class="token operator">~</span> <span class="token keyword">ANY</span><span class="token punctuation">(</span><span class="token keyword">ARRAY</span><span class="token punctuation">[</span><span class="token string">'@gmail\.com$'</span><span class="token punctuation">,</span> <span class="token string">'@yahoo\.com$'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>このクエリでは、ANY演算子を使用してさまざまなパターンに対してマッチングを行います。メールアドレスがいずれかのパターンにマッチすれば、条件は真となります。このアプローチは、Pythonなどのホスト言語から行うとやりやすいでしょう。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">with</span> connection<span class="token punctuation">.</span><span class="token keyword">cursor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">cursor</span>:
    <span class="token keyword">cursor</span><span class="token punctuation">.</span><span class="token keyword">execute</span><span class="token punctuation">(</span><span class="token string">'''
        SELECT *
        FROM users
        WHERE email ~ ANY(ARRAY%(patterns)s)
    '''</span> <span class="token operator">%</span> {
        <span class="token string">'patterns'</span>: <span class="token punctuation">[</span>
            <span class="token string">'@gmail\.com$'</span><span class="token punctuation">,</span>
            <span class="token string">'@yahoo\.com$'</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
    }<span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>SIMILAR TO演算子を用いた前述のアプローチとは異なり、ANY演算子を使用すればパターンのリストを変数に結合できます。</p>
<hr>
<h2>シーケンスを進めることなく現在値を確認する <a name="04"></a></h2>
<p>シーケンスの現在値を確認する必要がある場合、おそらく最初に<a href="https://www.postgresql.org/docs/current/functions-sequence.html">currval</a>を使用するでしょう。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> currval<span class="token punctuation">(</span><span class="token string">'sale_id_seq'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ERROR:  currval <span class="token keyword">of</span> <span class="token keyword">sequence</span> <span class="token string">"sale_id_seq"</span> <span class="token operator">is</span> <span class="token operator">not</span> yet defined <span class="token operator">in</span> this <span class="token keyword">session</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>その場合、筆者と同じように、currvalはシーケンスが現在のセッションで定義または使用されていなければ使えないことに気付くと思います。特に理由もなくシーケンスを進めることは通常避けたいため、これは好ましい解決策ではありません。</p>
<p>PostgreSQL 10では、シーケンスに関する情報に容易にアクセスできるよう、<a href="https://www.postgresql.org/docs/current/view-pg-sequences.html">pg_sequences</a>ビューが追加されました。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> pg_sequences <span class="token keyword">WHERE</span> sequencename <span class="token operator">=</span> <span class="token string">'sale_id_seq'</span><span class="token punctuation">;</span>
─<span class="token punctuation">[</span> <span class="token keyword">RECORD</span> <span class="token number">1</span> <span class="token punctuation">]</span>─┬────────────
schemaname    │ <span class="token keyword">public</span>
sequencename  │ sale_id_seq
sequenceowner │ db
data_type     │ <span class="token keyword">integer</span>
start_value   │ <span class="token number">1</span>
min_value     │ <span class="token number">1</span>
max_value     │ <span class="token number">2147483647</span>
increment_by  │ <span class="token number">1</span>
<span class="token keyword">cycle</span>         │ f
cache_size    │ <span class="token number">1</span>
last_value    │ <span class="token number">155</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このテーブルでも現在値は確認できますが、これは「あまり知られていない機能」というよりも、情報スキーマにおけるテーブルの1つに過ぎません。</p>
<p>ドキュメントには記載されていないのですが、pg<em>sequence</em>last_valueという関数を使用してシーケンスの現在値を確認する方法もあります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> pg_sequence_last_value<span class="token punctuation">(</span><span class="token string">'sale_id_seq'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 pg_sequence_last_value
────────────────────────
                   <span class="token number">155</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>なぜこの関数がドキュメントに記載されていないのかは定かではありませんが、筆者が確認したところ、<a href="https://www.postgresql.org/search/?u=%2Fdocs%2F14%2F&#x26;q=pg_sequence_last_value">公式ドキュメント</a>の中では言及されていませんでした。使用する場合はその点も考慮してください。</p>
<p>興味深いことに、このテーマについて調査をしているとき、テーブルと同じようにシーケンスもクエリできることを発見しました。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> sale_id_seq<span class="token punctuation">;</span>

 last_value │ log_cnt │ is_called
────────────┼─────────┼───────────
        <span class="token number">155</span> │      <span class="token number">10</span> │ t</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>PostgreSQLでは他にどのような種類のオブジェクトをクエリでき、どのような値が返されるのか気になるところです。</p>
<p>注意すべき点として、この機能はシーケンスを大まかに確認するためだけに使用してください。この出力の値をもとにIDの更新を試みるべきではありません。IDを更新したい場合はnextvalを使用してください。</p>
<hr>
<h2>複数行のSQLで\COPYを使用する <a name="05"></a></h2>
<p>psqlを頻繁に使用する人は、データベースからデータをエクスポートするために\COPYをかなりの頻度で使用しているのではないでしょうか。筆者は頻繁に使用しています。\COPYに関する不満点の1つは、複数行のクエリに対応していないことです。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \COPY <span class="token punctuation">(</span>
\copy: parse error <span class="token keyword">at</span> <span class="token keyword">end</span> <span class="token keyword">of</span> line</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>\COPYコマンドに新しい行を追加しようとすると、このようなエラーメッセージが表示されます。
この制約を回避するため、筆者はまずビューを使用しました。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> v_department_dbas <span class="token keyword">AS</span>
    <span class="token keyword">SELECT</span> department<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> employees
    <span class="token keyword">FROM</span> emp
    <span class="token keyword">WHERE</span> role <span class="token operator">=</span> <span class="token string">'dba'</span>
    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department
    <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> employees<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span>

db<span class="token operator">=</span># \COPY <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> v_department_dbas<span class="token punctuation">)</span> <span class="token keyword">TO</span> department_dbas<span class="token punctuation">.</span>csv <span class="token keyword">WITH</span> CSV HEADER<span class="token punctuation">;</span>
COPY <span class="token number">5</span>

db<span class="token operator">=</span># <span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> v_department_dbas<span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">VIEW</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この方法も有効ではあるものの、途中で何かがうまく行かなかった場合、ビューが散乱する結果になりかねません。スキーマはきれいに整理された状態にしておきたいので、作業後のクリーンアップを自動的に行える方法を探してみました。検索すると、<a href="https://www.postgresql.org/docs/current/sql-createview.html#id-1.9.3.97.6">一時ビュー</a>がすぐに出てきました。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">TEMPORARY</span> <span class="token keyword">VIEW</span> v_department_dbas <span class="token keyword">AS</span> # <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span>

db<span class="token operator">=</span># \COPY <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> v_department_dbas<span class="token punctuation">)</span> <span class="token keyword">TO</span> department_dbas<span class="token punctuation">.</span>csv <span class="token keyword">WITH</span> CSV HEADER<span class="token punctuation">;</span>
COPY <span class="token number">5</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>一時ビューは、セッションが終了すると自動的に削除されるため、これを使用することで作業後のクリーンアップを行う必要がなくなりました。
しばらく一時ビューを使用していましたが、<a href="https://www.postgresql.org/docs/current/app-psql.html#APP-PSQL-META-COMMANDS-COPY">psqlドキュメント</a>の中に素晴らしい発見がありました。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># COPY <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> department<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> employees
    <span class="token keyword">FROM</span> emp
    <span class="token keyword">WHERE</span> role <span class="token operator">=</span> <span class="token string">'dba'</span>
    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> department
    <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> employees
<span class="token punctuation">)</span> <span class="token keyword">TO</span> STDOUT <span class="token keyword">WITH</span> CSV HEADER \g department_dbas<span class="token punctuation">.</span>csv
COPY <span class="token number">5</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>実に秀逸ではないでしょうか。細かく見ていきましょう。</p>
<ul>
<li><strong>\COPYの代わりにCOPYを使用する</strong>：COPYコマンドはサーバ上で実行されるサーバコマンドであり、\COPYは同じインターフェースを持つpsqlコマンドです。したがって、\COPYは複数行のクエリに対応していませんが、COPYは対応しています。</li>
<li><strong>STDOUTに結果を書き込む</strong>：クエリの結果は、COPYを使用してサーバ上のディレクトリに書き込むか、TO STDOUTを使用して標準出力に書き込むことができます。</li>
<li><strong>\gを使用してSTDOUTをローカルファイルに書き込む</strong>：最後に、psqlは出力を標準出力からファイルに書き込むためのコマンドを提供しています。</li>
</ul>
<p>これら3つの機能を組み合わせることで、求めていた通りの結果が得られました。</p>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>コピーの達人</h5></div><div class="admonition-content"><p>大量のデータを動かす場合、<a href="https://hakibenita.com/fast-load-data-python-postgresql">Fastest Way to Load Data Into PostgreSQL Using Python</a>もチェックしてみてください。</p></div></div>
<hr>
<h2>自動生成キーの値の設定を防ぐ <a name="06"></a></h2>
<p>PostgreSQLで自動生成の主キーを使用している場合、おそらくまだ<a href="https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-SERIAL">SERIALデータ型</a>を使用しているのではないでしょうか。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> sale <span class="token punctuation">(</span>
    id <span class="token keyword">SERIAL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    sold_at TIMESTAMPTZ<span class="token punctuation">,</span>
    amount <span class="token keyword">INT</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>裏では、PostgreSQLは行が追加された場合に使用するシーケンスを作成しています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sale <span class="token punctuation">(</span>sold_at<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> sale<span class="token punctuation">;</span>
 id │           sold_at             │ amount
────┼───────────────────────────────┼────────
  <span class="token number">1</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">25</span> <span class="token number">10</span>:<span class="token number">06</span>:<span class="token number">56.646298</span><span class="token operator">+</span><span class="token number">03</span> │   <span class="token number">1000</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>SERIALデータ型はPostgreSQLに固有のものであり、いくつか既知の問題があります。したがって、バージョン10以降、SERIALデータ型はやんわり非推奨とされ、id列の使用が推奨されています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> sale <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> GENERATED <span class="token keyword">BY</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">AS</span> <span class="token keyword">IDENTITY</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    sold_at TIMESTAMPTZ<span class="token punctuation">,</span>
    amount <span class="token keyword">INT</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>id列は、SERIALデータ型の仕組みと非常に似ています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sale <span class="token punctuation">(</span>sold_at<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> sale<span class="token punctuation">;</span>
 id │           sold_at             │ amount
────┼───────────────────────────────┼────────
  <span class="token number">1</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">09</span><span class="token operator">-</span><span class="token number">25</span> <span class="token number">10</span>:<span class="token number">11</span>:<span class="token number">57.771121</span><span class="token operator">+</span><span class="token number">03</span> │   <span class="token number">1000</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>では、次のシナリオを検討してみてください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sale <span class="token punctuation">(</span>id<span class="token punctuation">,</span> sold_at<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>

db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sale <span class="token punctuation">(</span>sold_at<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ERROR:  <span class="token keyword">duplicate</span> <span class="token keyword">key</span> <span class="token keyword">value</span> violates <span class="token keyword">unique</span> <span class="token keyword">constraint</span> <span class="token string">"sale_pkey"</span>
DETAIL:  <span class="token keyword">Key</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> already <span class="token keyword">exists</span><span class="token punctuation">.</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>なぜエラーになったのでしょうか？</p>
<ul>
<li>最初のINSERTコマンドは、id列の値2を明示的に指定しているため、シーケンスは使用されませんでした。</li>
<li>2つ目のINSERTコマンドはidの値を指定していないため、シーケンスが使用されます。このコマンドは、シーケンスの次の値が偶然2であったため、一意性制約違反によりエラーになりました。</li>
</ul>
<p>自動採番するIDを手動で設定する必要があることはまれであり、手動で設定すると混乱を招くおそれがあります。では、ユーザが設定を行わないようにするにはどうすればよいでしょうか。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> sale <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> GENERATED ALWAYS <span class="token keyword">AS</span> <span class="token keyword">IDENTITY</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
    sold_at TIMESTAMPTZ<span class="token punctuation">,</span>
    amount <span class="token keyword">INT</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>GENERATED BY DEFAULTの代わりにGENERATED ALWAYSを使用するのです。両者の違いを理解するために、再び同じシナリオを試してみましょう。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sale <span class="token punctuation">(</span>sold_at<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>

db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sale <span class="token punctuation">(</span>id<span class="token punctuation">,</span> sold_at<span class="token punctuation">,</span> amount<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ERROR:  cannot <span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">column</span> <span class="token string">"id"</span>
DETAIL:  <span class="token keyword">Column</span> <span class="token string">"id"</span> <span class="token operator">is</span> an <span class="token keyword">identity</span> <span class="token keyword">column</span> defined <span class="token keyword">as</span> GENERATED ALWAYS<span class="token punctuation">.</span>
HINT:  <span class="token keyword">Use</span> <span class="token keyword">OVERRIDING</span> SYSTEM <span class="token keyword">VALUE</span> <span class="token keyword">to</span> override<span class="token punctuation">.</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>何が変わりましたか？</p>
<ul>
<li>最初のINSERTコマンドはidの値を指定せず、正常に完了します。
しかし、2つ目のINSERTコマンドはidに値2を設定しようとしてエラーになっています。</li>
<li>親切にも、PostgreSQLではid列に明示的に値を設定したい場合の解決策がエラーメッセージに記述されています。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sale <span class="token punctuation">(</span>id<span class="token punctuation">,</span> sold_at<span class="token punctuation">,</span> amount<span class="token punctuation">)</span>
<span class="token keyword">OVERRIDING</span> SYSTEM <span class="token keyword">VALUE</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>INSERTコマンドにOVERRIDING SYSTEM VALUEを追加することで、id列の値を設定可能にするようPostgreSQLに明示的に指示できます。それでも、一意性制約違反に対処する必要はあるかもしれませんが、それをPostgreSQLのせいにすることはもはやできません。</p>
<hr>
<h2>ピボットテーブルを作成するもう2つの方法 <a name="07"></a></h2>
<p>以前執筆した記事の中で、筆者は<a href="https://hakibenita.com/sql-for-data-analysis#pivot-tables">条件付き集計を使用してピボットテーブルを作成する方法</a>を説明しました。その記事を書いた後、PostgreSQLでピボットテーブルを生成する方法をさらに2つ発見しました。</p>
<p>各部門の職務ごとの従業員数を調べたいと思います。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">WITH</span> employees <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'Haki'</span><span class="token punctuation">,</span>    <span class="token string">'R&amp;D'</span><span class="token punctuation">,</span>      <span class="token string">'Manager'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Dan'</span><span class="token punctuation">,</span>     <span class="token string">'R&amp;D'</span><span class="token punctuation">,</span>      <span class="token string">'Developer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Jax'</span><span class="token punctuation">,</span>     <span class="token string">'R&amp;D'</span><span class="token punctuation">,</span>      <span class="token string">'Developer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'George'</span><span class="token punctuation">,</span>  <span class="token string">'Sales'</span><span class="token punctuation">,</span>    <span class="token string">'Manager'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Bill'</span><span class="token punctuation">,</span>    <span class="token string">'Sales'</span><span class="token punctuation">,</span>    <span class="token string">'Developer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'David'</span><span class="token punctuation">,</span>   <span class="token string">'Sales'</span><span class="token punctuation">,</span>    <span class="token string">'Developer'</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> t<span class="token punctuation">(</span>
        <span class="token keyword">name</span><span class="token punctuation">,</span>       department<span class="token punctuation">,</span>  role
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> role<span class="token punctuation">,</span> department<span class="token punctuation">,</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token keyword">FROM</span> employees
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> role<span class="token punctuation">,</span> department<span class="token punctuation">;</span>

   role    │ department │ count
───────────┼────────────┼───────
 Developer │ Sales      │     <span class="token number">2</span>
 Manager   │ Sales      │     <span class="token number">1</span>
 Manager   │ R<span class="token operator">&amp;</span>D        │     <span class="token number">1</span>
 Developer │ R<span class="token operator">&amp;</span>D        │     <span class="token number">2</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>同じ情報でも、ピボットテーブルを使用した方が見やすいでしょう。psqlでは、\crosstabviewコマンドを使用することで、前回のクエリの結果をピボットテーブルに変換できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \crosstabview

   role    │ Sales │ R<span class="token operator">&amp;</span>D
───────────┼───────┼─────
 Developer │     <span class="token number">2</span> │   <span class="token number">2</span>
 Manager   │     <span class="token number">1</span> │   <span class="token number">1</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この通り！</p>
<p>このコマンドは、デフォルトで最初の2つの列からピボットテーブルを作成しますが、これは引数を使用することで制御できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \crosstabview department role

 department │ Developer │ Manager
────────────┼───────────┼─────────
 Sales      │         <span class="token number">2</span> │       <span class="token number">1</span>
 R<span class="token operator">&amp;</span>D        │         <span class="token number">2</span> │       <span class="token number">1</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>利便性の面では若干劣りますが、あらかじめ組み込まれている<a href="https://www.postgresql.org/docs/current/tablefunc.html">tablefunc拡張機能</a>を使用してピボットテーブルを作成する方法もあります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> EXTENSION tablefunc<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> EXTENSION

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> crosstab<span class="token punctuation">(</span><span class="token string">'
    SELECT role, department, count(*) AS employees
    FROM employees
    GROUP BY 1, 2
    ORDER BY role
'</span><span class="token punctuation">,</span> <span class="token string">'
    SELECT DISTINCT department
    FROM employees
    ORDER BY 1
'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> t<span class="token punctuation">(</span>role <span class="token keyword">text</span><span class="token punctuation">,</span> sales <span class="token keyword">int</span><span class="token punctuation">,</span> rnd <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   role    │ sales │ rnd
───────────┼───────┼─────
 Developer │     <span class="token number">2</span> │   <span class="token number">2</span>
 Manager   │     <span class="token number">1</span> │   <span class="token number">1</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><a href="https://www.postgresql.org/docs/current/tablefunc.html#id-1.11.7.47.5.5">crosstab</a>関数を使用することで、ピボットテーブルを作成できます。この方法の欠点は、出力列をあらかじめ定義しておく必要があることです。しかし、crosstab関数が作成したテーブルをサブクエリとして使用し、さらなる処理を行えることは利点です。</p>
<hr>
<h2>ドル引用 <a name="08"></a></h2>
<p>データベースにテキストフィールド、特にパラグラフ全体を格納している場合、おそらくエスケープ文字についてはよくご存じでしょう。例えば、文字列リテラルにシングルクォート（'）を含める場合、もう1つシングルクォート（''）を使用して
エスケープする必要があります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token string">'John''s Pizza'</span><span class="token punctuation">;</span>
   ?<span class="token keyword">column</span>?
──────────────
 John's Pizza</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>テキストの規模が大きくなり、バックスラッシュなどの文字や新しい行が含まれるようになると、エスケープ文字を追加するのがかなり面倒になってきます。この問題に対処するため、PostgreSQLでは文字列定数を記述する方法が他にも用意されています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> $$a <span class="token keyword">long</span>
<span class="token keyword">string</span> <span class="token keyword">with</span> <span class="token keyword">new</span> <span class="token keyword">lines</span>
<span class="token operator">and</span> <span class="token string">'single quotes'</span>
<span class="token operator">and</span> <span class="token string">"double quotes

PostgreSQL doesn't mind ;)$$ AS text;
           text
───────────────────────────
 a long                   ↵
 string with new lines    ↵
 and 'single quotes'      ↵
 and "</span><span class="token keyword">double</span> quotes       ↵
                          ↵
 PostgreSQL doesn't mind <span class="token punctuation">;</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>文字列の始めと終わりにあるドル記号$$に注目してください。$$の間にある文字は文字列として扱われます。PostgreSQLでは、これを<a href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING">「ドル引用」</a>と呼んでいます。</p>
<p>これだけではありません。テキスト内で$$記号を使用する必要がある場合、タグを追加できるのですが、これが利便性を一層高めてくれるのです。以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> $JSON${
    <span class="token string">"name"</span>: <span class="token string">"John's Pizza"</span><span class="token punctuation">,</span>
    <span class="token string">"tagline"</span>: <span class="token string">"Best value for your $$"</span>
}$JSON$ <span class="token keyword">AS</span> json<span class="token punctuation">;</span>

                  json
─────────────────────────────────────────
 {                                      ↵
     <span class="token string">"name"</span>: <span class="token string">"John's Pizza"</span><span class="token punctuation">,</span>            ↵
     <span class="token string">"tagline"</span>: <span class="token string">"Best value for your $$"</span>↵
 }</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このブロックでは、$JSON$というタグを付けているため、出力には「$$」記号全体が含まれています。</p>
<p>また、これを使用して特殊文字を含むjsonbオブジェクトを素早く生成することもできます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> $JSON${
    <span class="token string">"name"</span>: <span class="token string">"John's Pizza"</span><span class="token punctuation">,</span>
    <span class="token string">"tagline"</span>: <span class="token string">"Best value for your $$"</span>
}$JSON$::jsonb <span class="token keyword">AS</span> json<span class="token punctuation">;</span>
                          json
─────────────────────────────────────────────────────────────
 {<span class="token string">"name"</span>: <span class="token string">"John's Pizza"</span><span class="token punctuation">,</span> <span class="token string">"tagline"</span>: <span class="token string">"Best value for your $$"</span>}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>値はjsonbオブジェクトとなり、意のままに操作できます。</p>
<h2>データベースオブジェクトに関するコメント <a name="09"></a></h2>
<p>PostgreSQLには、<a href="https://www.postgresql.org/docs/current/sql-comment.html">ほぼすべてのデータベースオブジェクトについてコメントを追加できる</a>便利な機能があります。以下の例では、テーブルに関するコメントを追加しています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> sale <span class="token operator">IS</span> <span class="token string">'Sales made in the system'</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>このコメントは、psql（およびおそらく他のIDE）で表示できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \dt<span class="token operator">+</span> sale
                                  List <span class="token keyword">of</span> relations
 <span class="token keyword">Schema</span> │ <span class="token keyword">Name</span> │ <span class="token keyword">Type</span>  │ Owner │ Persistence │    <span class="token keyword">Size</span>    │       Description
────────┼──────┼───────┼───────┼─────────────┼────────────┼──────────────────────────
 <span class="token keyword">public</span> │ sale │ <span class="token keyword">table</span> │ haki  │ permanent   │ <span class="token number">8192</span> bytes │ Sales made <span class="token operator">in</span> <span class="token keyword">the</span> system</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>テーブルの列に関するコメントを追加し、拡張記述を使用する際に表示できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">COLUMN</span> sale<span class="token punctuation">.</span>sold_at <span class="token operator">IS</span> <span class="token string">'When was the sale finalized'</span><span class="token punctuation">;</span>
<span class="token keyword">COMMENT</span>

db<span class="token operator">=</span># \d<span class="token operator">+</span> sale
  <span class="token keyword">Column</span>  │           <span class="token keyword">Type</span>           │         Description
──────────┼──────────────────────────┼─────────────────────────────
 id       │ <span class="token keyword">integer</span>                  │
 sold_at │ <span class="token keyword">timestamp</span> <span class="token keyword">with</span> <span class="token keyword">time</span> <span class="token keyword">zone</span> │ <span class="token keyword">When</span> was <span class="token keyword">the</span> sale finalized
 amount   │ <span class="token keyword">integer</span>                  │</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>また、COMMENTコマンドとドル引用を組み合わせて、関数などのより長く意義のある記述を含めることができます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">COMMENT</span> <span class="token keyword">ON</span> <span class="token keyword">FUNCTION</span> generate_random_string <span class="token operator">IS</span> $docstring$
Generate a random <span class="token keyword">string</span> <span class="token keyword">at</span> a given <span class="token keyword">length</span> <span class="token keyword">from</span> a list <span class="token keyword">of</span> possible characters<span class="token punctuation">.</span>

<span class="token keyword">Parameters</span>:

    <span class="token operator">-</span> <span class="token keyword">length</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>: <span class="token keyword">length</span> <span class="token keyword">of</span> <span class="token keyword">the</span> output <span class="token keyword">string</span>
    <span class="token operator">-</span> characters <span class="token punctuation">(</span><span class="token keyword">text</span><span class="token punctuation">)</span>: possible characters <span class="token keyword">to</span> choose <span class="token keyword">from</span>

Example:

    db<span class="token operator">=</span># <span class="token keyword">SELECT</span> generate_random_string<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     generate_random_string
    ────────────────────────
     o0QsrMYRvp

    db<span class="token operator">=</span># <span class="token keyword">SELECT</span> generate_random_string<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'AB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     generate_random_string
    ────────────────────────
     ABB
$docstring$<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この関数は、筆者が過去に<a href="https://hakibenita.com/sql-medium-text-performance#toast-compression">中規模のテキストがパフォーマンスに与える影響</a>を実証するために使用したものです。コメントにdocstringを記述しているため、関数の使い方を思い出すために再び記事を見返す必要はもうありません。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \df<span class="token operator">+</span> generate_random_string
List <span class="token keyword">of</span> functions
────────────┬────────────────────────────────────────────────────────────────────────────────
<span class="token keyword">Schema</span>      │ <span class="token keyword">public</span>
<span class="token keyword">Name</span>        │ generate_random_string
<span class="token comment">/* ... */</span>
Description │ Generate a random <span class="token keyword">string</span> <span class="token keyword">at</span> a given <span class="token keyword">length</span> <span class="token keyword">from</span> a list <span class="token keyword">of</span> possible characters<span class="token punctuation">.</span>↵
            │                                                                               ↵
            │ <span class="token keyword">Parameters</span>:                                                                   ↵
            │                                                                               ↵
            │     <span class="token operator">-</span> <span class="token keyword">length</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>: <span class="token keyword">length</span> <span class="token keyword">of</span> <span class="token keyword">the</span> output <span class="token keyword">string</span>                               ↵
            │     <span class="token operator">-</span> characters <span class="token punctuation">(</span><span class="token keyword">text</span><span class="token punctuation">)</span>: possible characters <span class="token keyword">to</span> choose <span class="token keyword">from</span>                   ↵
            │                                                                               ↵
            │ Example:                                                                      ↵
            │                                                                               ↵
            │     db<span class="token operator">=</span># <span class="token keyword">SELECT</span> generate_random_string<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                   ↵
            │      generate_random_string                                                   ↵
            │     ────────────────────────                                                  ↵
            │      o0QsrMYRvp                                                               ↵
            │                                                                               ↵
            │     db<span class="token operator">=</span># <span class="token keyword">SELECT</span> generate_random_string<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'AB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              ↵
            │      generate_random_string                                                   ↵
            │     ────────────────────────                                                  ↵
            │      ABB                                                                      ↵
            │</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<hr>
<h2>データベースごとに個別の履歴ファイルを維持する <a name="10"></a></h2>
<p>CLIツールを使用している場合、過去のコマンドを検索する機能をかなり頻繁に使用しているのではないでしょうか。bashとpsqlでは、<code class="language-text">CTRL + R</code>を押すことで通常逆引きが可能です。</p>
<p>ターミナルの他に複数のデータベースで作業する場合、データベースごとに個別の履歴ファイルを維持すると便利かもしれません。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \<span class="token keyword">set</span> HISTFILE <span class="token operator">~</span><span class="token operator">/</span><span class="token punctuation">.</span>psql_history<span class="token operator">-</span> :DBNAME</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>そうすることで、現在接続しているデータベースに関連するマッチを見つけやすくなります。このファイルは、<a href="https://www.postgresql.org/docs/current/app-psql.html#id-1.9.4.20.10">~/.psqlrc file</a>に置くことで永続化できます。</p>
<hr>
<h2>大文字の予約語の自動補完 <a name="11"></a></h2>
<p>SQLのキーワードを小文字で記述すべきか、それとも大文字で記述すべきかについては常に多くの議論（と冗談）の的になっています。このテーマに関する筆者の意見は明白です。</p>
<p>筆者のようにSQLで大文字のキーワードを使用するのを好む場合、大文字のキーワードを自動補完するオプションがpsqlに用意されています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># selec <span class="token operator">&lt;</span>tab<span class="token operator">></span>
db<span class="token operator">=</span># <span class="token keyword">select</span>

db<span class="token operator">=</span># \<span class="token keyword">set</span> COMP_KEYWORD_CASE upper
db<span class="token operator">=</span># selec <span class="token operator">&lt;</span>tab<span class="token operator">></span>
db<span class="token operator">=</span># <span class="token keyword">SELECT</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>COMP<em>KEYWORD</em>CASEをupperに設定すると、<strong>TAB</strong>キーを押すことでキーワードが大文字で自動補完されるようになります。</p>
<hr>
<h2>スリープ時間の指定 <a name="12"></a></h2>
<p>プログラムの実行を遅らせることは、テストやスロットリングなどにおいてかなり有益な場合があります。PostgreSQLでプログラムの実行を遅らせるには、通常pg_sleep関数を使用します。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \timing
Timing <span class="token operator">is</span> <span class="token keyword">on</span><span class="token punctuation">.</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> pg_sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 pg_sleep
──────────

<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>

<span class="token keyword">Time</span>: <span class="token number">3014.913</span> ms <span class="token punctuation">(</span><span class="token number">00</span>:<span class="token number">03.015</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この関数は、指定した秒数スリープします。しかし、長い時間スリープする必要がある場合、秒数の計算が煩わしくなることもあります。以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> pg_sleep<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>この関数がどれだけの時間スリープするか分かりますか？計算機を取り出す必要はありません。4分15秒です。
長い時間スリープする場合の利便性向上のため、PostgreSQLでは別の関数が用意されています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> pg_sleep_for<span class="token punctuation">(</span><span class="token string">'4 minutes 15 seconds'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>姉妹関数のpg<em>sleepとは異なり、[pg</em>sleep_for](<a href="https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-DELAY">https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-DELAY</a>)関数は時間間隔（interval）での設定が可能であり、秒数よりもはるかに読みやすく、直感的に理解できます。</p>
<hr>
<h2>サブクエリを使用せず、グループの最初または最後の行を取得する <a name="13"></a></h2>
<p>筆者はこの機能をいつも使用しているため、最初にこのリストを作成したときは、これを「あまり知られていない機能」だとは考えていませんでした。しかし、意外にもこの問題に対して奇妙な解決策が提示されていることが多く、これからお見せする方法で簡単に解決できるため、リストに加えることにしました。
以下のような生徒テーブルがあるとします。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> students<span class="token punctuation">;</span>

  <span class="token keyword">name</span>  │ class │ height
────────┼───────┼────────
 Haki   │ A     │    <span class="token number">186</span>
 Dan    │ A     │    <span class="token number">175</span>
 Jax    │ A     │    <span class="token number">182</span>
 George │ B     │    <span class="token number">178</span>
 Bill   │ B     │    <span class="token number">167</span>
 David  │ B     │    <span class="token number">178</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<details>
<summary>⚙テーブルデータ</summary>
<p>このセクションのクエリーを再現するために、以下のCTEを使用することができます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">WITH</span> students <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'Haki'</span><span class="token punctuation">,</span>    <span class="token string">'A'</span><span class="token punctuation">,</span>    <span class="token number">186</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Dan'</span><span class="token punctuation">,</span>     <span class="token string">'A'</span><span class="token punctuation">,</span>    <span class="token number">175</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Jax'</span><span class="token punctuation">,</span>     <span class="token string">'A'</span><span class="token punctuation">,</span>    <span class="token number">182</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'George'</span><span class="token punctuation">,</span>  <span class="token string">'B'</span><span class="token punctuation">,</span>    <span class="token number">178</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'Bill'</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">,</span>    <span class="token number">167</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'David'</span><span class="token punctuation">,</span>   <span class="token string">'B'</span><span class="token punctuation">,</span>    <span class="token number">178</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> t<span class="token punctuation">(</span>
        <span class="token keyword">name</span><span class="token punctuation">,</span>       class<span class="token punctuation">,</span>  height
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> students<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
</details>
<p><strong>各クラスで一番背の高い生徒の行全体を取得するにはどうすればよいでしょうか?</strong></p>
<p>最初に思いつく方法は次のようなものではないでしょうか。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> class<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token keyword">as</span> tallest
<span class="token keyword">FROM</span> students
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> class<span class="token punctuation">;</span>

 class │ tallest
───────┼─────────
 A     │     <span class="token number">186</span>
 B     │     <span class="token number">178</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これだと身長は取得できますが、生徒の名前は得られません。次に、サブクエリを使用して、身長をもとに一番背の高い生徒を見つけようとするかもしれません。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> students
<span class="token keyword">WHERE</span> <span class="token punctuation">(</span>class<span class="token punctuation">,</span> height<span class="token punctuation">)</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span> class<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token keyword">as</span> tallest
    <span class="token keyword">FROM</span> students
    <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> class
<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">name</span>  │ class │ height
────────┼───────┼────────
 Haki   │ A     │    <span class="token number">186</span>
 George │ B     │    <span class="token number">178</span>
 David  │ B     │    <span class="token number">178</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これで、各クラスで一番背の高い生徒に関する情報がすべて揃いましたが、まだ別の問題があります。</p>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>追記</h5></div><div class="admonition-content"><p>前のクエリ（(class, height) IN (...)）のようにレコードのセットをマッチングする機能もあまり知られていない、非常に強力なPostgreSQLの機能です。</p></div></div>
<p>クラス「B」には同じ身長の生徒が2人いますが、これがクラスで一番高い身長でもあります。集計関数MAXを使用すると身長しか得られないため、このような状況に直面する可能性があります。</p>
<p>MAXの使用が難しいのは、身長だけをもとに身長を選ばなくてはならないことであり、この場合は全く理にかなっているのですが、生徒を1人だけ選ぶ必要があります。2つ以上の列をもとに行を「ランク付け」できる別のアプローチとして、ウィンドウ関数を使用する方法があります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span>
    students<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>
    ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span>
        <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> class
        <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> height <span class="token keyword">DESC</span><span class="token punctuation">,</span> <span class="token keyword">name</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> rn
<span class="token keyword">FROM</span>
    students<span class="token punctuation">;</span>

  <span class="token keyword">name</span>  │ class │ height │ rn
────────┼───────┼────────┼────
 Haki   │ A     │    <span class="token number">186</span> │  <span class="token number">1</span>
 Jax    │ A     │    <span class="token number">182</span> │  <span class="token number">2</span>
 Dan    │ A     │    <span class="token number">175</span> │  <span class="token number">3</span>
 David  │ B     │    <span class="token number">178</span> │  <span class="token number">1</span>
 George │ B     │    <span class="token number">178</span> │  <span class="token number">2</span>
 Bill   │ B     │    <span class="token number">167</span> │  <span class="token number">3</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>身長をもとに生徒を「ランク付け」するには、各行に行番号を振ることができます。行番号はクラスごとに決められ（PARTITION BY class）まず身長の高い順にランク付けされ、次に生徒の名前でランク付けされます（ORDER BY height DESC, name）。身長の他に生徒の名前も追加することで、決定性のある結果が得られます（同じ名前がないと仮定した場合）。</p>
<p>各クラスで一番背の高い生徒の行だけを取得するには、サブクエリを使用できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span>
    <span class="token keyword">name</span><span class="token punctuation">,</span> class<span class="token punctuation">,</span> height
<span class="token keyword">FROM</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span>
        students<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>
        ROW_NUMBER<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">OVER</span> <span class="token punctuation">(</span>
            <span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> class
            <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> height <span class="token keyword">DESC</span><span class="token punctuation">,</span> <span class="token keyword">name</span>
        <span class="token punctuation">)</span> <span class="token keyword">AS</span> rn
    <span class="token keyword">FROM</span>
        students
<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">inner</span>
<span class="token keyword">WHERE</span>
    rn <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

 <span class="token keyword">name</span>  │ class │ height
───────┼───────┼────────
 Haki  │ A     │    <span class="token number">186</span>
 David │ B     │    <span class="token number">178</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>できました！これが各クラスで一番背の高い生徒の行全体です。</p>
<p>DISTINCT ONを<strong>使用する</strong></p>
<p>かなり手間のかかる方法を見てきましたが、次はもっと簡単な方法を紹介したいと思います。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">ON</span> <span class="token punctuation">(</span>class<span class="token punctuation">)</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    students
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    class<span class="token punctuation">,</span> height <span class="token keyword">DESC</span><span class="token punctuation">,</span> <span class="token keyword">name</span><span class="token punctuation">;</span>

 <span class="token keyword">name</span>  │ class │ height
───────┼───────┼────────
 Haki  │ A     │    <span class="token number">186</span>
 David │ B     │    <span class="token number">178</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>いかがでしょうか？<a href="https://hakibenita.com/the-many-faces-of-distinct-in-postgre-sql#distinct-on">最初にDISTINCT ONを発見した</a>ときは、とても感動しました。Oracleから来たものですが、他に同じような機能はなく、筆者が知る限りでは、PostgreSQL以外のデータベースに同様の機能はありません。</p>
<p>DISTINCT ONを<strong>直感的に理解する</strong></p>
<p>DISTINCT ONの仕組みを理解するために、その挙動について順を追って見ていきましょう。以下がテーブル上の生データです。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> students<span class="token punctuation">;</span>

  <span class="token keyword">name</span>  │ class │ height
────────┼───────┼────────
 Haki   │ A     │    <span class="token number">186</span>
 Dan    │ A     │    <span class="token number">175</span>
 Jax    │ A     │    <span class="token number">182</span>
 George │ B     │    <span class="token number">178</span>
 Bill   │ B     │    <span class="token number">167</span>
 David  │ B     │    <span class="token number">178</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>次に、データを並べ替えます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> students
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> class<span class="token punctuation">,</span> height <span class="token keyword">DESC</span><span class="token punctuation">,</span> <span class="token keyword">name</span><span class="token punctuation">;</span>

  <span class="token keyword">name</span>  │ class │ height
────────┼───────┼────────
 Haki   │ A     │    <span class="token number">186</span>
 Jax    │ A     │    <span class="token number">182</span>
 Dan    │ A     │    <span class="token number">175</span>
 David  │ B     │    <span class="token number">178</span>
 George │ B     │    <span class="token number">178</span>
 Bill   │ B     │    <span class="token number">167</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>DISTINCT ON句を追加します。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">ON</span> <span class="token punctuation">(</span>class<span class="token punctuation">)</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> students
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> class<span class="token punctuation">,</span> height <span class="token keyword">DESC</span><span class="token punctuation">,</span> <span class="token keyword">name</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>DISTINCT ONがこの時点で何をするかを理解するには、2つのステップを経なくてはいけません。</p>
<p>まず、DISTINCT ON句の中の列（この場合はclass）をもとに、データをグループに分けます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">  <span class="token keyword">name</span>  │ class │ height
─────────────────────────
 Haki   │ A     │    <span class="token number">186</span>  ┓
 Jax    │ A     │    <span class="token number">182</span>  ┣━━ class<span class="token operator">=</span>A
 Dan    │ A     │    <span class="token number">175</span>  ┛

 David  │ B     │    <span class="token number">178</span>  ┓
 George │ B     │    <span class="token number">178</span>  ┣━━ class<span class="token operator">=</span>B
 Bill   │ B     │    <span class="token number">167</span>  ┛</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>次に、各グループの1行目だけを残します。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"> <span class="token keyword">name</span>  │ class │ height
─────────────────────────
 Haki   │ A     │    <span class="token number">186</span>  ┣━━ class<span class="token operator">=</span>A
 David  │ B     │    <span class="token number">178</span>  ┣━━ class<span class="token operator">=</span>B</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>これで終わりです。各クラスで一番背の高い生徒が得られました。</p>
<p>DISTINCT ONを使う上での唯一の要件は、ORDER BY句の先行列がDISTINCT ON句の列と一致することです。ORDER BY句の残りの列は、各グループのどの行を選択するかを判断するために使用します。</p>
<p>ORDER BYが結果にどう影響するかを理解するには、各クラスで一番背の低い生徒を特定する次のクエリを検討してください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token keyword">ON</span> <span class="token punctuation">(</span>class<span class="token punctuation">)</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    students
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>
    class<span class="token punctuation">,</span> height<span class="token punctuation">,</span> <span class="token keyword">name</span><span class="token punctuation">;</span>

 <span class="token keyword">name</span> │ class │ height
──────┼───────┼────────
 Dan  │ A     │    <span class="token number">175</span>
 Bill │ B     │    <span class="token number">167</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>各クラスで一番背の低い生徒を選ぶには、各グループの1行目が一番背の低い生徒になるよう並び順を変えるだけでいいのです。</p>
<hr>
<h2>拡張機能なしでUUIDを生成する <a name="14"></a></h2>
<p>PostgreSQLのバージョン13より前では、おそらく<a href="https://www.postgresql.org/docs/current/uuid-ossp.html#id-1.11.7.53.5">拡張機能uuid-ossp</a>を使用してUUIDを生成していたのではないでしょうか。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> EXTENSION <span class="token string">"uuid-ossp"</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> EXTENSION

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> uuid_generate_v4<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> uuid<span class="token punctuation">;</span>
                 uuid
──────────────────────────────────────
 <span class="token number">8</span>e55146d<span class="token operator">-</span><span class="token number">0</span>ce5<span class="token operator">-</span><span class="token number">40</span>ab<span class="token operator">-</span>a346<span class="token operator">-</span><span class="token number">5</span>dbd466ff5f2</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>バージョン13以降、<a href="https://www.postgresql.org/docs/current/functions-uuid.html">ランダムなUUID（バージョン4）を生成するための関数</a>が組み込まれています。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> gen_random_uuid<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> uuid<span class="token punctuation">;</span>
                 uuid
──────────────────────────────────────
 ba1ac0f5<span class="token operator">-</span><span class="token number">5</span>d4d<span class="token operator">-</span><span class="token number">4</span>d80<span class="token operator">-</span><span class="token number">974</span>d<span class="token operator">-</span><span class="token number">521</span>dbdcca2b2</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>拡張機能uuid-osspは、バージョン4以外のUUIDを生成したい場合はまだ必要です。</p>
<hr>
<h2>再現可能なランダムデータの生成 <a name="15"></a></h2>
<p>ランダムデータの生成は、デモやテストなどさまざまな場面で非常に役立ちます。いずれの場合も、「ランダム」データを再現できると有用です。</p>
<p>PostgreSQLのrandom関数を使用することで、<a href="https://hakibenita.com/sql-for-data-analysis#random">さまざまなタイプのランダムデータを生成</a>できます。以下の例をご覧ください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span>
    random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_float<span class="token punctuation">,</span>
    ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_int_0_10<span class="token punctuation">,</span>
    <span class="token string">'2022-01-01'</span>::<span class="token keyword">date</span> <span class="token operator">+</span> <span class="token keyword">interval</span> <span class="token string">'1 days'</span> <span class="token operator">*</span> ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_day_in_2022<span class="token punctuation">;</span>

─<span class="token punctuation">[</span> <span class="token keyword">RECORD</span> <span class="token number">1</span> <span class="token punctuation">]</span>──────┬────────────────────
random_float       │ <span class="token number">0.6031888056092001</span>
random_int_0_10    │ <span class="token number">3</span>
random_day_in_2022 │ <span class="token number">2022</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">10</span> <span class="token number">00</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このクエリを再度実行すると、異なる結果が得られます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span>
    random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_float<span class="token punctuation">,</span>
    ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_int_0_10<span class="token punctuation">,</span>
    <span class="token string">'2022-01-01'</span>::<span class="token keyword">date</span> <span class="token operator">+</span> <span class="token keyword">interval</span> <span class="token string">'1 days'</span> <span class="token operator">*</span> ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_day_in_2022<span class="token punctuation">;</span>

─<span class="token punctuation">[</span> <span class="token keyword">RECORD</span> <span class="token number">1</span> <span class="token punctuation">]</span>──────┬────────────────────
random_float       │ <span class="token number">0.7363406030115378</span>
random_int_0_10    │ <span class="token number">2</span>
random_day_in_2022 │ <span class="token number">2022</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">23</span> <span class="token number">00</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>再現可能なランダムデータを生成するには、<a href="https://www.postgresql.org/docs/current/functions-math.html#FUNCTIONS-MATH-RANDOM-TABLE">setseed</a>を使用できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> setseed<span class="token punctuation">(</span><span class="token number">0.4050</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 setseed
─────────

<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span>
    random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_float<span class="token punctuation">,</span>
    ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_int_0_10<span class="token punctuation">,</span>
    <span class="token string">'2022-01-01'</span>::<span class="token keyword">date</span> <span class="token operator">+</span> <span class="token keyword">interval</span> <span class="token string">'1 days'</span> <span class="token operator">*</span> ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_day_in_2022
<span class="token keyword">FROM</span>
    generate_series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    random_float    │ random_int_0_10 │ random_day_in_2022
────────────────────┼─────────────────┼─────────────────────
 <span class="token number">0.1924247516794324</span> │               <span class="token number">9</span> │ <span class="token number">2022</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">17</span> <span class="token number">00</span>:<span class="token number">00</span>:<span class="token number">00</span>
 <span class="token number">0.9720620908236377</span> │               <span class="token number">5</span> │ <span class="token number">2022</span><span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span><span class="token number">13</span> <span class="token number">00</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>新しいセッションで再び同じブロックを実行すると、異なるデータベースであっても全く同じ結果が得られます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">otherdb<span class="token operator">=</span># <span class="token keyword">SELECT</span> setseed<span class="token punctuation">(</span><span class="token number">0.4050</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 setseed
─────────

<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span>

otherdb<span class="token operator">=</span># <span class="token keyword">SELECT</span>
    random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_float<span class="token punctuation">,</span>
    ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_int_0_10<span class="token punctuation">,</span>
    <span class="token string">'2022-01-01'</span>::<span class="token keyword">date</span> <span class="token operator">+</span> <span class="token keyword">interval</span> <span class="token string">'1 days'</span> <span class="token operator">*</span> ceil<span class="token punctuation">(</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">365</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> random_day_in_2022
<span class="token keyword">FROM</span>
    generate_series<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    random_float    │ random_int_0_10 │ random_day_in_2022
────────────────────┼─────────────────┼─────────────────────
 <span class="token number">0.1924247516794324</span> │               <span class="token number">9</span> │ <span class="token number">2022</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">17</span> <span class="token number">00</span>:<span class="token number">00</span>:<span class="token number">00</span>
 <span class="token number">0.9720620908236377</span> │               <span class="token number">5</span> │ <span class="token number">2022</span><span class="token operator">-</span><span class="token number">06</span><span class="token operator">-</span><span class="token number">13</span> <span class="token number">00</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>結果はランダムであるものの、全く同じであることに注目してください。次にデモを行ったり、スクリプトを共有したりする場合、結果を簡単に再現できるようsetseedを使用してみてください。</p>
<hr>
<h2>直ちに検証することなく制約を追加する <a name="16"></a></h2>
<p>制約はRDBMSに不可欠な要素です。制約はデータをクリーンで信頼できる状態に保つため、なるべく使用することが望まれます。本番稼働中のシステムでは、新たな制約を追加しなくてはならないことがしばしばありますが、制約の種類によっては、システムの動作を妨げる非常に制限の厳しいロックが必要になることもあります。</p>
<p>例として、大規模なテーブルに単純なチェック制約を追加してみてください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orders <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> check_price_gt_zero <span class="token keyword">CHECK</span> <span class="token punctuation">(</span>price <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span>
<span class="token keyword">Time</span>: <span class="token number">10745.662</span> ms <span class="token punctuation">(</span><span class="token number">00</span>:<span class="token number">10.746</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>この文は、注文の価格が0以上になるようチェック制約を追加します。制約を追加する際、データベースがテーブル全体をスキャンし、制約が既存のすべての行に対して有効であることを確認しました。このプロセスには約10秒かかり、その間テーブルはロックされました。</p>
<p><strong>PostgreSQLでは、制約を追加するプロセスを2つのステップに分けることができます。</strong></p>
<p>まず、制約を追加して新しいデータのみを検証し、既存のデータについては有効かどうかをチェックしません。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orders <span class="token keyword">ADD</span> <span class="token keyword">CONSTRAINT</span> check_price_gt_zero <span class="token keyword">CHECK</span> <span class="token punctuation">(</span>price <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> VALID<span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span>
<span class="token keyword">Time</span>: <span class="token number">13.590</span> ms</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>最後のNOT VALIDは、既存の行について新しい制約の検証を行わないようPostgreSQLに指示するものです。これは、データベースがテーブル全体をスキャンする必要がないことを意味します。この文が前の文に比べて所要時間が大幅に短く、ほぼ瞬時に処理されたことに注目してください。</p>
<p>次に、既存のデータについて、はるかに制限が緩く、テーブル上の他の演算を許容するロックを使用し、制約を検証します。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> orders <span class="token keyword">VALIDATE</span> <span class="token keyword">CONSTRAINT</span> check_price_gt_zero<span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span>
<span class="token keyword">Time</span>: <span class="token number">11231.189</span> ms <span class="token punctuation">(</span><span class="token number">00</span>:<span class="token number">11.231</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>制約の検証に要した時間が、制約の追加と検証を行った最初の例とおおむね同じであることにお気づきでしょうか。これは、既存のテーブルに制約を追加する際、ほとんどの時間が既存の行の検証に費やされていることを再確認させるものです。プロセスを2つのステップに分けることで、テーブルがロックされている時間を短縮できます。</p>
<p>ドキュメントは、<a href="https://www.postgresql.org/docs/current/sql-altertable.html#SQL-ALTERTABLE-NOTES">NOT VALIDの別のユースケース</a>についても言及しています。それは、たとえ好ましくない値があったとしても、将来のアップデートに対してのみ制約を適用するというものです。つまり、NOT VALIDを追加し、VALIDATEは行わないということです。</p>
<p>Paypalのエンジニアリングチームが<a href="https://medium.com/paypal-tech/postgresql-at-scale-database-schema-changes-without-downtime-20d3749ed680">ダウンタイムなしでスキーマに変更を加える</a>方法について素晴らしい記事を執筆しています。<a href="https://hakibenita.com/sql-tricks-application-dba#disable-constraints-and-indexes-during-bulk-loads">バルクロードを行う際に制約とインデックスを無効化する</a>ことを提案した筆者の記事も併せてご覧ください。</p>
<hr>
<h2>PostgreSQLにおけるシノニム <a name="17"></a></h2>
<p>シノニム（同義語）は、オブジェクトを別の名前で参照する手段を提供するもので、Linuxのシンボリックリンクと似ています。Oracleの使用経験がある方はシノニムになじみがあるかと思われますが、そうでなければ聞いたことがないかもしれません。PostgreSQLには「シノニム」という名前の機能はありませんが、同様のことができないわけではありません。</p>
<p>特定の名前に別のデータベースオブジェクトを参照させるには、まず、PostgreSQLが条件を持たない名前をどのように解決するのか理解する必要があります。例えば、ユーザhakiとしてデータベースに接続し、テーブルfooを参照した場合、PostgreSQLは以下のオブジェクトを、以下の順序で検索します。</p>
<ol>
<li>haki.foo</li>
<li>public.foo</li>
</ol>
<p>この順序は<a href="https://www.postgresql.org/docs/current/ddl-schemas.html#DDL-SCHEMAS-PATH">search_pathパラメータ</a>によって決まります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SHOW</span> search_path<span class="token punctuation">;</span>
   search_path
─────────────────
 <span class="token string">"$user"</span><span class="token punctuation">,</span> <span class="token keyword">public</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>最初の値"$user"は特殊な値であり、現在接続しているユーザの名前に解決されます。2つ目の値publicはデフォルトスキーマの名前です。</p>
<p>サーチパスに関してできることを実証するため、データベースdbにテーブルfooを作成してみてください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> foo <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token keyword">TEXT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>

db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> foo <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> foo<span class="token punctuation">;</span>
 <span class="token keyword">value</span>
───────
 A
<span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">row</span><span class="token punctuation">)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>何らかの理由により、ユーザhakiがfooという名前を参照した際に異なるオブジェクトを表示させたい場合、2つの選択肢があります。</p>
<p><strong>1. hakiという名前のスキーマにfooという名前のオブジェクトを作成する。</strong></p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> haki<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span>

db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> haki<span class="token punctuation">.</span>foo <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token keyword">text</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>

db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> haki<span class="token punctuation">.</span>foo <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>

db<span class="token operator">=</span># \conninfo
You are connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"haki"</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> foo<span class="token punctuation">;</span>
<span class="token keyword">value</span>
───────
B</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ユーザhakiがfooという名前を参照すると、PostgreSQLがpublic.fooではなくhaki.fooに名前を解決することに注目してください。これは、サーチパス上でスキーマhakiがpublicよりも前に来るためです。</p>
<p><strong>2.サーチパスのアップデート。</strong></p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> synonyms<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span>

db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> synonyms<span class="token punctuation">.</span>foo <span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token keyword">text</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>

db<span class="token operator">=</span># <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> synonyms<span class="token punctuation">.</span>foo <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token number">0</span> <span class="token number">1</span>

db<span class="token operator">=</span># <span class="token keyword">SHOW</span> search_path<span class="token punctuation">;</span>
   search_path
─────────────────
 <span class="token string">"$user"</span><span class="token punctuation">,</span> <span class="token keyword">public</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> foo<span class="token punctuation">;</span>
 <span class="token keyword">value</span>
───────
 A

db<span class="token operator">=</span># <span class="token keyword">SET</span> search_path <span class="token keyword">TO</span> synonyms<span class="token punctuation">,</span> <span class="token string">"$user"</span><span class="token punctuation">,</span> <span class="token keyword">public</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> foo<span class="token punctuation">;</span>
 <span class="token keyword">value</span>
───────
 C</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>サーチパスにスキーマsynonymsが含まれるよう変更を加えると、PostgreSQLがfooという名前をsynonyms.fooに解決するようになります。</p>
<p><strong>シノニムはなぜ有用か？</strong></p>
<p>筆者は以前、シノニムは避けるべきコードの臭いだと考えていましたが、その後シノニムが有用なユースケースをいくつか発見しました。その1つは、ゼロダウンタイムの移行です。</p>
<p>本番稼働中のシステムのテーブルに変更を加える際、アプリケーションの新旧バージョン両方を同時にサポートしなくてはならないことが多々あります。これは、アプリケーションの各バージョンが想定するテーブル構造が異なるため、困難を伴います。</p>
<p>テーブルから特定の列を削除する移行を例に検討してみましょう。移行が実行されている間、アプリケーションの古いバージョンは稼働しており、テーブルにその列があることを想定しているため、単純に削除することはできません。この問題に対処する1つの方法として、新しいバージョンを2段階に分けてリリースできます。1つ目のリリースではその列を無視し、2つ目のリリースで削除するのです。</p>
<p>ただし、1回のリリースで変更を行う必要がある場合、その列を含むテーブルのビューを古いバージョンに提供してから削除できます。これには「シノニム」を使用できます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \conninfo
You are now connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"app"</span><span class="token punctuation">.</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>
 username │ active
──────────┼────────
 haki     │ t</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>アプリケーションは、ユーザappとしてデータベースdbに接続しています。active列を削除したいのですが、アプリケーションがこの列を使用しています。移行を無事完了するためには、古いバージョンが稼働している間、その列がまだそこにあるとユーザappに思わせる必要があります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \conninfo
You are now connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"admin"</span><span class="token punctuation">.</span>

db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> app<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span>

db<span class="token operator">=</span># <span class="token keyword">GRANT</span> <span class="token keyword">USAGE</span> <span class="token keyword">ON</span> <span class="token keyword">SCHEMA</span> app <span class="token keyword">TO</span> app<span class="token punctuation">;</span>
<span class="token keyword">GRANT</span>

db<span class="token operator">=</span># <span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> app<span class="token punctuation">.</span>users <span class="token keyword">AS</span> <span class="token keyword">SELECT</span> username<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token keyword">AS</span> active <span class="token keyword">FROM</span> <span class="token keyword">public</span><span class="token punctuation">.</span>users<span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span>

db<span class="token operator">=</span># <span class="token keyword">GRANT</span> <span class="token keyword">SELECT</span> <span class="token keyword">ON</span> app<span class="token punctuation">.</span>users <span class="token keyword">TO</span> app<span class="token punctuation">;</span>
<span class="token keyword">GRANT</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ユーザappを「騙す」ために、ユーザの名前を用いたスキーマと、計算済みフィールドactiveを持つビューを作成しました。アプリケーションがユーザappとして接続しているとき、テーブルではなくそのビューが見えるため、列を削除しても問題ありません。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># \conninfo
You are now connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"admin"</span><span class="token punctuation">.</span>

db<span class="token operator">=</span># <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> users <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> active<span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span>

db<span class="token operator">=</span># \<span class="token keyword">connect</span> db app
You are now connected <span class="token keyword">to</span> <span class="token keyword">database</span> <span class="token string">"db"</span> <span class="token keyword">as</span> <span class="token keyword">user</span> <span class="token string">"app"</span><span class="token punctuation">.</span>

db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users<span class="token punctuation">;</span>
 username │ active
──────────┼────────
 haki     │ t</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>列を削除すると、アプリケーションは代わりに計算済みフィールドを参照します。後は少しクリーンアップを行って終了です。</p>
<hr>
<h2>重複レンジを探す <a name="18"></a></h2>
<p>以下のような会議テーブルがあるとします。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">db<span class="token operator">=</span># <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> meetings<span class="token punctuation">;</span>
       starts_at     │        ends_at
─────────────────────┼─────────────────────
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">10</span>:<span class="token number">00</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">10</span>:<span class="token number">30</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">30</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">45</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<details>
<summary>⚙テーブルデータ</summary>
<p>以下のCTEを使用して、このセクションのクエリーを再現することができます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">WITH</span> meetings <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span>
        starts_at::timestamptz <span class="token keyword">AS</span> starts_at<span class="token punctuation">,</span>
        ends_at::timestamptz <span class="token keyword">AS</span> ends_at
    <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'2021-10-01 10:00 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 10:30 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'2021-10-01 11:15 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:00 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'2021-10-01 12:30 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:45 UTC'</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">AS</span> t<span class="token punctuation">(</span>
        starts_at<span class="token punctuation">,</span>               ends_at<span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> meetings<span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
</details>
<p>新しい会議の予定を入れたいのですが、その前に、他の会議と重ならないことを確認する必要があります。いくつか検討すべきシナリオがあります。</p>
<ul>
<li>[A] 新しい会議は既存の会議が開始した後終了する。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token operator">|</span><span class="token comment">-------NEW MEETING--------|</span>
    <span class="token operator">|</span><span class="token comment">--------*EXISTING MEETING--------*|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<ul>
<li>[B] 新しい会議は既存の会議が終わる前に開始する。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">        <span class="token operator">|</span><span class="token comment">-------NEW MEETING--------|</span>
<span class="token operator">|</span><span class="token comment">--------*EXISTING MEETING--------*|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<ul>
<li>[C] 新しい会議は既存の会議が実施されている間に行われる。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">   <span class="token operator">|</span><span class="token comment">----NEW MEETING----|</span>
<span class="token operator">|</span><span class="token comment">--------*EXISTING MEETING--------*|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<ul>
<li>[D] 既存の会議は新しい会議が予定されている時間内に行われる。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token operator">|</span><span class="token comment">--------NEW MEETING--------|</span>
    <span class="token operator">|</span><span class="token operator">*</span><span class="token operator">*</span>EXISTING MEETING<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<ul>
<li>[E] 新しい会議は既存の会議と全く同じ時間に予定されている。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token operator">|</span><span class="token comment">--------NEW MEETING--------|</span>
<span class="token operator">|</span><span class="token comment">----**EXISTING MEETING--------|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>重複の有無をチェックするクエリをテストするため、上記のシナリオがすべて含まれるテーブルを作成し、以下の簡単な条件式を試してみてください。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">WITH</span> new_meetings <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span>
        id<span class="token punctuation">,</span>
        starts_at::timestamptz <span class="token keyword">as</span> starts_at<span class="token punctuation">,</span>
        ends_at::timestamptz <span class="token keyword">as</span> ends_at
    <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:10 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:55 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:20 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:05 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:20 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:55 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:10 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:05 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:15 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:00 UTC'</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">(</span>
        id<span class="token punctuation">,</span>   starts_at<span class="token punctuation">,</span>               ends_at
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    meetings<span class="token punctuation">,</span> new_meetings
<span class="token keyword">WHERE</span>
    new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">BETWEEN</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> meetings<span class="token punctuation">.</span>ends_at
    <span class="token operator">OR</span> new_meetings<span class="token punctuation">.</span>ends_at <span class="token operator">BETWEEN</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">;</span>

       starts_at     │        ends_at      │ id │       starts_at     │        ends_at
─────────────────────┼─────────────────────┼────┼─────────────────────┼────────────────────
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ A  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ B  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ C  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ E  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>最初の試みでは、5 つのシナリオのうち 4 つのシナリオで重複を発見しました
。シナリオDでは、新しい会議が既存の会議の前に始まり、後に終わる場合、重複を検出しませんでした。このシナリオも処理するためには、条件をもう少し長くする必要があります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">WITH</span> new_meetings <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
<span class="token keyword">SELECT</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    meetings<span class="token punctuation">,</span> new_meetings
<span class="token keyword">WHERE</span>
    new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">BETWEEN</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> meetings<span class="token punctuation">.</span>ends_at
    <span class="token operator">OR</span> new_meetings<span class="token punctuation">.</span>ends_at <span class="token operator">BETWEEN</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> meetings<span class="token punctuation">.</span>ends_at
    <span class="token operator">OR</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">BETWEEN</span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> new_meetings<span class="token punctuation">.</span>ends_at
    <span class="token operator">OR</span> meetings<span class="token punctuation">.</span>ends_at <span class="token operator">BETWEEN</span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> new_meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">;</span>


       starts_at     │        ends_at      │ id │       starts_at     │        ends_at
─────────────────────┼─────────────────────┼────┼─────────────────────┼────────────────────
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ A  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ B  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ C  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ D  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ E  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このクエリは5つすべてのシナリオで重複を検出しますが、以下の追加シナリオを検討してください。</p>
<ul>
<li>[F] 新しい会議は既存の会議の直後に予定されている。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql">                            <span class="token operator">|</span><span class="token comment">--------NEW MEETING--------|</span>
<span class="token operator">|</span><span class="token comment">----**EXISTING MEETING--------|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<ul>
<li>[G] 新しい会議は既存の会議の開始直後に終了する予定になっている。</li>
</ul>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token operator">|</span><span class="token comment">--------NEW MEETING--------|</span>
                            <span class="token operator">|</span><span class="token comment">----**EXISTING MEETING--------|</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p>会議が連続するのはよくあることですが、これらについては重複と認識されるべきではありません。2つのシナリオをテストに追加し、クエリを実行してみます。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">WITH</span> new_meetings <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span>
        id<span class="token punctuation">,</span>
        starts_at::timestamptz <span class="token keyword">as</span> starts_at<span class="token punctuation">,</span>
        ends_at::timestamptz <span class="token keyword">as</span> ends_at
    <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:10 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:55 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:20 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:05 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:20 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:55 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:10 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:05 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:15 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:00 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:00 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:10 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:00 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:15 UTC'</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">(</span>
        id<span class="token punctuation">,</span>   starts_at<span class="token punctuation">,</span>               ends_at
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    meetings<span class="token punctuation">,</span> new_meetings
<span class="token keyword">WHERE</span>
    new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">BETWEEN</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> meetings<span class="token punctuation">.</span>ends_at
    <span class="token operator">OR</span> new_meetings<span class="token punctuation">.</span>ends_at <span class="token operator">BETWEEN</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> meetings<span class="token punctuation">.</span>ends_at
    <span class="token operator">OR</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">BETWEEN</span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> new_meetings<span class="token punctuation">.</span>ends_at
    <span class="token operator">OR</span> meetings<span class="token punctuation">.</span>ends_at <span class="token operator">BETWEEN</span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">and</span> new_meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">;</span>

       starts_at     │        ends_at      │ id │       starts_at     │        ends_at
─────────────────────┼─────────────────────┼────┼─────────────────────┼────────────────────
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ A  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ B  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ C  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ D  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ E  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ F  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">10</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ G  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">00</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>2つの会議が連続するシナリオFとGは、誤って重複に分類されています。これは、<a href="https://hakibenita.com/sql-dos-and-donts#use-between-only-for-inclusive-ranges">演算子BETWEENがその前後を含む</a>ためです。BETWEENを使用せずにこの条件式を実行するには、以下のようにする必要があります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">WITH</span> new_meetings <span class="token keyword">AS</span> <span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span>
<span class="token keyword">SELECT</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    meetings<span class="token punctuation">,</span> new_meetings
<span class="token keyword">WHERE</span>
    <span class="token punctuation">(</span>new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">></span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">AND</span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">&lt;</span> meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">)</span>
    <span class="token operator">OR</span>
    <span class="token punctuation">(</span>new_meetings<span class="token punctuation">.</span>ends_at <span class="token operator">></span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">AND</span> new_meetings<span class="token punctuation">.</span>ends_at <span class="token operator">&lt;</span> meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">)</span>
    <span class="token operator">OR</span>
    <span class="token punctuation">(</span>meetings<span class="token punctuation">.</span>starts_at <span class="token operator">></span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">AND</span> meetings<span class="token punctuation">.</span>starts_at <span class="token operator">&lt;</span> new_meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">)</span>
    <span class="token operator">OR</span>
    <span class="token punctuation">(</span>meetings<span class="token punctuation">.</span>ends_at <span class="token operator">></span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">AND</span> meetings<span class="token punctuation">.</span>ends_at <span class="token operator">&lt;</span> new_meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">)</span>
    <span class="token operator">OR</span>
    <span class="token punctuation">(</span>meetings<span class="token punctuation">.</span>starts_at <span class="token operator">=</span> new_meetings<span class="token punctuation">.</span>starts_at <span class="token operator">AND</span> meetings<span class="token punctuation">.</span>ends_at <span class="token operator">=</span> new_meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">)</span><span class="token punctuation">;</span>

       starts_at     │        ends_at      │ id │       starts_at     │        ends_at
─────────────────────┼─────────────────────┼────┼─────────────────────┼────────────────────
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ A  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ B  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ C  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ D  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ E  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>クエリはシナリオA～Eを重複として正しく認識し、会議が連続するシナリオFとGは重複とは認識しません。求めていた結果はこれです。しかし、この条件式はあまりにも複雑です。容易に手に負えなくなってしまうでしょう。</p>
<p>そこで、PostgreSQLの以下の演算子が極めて有益となります。</p>
<div class="gatsby-highlight" data-language="plsql"><pre style="counter-reset: linenumber NaN" class="language-plsql line-numbers"><code class="language-plsql"><span class="token keyword">WITH</span> new_meetings <span class="token keyword">AS</span> <span class="token punctuation">(</span>
    <span class="token keyword">SELECT</span>
        id<span class="token punctuation">,</span>
        starts_at::timestamptz <span class="token keyword">as</span> starts_at<span class="token punctuation">,</span>
        ends_at::timestamptz <span class="token keyword">as</span> ends_at
    <span class="token keyword">FROM</span> <span class="token punctuation">(</span><span class="token keyword">VALUES</span>
        <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:10 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:55 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:20 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:05 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:20 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:55 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:10 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:05 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:15 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:00 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:00 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 12:10 UTC'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">'G'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:00 UTC'</span><span class="token punctuation">,</span> <span class="token string">'2021-10-01 11:15 UTC'</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token keyword">as</span> t<span class="token punctuation">(</span>
        id<span class="token punctuation">,</span>   starts_at<span class="token punctuation">,</span>               ends_at
    <span class="token punctuation">)</span>
<span class="token punctuation">)</span>
<span class="token keyword">SELECT</span>
    <span class="token operator">*</span>
<span class="token keyword">FROM</span>
    meetings<span class="token punctuation">,</span> new_meetings
<span class="token keyword">WHERE</span>
    <span class="token punctuation">(</span>new_meetings<span class="token punctuation">.</span>starts_at<span class="token punctuation">,</span> new_meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">)</span>
        <span class="token keyword">OVERLAPS</span> <span class="token punctuation">(</span>meetings<span class="token punctuation">.</span>starts_at<span class="token punctuation">,</span> meetings<span class="token punctuation">.</span>ends_at<span class="token punctuation">)</span><span class="token punctuation">;</span>

       starts_at     │        ends_at      │ id │       starts_at     │        ends_at
─────────────────────┼─────────────────────┼────┼─────────────────────┼────────────────────
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ A  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ B  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ C  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">20</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">55</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ D  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">10</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">05</span>:<span class="token number">00</span>
 <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span> │ E  │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">11</span>:<span class="token number">15</span>:<span class="token number">00</span> │ <span class="token number">2021</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">-</span><span class="token number">01</span> <span class="token number">12</span>:<span class="token number">00</span>:<span class="token number">00</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>これです！<a href="https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-TABLE">OVERLAPS演算子</a>を使用することで、5つの複雑な条件式が不要になり、クエリは短く単純で、読みやすく、分かりやすくなりました。</p>
<hr>
<p><em>改訂履歴</em></p>
<ul>
<li>2021年11月9日：<a href="https://www.reddit.com/r/programming/comments/qpj4cy/comment/hjwwqgi/?utm_source=share&#x26;utm_medium=web2x&#x26;context=3">Redditのコメント投稿者</a>が、「大文字の予約語の自動補完」のセクションでpsqlパラメータの名前の誤りを見つけてくれました。COMP<em>KEYWORD</em>UPPERをCOMP<em>KEYWORD</em>CASEに修正しました。</li>
<li>2021年11月9日：pg<em>sleepの例は、記事の中で以前述べていたように4分ではなく4時間（14400秒）のスリープでした。pg</em>sleep_forによる時間間隔を用いるメリットをより明確に伝えるため、例に変更を加えました。</li>
</ul>]]></content:encoded></item><item><title><![CDATA[Web開発者の悩みの種ランキング（2021年版）]]></title><description><![CDATA[私は先日、開発者が何を最も大きな課題に挙げているかを知ることで、開発者コミュニティのニーズを理解できるという記事を書きました。 元々の投稿はMDN Developer Needs Assessmen…]]></description><link>https://postd.cc/top-web-developer-pain-points-in-2021/</link><guid isPermaLink="false">https://postd.cc/top-web-developer-pain-points-in-2021/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[まとめ]]></category><category><![CDATA[Web開発]]></category><pubDate>Tue, 15 Mar 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>私は先日、開発者が何を<a href="https://paul.kinlan.me/thinking-about-developer-satisfaction-and-web-developers/">最も大きな課題</a>に挙げているかを知ることで、開発者コミュニティのニーズを理解できるという記事を書きました。</p>
<p>元々の投稿は<a href="https://insights.developer.mozilla.org/">MDN Developer Needs Assessment</a>（2019年）の結果を要約したものでしたが、不運なことに、この調査は2020年に中止されました。この調査情報は、Webプラットフォーム全体の方向性を定めるのに役立つ点で、私たちのチームにとって重要だったため、調査の中止は残念なことです。</p>
<p>調査を実施していたMozillaの代わりとして、私はチームのために、開発者の大まかなニーズを把握する調査を企画しました。</p>
<p>3カ月ごとに、米国、英国、インドのWeb開発者やWeb開発における意思決定者約700人をランダムにサンプリングして実施し、過去に実施したすべての調査とデータを比較して、トレンドに変化があるかを見ていきます。</p>
<p>注意すべきなのは、MDN Surveyと私たちの調査は違うということです。両者調査の回答者は異なっており、質問内容も（可能な限り似せようとしましたが）微妙に違います。回答者の人数も違うため、Max-Diff法を使用せずに、問題だと思っていること上位3つを選択する形式です。そのため、回答の優先順位をどのように付けるべきかという疑問が生じますが、結果を詳しく見てみると、結論に大差はありません。</p>
<p>2020年の調査では、開発者がフラストレーションを感じる主な点として、以下が挙げられました。</p>
<blockquote>
<ol>
<li>ブラウザの互換性 – <a href="https://paul.kinlan.me/the-lumpy-web/">Webは「でこぼこ」している、</a>もっと滑らかであるべきだ。Chromeは幅広いWebプラットフォームとの互換性を確保し続けるべき。Chromeはすべてのブラウザベンダーと協力して互換性を支援すべき。ChromeはWebブラウザがChromeのみにならないように手助けすべき。</li>
<li>テスト – すべてのブラウザでサイトのエンドツーエンドテストを簡単に実施できるようにすべきだ。現在はテストを実施するのが難しすぎる。</li>
<li>ドキュメント – 最適かつ最新の参照資料や、筆者の意見が記された検証済みのベストプラクティスガイダンスを、開発者が簡単に見つけられるようにすべきだ。</li>
<li>デバッグ – 開発者はデバッグを失敗と捉えている。直面している問題について、開発者が理解し、可能な限り速やかに解決できるように、あらゆるツールを利用できるようにすべきだ。</li>
<li>フレームワーク - 非常に多くの開発者がフレームワークを利用している事実から逃れることはできない。ブラウザベンダーとフレームワーク作者との強固な関係を確実に維持するには、また、開発者がこうしたツールの効果的な利用ノウハウを維持していくには、どうすればよいか？</li>
<li>プライバシーとセキュリティ – 有効競争によって生じるエコシステムの変化のみならず、非常に多くの法令が開発スピードを遅らせる要因となっている。こうした変化は開発者を悩ませ、私たちは人々の助けとなるガイダンスとツールを必要としている。</li>
</ol>
</blockquote>
<p>それでは、2021年はどうでしょうか？</p>
<p>（ドラムロール）</p>
<p>結果はほとんど変わりませんでした。測定方法が変わったため、一定の変化はありましたが、全体的な方向性は同じです。</p>
<p>トップ5は以下の通りです（パーセンテージは、その問題を上位3つに入れた開発者の割合を表します）。</p>
<table>
<thead>
<tr>
<th>課題</th>
<th>第1四半期</th>
<th>第2四半期</th>
<th>第3四半期</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebプラットフォームやWeb標準の変化についていく</td>
<td>27%</td>
<td>26%</td>
<td>27%</td>
</tr>
<tr>
<td>大量の新しい（および既存の）ツールやフレームワークについていく</td>
<td>26%</td>
<td>26%</td>
<td>25%</td>
</tr>
<tr>
<td>異なるブラウザでもデザインやユーザー体験が同一になるようにする</td>
<td>26%</td>
<td>28%</td>
<td>24%</td>
</tr>
<tr>
<td>複数のブラウザでテストを行う</td>
<td>23%</td>
<td>24%</td>
<td>20%</td>
</tr>
<tr>
<td>セキュリティ対策を理解し、実装する</td>
<td>23%</td>
<td>25%</td>
<td>20%</td>
</tr>
</tbody>
</table>
<p>各四半期の結果はほとんど同じです。</p>
<p>私にとって、このデータは、具体的に何を修正すべきかを教えてはくれませんが、どの分野の調査を深めればよいか分かる点で価値があります。</p>
<p>例えば、私は昨年、このデータの解釈として、「開発者にとって、プラットフォームレベルでも、ツールのエコシステムという点でも、変化やツールの数が多すぎる（両者は常に問題の上位に入っている）。この問題に対処する必要がある」と考えました。</p>
<p>上記のデータからは、開発者が利用するツールが、複数のブラウザにおけるテストや、ブラウザをまたぐ均一なユーザー体験を実現するには不十分であることも分かります。<a href="https://web.dev/compat2021/">Compat 2021</a>は、こうしたデータに基づいて私たちが構築したプログラムの1つであり、開発者はその成果に気づき始めていると言えるでしょう。しかし、このようなブラウザ間の互換性向上に関する取り組みが、開発者にとって有意義な変化をもたらしたかどうかを判断するには、まだ時期尚早であると考えられます。</p>
<h2>追記</h2>
<p>「Webサイトやアプリを開発するときに直面する最も大きな課題は何ですか？（3つ選択してください）」という質問に対する回答の結果全体。</p>
<table>
<thead>
<tr>
<th>課題</th>
<th>第1四半期 n=698</th>
<th>第2四半期 n=760</th>
<th>第3四半期 n=738</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebプラットフォームやWeb標準の変化についていく</td>
<td>27%</td>
<td>26%</td>
<td>27%</td>
</tr>
<tr>
<td>大量の新しい（および既存の）ツールやフレームワークについていく</td>
<td>26%</td>
<td>26%</td>
<td>25%</td>
</tr>
<tr>
<td>異なるブラウザでもデザインやユーザー体験が同一になるようにする</td>
<td>26%</td>
<td>28%</td>
<td>24%</td>
</tr>
<tr>
<td>複数のブラウザでテストを行う</td>
<td>23%</td>
<td>24%</td>
<td>20%</td>
</tr>
<tr>
<td>セキュリティ対策を理解し、実装する</td>
<td>23%</td>
<td>25%</td>
<td>20%</td>
</tr>
<tr>
<td>よく実施する小さなタスクが自動化されていない</td>
<td>15%</td>
<td>17%</td>
<td>18%</td>
</tr>
<tr>
<td>能力が不足しているため、望ましいユーザー体験を生み出すことができない</td>
<td>15%</td>
<td>13%</td>
<td>18%</td>
</tr>
<tr>
<td>最新のWebテクノロジーを活用するための知識が不足している</td>
<td>16%</td>
<td>16%</td>
<td>17%</td>
</tr>
<tr>
<td>既存のツールやフレームワークの使用法を理解する</td>
<td>16%</td>
<td>14%</td>
<td>17%</td>
</tr>
<tr>
<td>望ましいパフォーマンスを達成するのが困難/不可能</td>
<td>11%</td>
<td>12%</td>
<td>17%</td>
</tr>
<tr>
<td>組織内においてWebへの取り組みを優先させる</td>
<td>15%</td>
<td>16%</td>
<td>16%</td>
</tr>
<tr>
<td>古いブラウザをサポートする</td>
<td>21%</td>
<td>23%</td>
<td>16%</td>
</tr>
<tr>
<td>参照資料やドキュメントが不足している</td>
<td>14%</td>
<td>13%</td>
<td>15%</td>
</tr>
<tr>
<td>開発者向けのツールが不足している/乏しい</td>
<td>11%</td>
<td>14%</td>
<td>15%</td>
</tr>
<tr>
<td>望ましいUIを実現するのが困難/不可能</td>
<td>14%</td>
<td>13%</td>
<td>15%</td>
</tr>
<tr>
<td>上記のいずれでもない上記のいずれでもない</td>
<td>3%</td>
<td>1%</td>
<td>1%</td>
</tr>
</tbody>
</table>
<ul>
<li>「古いブラウザをサポートする」が大幅に低下しているのは興味深い点です。</li>
</ul>
<h3>筆者について：Paul Kinlan</h3>
<p>GoogleのChrome Developer Relationsチームでリーダーを務めています。
私たちは、ユーザーがネイティブアプリをインストールしたり、クローズドプラットフォームの中でコンテンツを制作したりしなくても、Web上で可能な限り最高の体験を享受できるようにしたいと考えています。</p>
<p>私たちのチームが目指すのは、開発者がWeb上での開発を進めやすくすることです。そのために、すべてのChromeのリリースをサポートし、<a href="https://web.dev/">web.dev</a>上で開発者を支援するための優れたコンテンツを生み出し、MDNに貢献しているほか、ブラウザの互換性や、特に優れた開発者向けツール（ほんの数例を挙げるとLighthouse、Workbox、Squooshなど）の改善を支援しています。</p>]]></content:encoded></item><item><title><![CDATA[Core Web VitalsはWebを高速化したか？]]></title><description><![CDATA[Core Web Vitals（CWV）は2020年5月に発表されました。Googleはこの発表の中で、「より良いWebのためにページエクスペリエンスを評価する」と述べています。特に重要なのは、この…]]></description><link>https://postd.cc/have-core-web-vitals-made-the-web-faster/</link><guid isPermaLink="false">https://postd.cc/have-core-web-vitals-made-the-web-faster/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[CWV]]></category><pubDate>Mon, 14 Feb 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<style>
  .image-text {
    margin-left: 1rem;
    margin-right: 1rem;
  }
  .image-text, .image-text ul li {
    font-size: 0.6rem;
  }
</style>
<p><a href="https://web.dev/vitals/">Core Web Vitals（CWV）</a>は2020年5月に発表されました。Googleはこの発表の中で、「<a href="https://developers.google.com/search/blog/2020/05/evaluating-page-experience">より良いWebのためにページエクスペリエンスを評価する</a>」と述べています。特に重要なのは、この評価がGoogleの検索順位アルゴリズムの一部を構成することでした。つまり、高速なWebサイトは、同等の遅いWebサイトよりも順位が上になり、Google検索によるトラフィック（ほとんどのWebサイトにとってWebトラフィックの最も大きな部分を占める）が増えます。</p>
<p>Webパフォーマンスコミュニティは、Webパフォーマンスのビジネス上のメリットを売り込むことに関して、常にSEO業界に劣っていました。Webパフォーマンスがビジネスのパフォーマンスに<a href="https://wpostats.com/">直接影響を及ぼす証拠</a>が数多く存在するにもかかわらずです。しかし、今やSEO業界全体がWebパフォーマンスを重視するようになり、企業もWebパフォーマンスについて真剣に考えなければならなくなったのです。</p>
<p>Googleは2020年11月に次の発表を行い、<a href="https://developers.google.com/search/blog/2020/11/timing-for-page-experience">2021年5月までにWebサイトをCore Web Vitalsに対応させる必要があるという明確な期限を定めました</a>（モバイルサイトの場合。<a href="https://developers.google.com/search/blog/2021/11/bringing-page-experience-to-desktop">デスクトップ向けサイトは1年後の予定</a>）。</p>
<p>そうして、Core Web Vitalsが検索順位に影響を与えるようになってから約半年が経ちました。実際に、何らかの影響はあったのでしょうか？GoogleがSEOという大きな力を振るったことで、Webは高速化したのでしょうか？</p>
<p>確かに影響はあったと示唆するサクセスストーリーは数多く存在します。しかし、筆者は「クリスマス嫌いのグリンチ」（※訳注：米国の童話の登場人物）のようにひねくれ者なので、あまり納得できずにいます。</p>
<h2>Core Web Vitalsに肯定的な証拠</h2>
<p>筆者は<a href="https://httparchive.org/">HTTP Archive</a>のメンテナンスに関わっています。このプロジェクトはWebの状態のトラッキングを目指すものです。HTTP Archiveは毎月Webのクローリングを実行し、発見したさまざまな事実や数値を報告することでトラッキングを行っています。このプロジェクトでは主に3つの方法でデータを提供しています。</p>
<ol>
<li>すべての基礎データを<a href="https://github.com/HTTPArchive/httparchive.org/blob/main/docs/gettingstarted_bigquery.md">BigQueryのデータセットとして公開しています</a>。SQLに関する多少の知識があればクエリを実行できます。</li>
<li><a href="https://httparchive.org/reports">Webサイト上でレポートとしてさまざまな統計を提供しています</a>。</li>
<li><a href="https://calendar.perfplanet.com/2021/have-core-web-vitals-made-the-web-faster/#:~:text=report%20called%20the-,Web%20Almanac,-which%20is%20a">Web Almanac</a>というレポートを毎年公開しています。このレポートは、業界の専門家がデータを詳細に分析し、そこから読み取れることを報告するものです（<a href="https://almanac.httparchive.org/en/2021/">2021年版</a>は最近発表されたばかりです。ぜひご覧ください）。</li>
</ol>
<p>また、HTTP Archiveは<a href="https://developers.google.com/web/tools/chrome-user-experience-report">Chrome User Experience Report（CrUX）</a>データセットとも連携し、より多くのデータについて報告するためにCrUXを活用しています。CrUXは、実際にWeb VitalsがどのようにGoogleに報告されるのかを明らかにするものです。そのレポートの1つは、特に2021年5月の期限以降において、Core Web Vitalsを達成したWebサイトが増加したことを明確に示しています。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image8.png"></p>
<div class="image-text">
画像内訳
<em>Core Web Vitals（LCP、FID、CLS）の３つの指標すべてで「良好」なエクスペリエンスを達成したオリジンの割合。オリジンのFIDのデータがない場合、残りの指標のパフォーマンスに基づいて評価。</em>
</div>
<p>さらに、他にも統計は公表されています（筆者自身も統計を公表している1人です）。多くの統計はHTTP Archiveのデータに基づいており、特に<a href="https://datastudio.google.com/u/0/reporting/55bc8fad-44c2-4280-aa0b-5f3f0cd3d2be/page/M6ZPC">Core Web Vitals Technology</a>レポートを活用しています。このレポートは、テクノロジーを通じてデータの詳細分析を行うためにHTTP Archiveが作成したものです。これらの統計はいずれも、とても前向きなストーリーを示しています。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image3.png"></p>
<div class="image-text">
画像内訳
<em>Webのパフォーマンスは改善しているか？答えはYES :) 今やオリジンの33%がCore Web Vitalsのしきい値を達成！フレームワークを利用しているサイトも大幅に改善</em>
<ul>
  <li><em>現在、全体で33%のオリジンがCore Web Vitalsの推奨しきい値を達成</em></li>
  <li><em>昨年以降、Core Web Vitalsのしきい値を達成したオリジンは26%増加</em></li>
</ul>
</div>
<p>このように、問題の答えは明らかになりました。このとても短いブログ記事は、タイトルで提示した疑問（Core Web VitalsはWebを高速化したか？）に回答したことになります。記事を読んでいただき、ありがとうございました！</p>
<h2>あまり楽観的ではない見方</h2>
<p>いやいや、ちょっと待ってください。最初のグラフはCore Web Vitalsを達成したWebサイトの数を表しています。これをWebが高速化しているかどうかを示す代理データとして使用するには、いくつかの前提が必要です。</p>
<ul>
<li>Core Web Vitalsを達成するためのしきい値は変化していない（実際もほとんど変化していない）。</li>
<li>測定対象のWebサイトは同一（CrUXは「広く知られているかどうか」（popularity threshold）を定めており、対象は毎月変わるが、全体としては概ね同一）。</li>
<li>改善の主な理由はCore Web Vitalsである（ネットワーク全般の速度が改善したことや、パンデミックによって多くの人が家にこもり、ブロードバンド接続を利用するようになったことなどが理由ではない）。</li>
<li>Core Web Vitalsの測定方法は、測定期間を通じて一貫しており、大幅に変更されていない。</li>
</ul>
<p>特に気になるのは最後の項目です。Core Web Vitalsは<strong>生まれたばかり</strong>の指標です。<a href="https://twitter.com/anniesullie">Annie Sullivan</a>はちょうど2年前に、<a href="https://calendar.perfplanet.com/2019/developing-the-largest-contentful-paint-metric/">3つのCore Web Vitalsの1つ（LCP）がどのように開発されたかに関する記事</a>をWeb Performance Calendarに投稿しています。つまり、Core Web Vitalsは人間でいうところの「魔の2歳児」と呼ばれる時期です。そして、親なら誰でも知っているとおり、生まれてから2歳になるまでには多くの変化が起こります。</p>
<p>このような新しい指標を最初から完璧な形で導入するのは不可能です。GoogleのChromeチームは、特にSEOへの影響を考慮して、熱心にCore Web Vitalsの改善に取り組み、適切な測定ができていないケースに対処してきました。Core Web Vitalsは多くの点で改善されています（すべての改善点は<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/README.md">公開変更ログ</a>で明確に追跡できます）。</p>
<p><a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/lcp.md">Largest Contentful Paint（LCP）は、最大のコンテンツ要素を正しく特定するためにいくつかの点が変更されています</a>。非表示の画像や背景の画像は「コンテンツ」ではないものとして無視され、LCPの計算が停止するタイミングも変更されました。これらはすべて（プラスとマイナスの）影響を及ぼすとみられ、LCPの改善のグラフは最初に示したグラフよりも（特にモバイルで）やや横ばいとなっています。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image10.png"></p>
<div class="image-text">
画像内訳
<em>LCPエクスペリエンスが「良好」（2.5秒以下）であるオリジンの割合。</em>
</div>
<p><a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/fid.md">First Input Delay（FID）の変更点</a>は、LCPに比べると多くありません。ただし、Chromeが<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/2021_05_fid.md">ダブルタップによるズームの禁止</a>条件を変更したことはプラスの影響を及ぼしています。これは2021年5月にリリースされており、リリース直後からモバイルのFIDの数値に影響を与えていることが分かります。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image7.png"></p>
<div class="image-text">
画像内訳
<em>FIDエクスペリエンスが「良好」（100ミリ秒以下）であるオリジンの割合。CrUXのFIDを参照。</em>
</div>
<p>FIDは通常、Core Web Vitalsの中で達成するのが最も簡単です。そのため、多くの人（何よりも<a href="https://web.dev/better-responsiveness-metric/">Chromeチーム自身</a>）が、抜本的な変更が必要ではないかという疑問を提起しています。したがって、来年ごろにはFID（少なくともCore Web VitalsにおけるFID）に何らかの大きな変化があるでしょう。</p>
<p>最後に、3番目のCore Web VitalsであるCumulative Layout Shift（CLS）は最も大きく変更されています。CLSは、Cumulative（累積）という名称が示すとおり、以前はページが存在する限り増加し続けていました。これは、シングルページアプリケーション（SPA）が不当に不利な立場に置かれているという苦情の原因となりました。SPAのページは長期にわたって存続すると見込まれるためです。CLSに対する影響がわずかであっても、時とともに蓄積し、しきい値を超えて「改善が必要」や「不十分」となる可能性が高まります。</p>
<p>CLSは、<a href="https://web.dev/evolving-cls/">1回のセッションウィンドウの間の最大累積CLSのみを報告する</a>ように変更されました。実質的に、現在のCLSスコアはすべてのCLSシフトの合計ではなく、一定の時間におけるCLSシフトの最大の部分を示すものとなっています。この変更は2021年5月ごろのChrome 91でリリースされており、グラフでは同じ時期にCLSスコアが良好なサイトが急増しているのが分かります。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image2.png"></p>
<div class="image-text">
画像内訳
<em>CLSエクスペリエンスが「良好」（0.1以下）であるオリジンの割合。</em>
</div>
<p>2021年9月のChrome 93では<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/cls.md">さらなる改善点</a>がリリースされており、再びグラフが上昇しています。</p>
<p>指標の変更と同様に、測定のベースラインにも留意する必要があります。3つすべてのCore Web Vitalsを達成したAngularサイトの数が111%増加したのは結構なことですが、詳しく見てみると、<a href="https://datastudio.google.com/u/0/reporting/55bc8fad-44c2-4280-aa0b-5f3f0cd3d2be/page/M6ZPC?params=%7B%22df44%22:%22include%25EE%2580%25800%25EE%2580%2580IN%25EE%2580%2580Angular%22%7D">Angularサイト全体の3%から6%に増えただけ</a>であり、素晴らしい改善というには程遠いようです。しかも、これらの統計が示す改善がなされていないAngularサイトであっても、上記の指標の変更による恩恵を受けているはずです。</p>
<h2>Webは高速化したのか？</h2>
<p>これまで筆者は、気難しいエベニーザ・スクルージ（※訳注：小説『クリスマス・キャロル』の登場人物）のように、クリスマスに水を差してきました。そして、Core Web Vitalsが向上した理由は、単に測定方法が改善されたためである可能性があるので、プラスの影響を主張するのはやや時期尚早かもしれないことを示しました。しかし、実際に多くのサイトはパフォーマンスの改善に忙しく取り組んでいます。そのため、Core Web Vitalsの向上の理由はすべて測定方法にあると主張するのは、逆の方向に極端であり、あまりに悲観的過ぎるかもしれません。では、指標の定義の大幅な変更を踏まえ、測定方法による影響と真のパフォーマンスの向上を分離し、Web全体が改善したのかを確認するにはどうすれば良いのでしょうか？</p>
<p>そのための方法の1つは、従来のより安定した指標に回帰し、それを読み解くことです。真新しく光るLCP、FID、CLSという指標が舞台に突然現れスポットライトを浴びる以前、Webパフォーマンスコミュニティでは、<a href="https://web.dev/first-contentful-paint/">First Contentful Paint</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/Events/load">onLoad</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event">edDOMContentLoad</a>、<a href="https://web.dev/lighthouse-total-blocking-time/">Total Blocking Time</a>、<a href="https://web.dev/interactive/">Time to Interactive</a>など多くの他の指標に頼っていました。筆者のお気に入りの1つは<a href="https://web.dev/speed-index/">Speed Index</a>です。</p>
<p>誤解のないように言うと、筆者はCore Web Vitalsの方が<strong>はるかに</strong>優れた指標だと考えています。Core Web Vitalsの3つの指標は、ユーザー体験の代わりとなることを意図した恣意的で細かな数値ではなく、ユーザーにとって意味のある影響を測定しようとしています。ユーザーはDOMがいつ読み込まれるかなどといったことは気にしません。ユーザーが気にするのは、目的のコンテンツがページにいつ表示されるかです。特に、ラボベース（※訳注：開発者内部の環境下で行われるモニタリング）の完全に人為的な測定から、リアルユーザモニタリング（RUM）ベースの現場での測定への転換は非常に大きな進歩です。ラボベースのテストがユーザー体験の良い指標となるように膨大な仮定を置く必要がなく、ユーザーが体験する実際のWebパフォーマンスを報告できるのはとても良いことです。</p>
<p>しかし、これまで見てきたとおり、この記事で挙げている疑問に答えるには、新たな指標は変動が大き過ぎると言わなければなりません。新しい指標は優れていますが、古い指標が役に立たなかったわけではありません。Webパフォーマンスが改善されれば、古い指標にもプラスの影響があるはずです。そこで、これらの指標を詳しく調べ、何が分かるのかを見ていきましょう。</p>
<p>筆者はSpeed Indexがお気に入りの「昔ながらの」指標だと述べました。Speed Indexは基本的に、読み込み中のページのスクリーンショットを保存して、変化ごとのページの「完成度」を計算し、それを使用してページの読み込みに関するスコアを算出するものです。ロゴなどわずかな一部を除いてほとんど読み込みが終わっているページと、最後まで一切描画されないページを比べると、一部の指標（onLoad、DOMContentLoadedなど）は同じであっても、Speed Indexでは前者の方が良い数値になります。</p>
<p>このように、Speed IndexはLCPの測定対象とそれほど違っておらず、CLSの一部も含まれています。LCPに影響する要素の読み込みが速く、読み込み中のビューポート内のコンテンツがあまり移動しなければ、Speed Indexも改善するでしょう。Annieは、上記の過去の記事で、Speed IndexがCore Web Vitalsとして使用されず、代わりにLCPが考案された主な理由として「Speed Indexを実行するのは大きなコストがかかり、リアルタイムで利用できないこと」を挙げています。Speed Indexはあくまでラボベースの指標なのです。</p>
<p>HTTP Archiveは2016年から、調査の一環としてSpeed Indexを算出しています。Speed Indexがラボベースであるという事実は、RUMベースの指標に影響を与える一部の変動やノイズに左右されないことを意味します。このような変動やノイズには、例えばネットワーク速度の改善や、パンデミックによってモバイルネットワークよりも家庭用のWi-Fiを利用した在宅勤務が増えていることなどがあります。HTTP Archiveの調査ではこうした要素が除去されています。クローリングに使用するハードウェアや、ネットワークの調査手法に（とても）一貫性があるからです。</p>
<p>注意すべき点として、HTTP Archiveは、Speed Indexの独自の定義を定めている<a href="https://www.webpagetest.org/">WebPageTest</a>（WPT）を利用しています。これは（WPTの定義を基礎とする）Lighthouseの定義とはわずかに異なります。WPTは色ヒストグラムを利用しているため、（コンテンツがビューポートの内外を移動しない限り）コンテンツの移動による影響をあまり受けません。一方、Lighthouse版はより複雑な<a href="https://www.imatest.com/docs/ssim/">構造的類似性</a>（SSIM）指数を利用しており、コンテンツの移動による影響を受けやすくなっています。</p>
<p>Speed IndexのグラフはHTTP ArchiveのWebサイトでは提供していませんでした。しかし、データは既に収集してあったので、この記事を作成する一環として<a href="https://httparchive.org/reports/loading-speed#speedIndex">グラフを追加しました</a>。以下がそのグラフです（数値は低いほど良い）。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image6.png"></p>
<div class="image-text">
画像内訳
<em>ページのコンテンツが視覚的に表示される速度。この指標はWebPageTestによるものであり、（WebPageTestの定義を基礎とする）Lighthouse版とはわずかに異なる。</em>
</div>
<p>グラフは筆者が恐れていたことを示しています。Core Web Vitalsの代わりに変動の小さいSpeed Indexで測定したところ、Core Web Vitalsの導入以降、Webは全体として大幅に高速化してはいないようです。それどころか、モバイルでは2021年6月以降にSpeed Indexも悪化しています。</p>
<p>HTTP Archiveによる<a href="https://httparchive.org/reports/loading-speed">読み込み速度レポート</a>では、他の指標も同様の結果を示しています。実質的な変化はなく、First Contentful Paintがある程度改善した程度にとどまりました（ただし、この指標も<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/docs/speed/metrics_changelog/fcp.md">最近変更がありました</a>）。Time to InteractiveもWebサイトの応答時間の長期化を示しています（恐らく<a href="https://almanac.httparchive.org/en/2021/javascript#how-much-javascript-do-we-load">JavaScriptの使用が多過ぎる</a>ためでしょう）。この傾向はCore Web Vitalsが登場する以前から続いているものです。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image9.png"></p>
<div class="image-text">
画像内訳
<em>操作が開始された時点から、CPUが5秒以上停止するまでの秒数。この指標はLighthouseによるもので、モバイルのテストでのみ利用できる。</em>
</div>
<h2>とても残念な結果に思えるが……</h2>
<p>以上のように、Googleや、同社の最も人気のあるWebブラウザや検索エンジンの絶大な影響力をもってしても、パフォーマンスを改善できていないようです。これはとても残念な結果であり、Webパフォーマンスマニアのクリスマスを台無しにしてしまったことを申し訳なく思います……。しかし、筆者はそこまで残念だとは思っていません。ですから、この記事はもっと明るい雰囲気で終わらせましょう。</p>
<p>HTTP ArchiveとCrUXのデータの重要な違いは、HTTP Archiveがホームページのみをクローリングしているという点です。CrUXのデータは、Webサイト全ページの実際の利用状況に基づいています。この取り組みの優れた点の1つは、ホームページ以外のパフォーマンス指標を明らかにしているところにあります。過去のWebパフォーマンス測定ツールでは、ホームページのみを測定対象としていた場合もあったはずです。</p>
<p>かつてのパフォーマンス測定ではホームページばかりが注目されていたことや、ホームページは比較的シンプルなので問題がある可能性が低いことは、十分にあり得ます。もしかすると、筆者が悲観的過ぎるだけであって、上記のCrUXデータの方が、ユーザーが体験した実際のパフォーマンスの改善状況をよく表しているのでしょうか。筆者は、真実はその中間にあるとみています。しかし、胸に手を当てて考えてみると、HTTP Archiveのクローリングによるグラフの方が恐らく真実に近いでしょう。ただし、指標が成熟するにつれて変化が小さくなると仮定すれば、将来的にはCrUXベースのグラフは大いに興味深いものになるとみられます。</p>
<p>どれほどの影響力を持っていても、Web全体で何かを変えるのは困難です。<a href="https://httparchive.org/reports/state-of-the-web#numUrls">HTTP Archiveはクローリングの一環として750万件以上のWebサイトをクロールしています</a>。そして、WebパフォーマンスやSEOのコミュニティがパフォーマンスについて大騒ぎをしていたにもかかわらず、大部分のサイトはその間も大きく変化してはいないでしょう。一方で、変化したサイトも数多く存在するため、Webサイトは実際に高速化したのかもしれません。しかし、それはまだWeb全体を見た場合に有意義な影響を与えられるほど十分な規模ではありません。</p>
<p>筆者はCore Web Vitalsを気に入っており、優れた指標だと考えています。また、GoogleによるCore Web Vitalsへの投資や、同社がWebサイトに対して改善に向けた圧力をかけていることも評価しています。たとえその取り組みの一部に不満があったとしてもです（Google Search Consoleにおけるページのグルーピングの不透明さは大いに不満です）。指標が依然として発展途上であるという指摘は、批判ではなく、とても前向きなものです。この事実は、Core Web Vitalsは変化を拒むものではなく、あくまでWebパフォーマンスの改善に向けた次のステップだという認識を示しており、だからこそ前進できるのです。</p>
<p>たとえ上記のHTTP Archiveのデータに対する影響がまだ表れていないとしても、Webパフォーマンスに関する議論が大幅に増えたのは事実です。そして、こうした議論が今や、比較的小さいWebパフォーマンスコミュニティ（いつでも歓迎します！）の外でも行われるようになったのは素晴らしいことです。</p>
<h2>最後にうれしいニュースを紹介</h2>
<p>上位1,000件のWebサイトを見てみると、Core Web Vitalsを達成したWebサイトの割合は全体よりも大幅に上昇していることが分かります。2021年5月以降の改善割合は、モバイルWebサイト全体では32.8%ですが、上位1,000件のサイトでは37.1%となっています。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image5.png"></p>
<div class="image-text">
画像内訳
<em>Core Web Vitals達成割合の時系列データ</em>
</div>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image1.png"></p>
<div class="image-text">
画像内訳
<em>上位1,000件のサイトのCore Web Vitals達成割合の時系列データ</em>
</div>
<p>当然ながら、大規模なサイトほど予算も多く（改善のインセンティブも大きく）、SEOのトレンドをより正確に把握しているかもしれません。また、こうしたサイトは指標の改善による影響が比較的大きい場合があるという事実が一因となっている可能性もあります。しかし、それでも筆者はこれを前向きな兆候と捉えています。こうしたサイトが先頭を進み、他のWebサイトがそれを追いかけるというトリクルダウン効果が起きるのはよくあることです。</p>
<p>また、Wixなどの一部のプラットフォームは、<a href="https://www.smashingmagazine.com/2021/11/improving-performance-wix-websites-case-study/">パフォーマンスを改善するための取り組みに膨大な労力を費やしています</a>。これらのWebサイトの取り組みは、HTTP ArchiveのSpeed Indexのスコアに反映されています（これは、Speed Indexを使用するという筆者の判断を正当化するのに役立っており、Speed IndexがCrUXに比べて実情を反映していないのではないかという筆者の懸念をある程度緩和するものです）。</p>
<p><img src="https://calendar.perfplanet.com/images/2021/barry/image4.png"></p>
<p>一度に1つのプラットフォームのみに注目するよりも、（<a href="https://datastudio.google.com/u/0/reporting/55bc8fad-44c2-4280-aa0b-5f3f0cd3d2be/page/M6ZPC?params=%7B%22df44%22:%22include%25EE%2580%25800%25EE%2580%2580IN%25EE%2580%2580Angular%22%7D">Core Web Vitals Technology Report</a>が示すように）その他のプラットフォームの相対的な改善度合いに注目する方が指標として優れているかもしれません。しかし、<a href="https://twitter.com/igrigorik/status/1415340002494402564?s=20">多少の競争がある</a>のはきっと良いことです。</p>
<p>恐らくもっと興味深い点として、<a href="https://almanac.httparchive.org/en/2021/cms#fig-6">Web全体の3分の1に利用されている</a>WordPressは最近、「<a href="https://make.wordpress.org/core/2021/10/12/proposal-for-a-performance-team/">パフォーマンス改善提案チーム</a>」を立ち上げました。これはWixなどが強調しているパフォーマンスの改善に対応して、WordPressが後れを取っているという印象を避けるためです。WordPressはまさに「Webを動かす」力を持っており、そのことは<a href="https://twitter.com/rick_viscomi/status/1344380340153016321?s=20">ネイティブLazyload</a>の導入にも表れています（ただし、大いなる力には大いなる責任が伴うもので、<a href="https://web.dev/lcp-lazy-loading/">導入の方法がやや稚拙だったという証拠もあります</a>）。</p>
<h2>そろそろ質問に答えてくれ！</h2>
<p>結局、Core Web VitalsによってWebは高速化したのでしょうか？筆者はイエスだと考えていますが、Core Web Vitalsの一部のデータが示すほど数値は明確に改善してはいません。しかし、この記事で言及した一部のプラットフォームの例に追随するプラットフォームが増え、Webパフォーマンスへの投資が増加すれば、上記の数値も間違いなく追いつくでしょう。もしかすると、来年のブログ記事はもっと短くなり、すべてうまくいっていると述べるだけになるかもしれません。それまでは、指標から読み取れることをしっかりと理解し、出来過ぎた話には疑問を持つようにしてください。たとえ、それが本当であってほしいと望むストーリーであってもです。</p>
<p><em>この記事のために質問に答えてくれたこと、また言うまでもなく、Speed Index、WebPageTestや、その他にもWebパフォーマンスを測定・改善するための素晴らしいツールを数多く作成してくれたことについて、<a href="https://twitter.com/patmeenan">Patrick Meenan</a>にとても感謝しています。</em></p>]]></content:encoded></item><item><title><![CDATA[Rustのビルドを高速化する方法]]></title><description><![CDATA[Rustコードのコンパイルが遅いことは誰でも知っています。しかし筆者は、世の中のほとんどのRustコードはコンパイルをもっと速くできると強く感じています。 例えば、つい最近の記事にこのように書かれて…]]></description><link>https://postd.cc/fast-rust-builds/</link><guid isPermaLink="false">https://postd.cc/fast-rust-builds/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[Rust]]></category><pubDate>Mon, 24 Jan 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Rustコードのコンパイルが遅いことは誰でも知っています。しかし筆者は、世の中のほとんどのRustコードはコンパイルをもっと速くできると強く感じています。</p>
<p>例えば、つい最近の<a href="https://kerkour.com/blog/rust-development-workflow/">記事</a>にこのように書かれていました。</p>
<blockquote>
<p>一方、Rustでは、プロジェクトやCIサーバーの性能にもよりますが、
CIパイプラインの実行に15～45分かかります。</p>
</blockquote>
<p>これは筆者には理解できません。GitHub Actions上にあるrust-analyzerのCIの所要時間は8分です。しかも、これは100万行の依存関係に加え、20万行の独自コードが記述されたとても大規模で複雑なプロジェクトでの話です。</p>
<p>確かに、Rustは根本的な部分で非常にコンパイルが遅いのは間違いありません。Rustは<a href="https://research.swtch.com/generic">ジェネリクスのジレンマ</a>において「遅いコンパイラ」を選び、全体的な設計思想としてコンパイル時間よりもランタイムを優先しています（この点に関する優れたシリーズ記事を紹介します：<a href="https://pingcap.com/blog/rust-compilation-model-calamity">1</a>、<a href="https://pingcap.com/blog/generics-and-compile-time-in-rust">2</a>、<a href="https://pingcap.com/blog/rust-huge-compilation-units">3</a>、<a href="https://pingcap.com/blog/reasons-rust-compiles-slowly">4</a>）。しかし、rustcは低速なコンパイラではありません。rustcは業務用コンパイラの中で最も<a href="https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/#:~:text=I%20think%20Rust%20qualifies%20as%20a%20counter%20example%20here">先進的なインクリメンタルコンパイル手法</a>を導入し、適切なモジュール（クレート）に基づくコンパイルモデルを活用しており、<a href="https://blog.mozilla.org/nnethercote/2020/09/08/how-to-speed-up-the-rust-compiler-one-last-time/">細かい部分まで最適化されています</a>。Rustプロジェクトの高速なコンパイルは、たとえ一般的ではなくても現実に可能です。ただし、それにはいくつかの注意点と専門知識が必要です。</p>
<p>それでは、私たちがrust-analyzerのコンパイル時間を妥当な範囲に収めるために実施した対策を詳しく見ていきましょう。</p>
<h2>ビルド時間を気にする理由</h2>
<p>筆者が明確にしておきたいのは、プロジェクトのビルド時間を最適化するのは、ある意味ではあまり価値のない取り組みだという点です。コンパイル時間を削減しても、ユーザーにとっての<strong>直接的</strong>なメリットはごくわずかで、あくまで本質から外れた問題にすぎません。</p>
<p>とはいえ、コンパイル時間はほぼすべての作業の所要時間を<strong>倍増</strong>させます。追加機能の搭載、コードの高速化、要件変更への対応や、新しいコントリビュータの勧誘にもビルド時間が関わってきます。</p>
<p>コンパイル時間には間接的な影響もあります。コンパイラの作業を待つだけなら比較的小さな問題です。大きな問題は、コードのコンパイルの間に、集中力が失われたり、さらに悪いことに気分が変わって別の作業をしたくなったりすることです。コンパイラにとっては1分の仕事でも、人間にとっては1分以上の時間が無駄になります。</p>
<p>こうした影響を定量化するのは困難ですが、直感的にはプロジェクトの1人当たりのコードが数千行を超えると、ビルド時間は非常に重要になると思います。</p>
<p>ビルド時間の最も恐ろしい特徴は、気づかないうちに増大する点です。プロジェクトが小規模なうちは、ビルド時間は許容できる範囲にとどまるでしょう。プロジェクトが成長するにつれて、ビルド時間もゆっくりと増加し始めます。放っておくと、後でコントロールできる状態に戻そうとしても困難になる恐れがあります。</p>
<p>プロジェクトのコンパイル時間がすでに許容できないほど遅くなっている場合は、以下のような事態を招きます。</p>
<ul>
<li>ビルド時間の改善には時間がかかります。なぜなら、「変更を試し、ビルドを実行して、改善度を測定する」ためのイテレーションに毎回長い時間がかかるからです（ビルド時間はすべての作業の所要時間を倍増させますが、それにはビルド時間自体も含まれます）。</li>
<li>簡単に成果を上げるのは難しいでしょう。ランタイムのパフォーマンスとは異なり、パレートの法則は機能しません。1,000行のコードのうち、パフォーマンスに影響するのは100行かもしれませんが、コンパイル時間は1行ごとに増えます。</li>
<li>ビルド時間がわずかに短縮されても、それが十分に蓄積するまでは、取るに足らないと感じられるでしょう。コンパイル時間を5秒削減できたとして、元々のビルド時間が5分であれば非常に大きな成果ですが、1時間であればそうでもありません。</li>
<li>同様に、ビルド時間がわずかに増加しても誰も気づきません。</li>
</ul>
<p>これには文化的な要因もあります。あなたがプロジェクトに参加して、そのCIに1時間かかるとしたら、1時間のCIは普通だと思うようになるでしょう。</p>
<p>うれしいことに、ビルド時間の問題を解決するには簡単なコツがあります。</p>
<h2>銀の弾丸</h2>
<p>ビルド時間は、問題になる<strong>前</strong>から注視し、修正する必要があります。ビルド時間の短縮は、最適化に関する問題としてはかなり簡単です。直接的なフィードバックを得る方法は明確で（ビルド時間を測るだけです）、プロファイリングツールも数多く存在し、目安となるベンチマークを考案する必要さえありません。課題となるのはコンパイラ全般のパフォーマンスの向上ではなく、特定のプロジェクトのビルド時間の最適化です。一般に、ビルド時間の最適化のように本質的でない問題では、ほとんどのケースでこのような好ましい特徴が見られます。つまり、エンジニアリング問題としての定義が明確で、その解決策もよく知られている傾向があります。</p>
<p>コンパイル時間に関して唯一難しいのは、実際に問題になるまで、それが問題だと認識できない点です。ですから、この記事から学べる最も有益なポイントは、もしあなたがRustプロジェクトに取り組んでいるなら、今日はビルドの最適化のためにある程度時間をとり、今後もなるべく、たまには最適化を行うべきだということです。</p>
<p>これでソフトウェアエンジニアリングの話は終わったので、ようやく実用的なプログラミングのアドバイスに入ることができます。</p>
<h2>bors</h2>
<p>筆者は、注目すべき主要な指標の1つとして好んでCI実行時間を利用します。</p>
<p>理由の1つはCI時間それ自体が重要だからです。機能の開発がCIに制約されない場合でも、CI時間は1つの作業を終えて次の作業を始めるための意識の切り替えによる負担に直接影響します。CI完了を待ちながら、5件のプルリクエスト（PR）を同時並行で処理するのは生産的ではありません。またCIが長くなると、作業を独立したまとまりに分割しにくくなります。1つのタイポを訂正するのにPRタブを30分開いておく必要があるなら、次の機能のブランチで修正を実行する方が良いでしょう。</p>
<p>しかし、それより大きな理由は、CIが標準的なベンチマークになることです。ローカル環境では、コンパイルは徐々に行われ、変更の内容によってビルド時間は大きく異なります。通常、コンパイルするのはプロジェクトの一部です。こうした変動が避けられないため、ローカル環境におけるビルドでは、ビルド時間に関する継続的なフィードバックを十分に得られません。一方、標準化されたCIはすべての変更に対して実行されるので、直接比較可能なデータを時系列で把握できます。</p>
<p>CIによる標準化を推進するには、“<a href="https://graydon2.dreamwidth.org/1597.html">ロケットサイエンスのルール</a>”ではなく、メインブランチのあらゆる段階でCIを確実に実行するためのマージボットの設定をお勧めします。筆者は特に<a href="https://bors.tech/">bors</a>をよく導入していますが、他の方法もあります。</p>
<p>borsのようなツールには、（導入の決め手には全くなりませんが）妥当なコンパイル時間を実現するうえで2つのメリットがあります。</p>
<ul>
<li>あらゆる変更に対してCIが確実に実行されるようにし、全体的なCIの健全性の維持を推進します。</li>
<li>PRに<code class="language-text">r+</code>コメントを付けてから「PR merged」の通知を受け取るまでの時間を常にフィードバックループで活用できます。わざわざビルド時間を測定する必要はなく、あらゆるPRがビルドのベンチマークとなります。</li>
</ul>
<h2>CIキャッシング</h2>
<p>考えてみれば、優れたキャッシング戦略がCIにとって有効なのはどう見ても明らかです。めったに変更されないものをキャッシュするのは理にかなっていますが、頻繁に変更されるものをキャッシュしても無意味です。つまり、依存関係はすべてキャッシュすべきですが、プロジェクト自体のクレートはキャッシュすべきではありません。</p>
<p>しかし、残念なことに、これを実践している人はほとんどいません。<a href="https://github.com/actions/cache/blob/main/examples.md#rust---cargo">よくあるのが</a><code class="language-text">./target</code>ディレクトリ全体をキャッシュしているケースです。これは間違っています。<code class="language-text">./target</code>はサイズが大きく、その大部分はCIには不要です。</p>
<p>とはいえ、修正するのはそれほど簡単ではありません。悲しいことに、Cargoを使用しても、<code class="language-text">./target</code>のどの部分が持続的な依存関係で、どの部分が変更されやすいローカルなクレートであるかを容易には判別できません。ですから、キャッシュを保存する前に<code class="language-text">./target</code>を整理するための<a href="https://github.com/rust-analyzer/rust-analyzer/blob/94d9fc2a28ea5d97e3a9293b9dac05bdb00304cc/xtask/src/pre_cache.rs#L30-L53">コード</a>を書く必要があります。特にGitHub Actionsでは<a href="https://github.com/Swatinem/rust-cache">Swatinem/rust-cache</a>も利用できます。</p>
<h2>CIワークフロー</h2>
<p>キャッシングは通常、簡単に大きな成果を上げられます。しかし、他にも微調整できる点はいくつか存在します。</p>
<p>まず、CIを<code class="language-text">cargo test --no-run</code>と<code class="language-text">cargo test</code>に<a href="https://github.com/rust-analyzer/rust-analyzer/blob/48f84a7b60bcbd7ec5fa6434d92d9e7a8eb9731b/.github/workflows/ci.yaml#L56-L61">分割</a>します。CIのどの部分がビルドで、どの部分がテストかを把握するのは必要不可欠です。</p>
<p>次に、インクリメンタルコンパイルを<a href="https://github.com/rust-analyzer/rust-analyzer/blob/25368d24308d6a94ffe8b99f0122bcf5a2175322/.github/workflows/ci.yaml#L11">無効化</a>します。CIビルドはスクラッチビルドに近いケースが多いです。通常、変更はローカルな編集とコンパイルのサイクルよりはるかに大規模になるからです。スクラッチビルドでは、インクリメンタルコンパイルによって、新たな依存関係を追跡するオーバーヘッドが増えます。IOの量と<code class="language-text">./target</code>のサイズも大幅に増加し、キャッシングの有効性が低下します。</p>
<p>debuginfoを<a href="https://github.com/rust-analyzer/rust-analyzer/blob/48f84a7b60bcbd7ec5fa6434d92d9e7a8eb9731b/Cargo.toml#L6-L10">無効化</a>するのも有効です。debuginfoは<code class="language-text">./target</code>のサイズを大幅に増大させるため、やはりキャッシングにとって悪影響です。望ましいワークフローに応じて、debuginfoを無条件に無効化することを検討しても良いでしょう。ローカル環境でのビルドにとっても一定のメリットがあります。</p>
<p>ついでに、<code class="language-text">-D warnings</code>を<code class="language-text">RUSTFLAGS</code>環境変数に<a href="https://github.com/rust-analyzer/rust-analyzer/blob/3dae94bf2b3e496adb049da589c7efef272a39b8/.github/workflows/ci.yaml#L15">追加</a>して、すべてのクレートの警告をまとめて拒否しましょう。<code class="language-text">#![deny(warnings)]</code>をコードに追加するのは良いアイデアではありません。すべてのクレートで同じことを繰り返さなければならず、ローカルの開発を不必要に困難にし、ユーザーがコンパイラをアップグレードする際に気力をそがれる恐れがあります。Cargoネットワークのリトライ回数を増やすのも有効かもしれません。</p>
<h2>Lockfileを読み込む</h2>
<p>他のアドバイスとしては、当然のことですが、利用する依存関係の数を減らし小規模化すると良いでしょう。</p>
<p>ただし、これには微妙な点があります。ライブラリは実際に問題を解決するものです。crates.ioで解決済みの問題に自分でソリューションを導入するのはばかげています。そして、あなたのソリューションがより小規模である保証はありません。</p>
<p>しかし、アプリケーションが解決しようとしている問題と、そうでない問題を認識するのは重要です。数千人が利用するCLIユーティリティを構築している場合、<a href="http://clap.rs/">clap</a>とそのすべての機能は絶対に必要です。一方、CIの間に実行する簡単なスクリプトを書いていて、それがチームにしか使用されない場合、コマンドラインのパーシングを単純にして、ビルドを高速化しても構わないでしょう。</p>
<p>これに関して、<code class="language-text">Cargo.lock</code>（Cargo.tomlではありません）を読み、それぞれの依存関係が自分のアプリケーションを使用する人たちにとってどんな実際の問題を解決するか考えてみるのは、とても有用なトレーニングとなります。<strong>自分の環境</strong>では依存関係が全く意味を持たないのに気づくのは非常によくあることです。</p>
<p>例を挙げると、rust-analyzerはregexに依存していますが、これは無意味です。私たちには RustとMarkdown向けの厳密なパーサーとレキサーがあるため、ランタイムで正規表現を解釈する必要はありません。さらに、regexは小規模な言語を丸ごと導入するため、依存関係がかなり重いクレートの1つです。この依存関係が存在する理由は、私たちが利用しているロギングライブラリにおいて、以下のような記述が可能になるためです。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">RUST_LOG=rust_analyzer=very complex filtering expression</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>この場合、フィルタリング式のパーシングは正規表現によって行われます。</p>
<p>これは一部のアプリケーションにとって間違いなくとても便利な機能ですが、rust-analyzerに関しては不要です。<code class="language-text">env_logger-</code>の単純なフィルタリングで十分でしょう。</p>
<p>同様に冗長な依存関係を特定したら、どこかのfeaturesフィールドを微修正するか、PRを上流に送信して不必要な部分を変更可能にすれば十分です。</p>
<p>時にはもっと大規模なyak shaving（※訳注 問題を解決しようとすると別の問題が出てきて、それを解決しようとするとさらに別の問題が出てくるという繰り返しのこと）が必要な場合もあります。例えば、rust-analyzerはオプションでjemallocクレートを利用しており、そのビルドスクリプトは<a href="https://docs.rs/fs_extra">fs_extra</a>と（よりによって）<a href="https://docs.rs/paste">paste</a>を呼び出します。ここでの理想的な解決策はもちろん、堅牢で安定した純正なrustメモリアロケータの導入です。</p>
<h2>最適化の前にプロファイリングを</h2>
<p>ここまで常識的な対策を実施してきたので、そろそろビルド時間を削減する前に測定してみましょう。今回使用するツールはCargoのtimingsフラグです（<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#timings">ドキュメントはこちら</a>）。悲しいことに、筆者はこの機能の質の高さと洗練性を十分に表現できるだけの雄弁さを持ち合わせていません。そこで、ここでは愛 ❤️ を表明するだけにとどめ、ドライに説明を続けさせてください。</p>
<p><code class="language-text">cargo build -Z timingsは</code>、ビルド中のプロファイリングデータを記録し、それをとても読みやすくて情報が詰まったHTMLファイルとして出力します。これはナイトリー版の機能であるため、<code class="language-text">+nightly</code>トグルが必要です。とはいえ、ときどき手動で実行すればよいだけなので、実際は問題ありません。</p>
<p>以下はrust-analyzerの例です。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">cargo +nightly build -p rust-analyzer --bin rust-analyzer \
  -Z timings –release</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span></span></pre></div>
<p><img src="https://matklad.github.io/assets/cargo-timings.png"></p>
<p>各クレートのコンパイルにどれだけ時間がかかったかだけでなく、個々のコンパイルがどのようにスケジューリングされ、各クレートのコンパイルがいつ開始されたかや、クリティカルな依存関係も分かります。</p>
<h2>コンパイルのモデル：クレート</h2>
<p>ここからは重要な最後のポイントを説明します。クレートは依存関係の有向非巡回グラフを形成し、マルチコアのCPUではこのグラフの形状がコンパイル時間に大きく影響します。</p>
<p>以下はすべてのクレートを順番にコンパイルする必要があるため、コンパイルに時間がかかります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">A -&gt; B -&gt; C -&gt; D -&gt; E</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>一方、以下のグラフでは並列処理が可能な部分が大幅に増えるため、コンパイルははるかに速くなります。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">   +-  B  -+
  /         \
A  -&gt;  C  -&gt;  E
  \         /
   +-  D  -+</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>並列処理とインクリメンタリティにも関係があります。2番目の大きいグラフでは、Bを変更してもCとDを再びコンパイルする必要はありません。</p>
<p>Rustのコンパイル時間について不満を言うと、最初に返ってくるアドバイスは「コードをクレートに分割しよう」です。しかし、これはさほど簡単ではありません。最初のグラフのような形状になっている場合、大きな成果は見込めません。アプリケーションを2番目のグラフのように構築するのが重要となります。つまり、共通用語のクレート、複数の独立した機能、そしてすべてを繋ぐ「葉」の役割を果たすクレートから成る構造です。クレートの最も重要なプロパティは、そのクレートが（推移的に）依存していないクレートはどれかということです。</p>
<p>もう1つの重要な検討事項は、最終的なアーティファクト（最も一般的にはバイナリ）の数です。Rustは静的リンク方式であるため、2つの異なるバイナリが同一のライブラリを使用する場合、各バイナリにはそれぞれ別にリンクされたライブラリのコピーが含まれます。仮にn個のバイナリとm個のライブラリが存在し、各バイナリが各ライブラリを使用するとき、リンクを作成する際の作業量は<strong>m * n</strong>です。そのため、アーティファクトの数は最小限に抑えると良いでしょう。よくあるテクニックの1つが、<a href="https://www.busybox.net/FAQ.html#design">BusyBox</a>のような多機能ナイフ型の実行可能ファイルです。このアイデアは、同じ実行可能ファイルを、異なる名前を持つ複数のファイルとしてハードリンクするものです。プログラムは0番目のコマンドライン引数を参照することで、自らが呼び出されたファイル名を把握し、それをサブコマンドの名前として有効に利用できます。ただし、Cargoに特有の注意点として、<code class="language-text">./examples</code>と<code class="language-text">./tests</code>フォルダ内の各ファイルはデフォルトで新たな実行可能ファイルを作成します。</p>
<h2>コンパイルのモデル：マクロとパイプライン化</h2>
<p>しかし、Cargoにはそれ以上にスマートな機能があります。それはコンパイルのパイプライン化です。Cargoはクレートのコンパイルをメタデータとコード生成の段階に分け、メタデータの段階が終わるとすぐに依存するクレートのコンパイルを開始します。</p>
<p>このとき、手続きマクロ（とビルドスクリプト）との間に面白い関係が発生します。<code class="language-text">rustc</code>はクレートのメタデータを計算するために手続きマクロを実行する必要があります。これは手続きマクロがパイプライン化できないことや、手続きマクロが完全にコンパイルされてバイナリコードになるまで、その手続きマクロを使用するクレートがブロックされることを意味します。</p>
<p>一方、手続きマクロはRustコードをパースする必要がありますが、これはかなり複雑なタスクです。この機能を担うデファクトスタンダードのクレートである<code class="language-text">syn/serde</code>はコンパイルに長い時間がかかります（肥大化しているからではなく、単純にRustのパーシングが難しいからです）。</p>
<p>これは一般に、プロジェクトにおいて、コンパイル中のCPU稼働率のプロファイルに <code class="language-text">syn/serde</code> は大きく穴をあける傾向にあることを意味します。（訳注: syn/serde によって、 コンパイル中にCPUに対して大きく負荷がかかります）そのため、手続きマクロはそれが十分に活用される場合のみ使用し、<code class="language-text">cargo -Z timings</code>グラフで<code class="language-text">syn</code>の前にクレートを配置することがかなり重要です。</p>
<p>ただし、後者は難しい場合があります。手続きマクロの依存関係はいつの間にか増大する可能性があるからです。こうした依存関係はフィーチャーフラグに隠れていることが多く、それらのフィーチャーフラグが川下のクレートによって有効化されるケースが問題となります。以下の例を考えてみましょう。</p>
<p>便利なユーティリティ型、例えばSSO文字列が<code class="language-text">small_string</code>クレートに存在するとします。シリアル化を実装するには、実は継承は必要ないため（Stringへの委譲で十分です）、<code class="language-text">serde</code>との（任意の）依存関係を追加します。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">[package]
name = &quot;small-string&quot;

[dependencies]
serde = { version = &quot;1&quot; }</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>SSO文字列は非常に便利な抽象型なので、コードベース全体で使用されます。その後、例えばJSON APIを公開する必要がある葉のクレートに、<code class="language-text">serde</code>フィーチャーを持つ<code class="language-text">small_string</code>と、deriveフィーチャーを持つ<code class="language-text">serde</code>自体との依存関係を追加します。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">[package]
name = &quot;json-api&quot;

[dependencies]
small-string = { version = &quot;1&quot;, features = [ &quot;serde&quot; ] }
serde = { version = &quot;1&quot;, features = [ &quot;derive&quot; ] }</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ここで問題になるのは、<code class="language-text">json-api</code>が<code class="language-text">serde</code>の<code class="language-text">derive</code>フィーチャーを有効化するため、<code class="language-text">small-string</code>とその逆依存関係のすべてが<code class="language-text">syn</code>のコンパイルを待つ必要があることです。同様に、あるクレートが<code class="language-text">syn</code>のフィーチャーの一部にしか依存していなくても、クレートグラフ内の別の何かがすべてのフィーチャーを有効化すると、元のクレートにはそのフィーチャーも追加されます。</p>
<p>これは必ずしも破滅的な状況ではありませんが、依存関係グラフがフィーチャーの存在によって厄介なものとなり得ることが分かります。うれしいことに、<code class="language-text">cargo -Z timings</code>は問題の発生を気づきやすくしてくれます。もっとも、いったい何が間違っているのか明らかになるとは限りませんが。</p>
<p>手続きマクロは、もっと直接的にコンパイルを遅くする原因にもなります。マクロが大量のコードを生成する場合、コンパイルに一定の時間がかかります。というのも、一部のマクロは少量のソースコードを書くことを可能にしており、それ自体は害がないように感じられますが、そのコードが大量のロジックに拡大するのです。代表的な例はシリアル化です。筆者は、数値からJSONへの変換（とその逆）がコンパイルにおいて驚くほど大きな部分を占めていると気づきました。ここではクレートのグラフ全体について考えるのが役立ちます。シリアル化は、システムの境界の葉のクレートで実行するようにすべきです。システムの根幹の付近にシリアル化を導入すると、すべての中間クレートがビルド時間のコストを負担することになります。</p>
<p>いずれにせよ、面白いポイントは、手続きマクロは本質的にコンパイルが遅いわけではないことです。むしろ、ほとんどの手続きマクロはRustをパースする必要があるか、あるいは多くのコードを生成するために遅くなっています。ときには、マクロはsynなしでパースできる単純な構文を受け入れ、それに基づいてわずかなRustコードを生成する場合もあります。有効なRustの生成は、そのパーシングに比べれば全く複雑ではありません。</p>
<h2>コンパイルのモデル：モノモーフィゼーション</h2>
<p>以上でクレートレベルのマクロに関する問題はカバーしたので、コードレベルの問題を詳しく見ていきましょう。主に注目するのはジェネリクスです。ジェネリクスがどのようにコンパイルされるかを理解するのは非常に重要です。Rustの場合はモノモーフィゼーションによって実現されます。以下のありふれたジェネリック関数について考えてみましょう。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">fn frobnicate&lt;T: SomeTrait&gt;(x: &amp;T) {
   ...
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>Rustがこの関数をコンパイルするとき、実際には機械語は出力しません。代わりに、関数の本体の抽象表現をライブラリに保存します。実際のコンパイルは、関数を特定の型の変数で<strong>インスタンス化</strong>したときに行われます。直感的な理解のためにC++の用語を借用するならば、 <code class="language-text">frobnicate</code>は「テンプレート」です。これは変数Tに具体的な型が代入された際に実際の関数を生成します。</p>
<p>言い換えると、以下のケースでは</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">fn frobnicate_both(x: String, y: Widget) {
  frobnicate(&amp;x);
  frobnicate(&amp;y);
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>機械語のレベルで2つの異なる<code class="language-text">frobnicate</code>のコピーが生成されます。両者は変数の詳細な処理が違っていますが、それ以外は同一です。</p>
<p>これではとても困ると思いませんか？どうやら大規模なジェネリック関数を書くと、それをインスタンス化するために複数の型のコードを少し書いただけで、コンパイラに大きな負荷がかかるようです。</p>
<p>ここで残念なお知らせがあります。現実は想像よりもはるかに悪いのです。型が異なっていない場合さえ、重複は発生します。例えば、以下のようなダイヤモンド型の4つのクレートがあるとしましょう。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">   +- B -+
  /       \
A           D
  \       /
   +- C -+</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">frobnicate</code>はAで定義され、BとCで使用されます。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">// A
pub fn frobnicate&lt;T: SomeTrait&gt;(x: &amp;T) { ... }

// B
pub fn do_b(s: String) { a::frobnicate(&amp;s) }

// C
pub fn do_c(s: String) { a::frobnicate(&amp;s) }

// D
fn main() {
  let hello = &quot;hello&quot;.to_owned();
  b::do_b(&amp;hello);
  c::do_c(&amp;hello);
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このケースでは<code class="language-text">frobincate</code>を<code class="language-text">String</code>でしかインスタンス化していませんが、モノモーフィゼーションはクレートごとに行われるため、コンパイルは2回となります。BとCは別々にコンパイルされ、それぞれに<code class="language-text">do_*</code>関数の機械語が含まれるため、<code class="language-text">frobnicate&lt;String&gt;</code>を必要とします。最適化が無効な場合、<code class="language-text">rustc</code>はテンプレートのインスタンス化を直接の依存関係と共有できますが、親が共通の依存関係とは共有しません。最適化が有効な場合、<code class="language-text">rustc</code>は直接の依存関係とさえモノモーフィゼーションを共有しません。</p>
<p>言い換えると、Rustのジェネリクスによって、多くのクレートでコンパイル回数が意図せず二次関数的に増加する恐れがあります。</p>
<p>これ以上悪いことがあり得るのかと考えているなら、その答えはイエスです。筆者は、モノモーフィゼーションの実際の単位はコード生成単位だと考えており、そのため重複は1つのクレート内でも発生する可能性があります。</p>
<h2>インスタンス化に注意</h2>
<p>ジェネリクスには、重複に加えて、コンパイル時間を利用者に転嫁する問題もあります。ジェネリック関数のコンパイル時間のコストの大部分はその機能を使用するクレートが負担する一方、定義が記述されたクレートはコードを一切生成せず、コードの型をチェックするだけです。何が、どこで、なぜインスタンス化されるかが全く明確でない場合（<a href="https://github.com/rust-analyzer/rust-analyzer/issues/10065">例</a>）もあるため、ジェネリックAPIを直接追跡するのは困難です。</p>
<p>しかし、うれしいことに、その作業は必要ありません。そのためのツールがあるからです。<a href="https://github.com/dtolnay/cargo-llvm-lines">cargo llvm-lines</a>は、特定のクレートでどのようなモノモーフィゼーションが起きているかを教えてくれます。</p>
<p>以下は<a href="https://github.com/rust-analyzer/rust-analyzer/issues/10065">最近の調査に基づく例</a>です。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">$ cargo llvm-lines --lib --release -p ide_ssr | head -n 12
 Lines          Copies        Function name
  -----          ------        -------------
  533069 (100%)  28309 (100%)  (TOTAL)
   20349 (3.8%)    357 (1.3%)  RawVec&lt;T,A&gt;::current_memory
   18324 (3.4%)    332 (1.2%)  &lt;Weak&lt;T&gt; as Drop&gt;::drop
   14024 (2.6%)    332 (1.2%)  Weak&lt;T&gt;::inner
   11718 (2.2%)    378 (1.3%)  core::ptr::metadata::from_raw_parts_mut
   10710 (2.0%)    357 (1.3%)  &lt;RawVec&lt;T,A&gt; as Drop&gt;::drop
    7984 (1.5%)    332 (1.2%)  &lt;Arc&lt;T&gt; as Drop&gt;::drop
    7968 (1.5%)    332 (1.2%)  Layout::for_value_raw
    6790 (1.3%)     97 (0.3%)  hashbrown::raw::RawTable&lt;T,A&gt;::drop_elements
    6596 (1.2%)     97 (0.3%)  &lt;hashbrown::raw::RawIterRange&lt;T&gt; as Iterator&gt;::next</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この表は各ジェネリック関数について、生成されたコピーの数とその合計サイズを示しています。サイズは関数のエンコードに必要なllvm irの行数として非常に大ざっぱに測定されています。有益な情報としては、llvmはジェネリック関数を持っていません。関数テンプレートをインスタンス化によって実際の関数に変えるのはrustcの仕事です。</p>
<h2>インスタンス化のコントロール</h2>
<p>モノモーフィゼーションの落とし穴が分かれば、大まかな対策も明らかになります。それはジェネリックコードをクレート間の境界に設置しないことです。大規模なシステムを設計するときは、一連のコンポーネントとして設計したうえで、各コンポーネントが具体的な作業を行い、ジェネリックでないインターフェースを持つようにします。</p>
<p>型安全性や作業効率を改善するためにジェネリックインターフェースが必要な場合は、必ずインターフェースのレイヤーを薄くし、ジェネリックでない実装にすぐに委譲するようにします。ここで埋め込むべき関数の典型的な例は、<code class="language-text">str::fs</code>モジュールに記述され、パス上で動作するさまざまな関数です。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">pub fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
  fn inner(path: &amp;Path) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; {
    let mut file = File::open(path)?;
    let mut bytes = Vec::new();
    file.read_to_end(&amp;mut bytes)?;
    Ok(bytes)
  }
  inner(path.as_ref())
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>外側の関数はパラメータ化されており、効率良く使用できますが、川下のあらゆるクレートで毎回コンパイルされます。とはいえ、この関数は非常に小規模で、stdでコンパイルされるジェネリックでない関数にすぐ移譲されるので問題ありません。</p>
<p>引数としてパスを必要とする関数を記述する場合、<code class="language-text">&amp;Path</code>を利用するか、あるいは<code class="language-text">impl AsRef&lt;Path&gt;</code>を利用してジェネリックでない実装へ委譲しましょう。APIの効率が気になって、implトレイトを利用するくらいなら、<code class="language-text">inner</code>をうまく使うべきです。関数を呼び出すのに使用される構文と同様に、コンパイル時間も効率の大きな要素となります。</p>
<p>第2の典型的なケースはクロージャです。基本的に<code class="language-text">&amp;dyn Fn()</code>を<code class="language-text">impl Fn()</code>よりも優先しましょう。パスの場合と同様に、<code class="language-text">impl</code>ベースの優れたAPIを薄いラッパーとして、<code class="language-text">dyn</code>ベースの実装が大部分の作業を実施するのが良いでしょう。</p>
<p>これに関する別のアイデアは、「ジェネリックなインラインのホットパスと、コンクリート（具体的）なアウトラインのコールドパス」です。<a href="https://lib.rs/crates/once_cell">once_cell</a>クレートには、以下のような面白いパターンが記述されています（以下は簡略化済み。<a href="https://github.com/matklad/once_cell/blob/f92720a4cac370c117e9d565aebbae2b8de51852/src/imp_std.rs#L86">実際のソース</a>はこちら）。</p>
<div class="gatsby-highlight" data-language="text"><pre style="counter-reset: linenumber NaN" class="language-text line-numbers"><code class="language-text">struct OnceCell&lt;T&gt; {
  state: AtomicUsize,
  inner: Option&lt;T&gt;,
}

impl&lt;T&gt; OnceCell&lt;T&gt; {
  #[cold]
  fn initialize&lt;F: FnOnce() -&gt; T&gt;(&amp;self, f: F) {
    let mut f = Some(f);
    synchronize_access(self.state, &amp;mut || {
      let f = f.take().unwrap();
      match self.inner {
        None =&gt; self.inner = Some(f()),
        Some(_value) =&gt; (),
      }
    });
  }
}

fn synchronize_access(state: &amp;AtomicUsize, init: &amp;mut dyn FnMut()) {
  // One hundred lines of tricky synchronization code on atomics.
}</code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この<code class="language-text">initialize</code>関数は2回ジェネリックになります。最初に<code class="language-text">OnceCell</code>が、保存された値の型とともに変数化され、次に<code class="language-text">initialize</code>がジェネリックなクロージャ変数を受け取ります。<code class="language-text">initialize</code>の仕事は、（たとえ同時に多くのスレッドから呼び出されたとしても）最大で1つのfしか実行されないようにすることです。この相互排他タスクは、コンパイル時間を改善するために、実際は具体的なTやFに依存せず、ジェネリックではない<code class="language-text">synchronize_access</code>として実装されています。理想的には<code class="language-text">init: dyn FnOnce()</code>引数を使用したいのですが、現在のRustでは記述できないのが欠点です。このケースでは、<code class="language-text">let mut f = Some(f) / let f = f.take().unwrap()</code>が標準的な次善の策となります。</p>
<h2>結論</h2>
<p>大体こんなところでしょうか！要点を振り返っておきましょう。</p>
<p>ビルド時間はプロジェクトに取り組む人間のトータルな生産性に大きく影響します。ビルド時間の最適化はエンジニアリング課題としては単純で、ツールも存在します。恐らく難しいのは、取り組みが少しずつ後退しないようにすることです。この記事がそのための十分なモチベーションとインスピレーションになるように願っています。大まかな目安として、20万行のRustプロジェクトのビルド時間を妥当な範囲に収めるためにある程度最適化すれば、GitHub Actions上のCIの所要時間は約10分となるはずです。</p>
<p><a href="https://old.reddit.com/r/rust/comments/pid70f/blog_post_fast_rust_builds">/r/rust</a>での議論はこちらです。</p>
<p>本記事は<a href="https://matklad.github.io/2021/09/05/Rust100k.html">One Hundred Thousand Lines of Rust</a>シリーズの一部です。</p>]]></content:encoded></item></channel></rss>