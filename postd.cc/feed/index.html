<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア]]></title><description><![CDATA[POSTD は、ニジボックスが運営する、エンジニアに向けたキュレーションメディアです。ニジボックスはWebサービスの企画、制作、開発、運用を一貫して担うリクルートの100%子会社です。 リクルートグループのオンラインサービスをはじめ、様々な業種・業界・業態のサービス開発を行っております。]]></description><link>https://postd.cc</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 30 Mar 2023 02:39:35 GMT</lastBuildDate><language>ja</language><atom:link href="https://postd.cc/feed/" rel="self" type="application/rss+xml"/><image><title>POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア</title><link>https://postd.cc</link></image><item><title><![CDATA[WebAssemblyに注目]]></title><description><![CDATA[WebAssemblyは今、転換点にあります。今後数年間で、コンテナ化からプラグインシステムやサーバレス・コンピューティング・プラットフォームに至るまで、IT業界全体でWebAssemblyの導入が…]]></description><link>https://postd.cc/pay-attention-to-web-assembly/</link><guid isPermaLink="false">https://postd.cc/pay-attention-to-web-assembly/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[プログラミング言語]]></category><pubDate>Thu, 30 Mar 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>WebAssemblyは今、転換点にあります。今後数年間で、コンテナ化からプラグインシステムやサーバレス・コンピューティング・プラットフォームに至るまで、IT業界全体でWebAssemblyの導入が増えると筆者は予想しています。この記事では、WebAssemblyとは何か、なぜそれが重要なテクノロジーであるのか、現在はどのような分野で利用されているかを説明します。また、WebAssemblyが大きな影響をもたらす可能性がある用途や、WebAssemblyの将来に関する予測も紹介します。</p>
<h2>WebAssemblyとは何か</h2>
<p>WebAssembly（Wasm）とは、さまざまなプログラミング言語と多様な実行環境の間に位置する中間層です。30以上の異なるプログラミング言語で書かれたコードを.wasmファイルにコンパイルし、そのファイルをブラウザ、サーバ、あるいは自動車でも実行できます。</p>
<p>「WebAssembly」という名前は誤解を招きます。WebAssemblyは元々、Webでのコードの実行を高速化するために開発されましたが、今ではブラウザ以外のさまざまな環境でも実行できます。さらに、WebAssemblyはアセンブリではなく、アセンブリより若干高水準なバイトコードです。</p>
<p>WebAssemblyの解説とその歴史の説明については、数多くの記事が書かれています。ですから、ここでは優れた入門記事をいくつか紹介するにとどめたいと思います。</p>
<ul>
<li><a href="https://hacks.mozilla.org/2017/02/a-cartoon-intro-to-webassembly/">A cartoon intro to WebAssembly - Mozilla Hacks - the Web developer blog</a></li>
<li><a href="https://nickymeuleman.netlify.app/blog/webassembly">WebAssembly. Scary name, exciting applications. | Nicky blogs</a></li>
<li><a href="https://desiatov.com/why-webassembly/">How WebAssembly changes software distribution | Max Desiatov</a></li>
</ul>
<h2>WebAssemblyの長所</h2>
<p>WebAssemblyが優れているのは、以下の5つの特徴があるためです。</p>
<ul>
<li><strong>ポータブル</strong>：Wasmのバイトコードのバイナリ形式は標準化されています。このことは、Wasmを実行可能なあらゆるランタイムがどんなWasmコードでも実行できることを意味します<a href="#01">1</a>。これはJavaの「write once, run anywhere」（一度書けばどこでも実行できる）というスローガンと似ています。ブラウザに関しては、<a href="https://caniuse.com/wasm">95%のユーザのブラウザ</a>でWebAssemblyを実行でき、残り5%もwasm2jsコンパイラを利用すれば対応できます。サーバに関しては、<a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a>や<a href="https://github.com/wasmerio/wasmer">Wasmer</a>などのランタイムがあります。リソースが限られているIoT端末でも、<a href="https://github.com/bytecodealliance/wasm-micro-runtime">WAMR</a>を利用すればWasmコードを実行可能です<a href="#02">2</a>。</li>
<li><strong>普遍性</strong>：多くのプログラミング言語をWasmにコンパイルできます。Wasmがサポートしている言語には、C、C++、Rustなどのシステム言語だけでなく、Go、Python、Rubyなどのガベージコレクション機能を導入している高水準言語も含まれます<a href="#03">3</a>。Wasmにコンパイルできるプログラミング言語の一覧は<a href="https://github.com/appcypher/awesome-wasm-langs">こちら</a>です。</li>
<li><strong>“ニアネイティブパフォーマンス”</strong>：Wasmは「ニアネイティブパフォーマンス」（ネイティブに近いパフォーマンス）を<a href="https://developer.mozilla.org/en-US/docs/WebAssembly">実現するとよく言われます</a>。実際には、Wasmはほとんどの状況でJavaScriptより高速で、特に演算の負荷が大きいワークロードでその傾向が顕著です。また、Wasmは平均で<a href="https://www.usenix.org/conference/atc19/presentation/jangda">ネイティブコード</a>より1.45～1.55倍遅いものの、<a href="https://00f.net/2021/02/22/webassembly-runtimes-benchmarks/">ランタイムによって</a>結果は異なります。</li>
<li><strong>高速な起動時間</strong>：Wasmのコールドスタート時間は、それ自体が一つのカテゴリを構成するほど重要です。サーバ上では、WasmはDockerのコンテナと比べて10～100倍<a href="https://repositum.tuwien.at/bitstream/20.500.12708/17598/1/Gackstatter%20Philipp%20-%202021%20-%20A%20WebAssembly%20Container%20Runtime%20for%20Serverless%20Edge...pdf">高速なコールドスタート</a>時間を実現できます。これはWasmがすべてのコンテナについて新たなOSプロセスを作成する必要がないためです。ブラウザでは、Wasmのデコードと機械語への変換はJavaScriptのパース、解釈、最適化よりも高速であるため、WasmコードはJavaScriptよりも速く最大のパフォーマンスで実行を開始できます<a href="#04">4</a>。</li>
<li><strong>安全性</strong>：WebAssemblyはWebを念頭に置いていたため、セキュリティを重視して設計されました。Wasmランタイムで実行されるコードは、メモリがサンドボックス化され、機能が制約されています。これはコードが明示的に許可されていることしか実行できないことを意味します<a href="#05">5</a>。Wasmコードはサンドボックス化されていますが、システムレベルのインタフェースやハードウェア機能など、下層のシステムへのアクセスも依然として許可されています。</li>
</ul>
<h2>WebAssemblyの便利な利用法</h2>
<h3>JavaScriptの高速化</h3>
<p>Wasmとその前身であるasm.jsが開発された元々の動機は、Web上でのクライアントサイドのコードを高速化することでした。Wasmがこの分野で優れていることを示す事例は数多く存在します。</p>
<ul>
<li>例えば、デザインツールのFigmaの中心的なプログラムはC++で書かれ、WebAssemblyにコンパイルされています。Figmaの開発者は、C++で書かれたプログラムには<a href="https://www.figma.com/blog/building-a-professional-design-tool-on-the-web/">パフォーマンスとユーザビリティの面</a>で大きなメリットがあり、それを<a href="https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/">WebAssemblyにコンパイルする</a>ことによって読み込み時間を3分の1に削減し、ダウンロードするファイルの容量を劇的に縮小できると述べています。</li>
<li>パスワードマネージャの1Passwordでは、Wasmへの転換によって、フォームが多いサイトでの動作が最大で<a href="https://blog.1password.com/1password-x-may-2019-update/">13～39倍高速化</a>しました。また、WasmがJavaScriptよりもパフォーマンスが<a href="https://developers.google.com/web/updates/2019/02/hotpath-with-wasm">安定している</a>という点は、レイテンシの影響を受けやすいアプリケーションにとって重要です<a href="#06">6</a>。</li>
</ul>
<h3>プログラミング言語の相互運用性</h3>
<p>WebAssemblyはプログラミング言語の境界を簡単に越えることを可能にします。通常、ライブラリとフレームワークは1つの言語のみで書かれているため、完全に書き換えない限り、そのコードを別の言語で利用するのは困難です。WebAssemblyでは、別の言語で書かれたコードの実行を簡単にすることができます。<strong>これにより、コードを一から書き直すのではなく再利用することが可能になります。</strong></p>
<p>現在、この機能は主にアプリケーションをWebに移植するために利用されています。以下に例を紹介します。</p>
<ul>
<li>Figmaは、一部のグラフィックアルゴリズムについて、Skiaという低水準のC++ライブラリを利用しています。自社でアルゴリズムを開発したり、それをJavaScriptに移植したりはしていません<a href="#07">7</a>。</li>
<li>筆者のお気に入りのチェスサーバであるlichess.orgは、世界クラスのチェスエンジンであるStockfishをユーザのブラウザで実行しており、サーバサイドでStockfishを実行することによる演算負荷を回避しています。</li>
<li><a href="https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6">Google Earth</a>と<a href="https://web.dev/ps-on-the-web/">Adobe Photoshop</a>はWasmを利用してC++のコードベースをWebに移植しています。</li>
</ul>
<p>アプリケーションのWeb移植はWasmを利用するうえで最も簡単な出発点となっており、<a href="https://paulbutler.org/2020/the-webassembly-app-gap/">その傾向は今後も続く</a>と予想されます。しかし、Wasmの相互運用性はブラウザに限られません。Wasmはプラットフォームや端末を越えてコードを実行するのにも利用されています。</p>
<ul>
<li><a href="https://platform.uno/">Uno Platform</a>は、単一のアプリケーションを開発し、それをWindows、macOS、iOS、Android、Linux、ブラウザで実行できるUIプラットフォームです。このプラットフォームは、アプリケーションがC#とXAMLで書かれており、かなりWindows中心に設計されているようです。また、レガシーアプリケーションを新たなプラットフォームに移植するために必要な労力を減らすことを目的とした活用例が非常に多いのも特徴です。</li>
<li><a href="https://www.amazon.science/blog/how-prime-video-updates-its-app-for-more-than-8-000-device-types">Amazon Prime</a>、<a href="https://medium.com/disney-streaming/introducing-the-disney-application-development-kit-adk-ad85ca139073">Disney+</a>、<a href="https://www.youtube.com/watch?v=28paRXqI-Gk">BBC</a>はいずれも自社の動画配信プラットフォームでWebAssemblyを利用しています。例えば、Amazon Primeでは、新機能を膨大な種類の端末に対応させつつ、問題ないパフォーマンスを維持するためにWebAssemblyが活用されています。</li>
</ul>
<p>WebAssemblyは、アプリケーションの移植以外にも、サーバサイドでの言語間の橋渡しとしても役立ちます。残念ながら、この用途の活用例はまだ多くありません。なぜなら、OSとの通信に利用されるインタフェース（<a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">Web Assembly System Interface</a>、略称WASI）や言語の境界を越えて機能するインタフェース（<a href="https://github.com/WebAssembly/component-model">Wasm Component Model</a>）は依然として開発途上であり、必要な成熟度に達していないためです。</p>
<h3>プラグインシステム</h3>
<p>ほとんどのアプリケーションは、ある程度の成熟度に達すると、エンドユーザによる拡張性が必要になります。従来のアプリケーションは、設定項目を大量に増やしたり、複雑なドメイン固有言語（DSL）を開発したりしてきましたが、管理がとても面倒になることや、開発者がよく知らない言語での作業を強いられることが常でした。</p>
<p>例を考えてみましょう。NGINXなどのシステムでリクエストのフィルタリング規則を設定するとします。そのためには、システム管理者は、なじみのない独自の設定言語で望ましいロジックを宣言型で実装しなければなりません。NGINXの開発者があらかじめ設定したマッチング演算子やフィルタリング演算子は、普段は役立ちますが、システム管理者が望む挙動を実装するうえで大きな妨げとなることがよくあります。また、利用できるツールが少ないので、問題が生じたときのデバッグはストレスがたまるでしょう。</p>
<p>一部の比較的新しいアプリケーションは異なるアプローチを採用しています。そのアプローチとは、インタフェースの標準的なセットを提供し、Wasmランタイムを組み込んだうえで、必要なカスタムロジックを実装するためのWasmバイナリはエンドユーザに提供させるものです。これにより、エンドユーザにとってはるかに柔軟でなじみのあるインタフェースが実現されます。エンドユーザは、自分が選んだ言語で、複雑なビジネスロジックを自由に実装できます。この機能は、他の言語ではセキュリティ上の懸念により不可能でしたが、Wasmではユーザが提供するコードをランタイムがサンドボックス化することによって実現しています。</p>
<p>現在の活用例を見てみましょう。</p>
<ul>
<li>元々Lyftによって開発され、現在では業界全体で利用されているEnvoyプロキシは、拡張機能をWasmで開発し、ランタイムで動的に<a href="https://github.com/proxy-wasm/spec/blob/master/docs/WebAssembly-in-Envoy.md">読み込む</a>ことを可能にしています。Envoyを基に開発されたサービスメッシュのIstioにも同様の機能があります。</li>
<li>Kafkaの代わりとして使用されているRedpandaでは、ユーザがWasmを利用して、独自の<a href="https://vectorized.io/blog/wasm-architecture/">ストリーミングデータ変換プログラム</a>を書くことができます。</li>
<li>Open Policy Agentでは<a href="https://www.openpolicyagent.org/docs/latest/wasm/">Wasmを利用</a>してポリシーを定義できます。</li>
<li>Minecraftサーバの<a href="https://github.com/feather-rs/feather">Feather</a>は、サンドボックス内でのプラグインの実行にWebAssemblyを利用しています。</li>
</ul>
<h3>サンドボックス化機能の組み込み</h3>
<p>WebAssemblyを他のアプリケーションに組み込むというアイデアは、プラグインシステム以外にとっても有用です。実際、サードパーティライブラリ全体のサンドボックス化や、ファーストパーティコード向けのセキュリティ層の構築に利用できます。</p>
<p>Firefoxはこの分野で<a href="https://hacks.mozilla.org/2021/12/webassembly-and-back-again-fine-grained-sandboxing-in-firefox-95/">先頭に立っており</a>、スペルチェックや画像のデコードなどに利用するサードパーティライブラリのバグから自らを守っています。Wasmは、「<a href="https://hacks.mozilla.org/2020/02/securing-firefox-with-webassembly/">汚染レイヤ</a>」を提供するRLBoxというツールと組み合わせることで、強引なプロセス隔離に頼ることなく、こうしたライブラリの脆弱性からシステムを保護します。Firefoxの場合、Wasmバイナリを最終リリースに搭載してすらいません。Wasmへのコンパイルと別の言語へのトランスパイルというプロセスによって、RLBoxとともに、必要なセキュリティを確保しているのです。</p>
<p>このアプローチは一部の重大な脆弱性の悪用を防止できるかもしれません。攻撃者は通常、複数の脆弱性を組み合わせて利用するため、こうした中間的なセキュリティ層は今後の安全性向上にとても役に立つでしょう。</p>
<h3>コンテナ化</h3>
<p>Dockerの創業者であるSolomon Hykesは、よく引用されている<a href="https://twitter.com/solomonstre/status/1111004913222324225?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1111004913222324225%7Ctwgr%5E%7Ctwcon%5Es1_&#x26;ref_url=https%3A%2F%2Fnickymeuleman.netlify.app%2Fblog%2Fwebassemblysecurity">ツイート</a>で、WebAssemblyの重要性を次のように強調しています。</p>
<blockquote>
<p>WASMとWASIが2008年に存在していたらDockerを開発する必要はなかった。それくらい重要な存在だ。サーバサイドのWebAssemblyはコンピューティングの未来だ。</p>
</blockquote>
<p>Wasmがコンテナ化の未来を示していると考えるのには<a href="https://kubesphere.io/blogs/will-cloud-native-webassembly-replace-docker_/">十分な理由</a>があります。<strong>Dockerと比べて、Wasmはコールドスタート時間が10～100倍高速で、メモリの使用量が少なく、機能の制約による優れたセキュリティモデルを採用しています</strong>。コンテナではなくWasmモジュールが演算とデプロイの標準的な単位となれば、拡張性とセキュリティは向上するでしょう。</p>
<p>こうした変化は突然起きるものではありません。したがって、Wasmベースのコンテナ化は、完全にDockerを代替するのではなく、既存のオーケストレーションシステムに統合される可能性が高いでしょう。</p>
<p>筆者は今後数年間でこの分野の動きがとても盛んになると予想します。既にいくつかのプロジェクトがいち早く動き始めています。</p>
<ul>
<li>Microsoft AzureのDeis Labsは<a href="https://krustlet.dev/">Krustlet</a>を開発しました。これは既存のKubernetesクラスタでWasmワークロードを実行する方法の一つです。</li>
<li>Deis Labsは、Wasmを中心とするPaaS（platform-as-a-service）の<a href="https://github.com/deislabs/hippo">Hippo</a>もリリースしました。筆者は<a href="https://github.com/fermyon">Fermyon</a>がこのテクノロジーの商用化を目指しているのではないかと推測します。</li>
<li><a href="https://cosmonic.com/">Cosmonic</a>は、<a href="https://github.com/wasmCloud/wasmCloud">wasmCloud</a>プロジェクトにおいて、分散システム向けにWasmコンテナ化とアクターモデルを結合するプラットフォーム兼オーケストレーション層を構築しています。</li>
<li><a href="https://github.com/lunatic-solutions/lunatic">Lunatic</a>プラットフォームもアクターモデルを採用しており、単一のWebAssemblyランタイムプロセス上で複数の軽量なコンテナを実行するための最高のサポート機能を搭載しているとみられます。</li>
<li><a href="https://suborbital.dev/">Suborbital</a>の<a href="https://github.com/suborbital/atmo">Atmo</a>もプラットフォーム兼オーケストレーションシステムですが、サーバレスのワークロードに比較的大きな重点を置いています。
### FaaS/サーバレスプラットフォーム
FaaS（function-as-a-service）プラットフォームは、ユーザ提供コードを高速かつ安全に実行する必要があります。サーバレスプラットフォームは、コードを短期間実行するために利用されることが多いため、起動時間が特に重要な指標となります。<strong>Wasmは超高速なコールドスタートと幅広い言語のサポートにより、サーバレスのワークロードにとって優れた選択肢となっています</strong><a href="#08">8</a>。</li>
</ul>
<p><a href="https://blog.cloudflare.com/webassembly-on-cloudflare-workers/">Cloudflare Workers</a>とFastly <a href="https://www.fastly.com/blog/how-compute-edge-is-tackling-the-most-frustrating-aspects-of-serverless">Compute@Edge</a>が提供するCDNエッジ・コンピューティング・プラットフォームには既にWebAssemblyの実行機能が搭載されています。Fastlyは、市場の他のサービスよりも起動時間が100倍速いと主張しており、その高速化の理由をWebAssemblyベースのコンパイラとランタイムにあるとしています。NetlifyとVercelもこの分野の製品を開発中です。</p>
<p>主要なクラウドプロバイダが構築したサーバレスプラットフォームも後れを取ってはいません。AWS Lambdaは数カ月前（※訳注：翻訳元の記事は2022年1月31日公開）にWebAssemblyサーバレス関数をローンチしており、GCPとAzureもこれに続くと予想されます。</p>
<h3>ブロックチェーン</h3>
<p>EthereumやSolanaなどのプラットフォームは、ブロックチェーン上で実行できる「スマートコントラクト」と呼ばれるコードをユーザが書くための仕組みを提供します。Ethereumは完全な独自システムを構築しており、コンパイル済みバイトコードのバイナリ表現であるSolidityという言語や、サンドボックスでコードを実行するためのEthereum Virtual Machineを作成しています。Solanaは一部既存のイノベーションを再利用することを選択しており、LLVMコンパイラインフラを利用して、C、C++やRustのコードをバイナリ形式のBerkeley Packet Filterバイトコードの一種にコンパイルします。しかし、Solanaも依然としてSealevelという独自のランタイムを開発しています。</p>
<p>WebAssemblyはこうしたインフラの大部分を既に提供しています。ユーザは、任意の言語でコードを書き、コンパイラインフラによってWasmバイトコードを作成し、無数の高性能なランタイムを利用できます。</p>
<p>しかし、EthereumとSolanaが既にこうしたインフラを構築しているならば、WebAssemblyはどんな価値を提供できるのでしょうか？実際には、主な付加価値はエコシステム関連にあります。例えば、Ethereumはスマートコントラクトを書くための独自言語を持っていますが、これは他言語で書かれたライブラリや共通関数をすべて活用することはできないという意味です。SolanaはRustエコシステムを利用できるため、その点ではEthereumをわずかに上回っています。<strong>WebAssemblyの技術的な課題が克服されれば、現在よりはるかに多くの人がスマートコントラクトを開発し、既に使い慣れたライブラリやツールを利用できるようになるでしょう</strong>。</p>
<p>このように考えているのは決して筆者だけではありません。例えば、Polkadotネットワークはランタイムとして<a href="https://eos.io/news/eos-virtual-machine-a-high-performance-blockchain-webassembly-interpreter/">WebAssemblyベースの仮想マシン</a>を使用しています。EOS仮想マシンも<a href="https://eos.io/news/eos-virtual-machine-a-high-performance-blockchain-webassembly-interpreter/">WebAssemblyがベース</a>です。<a href="https://cosmwasm.com/">CosmWasm</a>は複数のブロックチェーンで機能するスマートコントラクトの構築にWebAssemblyを使用しています。Ethereum Virtual MachineをWebAssemblyの一部のみで代替する「<a href="https://github.com/ewasm/design">eWASM</a>」という案もありましたが、これは立ち消えになったようです。Wasmerランタイムは、明確にブロックチェーン向けに構築された「シングルパス」コンパイラモードを提供します。一方、WasmEdgeは、Ethereumとの互換性があるスマートコントラクト実行エンジンを搭載していると主張しています。</p>
<h2>予測と展望</h2>
<h3>新たなアプリケーションアーキテクチャ</h3>
<p>Dockerが仮想マシンを完全に代替できなかったように、WasmもDockerを完全には代替できません。例えば、仮想マシンがカスタムOSカーネルを実行できるのに対して、Dockerのコンテナでは実行できません。同様に、Wasmのコンテナは、x86の256ビットAVX命令などの一部の特殊なCPU命令を利用できないため<a href="#09">9</a>、アプリケーションによってはDockerと同等のパフォーマンスを発揮することが不可能です。</p>
<p>筆者の見解では、DockerではサポートされているがWasmではサポートされていないワークロードの差は、現時点ではDockerと仮想マシンの同様の差よりも大きいと考えられます。しかし、Wasmはまだ発展途上のテクノロジーであるため、対応可能なワークロードの種類は増えていくでしょう。Dockerの台頭はマイクロサービスアーキテクチャの台頭と密接に連動していました。これにより、仮想マシンに適したモノリシックなアプリケーションはDockerのコンテナに適したマイクロサービスに置き換えられていきました。<strong>いずれはWebAssembly の独自機能を活用した新たなアプリケーションアーキテクチャが登場するでしょう</strong>。</p>
<p>コンウェイの法則によれば、アプリケーションのアーキテクチャは、そのアプリケーションを設計した組織のコミュニケーション構造を反映します。コンピューティングの歴史上すべての新しい「リファレンスアーキテクチャ」は、人と人の間で必要な調整の量を減らしてきました。メインフレームから仮想マシンやDockerのコンテナまで、デプロイ可能なユニットを生産するために必要な人間の数は徐々に減少しています。これは、システムをどんどん小さいコンポーネントに分解し、それらのコンポーネントを構築する作業者が、明確に定義されたインタフェースを参照しながら個別に作業できるようにすることによって実現されました。マイクロサービスがモノリシックなアプリケーションを複数の独立したサービスに分解する一方、<strong>WebAssemblyはマイクロサービスをさらに小さいコンポーネントに分解しやすくしています</strong><a href="#10">10</a>。</p>
<p>これはどのような結果を生むでしょうか？いくつかの可能性を紹介します。</p>
<ul>
<li>アプリケーションを中核的なビジネスロジックと他のシステムとの連携に必要なグルーコードに分割した場合、通常はビジネスロジックが他の部分よりかなり小さくなります。グルーコードのインタフェースを、それが提供する機能の実装から分離すれば、ビジネスロジック中心のアプリケーションを構築し、残りを外部の機能プロバイダに任せることが可能になります。これと、長く蚊帳の外に置かれていた<a href="https://www.brianstorti.com/the-actor-model/">アクターモデル</a>を組み合わせたものが<a href="https://github.com/wasmCloud/wasmCloud">wasmCloud</a>のアプローチの本質です。</li>
<li>もう一つの可能性は、サーバレスアーキテクチャがマイクロサービスを超える次のステップになるというものです。ほとんどのサービスはステートフルな部分とステートレスな部分に分割でき、ステートレスな部分は任意に拡張可能なサーバレス関数として実行できます。この場合、WebAssemblyは、こうしたサーバレス関数にとって便利で簡単に拡張可能なランタイムとして機能します。</li>
<li>WebAssemblyはサードパーティの依存関係についての見方を変えるかもしれません。モダンなコードはサードパーティのライブラリに大きく依存しており<a href="#11">11</a>、そうした依存関係のほとんどは十分に何度も調査されることがありません。最近の<a href="https://en.wikipedia.org/wiki/Log4Shell">Log4jの脆弱性</a>のようなソフトウェアのサプライチェーンの問題が明らかになるにつれて、人々はサードパーティライブラリのセキュリティを真剣に考えるようになると筆者は予想しています。Firefoxのように、WasmとRLBoxを利用して特定のライブラリを隔離するアプローチはいっそう広まっていくでしょう。パフォーマンス上の制約を克服できれば、同一のWasmランタイム内の機能が制約された別個のコンテナにサードパーティライブラリを隔離することも可能かもしれません<a href="#12">12</a>。</li>
</ul>
<h3>ブラウンフィールドへのデプロイ</h3>
<p>Wasmはいずれ何らかの形でDockerと相互運用できるようになる必要があります。今後2～3年は、Wasmの主な用途は後方互換性の要件が少ないグリーンフィールド（※訳注）へのデプロイとなるため、相互運用性が絶対に必要というわけではありません。しかし、最終的には、Wasmが（特に法人向け環境で）コンテナ化をめぐる競争に完全に勝利するには、ブラウンフィールド（※訳注）へのデプロイが簡単であることが必要です。
（※訳注：本翻訳は既存の投資用語を参照した表現として解釈します。「グリーンフィールド」既存環境による制約がない、新規開発できる環境。「ブラウンフィールド」既に既存のシステム等が動作している、制約つきの環境。）</p>
<p>考えられる結末の一つは、DockerがWasmランタイムを統合することです。これはあり得そうな話ですが、Wasmは今後、十分に差別化され、完全に別個のツールとして利用することが妥当になると筆者は予想しています。その代わり、<strong>DockerとWasmのコンテナはオーケストレーション層で統合されるでしょう</strong>。</p>
<p>KubernetesがWasmベースの実行を効果的に統合できるか、あるいは新たなオーケストレーションシステムが登場するかは、あまりはっきりしません。一方では、Kubernetesは現在、オーケストレーションに関して他の追随を許さない王者です。その勢いは驚異的で、Wasmによるコンテナ化の推進派はそれに乗じるのが賢明でしょう。MicrosoftのエンジニアはKubernetesとWasmが統合されるという未来に投資しており、<a href="https://github.com/krustlet/krustlet">Krustlet</a>を開発しています。これはKubernetesでWasmのワークロードを実行できるようにするものです。他方、WasmのコードはDockerのコンテナとは要件が異なるとみられるため、Kubernetesとは相性が良くない可能性があります。例えば、Wasmによるサードパーティライブラリの隔離を採用している場合、コンテナ間の通信のために共有メモリを設定するのが便利ですが、これはKubernetesでは困難でしょう。いずれはこうしたWasmネイティブのオーケストレータが懸け橋となり、Dockerからの移行やDockerとの統合が簡単になるはずです。</p>
<p>筆者はこれからWasmオーケストレータの波が来ることを期待していますが、Kubernetesは十分に定着しているため、すぐに廃れはしないでしょう。

### 標準化されたサーバレス/エッジフレームワーク</p>
<p>ほとんどのサーバレスプロバイダはルートやラムダ関数を定義するための独自のフレームワークを定めています。例えば、Cloudflareは独自の「cf」という型を定め、コードのスキャフォールディングを設定するためにwranglerというCLIツールを提供しています。Fastlyにはキャッシュとのインタラクションとロギングのための一連の独自インタフェースがあり、AWS Lambdaにも同様の設定が存在します。KubernetesのFissionフレームワークは、さまざまな言語を統合するための独自ライブラリを持っています。一部のプラットフォームは、ユーザにDockerのコンテナを提供させ、プラットフォームが実行のみをすれば良いようにすることで、この問題を回避しようとしています。<a href="https://knative.dev/docs/">Knative</a>と<a href="https://fly.io/">Fly.io</a>はどちらもこのアプローチを採用しています。しかし、これらはコールドスタート時間の影響を軽減するために「ワーカープールを温めておく」問題をユーザに転嫁しなければなりません。</p>
<p>現在は標準化されたサーバレス関数の定義とデプロイ仕様を構築するチャンスがあります。人気の<a href="https://github.com/serverless/serverless">Serverless Framework</a>は、デプロイの抽象化にはそれなりに役立ちますが、依然としてプロバイダ固有の詳細な部分は関数の実装に委ねられています。こうした詳細部分が抽象化されれば、すぐにマルチクラウドのデプロイは大幅に簡単になり、このフレームワークははるかに強力になるでしょう。いずれはサーバレスにおけるTerraformのような存在になるかもしれません<a href="#13">13</a>。</p>
<h3>パッケージ管理</h3>
<p>あらゆるプログラミング言語には、その言語を取り巻くエコシステムが存在します。ほとんどのモダンな言語は一元的なパッケージレジストリを利用しており、PythonにはPyPI、Node.jsにはnpm、Rustにはcrates.ioがあります。こうしたレジストリやそれに付属するツールとワークフローは、高品質なエコシステムの開発や開発者の作業の効率化にとって重要です。</p>
<p>Wasmの場合、<a href="https://wapm.io/">WebAssembly Package Manager</a>（WAPM）がこの需要を満たすはずでした。しかし、実際にはプロジェクトはほとんど休止しているようです。この記事の執筆時点（※訳注：翻訳元の記事は2022年1月31日公開）で、<a href="https://web.archive.org/web/20211229050050/https://wapm.io/">過去2カ月</a>に更新されたパッケージは3つにとどまっています。問題は、パッケージがお互いに依存すると想定されているのに対し、WAPMが相互依存関係のないスタンドアロンのWasmバイナリでしか機能しないことです。開発者にとって他の選択肢はWasmモジュールをnpmに公開することですが、npmは言語をまたぐ相互運用性を促進するものではないため、当然ながらJavaScriptやAssemblyScriptを越えるWasmエコシステムを構築するうえで理想的とは言えません。</p>
<p>問題の原因は、実際にはWAPMやnpmではなく、WebAssembly自体が粗削りな点にあります。</p>
<blockquote>
<p>現在、意味のあるWebAssemblyアプリケーションを書き、それがランタイムや言語の境界を越える相互運用性を持つようにするには、多大な労力が求められます。また、基本的でないデータ型（文字列や構造体など）のやり取りにはポインタの演算と低水準なメモリの操作が必要です。</p>
<p><a href="https://radu-matei.com/blog/intro-wasm-components/">― Introduction to WebAssembly components | radu’s blog</a></p>
</blockquote>
<p>これこそ、まさにWebAssembly Component Modelが解決しようとしている問題です。WasmコンポーネントはWebAssembly Interfaceフォーマットを標準化し、こうしたインタフェースの実装・利用の両方のための<a href="https://github.com/bytecodealliance/wit-bindgen">コードジェネレータ</a>を提供します。つまり、Wasmでランタイムと言語の壁を乗り越えるのが簡単になるのです。</p>
<p>WebAssemblyには高品質なパッケージマネージャを構築する大きな機会があります。このパッケージマネージャは、Wasmモジュールを他の言語から利用するためのバインディングを生成するのにWasmコンポーネントのcodegenを利用すべきでしょう。このツールが十分に優れていれば、言語をまたぐ開発がとても簡単になり、サーバサイドのWebAssemblyエコシステムの可能性を本当の意味で広げる可能性があります。Wasmパッケージレジストリは、他のパッケージレジストリと連携し、適切に生成されたバインディングとともにパッケージをPyPI、npm、crates.ioに自動的に公開することもできるかもしれません。</p>
<h2>終わりに</h2>
<p>ここまで読んできた方は、「WebAssemblyがそんなに優れているなら、なぜ広く使われていないのか？」と考えていることでしょう。その理由をいくつか挙げたいと思います。</p>
<ul>
<li>WebAssemblyはマーケティングがうまくありません。WebAssemblyはWeb限定でもアセンブリでもなく、名前が実体とかけ離れています。WebAssemblyは主にWeb開発者向けにマーケティングと宣伝が行われていますが、実際のポテンシャルは<a href="https://blog.bitsrc.io/whats-wrong-with-web-assembly-3b9abb671ec2">ブラウザを越えたところ</a>にあります。本当の力が明らかになるのは、C++とRustの開発者がWasmの持つポテンシャルに一斉に気づき始めたときでしょう。</li>
<li>WebAssemblyは依然として標準化されていません。例えば、WebAssembly System Interfaceには正式に標準化されていない無数の拡張機能がありますが、さまざまなランタイムがこうした拡張機能の一部を実装しています。ユニバーサルポータビリティという目標も完全には実現されていません。</li>
<li>言語間のインタラクション機能が不便です。ユーザが実際にさまざまな言語でWasmを使用し始めるには、クリティカルマスに相当する数の言語について、WebAssemblyコンポーネントと優れたコードジェネレータが必要です。</li>
<li>開発者体験に大きな改善の余地があります。<a href="https://thenewstack.io/the-pain-of-debugging-webassembly/">デバッグをはじめ</a>とするツールや、パッケージマネージャ、ビルドシステム、IDEとの統合性が改善されることが理想です。</li>
<li>こういうことは言いたくないのですが、WebAssemblyのライブラリ隔離機能が正当に評価されるには、Log4Shellと同様の規模の深刻なソフトウェア・サプライチェーン・インシデントがあと何回か起きる必要があるでしょう。</li>
</ul>
<p>WebAssemblyは名だたる数々のサービスで導入されており、さまざまな用途に利用できますが、IT業界全体では一部で散発的に使われているにすぎません。筆者の友人の中でWebAssemblyを知っている数少ない人たちは、基本的にはWebAssemblyをとても面白いと考えているものの、まだ十分に成熟していないため開発には利用していません。しかし、こうした課題の多くに対して積極的な取り組みが行われており、今後1～2年で問題ない状態に達するでしょう。ですから、<strong>私たちは現在、WebAssemblyの利用、エコシステム、コミュニティが爆発的に拡大する瀬戸際にあると思われます</strong>。</p>
<p><em><a href="https://news.ycombinator.com/item?id=30155295">Hacker News</a>での議論にぜひご参加ください。また、<a href="https://harshal.sheth.io/about">筆者へのご意見も歓迎します</a>。この記事の初期の草案に対するフィードバックをくれたNihar Sheth、Mohak Jain、Andrew Sun、Michelle Fangに感謝します。</em></p>
<h3>注記</h3>
<ol>
<li><a name="01"></a>実際には若干微妙な部分があります。WasmにはWeb APIとWebAssembly System Interface（WASI）APIという2つの<a href="https://v8.dev/blog/emscripten-standalone-wasm">標準的なAPI</a>が存在します。また、WebAssemblyは急速に進化しているため、例えばスレッディングのように、広く実装されているが正式には標準化されていない実験的機能が数多くあります。それ以外にも、Wasmが別のアプリケーションに組み込まれる場合、そのアプリケーションが独自のAPIを提供するかもしれません。したがって、Wasmコードが実行されるのは、そのランタイムが対応しているAPIと機能のみを使用する場合に限られますが、これは十分に妥当な想定と言えます。↩</li>
<li><a name="02"></a>なぜかは分かりませんが、WebAssemblyのランタイムの名前はすべて「wa」で始まるようです。他にも<a href="https://github.com/WasmEdge/WasmEdge">WasmEdge</a>、<a href="https://github.com/WAVM/WAVM">WAVM</a>、<a href="https://github.com/wasm3/wasm3">wasm3</a>があります。数少ない例外の一つが<a href="https://github.com/wasmx/fizzy">Fizzy</a>ですが、このプロジェクトもwasmxという組織によってホストされています。↩</li>
<li><a name="03"></a>ただし、PythonやRubyなどのインタプリタ型言語やGoなどのランタイムが複雑な言語は、Wasmで実行しても良いパフォーマンスを生まないでしょう。↩</li>
<li><a name="04"></a>Firefoxでは、Wasmへのコンパイルはネットワークによるパケットの送信よりも実際に<a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">速くなります</a>。<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">WebAssembly.instantiateStreaming</a>メソッドにより、ファイルのダウンロード完了前からコンパイルのプロセスを開始できるため、Wasmコードの実行開始前のレイテンシはごくわずかしか増加しません。↩</li>
<li><a name="05"></a>ただし、それでも小さな欠点は残っています。機能ベースの許可システムは依然として粒度が非常に高いわけではなく、ほとんどのWasmランタイムはSpectreのようなサイドチャネル攻撃を防止できないため、追加的な戦略が必要になります。CloudflareのKenton Vardaは、自社の脅威モデルと、脅威を軽減するために実装した対策について、<a href="https://blog.cloudflare.com/mitigating-spectre-and-other-security-threats-the-cloudflare-workers-security-model/">詳細な記事</a>を執筆しています。↩</li>
<li><a name="06"></a>WasmはJavaScriptの「ファストパス」から逸脱した場合に生じる脱最適化の問題を回避できるため、JavaScriptの最高のパフォーマンスと同等以上のパフォーマンスで安定して高速にコードを実行できます。面白いことに、実はJavaScriptをWebAssemblyにコンパイルして元のコードの代わりに実行するだけで、ブラウザでJavaScriptの実行を高速化することが可能です。Lin Clarkはその方法とそれがうまくいく理由について、<a href="https://www.youtube.com/watch?v=CRaMls9oVBw">素晴らしい講演</a>を実施しています。↩</li>
<li><a name="07"></a>数年前にFigmaの技術リーダーとの個人的な会話で聞いた情報です。Google ChromeやFirefoxなどの多くのブラウザは既に内部でSkiaを利用しています。しかし、こうしたブラウザはSkia APIを直接は公開していないため、アプリケーションは低速なブラウザDOMやSVGインタフェースを利用しなければなりません。Figmaはこうした低速なレイヤを回避し、ブラウザのキャンバス要素に直接描画しますが、依然としてアプリケーションへの<a href="https://skia.org/docs/user/modules/canvaskit/">組み込み</a>を通じてSkiaの一部の機能を利用しています。↩</li>
<li><a name="08"></a>他にも注目すべき選択肢があります。例えば、AWS Lambdaは軽量な<a href="https://firecracker-microvm.github.io/">Firecracker microVM</a>を利用しています。両者を直接比較すると、<a href="https://arxiv.org/ftp/arxiv/papers/2010/2010.07115.pdf">WebAssemblyのパフォーマンスの方が少し優れています</a>。↩</li>
<li><a name="09"></a>WebAssemblyによる128ビット型のSIMDのサポートは、現在は実験的な段階にありますが、多くのブラウザとランタイムに実装されています。「ロングSIMD」のサポートは引き続き<a href="https://github.com/WebAssembly/design/blob/5b2c607fe173c813214afde33e0ea82d33dd0983/FutureFeatures.md#long-simd">今後の課題</a>と言えます。↩</li>
<li><a name="10"></a>この主張に対する反論は、「マイクロサービスを分解できるからといって、実際に分解するとは限らない」というものです。これは確かにもっともな批判であり、実はモノリスとマイクロサービスの関係にも当てはまります。例えば、「マイクロサービスを本番環境で始めるべきではない――モノリスは君の友人だ」という<a href="https://arnoldgalovics.com/microservices-in-production/">最近の記事</a>は<a href="https://news.ycombinator.com/item?id=29576352">大きな議論</a>を呼びました。それでも、マイクロサービスアーキテクチャは、適切な状況で導入すればとてつもなく有効で、生産性を大幅に高めます。筆者はWebAssembly中心のアーキテクチャにも同じことが言えると予想しています。ただし、WebAssemblyに適した状況がどれだけ存在するかはあまりはっきりしません。↩</li>
<li><a name="11"></a>この問題はとても有名で、<a href="https://www.reddit.com/r/ProgrammerHumor/comments/992u1p/dependencies_101/">これ</a>に<a href="https://xkcd.com/2347/">関する</a><a href="https://www.reddit.com/r/ProgrammerHumor/comments/6s0wov/heaviest_objects_in_the_universe/">ミーム</a>が存在するほどです。↩</li>
<li><a name="12"></a>誰かがこうしたサービスを提供する企業を設立すべきでしょう。最近Log4jの脆弱性が判明したことで、ソフトウェアのサプライチェーンは現在、最も重要な問題となっています。さらに、ほとんどの既存企業は依存関係の隔離よりも検証に重点を置いているようです。↩</li>
<li><a name="13"></a>これは最適な比較対象ではないかもしれません。なぜなら、Terraformがデプロイやクラウドプロバイダとのインタラクションのみを抽象化するのに対し、このフレームワークはコード層でも機能するからです。↩</li>
</ol>]]></content:encoded></item><item><title><![CDATA[Miško HeveryのQwik記事シリーズ]]></title><description><![CDATA[POSTDでは、DEV Communityで公開されているQwikシリーズ の翻訳記事を公開予定です。 翻訳記事の更新に合わせてこのページも更新されていきます。 シリーズ記事一覧 Qwikの紹介 –…]]></description><link>https://postd.cc/series-qwik/</link><guid isPermaLink="false">https://postd.cc/series-qwik/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:01:00 GMT</pubDate><content:encoded><![CDATA[<p>POSTDでは、DEV Communityで公開されている<a href="https://dev.to/mhevery/series/13467">Qwikシリーズ</a> の翻訳記事を公開予定です。</p>
<p>翻訳記事の更新に合わせてこのページも更新されていきます。</p>
<h2>シリーズ記事一覧</h2>
<ol>
<li><a href="/a-first-look-at-qwik-the-html-first-framework/">Qwikの紹介 – HTMLファーストのフレームワーク</a></li>
<li><a href="/death-by-closure-and-how-qwik-solves-it/">クロージャによる死（とQwikによる解決方法）</a></li>
<li><a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣</a></li>
<li><a href="/qwik-the-answer-to-optimal-fine-grained-lazy-loading/">Qwik：最適できめ細かい遅延読み込みを実現</a></li>
<li><a href="/how-to-score-100-on-google-pagespeed-insights-on-mobile/">モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには</a></li>
<li><a href="/your-bundler-is-doing-it-wrong/">既存のバンドラの手法は間違っている</a></li>
<li><a href="/how-we-cut-99-of-our-javascript-with-qwik-partytown/">QwikとPartytownでJavaScriptを99%削減する方法</a></li>
<li><a href="/introducing-qwik-starters-get-up-and-running-with-qwik-now/">Qwikスターターの紹介 – 今すぐQwikを起動・実行してみよう</a></li>
</ol>]]></content:encoded></item><item><title><![CDATA[Qwikスターターの紹介 – 今すぐQwikを起動・実行してみよう]]></title><description><![CDATA[コードを書いて新たな発見をするほど楽しいことはありません。
ついにの登場です。
どんなサイズでもリーンで高パフォーマンスなWebアプリを開発するための新たな方法をお試しください。
builder.i…]]></description><link>https://postd.cc/introducing-qwik-starters-get-up-and-running-with-qwik-now/</link><guid isPermaLink="false">https://postd.cc/introducing-qwik-starters-get-up-and-running-with-qwik-now/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:00:02 GMT</pubDate><content:encoded><![CDATA[<p>コードを書いて新たな発見をするほど楽しいことはありません。
ついに<code class="language-text">npm init qwik</code>の登場です。
どんなサイズでもリーンで高パフォーマンスなWebアプリを開発するための新たな方法をお試しください。
<a href="https://www.builder.io/">builder.io</a>のサイトも同じ技術で開発されており、<a href="https://www.builder.io/blog/how-we-cut-99-percent-js-with-qwik-and-partytown">PageSpeed Insights</a>で100点中100点を獲得しています。</p>
<p>QwikスターターCLIは、Qwikを試しに直接体験してみて、他のフレームワークとの違いを深く理解するためのシンプルなスターターです。

このCLIに含まれている例は次の4つで、近い将来に拡張される予定です。</p>
<ul>
<li><code class="language-text">starter</code>：基本的なHello Worldプログラム。</li>
<li><code class="language-text">starter-builder</code>：基本的なHello Worldプログラムをbuilder.ioの<a href="https://www.builder.io/c/docs/qwik-api">Qwik API</a>と統合したもの。</li>
<li><code class="language-text">starter-partytown</code>：基本的なHello Worldプログラム。<a href="https://github.com/BuilderIO/partytown">Partytown</a>を利用して、Web Workerで重いタスクを実行できることを明らかにします。</li>
<li><code class="language-text">todo</code>：古典的な<a href="https://todomvc.com/">TodoMVC</a>アプリケーション。</li>
</ul>
<h2>基本的なスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-starter
✔ Select a starter › Starter
✔ Select a server › Express

⭐️ Success! Project saved in qwik-starter directory

📟 Next steps:
   cd qwik-starter
   npm install
   npm start

> (cd qwik-starter; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--pTKj8XhI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F17ab71fc12be4fbb9a8b19415998995f%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-starter">StackBlitz</a>で試す</p>
<h2>Builder Qwik APIを利用するスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-builder
✔ Select a starter › Starter Builder
✔ Select a server › Express

⭐️ Success! Project saved in qwik-builder directory

📟 Next steps:
   cd qwik-builder
   npm install
   npm start

> (cd qwik-builder; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--pLn7Tx8D--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F8c4425a663a84a41a85555f53f2665fc%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-todo-builder">StackBlitz</a>で試す</p>
<h2>Partytownを利用するスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-partytown
✔ Select a starter › Starter Partytown
✔ Select a server › Express

⭐️ Success! Project saved in qwik-partytown directory

📟 Next steps:
   cd qwik-partytown
   npm install
   npm start

> (cd qwik-partytown; npm install; npm start) </span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Z3-eRBUs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F135effed7c724979b0fe246bd9cc20ac%3Fformat%3Dwebp%26width%3D2000"></p>
<h2>古典的なTodoMVC</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-todo
✔ Select a starter › Todo
✔ Select a server › Express

⭐️ Success! Project saved in qwik-todo directory

📟 Next steps:
   cd qwik-todo
   npm install
   npm start

> (cd qwik-todo; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--jlVYtU6n--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252Fc7c0ea671c4547ecb2cd7da50843b97f%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</p>
<h2>プロファイラで解析</h2>
<p>開発ツールを開き、上記の例をすべてプロファイラで解析してみてください。
メインスレッドでほとんど時間がかかっていないのが分かるでしょう。</p>
<p>皆さんのコーディングが楽しくなることを願っています。ぜひフィードバックをお寄せください。</p>
<ul>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[QwikとPartytownでJavaScriptを99%削減する方法]]></title><description><![CDATA[うれしいことに、builder.ioのホームページは今やモバイル端末でもPageSpeed Insightsで100点中100点をとれるようになりました。
これはQwikを導入したおかげです。 Qw…]]></description><link>https://postd.cc/how-we-cut-99-of-our-javascript-with-qwik-partytown/</link><guid isPermaLink="false">https://postd.cc/how-we-cut-99-of-our-javascript-with-qwik-partytown/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>うれしいことに、<a href="http://builder.io/">builder.io</a>のホームページは今やモバイル端末でも<a href="https://pagespeed.web.dev/report?url=https%3A%2F%2Fbuilder.io%2F">PageSpeed Insights</a>で100点中100点をとれるようになりました。
これは<a href="https://github.com/builderio/qwik">Qwik</a>を導入したおかげです。</p>
<p><a href="https://github.com/builderio/qwik">Qwik</a>はアプリケーションの規模に関係なく高いパフォーマンスを実現します。
上記のスコアは、以下の優れた技術によって達成されました。</p>
<ul>
<li><a href="https://github.com/builderio/qwik">Qwik</a>で提供されるページの起動に必要なJavaScriptは1KB未満</li>
<li>ホームページは画面上の領域のコンテンツに必要なHTMLのみを送信</li>
<li><a href="https://github.com/BuilderIO/partytown">Partytown</a>を利用し、すべてのサードパーティスクリプトをWeb Workerに移動</li>
<li><a href="https://builder.io/">builder.io</a>の視覚的なノーコードエディタを利用してサイトを作成</li>
</ul>
<p>Qwikは、数百のコンポーネントや数MBのコンテンツを有する大規模なサイトでも高速なパフォーマンスを実現します。
また、クライアントコンポーネントに移動できるインタラクティブなサーバーサイドコンポーネントも提供します。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aDEN_dzQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mfuty5116bna9h6xyawr.png"></p>
<h2>過去のスコア</h2>
<p>当社のストーリーはここから始まりました。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--CzQUpHAt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ol56o66cw8gpxsbxaixr.png"></p>
<p>注目すべき点は、サイトのパフォーマンスが平均的であることです。
GoogleのPageSpeed Insightsは、モバイル端末において、ページの読み込みが開始されてから、ユーザーがリンクをクリックして反応が返ってくるまでの時間を7.6秒と推定していました。
これは優れたユーザー体験とは言えません。
さらに、GoogleはPageSpeed InsightsのスコアをSEOランキングに反映しています。</p>
<p>スコアがいまひとつである理由は、サイトの起動時に大量のJavaScriptを実行する必要があるためです。
現在は静的サイトでも、メニューやインタラクティブコンテンツに加え、Google Tag Manager、Intercom、CRMサービスといったサードパーティの解析スクリプトを追加するために、多くのJavaScriptを搭載しています。</p>
<p>JavaScriptサイトの速度を遅くする主な要因は、サイト自体とサードパーティスクリプトの2つです。</p>
<p>低速化の第1の原因はフレームワークです。
現代のフレームワークは優れた開発者体験を提供し、Webサイトのインタラクティブ性を高めます。
しかし、その代わりに大規模なJavaScriptをダウンロードする必要があるうえに、サーバーで生成されたHTMLと、フレームワークが予測するDOMを照合しなければならないため、起動時間が遅くなります。
このプロセスは差分検出や再ハイドレーションと呼ばれており、あらゆるフレームワーク（Qwikを除く）はこの宿命から逃れられません。
差分検出や再ハイドレーションで重要なのは、フレームワークがリスナーをDOMにアタッチし、サイトをインタラクティブにする部分です。
これが理由で、差分検出や再ハイドレーションは可能な限り早くしなければなりません。
そうしないと、サイトが機能しなくなります（メニューやチャットウィジェットがないサイトを想像してみてください）。</p>
<p>低速化の第2の原因はサードパーティスクリプトです。
確かに、現実にはPageSpeed Insightsのスコアが良いデモサイトや「新築」のWebサイトが数多くありますが、ほとんどの場合、スコアが良い理由はサードパーティスクリプトがまだ搭載されていないからです。
当社のサイトに搭載されているサードパーティスクリプトをいくつか紹介します。</p>
<ul>
<li>Google Tag Manager：現在のあらゆるサイトにとって必須の存在です。利用状況に関する統計データを収集し、サイトの使われ方や、どう改善すれば良いかについて、マーケティング上の知見を得るために利用されます。Google Tag Managerは最初に実行され、PageSpeed Insightsにおけるサイトの基準タイム以上のCPU処理時間を単独で消費するため、スコアが低下します。</li>
<li>Intercom：顧客がサイトで開発者とリアルタイムでチャットし、質問をしたり、詳しい情報を聞いたりすることができます。</li>
<li>Twitter：当社の製品に関する感想はTwitterウィジェットに表示されます。ウィジェットを利用するにはTwitterのJavaScriptを読み込む必要があります。</li>
</ul>
<p>これらのスクリプトはすべて、サイトが読み込まれた時点で即座に実行され、上記の差分検出や再ハイドレーションのステップのためにCPUを奪い合うので、ユーザー体験が悪化します。</p>
<p>問題は開発者がこうした状況をほとんどコントロールできないことです。
マーケティングチームが必要とする解析機能やユーザーサービス機能を追加するには、サードパーティスクリプトを利用しなければなりません。
また、サイトの起動時に時間のかかる差分検出が求められる既存のフレームワークを利用する必要もあります。
開発者がコントロールできる部分は多くありません。
これが業界の現状であり、そのため標準的なアプローチでは誰もあまり良い結果を出せません。</p>
<p>QwikとPartytownは、この問題の解決を目指しています。</p>
<h2>現在のスコア</h2>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aDEN_dzQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mfuty5116bna9h6xyawr.png"></p>
<table>
<thead>
<tr>
<th>指標</th>
<th>前</th>
<th>後</th>
<th>単位</th>
<th>%</th>
</tr>
</thead>
<tbody>
<tr>
<td>パフォーマンススコア</td>
<td>52</td>
<td>100</td>
<td>秒</td>
<td>92%</td>
</tr>
<tr>
<td>First Contentful Paint</td>
<td>3.4</td>
<td>1.1</td>
<td>秒</td>
<td>309%</td>
</tr>
<tr>
<td>Speed Index</td>
<td>3.4</td>
<td>1.1</td>
<td>秒</td>
<td>309%</td>
</tr>
<tr>
<td>Largest Contentful Paint（LCP）</td>
<td>3.8</td>
<td>1.2</td>
<td>秒</td>
<td>316%</td>
</tr>
<tr>
<td>Time to Interactive（TTI）</td>
<td>7.6</td>
<td>1.4</td>
<td>秒</td>
<td>543%</td>
</tr>
<tr>
<td>TTI – LCP（差）</td>
<td>3.8</td>
<td>0.3</td>
<td>秒</td>
<td>1,266%</td>
</tr>
<tr>
<td>Total Blocking Time</td>
<td>1,300</td>
<td>40</td>
<td>ミリ秒</td>
<td>3,250%</td>
</tr>
<tr>
<td>Cumulative Layout Shift</td>
<td>0</td>
<td>0</td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
<p>この数値はモバイル端末のものです。
モバイル端末はデスクトップに比べて、優れたパフォーマンスを達成するためのハードルがはるかに高くなります。</p>
<p>上記の表は、当社が現在、QwikとPartytownでどれだけのスコアを達成したかを示しています。
これは非常に大きな改善と言えます。
Time to Interactiveは7.6秒から1.2秒へ、Total Blocking Timeは1.3秒から40ミリ秒へ短縮されています。
JavaScriptの実行時間を短縮できた直接の要因は、フレームワークについてはQwik、サードパーティスクリプトについてはPartytownです。</p>
<p> <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ky-SejuS--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/66w9x8saqkumy3nttv4d.png"></p>
<p>上記はQwikとPartytownを導入する前のパフォーマンスの解析結果です（モバイル端末のエミュレート）。</p>
<ul>
<li>ページの読み込みには1.8秒かかっています。</li>
<li>メインスレッドは、ほとんどの時間、「差分検出」（DOMリスナーを設置する場所を探す作業）で非常にビジーな状態です。</li>
<li>上記の結果、多くのフレームが落ちています。</li>
<li>メインスレッドが「差分検出」でビジーになる前に、JavaScriptコードを読み込むためのカスケードが生じています。</li>
</ul>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--NFv_raDZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4940z1i5ar81b1kq3340.png"></p>
<p>ここで、従来の起動時のパフォーマンスと、QwikとPartytownを導入した後のパフォーマンスを比較してみましょう。</p>
<ul>
<li>JavaScriptはダウンロードしていません。</li>
<li>ページの読み込みにかかった時間は0.5秒です。</li>
<li>メインスレッドは、ほぼアイドル状態です。</li>
<li>フレームはほとんど落ちていません。</li>
<li>Partytownの読み込みは後回しにされています。</li>
<li>サードパーティスクリプトは（メインスレッドではなく）Web Workerで実行されています。</li>
</ul>
<p>過去と現在のパフォーマンスには明らかな違いがあります。</p>
<p>重要なことは、QwikやPartytownのアルゴリズムが特別に優れているわけではないということです。
QwikやPartytownはほとんどのJavaScriptをメインスレッドから移動させて負担を軽減しており、それによってページを高速に読み込んでいます。
ただし、Qwikでは、たとえJavaScriptがほぼ存在しなくても、ページは完全にインタラクティブな状態に維持されます。
Qwikは「良いとこ取り」が可能なのです。JavaScriptのサイズを見てみましょう。</p>
<table>
<thead>
<tr>
<th>指標</th>
<th>最小化</th>
<th>圧縮</th>
</tr>
</thead>
<tbody>
<tr>
<td>ベースライン（メインスレッドのJavaScript）</td>
<td>1,800KB</td>
<td>326KB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Qwik + Partytown (Main Thread JS)</strong>*</td>
<td>3.5KB</td>
<td>2.5KB</td>
</tr>
<tr>
<td>-->パート：Qwikloader</td>
<td>.5KB</td>
<td>1KB</td>
</tr>
<tr>
<td>-->パート：Partytown confg</td>
<td>.5KB</td>
<td>1KB</td>
</tr>
<tr>
<td>-->パート：Partytown</td>
<td>2.5KB</td>
<td>1.5KB</td>
</tr>
<tr>
<td>===サイズの改善===</td>
<td>51,429%</td>
<td>13,000%</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Web WorkerのサードパーティJavaScript</td>
<td>219KB</td>
<td>82KB</td>
</tr>
<tr>
<td>-->パート：Zoominfo</td>
<td>1.5KB</td>
<td>1.3KB</td>
</tr>
<tr>
<td>-->パート：Google Tag Manager</td>
<td>167KB</td>
<td>60KB</td>
</tr>
<tr>
<td>-->パート：Google Analytics</td>
<td>50KB</td>
<td>21KB</td>
</tr>
<tr>
<td>-->パート：site-tracking</td>
<td>217KB</td>
<td>64KB</td>
</tr>
</tbody>
</table>
<p>メインスレッドのJavaScriptを1.8MBから3.5KBに縮小できました。これは素晴らしい成果です。</p>
<p>元のサイトのJavaScriptは1.8MBで、うち219KBは開発者がコントロールできないサードパーティスクリプトでした。
つまり、サイト自体のJavaScriptは1.6MBで、そこには再ハイドレーションが必要なフレームワーク、テンプレート、スタイリングが含まれます。
標準的なフレームワークを利用する場合、サイトはコンテンツを2回ダウンロードすることになります。
1回目はHTMLとして、2回目はJavaScriptとしてのダウンロードです。
二重のダウンロードが1.6MBのコードの主な要因です（圧縮すると大幅に減って244KBになるため、サイトのテンプレートであると分かります）。</p>
<p>こちらを基準として、QwikとPartytownを利用した場合の3.5KBと比較してみましょう（圧縮すると2.5KB）。
再度強調しますが、QwikとPartytownを利用すれば、メインスレッドで実行する必要があるJavaScriptはわずか3.5KBになります。
メインスレッドの仕事がないので、サイトの読み込みはとても高速になります。
もう1つのポイントは、どんなにサイトが複雑化しても3.5KBのサイズは変わらず、いわば「固定費」であることです。</p>
<p>サードパーティコードの実行に関する問題はまだ残っていますが、これらのコードはメインスレッドより優先順位が低いWeb Workerのスレッドに再配置されています。
サードパーティコードは全体でも220KBで、メインスレッドのパフォーマンスに影響を及ぼさずに役割を果たすことができます。</p>
<p>さらに、もう1つポイントがあります。先ほど述べたとおり、既存のフレームワークはサイトを2回ダウンロードする必要があります。
1回目はHTMLとして、2回目はJavaScriptとしてのダウンロードで、JavaScriptのサイズは1.6MBです。
このような場合にQwikは威力を発揮します。
Qwikは1.6MBのJavaScriptを複数の異なるチャンクに分割します。
そして、Qwikはユーザーインタラクションがあったときだけ、JavaScript全体の一部だけをダウンロードします。
Qwikはコンポーネントを順不同に、かつ遅延して再ハイドレーションできます。
そのため、ユーザーがページ上で何らかのインタラクションをするまで、JavaScriptはまったく必要ありません。
さらに、ハイドレーションがコンポーネントごとに独立しているため、ユーザーのインタラクション時にJavaScriptのごく一部をダウンロード・実行するだけで、インタラクトされたコンポーネントのみをハイドレートできます。</p>
<p>つまり、メリットは以下の2つです。</p>
<ol>
<li>ページの起動時に何もする必要がない。</li>
<li>再ハイドレーションの必要があるときでも、範囲を限定し、（ページ全体ではなく）1つのコンポーネントだけを再ハイドレートできる。</li>
</ol>
<p>最後に注目しておきたいのは、ページの大部分は静的なのでその部分のコンポーネントがハイドレートされることはなく、JavaScriptもまったくダウンロードされないという点です。</p>
<h2>Qwikとは？</h2>
<p>QwikはTime to Interactiveに焦点を当てた新しいタイプのWebフレームワークです。
Qwikには、サーバーで実行を開始し、HTMLへシリアライズし、クライアントに送信できるというResumability（再開性）があります。
クライアント側では、qwikloader.js（クライアント側で実行される1KB未満のJavaScript）がアイドル状態でユーザーのインタラクションを待っています。
ユーザーがインタラクトすると、Qwikはサーバーが処理を中断したところから実行を再開できます。
QwikにはResumabilityがあるので、起動時に差分検出をする必要がなく、ユーザーがインタラクトしたコンポーネントのみをハイドレートすればよいのです。
Qwikはサーバーでコンポーネントを作成し、それをクライアントへシームレスに移動できます。
これらすべてのプロセスによって、上記のとおり、アプリケーションは即座に利用可能になります。</p>
<h2>画面外領域のコンテンツを遅延読み込み</h2>
<p>QwikはすべてのステートをDOMに保持します。
これはQwik自体がステートレスであるという意味です。
ステートレス属性によって、画面外領域のコンテンツを遅延読み込みできます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o48jE9q6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/565yei3n8jydkkvs81yr.gif"> </p>
<p>上記は既存のフレームワークではとても困難ですが、Qwikなら朝飯前です。</p>
<h2>Partytownとは？</h2>
<p>PartytownはサードパーティスクリプトをWeb Workerに再配置できます。
サードパーティスクリプトは、サイトのTime to Interactiveを遅くする最大の原因になっていることがよくあります。</p>
<h2>次はどうなる？</h2>
<p>私たちは、Qwikを皆さんに早く届けるために尽力しています。
Qwikによってどんなに素晴らしいサイトを開発できるか、皆さん自身の目で確かめてください。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[既存のバンドラの手法は間違っている]]></title><description><![CDATA[最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、…]]></description><link>https://postd.cc/your-bundler-is-doing-it-wrong/</link><guid isPermaLink="false">https://postd.cc/your-bundler-is-doing-it-wrong/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、遅延読み込みをする場所とタイミングを決定します。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> chunk <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-chunk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>someSymbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>開発者は以下を行う必要があります。</p>
<ul>
<li>コードのどの部分が遅延読み込みに適しているかを判断します。</li>
<li>既存のアプリケーションワークフローとの互換性がある方法で遅延読み込みを実行します（遅延読み込みは本質的に非同期ですが、遅延読み込みを実行するための理想的な関数は同期型の可能性があるため、遅延読み込みコードを設置できる場所は限られます）。</li>
<li><code class="language-text">./my-chunk</code>にチャンク名を割り当てます。バンドラがチャンクに割り当てる名前や、チャンクを1つのアプリケーションにまとめる方法に影響を及ぼします。</li>
<li>何をチャンクに含めるかを判断します（例えば、<code class="language-text">symbolA</code>と<code class="language-text">symbolB</code>は同じチャンクに含めるべきか、別のチャンクに分けるべきか？）。</li>
</ul>
<p>ここで問題なのは、開発者はソースコードを書いている時点では、遅延読み込みするコードの選択が適切であるか、チャンクに適切なシンボルが存在するかが分からないということです。
この点は、アプリケーションを実際にデプロイし、現実に利用状況を観察してみないとはっきりしません。
例えば、設定ページはほとんどアクセスされないので、メインバンドルから除くべきかもしれません。
あるいは、通知セクションを遅延読み込みにしたところ、実際はユーザが最もよくアクセスするページだったため、ユーザ体験がかえって悪化している可能性もあります。</p>
<p>さらに悪いことに、ひとたび開発者が選択をすると、バンドラがそれを補うためにできることはほんの少しです。
バンドラは、まさに開発者が求めることをしなければなりません。
バンドラにもっと自由を与えるには、まったく新しい方法で問題を見る必要があります。</p>
<p>ポイントは、コードを書いている時点では最終的なバンドルがどうなるかが分からないため、どこにdynamic importを挿入すべきかを判断するための十分な情報がないことです。
一方、チャンクの理想的な姿を判断するための十分なデータが集まったときには、ソースコードはすでに書き上がっています。
さかのぼってdynamic importを挿入するのは、大きな手間になるかもしれません（あるいは、過剰な遅延読み込みによって、アプリを細かく分割しすぎる恐れもあります）。</p>
<p>私たちが求めているのは、チャンクの理想的な数を判断し、現実のユーザによるアプリケーションの利用状況に基づいてチャンク間でコードを移動できることです。
これを実行する際に、さかのぼってソースコードをリファクタリングする必要がないことが望ましいでしょう。
チャンクのレイアウトは、コードとしてコードベースに組み込むのではなく、設定情報としてバンドラに移すべきです。</p>
<p>さらに複雑なことに、最近のフレームワークはすべて同期方式のレンダリングパイプラインを採用しています。
そのため、非同期方式のdynamic importをアプリケーションに挿入するのがとても難しくなります。</p>
<p>最適な遅延読み込み戦略を追求するなら、上記の問題を解決する必要があります。</p>
<h2>Qwikの登場</h2>
<p>コンポーネントはQwikアプリケーションの基本的な構成要素です。
Qwikはコンポーネントを3つの部分に分割することを求めます。</p>
<ol>
<li><strong>ビュー</strong>：コンポーネントのビジュアル部分をレンダリングするJSXコードが含まれます。</li>
<li><strong>ステート</strong>ファクトリー：コンポーネントの新たなステートを作成するコードが含まれます。</li>
<li>イベント<strong>ハンドラ</strong>：コンポーネントの挙動やユーザとのインタラクションに利用されるコードが含まれます。</li>
</ol>
<h2>なぜコンポーネントを3つの部分に分割するのか？</h2>
<p>ほとんどのフレームワークは、ビュー、ステート、ハンドラのコードを1つにまとめています。
以下は、この働きを解説するために用意した擬似フレームワークのコードです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> <span class="token punctuation">{</span>step<span class="token operator">?</span><span class="token operator">:</span>number<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> step <span class="token operator">=</span> props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">-</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">-</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">+</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
 )
}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントのビュー、ステート、ハンドラがすべて一緒になっているのに注目してください。
これはそれらのすべて（ビュー、ステート、ハンドラ）を同時にダウンロード、パース、実行しなければならないことを意味します。
そのため、遅延読み込みはかなり制限されます。</p>
<p>ここで挙げた程度の例では大きな問題にならないかもしれませんが、上記のコードがもっと複雑になって、何KBものコードを一度にダウンロード、パース、実行する必要がある場合を想像してみてください。
その場合、ビュー、ステート、ハンドラを何としても一緒に読み込ませようとするのは良くないかもしれません。
それがなぜ問題なのかを、ユーザのよくある利用パターンを通して見ていきましょう。</p>
<p><strong>ユーザがコンポーネントをクリックしてインタラクトする：</strong></p>
<ul>
<li>一部の<code class="language-text">handler</code>だけが必要：ダウンロードしなければならないのは、トリガーされた特定のハンドラのみです。その他のハンドラはすべて不要です。</li>
<li><code class="language-text">view</code>は<strong>不要</strong>：ハンドラによる再レンダリングが行われない可能性や、異なるコンポーネントの再レンダリングが行われる可能性があるので、ビューは不要かもしれません。</li>
<li><code class="language-text">state factory</code>は<strong>不要</strong>：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>コンポーネントのステートが変更される：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は不要：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>親が新たなコンポーネントを作成する：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は必要：コンポーネントが作成されるため、ステートを初期化するためのコードは必要です。</li>
</ul>
<p>上記の例は、それぞれのケースで必要なのがビュー、ステート、ハンドラ情報の一部のみであることを示しています。
問題は、3つの異なる情報がすべて一緒に埋め込まれているのに対し、それらがコンポーネントのライフサイクルにおいて異なるタイミングでしか利用されないことです。
最適なパフォーマンスを達成するには、コンポーネントに求められる役割に基づき、コンポーネントを部分ごとにダウンロード・実行する方法が必要です。
上記のコードでは、ご覧のとおり、コンポーネントを永久に分離できません。</p>
<h2>分割は簡単</h2>
<p>Qwikは、当面のタスクに必要なコードだけをダウンロード・実行することでこの問題を解決します。
上記の例のコードはシンプルですが、現実のコードはずっと複雑であることを忘れないでください。
さらに、コードが複雑になるとimportが増えることが多く（import自身もimportを必要とします）、コンポーネントのコードは一段と増加します。
この状況を「ツール」で解決することはできません。
コンポーネントをパーツ単位に分割し、必要に応じて遅延読み込みできるようにするための静的解析ツールを作成するのは不可能です。
開発者は、対応する部分ごとにコンポーネントを分割し、きめ細かい遅延読み込みを可能にしなければなりません。</p>
<p>そのために、Qwikはマーカー関数の<code class="language-text">qrlView</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を導入しています。</p>
<p>ファイル：<code class="language-text">my-counter.tsx</code></p>
<div class="gatsby-highlight" data-language="tsx"><pre style="counter-reset: linenumber NaN" class="language-tsx line-numbers"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>
 QComponent<span class="token punctuation">,</span>
 qComponent<span class="token punctuation">,</span>
 qrlView<span class="token punctuation">,</span>
 qrlHandler<span class="token punctuation">,</span>
 qrlState
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントの型を宣言し、プロパティとステートの形態を定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Counter</span> <span class="token operator">=</span> QComponent<span class="token operator">&lt;</span><span class="token punctuation">{</span> step<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
                                   <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのステートファクトリーを宣言します。</span>
<span class="token comment">//これはステートを初期化するために新たなコンポーネントが作成される際に利用されます。</span>
<span class="token comment">//（再ハイドレーションでは利用されません。）</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlState</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのレンダリングに利用されるコンポーネントのビューを定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlView</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのビューは、挙動を記述するハンドラを必要とする場合があります。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update
   <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlHandler</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token punctuation">,</span> <span class="token punctuation">{</span>direction<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
       <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//最後にすべてを1つのコンポーネントにまとめます。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qComponent</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> CounterState<span class="token punctuation">,</span>
 view<span class="token operator">:</span> CounterView<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>上記のコードは他のフレームワークに比べて冗長です。
しかし、コンポーネントを部分ごとに明確に分割するという手間をかけることで、きめ細かい遅延読み込みが可能になるというメリットが生まれます。</p>
<ul>
<li>開発者体験の観点から見て、コンポーネント当たりのオーバーヘッドはあまり変わらないことを忘れないでください。コンポーネントの複雑性が高まるにつれて、オーバーヘッドの増加は大きな問題ではなくなります。</li>
<li>この方式のメリットは、ツールによってコンポーネントを自由に複数のチャンクにパッケージ化し、必要に応じて遅延読み込みできる点です。</li>
</ul>
<h2>裏側で何が起きているのか</h2>
<p><code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>、<code class="language-text">qrlView</code>はいずれもQwik Optimizerのマーカーであり、自身への参照をQRLに変換する必要があることをツールに伝達します。
その結果、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">my-counter.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>qComponent<span class="token punctuation">,</span> qrlView<span class="token punctuation">,</span> qrlHandler<span class="token punctuation">,</span> qrlState<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token function">qComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> <span class="token string">'/chunk-abc#CounterState'</span><span class="token punctuation">,</span> <span class="token comment">// &lt;&lt;===注目</span>
 view<span class="token operator">:</span> <span class="token string">'/chunk-cde#CounterView'</span><span class="token punctuation">,</span>   <span class="token comment">// &lt;&lt;===注目</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ソースファイルの変換に加え、Optimizerはビュー、ステート、ハンドラ間の静的参照をすべて削除します。
QwikはRollupのためのエントリーポイントファイルも作成します。
これらのエントリーポイントは上記のQRLに対応します。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> Counter_update <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterView <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>重要なのは、いくつのエントリーファイルを作成するか、どのエクスポートをどのエントリーファイルと結びつけるかに関して、Qwikに大きな自由がある点です。
これは開発者が遅延読み込みする部分とそうでない部分の境界をまったく指定しないことによります。
その代わり、Qwikは、コードベースにたくさんの遅延読み込み境界（原文: lazy load boundaries）を導入するようにコードを書くよう開発者を導きます。
これによりQwikは、実際のアプリケーションの利用状況に基づき、最適なファイル配分を実現できます。
例えば、小規模なアプリケーションの場合はファイルを1つ作成し、アプリケーションの規模が大きくなるにつれて、エントリーファイルを増やすことができます。
また、特定の機能がめったに利用されない場合、その機能だけを単独のバンドルにすることもできます。</p>
<p>Rollupがエントリーファイルを処理すると、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlHandler<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlView<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>注目してほしいのは、Rollupがファイルの内容を展開してエントリーファイルにまとめ、不要なコードを削除し、理想的なサイズのバンドルを作成している点です。</p>
<h2>制約</h2>
<p>ツールが<code class="language-text">qComponent</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を移動できるようにするため、これらのメソッドの利用は制約されています（すべての有効なJavaScriptプログラムが有効なQwikプログラムとは限りません）。
その制約とは、すべてのマーカー関数が<code class="language-text">export</code>の対象となるトップレベル関数でなければならないというものです。</p>
<p>無効なコードの例は次のとおりです。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> someFn <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./some-place'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//トップレベルではないので無効</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">someFn</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//有効なimportなので問題なし</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>ツールにとっての選択肢</h2>
<p>アプリケーションを小さいファイルに分割しすぎて、ダウンロードのパフォーマンスに悪影響を与えてしまうのは、あり得ないことではありません（むしろ、とてもよくあることです）。
そのため、ツールではファイルをマージしてバンドルにすることを選択できます。
これは理想的な挙動と言えます。
アプリケーション全体の規模が比較的小さい（50KB未満の）場合、数百個ものファイルに分割するのは生産的ではないでしょう。</p>
<p>コード構造がきめ細かければ、ツールは常に、バンドルを大きくする（そして少なくする）ことを選択できます。
しかし、その逆は正しくありません。
コード構造が粗ければ、ツールがコードを分割するためにできることは何もありません。
Qwikは、開発者がアプリケーションを可能な限り小さいチャンクに分割し、ツールを利用して最適なバンドルのチャンクを発見する助けになります。
このように、Qwikはあらゆるサイズのアプリケーションに最適なパフォーマンスを提供できます。</p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには]]></title><description><![CDATA[Google PageSpeed InsightsはWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いス…]]></description><link>https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</link><guid isPermaLink="false">https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p><a href="https://developers.google.com/speed/pagespeed/">Google PageSpeed Insights</a>はWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いスコアが必要不可欠です。</p>
<p>私たちは、モバイルサイトのPageSpeed Insightsスコアを100点にするために何が必要かを探ってきました。
この取り組みを始めたとき、デスクトップサイトのスコアはすでに100点でした。
しかし、現代のeコマースの主流はモバイルコマースであり、モバイルサイトでは60点台半ばのスコアしか獲得できていませんでした。
このブログ記事では、モバイルサイトでも100点を取るための方法を共有します。
多くの企業がデスクトップサイトで100点を獲得していますが、モバイルサイトで100点を取れることは滅多にありません。
それでは始めましょう。</p>
<p>Builder.ioは標準的なNext.jsサイトです。
サイト自体がBuilderコンテンツプラットフォームで実行されているため、画像サイズや事前読み込みなど、コンテンツに関するあらゆるベストプラクティスはすでに守られているはずです。
それでもスコアはわずか60点台にとどまっていました。なぜでしょうか？</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0DMRzttv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iy8vyp90ed82l4kmhshx.png"></p>
<p>その理由を探るために、スコアの内訳を見てみましょう。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--eTUcudeP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aeaoni0mhgjyttr3utm5.png"></p>
<p>問題は以下の2つに分解できます。</p>
<ul>
<li>Total Blocking Time（TBT）とTime to Interactive（TTI）：JavaScriptによるページ上のブロッキング時間が長すぎる。</li>
<li>First Contentful Paint（FCP）とLargest Contentful Paint（LCP）：モバイルブラウザにとって、レンダリングが必要なページ上のコンテンツが多すぎる。</li>
</ul>
<p>そのため、以下を目指す必要があります。</p>
<ol>
<li>JavaScriptの量を減らす。</li>
<li>初回のレンダリング時のコンテンツ量を減らす。</li>
</ol>
<h2>なぜJavaScriptの量が増えるのか？</h2>
<p>私たちのホームページはほとんど静的なページです。
なぜJavaScriptが必要なのでしょうか？それはホームページがNext.jsサイトであり、つまりReactアプリケーションであるからです（ドラッグ&#x26;ドロップエディタによる出力をReactに変換するために<a href="https://github.com/BuilderIO/mitosis">Mitosis</a>を使用しています）。
サイトの大部分は静的ですが、JavaScriptが必要な要素が3つあります。</p>
<ol>
<li>ナビゲーションシステム：メニューにはインタラクティブ性が必要であり、したがってJavaScriptも必要。また、デスクトップとモバイル端末では異なるメニューが使用されている。</li>
<li>チャット用のウィジェットを読み込む必要がある。</li>
<li>Google Analyticsが必要。</li>
</ol>
<p>それぞれ詳しく見ていきましょう。</p>
<h2>アプリケーションのブートストラップ</h2>
<p>サイトはほとんど静的であるとはいえ、それでもアプリケーションです。
メニューを有効にするにはアプリケーションをブートストラップする必要があります。
具体的には、フレームワークは再ハイドレーションを実行する中でテンプレートをDOMと比較し、すべてのDOMリスナーをインストールする必要があります。
このプロセスによって、既存のフレームワークは<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable（再生型）</a>になります。
つまり、たとえページの95％が静的であっても、フレームワークはすべてのテンプレートをダウンロードし、リスナーが存在するかを判断するためにテンプレートを再実行しなければなりません。
これが意味するのは、最初にHTMLとして、次にJavaScriptのJSXとして、サイトが合計2回ダウンロードされるということです。</p>
<p>さらに悪いことに、再ハイドレーションのプロセスは低速です。
フレームワークはDOMの各ノードにアクセスし、仮想DOMとの差分を検出しなければならず、それに時間がかかります。
また、再ハイドレーションのプロセスはDOMリスナーのインストールと同じプロセスなので、遅延させることができません。
再ハイドレーションが遅延すると、メニューは動作しません。</p>
<p>上記は既存のあらゆるフレームワークの根本的な限界を説明したものです。
お分かりのとおり、こうしたフレームワークはすべて<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable</a>です。
これは、既存のどんなフレームワークも、現実のモバイルサイトで100点を取れないという意味でもあります。
PageSpeed Insightsが想定しているモバイルサイトのHTMLとJavaScriptのコード量はごくわずかであり、それに対して現実のコードがあまりに多すぎるのです。</p>
<p>私たちは問題を根本的に考え直す必要があります。
サイトの大部分は静的なので、その部分のJavaScriptを再ダウンロードしたり、不要な部分の再ハイドレーションに時間をかけたりすべきではありません。
このような場面でこそ、<a href="https://github.com/builderio/qwik">Qwik</a>が真の意味で輝きます。
Qwikは<a href="https://github.com/builderio/qwik">replayableではなくresumable（再開型）</a>で、それがあらゆる違いを生み出します。
結果として、Qwikでは以下が不要になります。</p>
<ol>
<li>ページを読み込むときのブートストラップ</li>
<li>リスナーをどこに入れるべきか判断するためにDOMを探索すること</li>
<li>メニューを動かすためにJavaScriptをダウンロード・実行すること</li>
</ol>
<p>これらはすべて、サイトの読み込みを実行するためのJavaScriptをほとんど必要とせず、それでもサイトのインタラクティブ性を完全に維持できることを意味します。</p>
<h2>Intercom</h2>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--On4okiXm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/v8v1uurp49y7nlkh7fr3.png"></p>
<p>Intercomは、私たちのサイトで実行されているサードパーティウィジェットで、私たちとお客様のインタラクションを可能にします。
このウィジェットをインストールする標準的な方法は、例えば以下のように、JavaScriptをHTMLに少しだけ追記することです。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">async</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://widget.intercom.io/widget/abcd1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">defer</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
<span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span><span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、上記のコードには2つの問題があります。</p>
<ol>
<li>ダウンロードと実行が必要なJavaScriptが増え、TBTとTTIに悪影響を及ぼす。</li>
<li>レイアウトシフトが発生し、CLSに悪影響を及ぼす可能性がある。その原因は、最初にウィジェット以外のUIがレンダリングされ、その後にJavaScriptのダウンロードと実行によってUIがウィジェットとともに再びレンダリングされるためである。
Qwikはそれら両方の問題を同時に解決します。</li>
</ol>
<p>まず、QwikはIntercomがウィジェットのレンダリングに使用するDOMを取得します。
次に、そのDOMが以下のように実際のページに挿入されます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app<span class="token punctuation">"</span></span> <span class="token attr-name">aria-live</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>polite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-launcher intercom-launcher<span class="token punctuation">"</span></span>
    <span class="token attr-name">role</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span>
    <span class="token attr-name">tabIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{0}</span>
    <span class="token attr-name">arial-abel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Open Intercom Messenger<span class="token punctuation">"</span></span>
    <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>ui:boot_intercom<span class="token punctuation">'</span></span>
  <span class="token punctuation">></span></span>
    ...
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-style<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">...</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この方法のメリットは、ウィジェットがアプリケーションの残りの部分と同時に即座にレンダリングされることです。
ブラウザがIntercomのJavaScriptをダウンロードし、ウィジェットの作成を実行している間、遅延や画面のちらつきは発生しません。
その結果、ユーザ体験が改善され、Webサイトのブートストラップが高速化されます（モバイル端末の通信量も節約できます）。</p>
<p>ただし、ウィジェットがクリックされたことを検知する方法や、ユーザのインタラクションに応じてウィジェットのモックアップを実際のIntercomウィジェットに置き換える何らかのコードは依然として必要です。
これは<code class="language-text">on:click=&quot;ui:boot_intercom&quot;</code>属性によって実現できます。
この属性は、ユーザがウィジェットのモックアップをクリックした場合に、Qwikに<code class="language-text">boot_intercom.js</code>をダウンロードさせるものです。</p>
<p><code class="language-text">boot_intercom.js</code>の内容</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'https://widget.intercom.io/widget/abcd1234'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> container <span class="token operator">=</span> element<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 <span class="token keyword">const</span> body <span class="token operator">=</span> container<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'show'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このファイルは、実際のIntercomウィジェットをダウンロードし、モックアップを削除し、Intercomをブートストラップします。
こうした作業はすべて勝手に行われ、ユーザはウィジェットが入れ替わったことにまったく気づきません。</p>
<h2>Google Analytics</h2>
<p>これまで私たちはJavaScriptの遅延読み込みに取り組み、Webサイトのパフォーマンスを順調に改善してきました。
しかし、アナリティクスは別物です。
なぜなら、アナリティクスを遅延させることはできず、ただちにブートストラップが必要だからです。
アナリティクスをブートストラップするだけで、モバイルサイトのPageSpeed Insightsスコアで100点を取るのは難しくなります。
この問題を解決するために、<a href="https://github.com/adamdbradley/partytown">PartyTown</a>を利用して、Web WorkerでGoogle Analyticsを実行します。
詳しくは今後の記事で説明します。</p>
<h2>JavaScriptの遅延</h2>
<p>上記の処理は、Webサイトがダウンロード・実行しなければならないJavaScriptの量を約1KBに減らします。
実行にかかる時間はわずか1ミリ秒で、ほとんどゼロと言ってよいでしょう。
このようにJavaScriptを最小限にすることで、TBTとTTIのスコアが完璧になります。</p>
<h2>HTMLの遅延</h2>
<p>しかし、JavaScriptがほとんど存在しなくても、画面上の領域をレンダリングするためにクライアントに送信するHTMLの量を修正しない限り、依然としてモバイルサイトで100点は取れません。
FCPとLCPを改善するには、とにかくHTMLを最小限に減らさなければなりません。
それを実現する方法は、画面上の領域のHTMLのみを送信することです。</p>
<p>これは目新しいアイデアではありませんが、実行するのは骨が折れます。
アプリケーションを画面上の領域と画面外の領域に簡単に分割する方法がないため、既存のフレームワークでは困難です。
ここでは仮想DOMも役に立ちません。
たとえ表示されるのがほんの一部だとしても、アプリケーションは仮想DOM全体を生成するからです。
フレームワークは、サイトの一部が欠けていると再ハイドレーション時にサイト全体を再生成するため、初回のブートストラップ時の作業がさらに増えます。</p>
<p>理想的には、画面外の領域のHTMLは送信せず、画面上の領域のメニューシステムは完全にインタラクティブな状態に維持したいところです。
しかし実際には、現実のサイトでそのようなベストプラクティスが見られないことから分かるように、実現するのは困難です。難しすぎるので誰もやらないのです。</p>
<p>QwikはDOM主体であり、それがすべての違いを生み出しています。
まずページ全体がサーバでレンダリングされます。
その後、ページの中で送信する必要がない部分が特定され、削除されます。
ユーザのスクロールに応じて、残りの部分が遅れてダウンロードされ、ページに挿入されます。
QwikはステートレスでDOM主体のフレームワークであるため、この種のDOMの操作による影響を受けません。</p>
<p>これは私たちのサーバで、サイトの画面外の領域で遅延読み込みを実現している実際のコードです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">async</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vmSandbox<span class="token punctuation">.</span><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'./server-index'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ServerIndexModule<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serverIndex</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> lazyNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'section[lazyload=true]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> lazyHTML <span class="token operator">=</span> lazyNode<span class="token punctuation">.</span>innerHTML<span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
      <span class="token punctuation">(</span>lazyNode <span class="token keyword">as</span> HTMLElement<span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'999em'</span><span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'on:document:scroll'</span><span class="token punctuation">,</span> <span class="token string">'ui:/lazy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>transpiledEsmFiles<span class="token punctuation">[</span><span class="token string">'lazy.js'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        export default (element) => {
          element.removeAttribute('on:document:scroll');
          element.style.height = null;
          element.innerHTML = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>lazyHTML<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
        };</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コードは簡潔で的確ですが、既存のどのフレームワークでも実現するのは困難でしょう。</p>
<p>以下は、画面外の領域を遅延読み込みするようにした実際のサイトです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o48jE9q6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/565yei3n8jydkkvs81yr.gif"></p>
<p>当初、ページは画面外のコンテンツを読み込んでいません。
ユーザがスクロールすると、すぐにコンテンツが追加されます。
ほとんど一瞬でコンテンツが追加されるのは、複雑なコードを実行する必要がなく、高速で単純な<code class="language-text">innerHTML</code>だけで済むためです。</p>
<h2>実際に試す</h2>
<p>こちらのページを実際に体験してみてください：<a href="https://www.builder.io/?render=qwik">https://www.builder.io/?render=qwik</a> （<a href="https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.builder.io%2F%3Frender%3Dqwik">PageSpeed Insights</a>のスコアもご覧ください）。
アナリティクスについてはまだ説明していませんが、近いうちに記事を投稿する予定です。</p>
<p>サイトは気に入っていただけましたか？
私たちは、お客様のサイトが超高速に利用できるものとなるように、Builder.ioのすべてのお客様にQwikを提供したいと考えています。
これは今まで見たことがないほど高速なプラットフォームになるはずです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Ii5M-zIi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2rgulo7ew94yp06dyevs.png"></p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwik：最適できめ細かい遅延読み込みを実現]]></title><description><![CDATA[Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけ…]]></description><link>https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</link><guid isPermaLink="false">https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけでなく、アプリケーションが続く限り行われます。
言い換えると、Qwikはきめ細かい遅延読み込みを追求しているのです。
「きめ細かい」とは、ユーザのアクションを処理するのに直接必要なコードのみがダウンロードされるという意味です。
この記事では、きめ細かい遅延読み込みを実現するために解決すべき技術的課題について探っていきます。</p>
<h2>リスナーをシリアライズ</h2>
<p>最も明確に解決すべき課題は初回のページ読み込みです。
この点に関しては、「<a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に</a>」で対応策をすでに取り上げました。
ポイントは、イベントの名称とアクションをURLとしてシリアライズし、DOMの属性として保持することです。その後、最上位のグローバルなイベントハンドラがイベントをリッスンし、そのイベントに関連するコードをダウンロードできます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>このコードは、初回のページ読み込みで（1KBのローダを除いて）JavaScriptを一切読み込むことなく、上記の処理を実現します。
これにより初回読み込み時のTime to Interactiveの目標を達成できますが、新たな問題が生まれます。
私たちは、ユーザとの初回のインタラクション時にアプリケーション全体をダウンロードしたり、ブートストラップしたりしたくはありません。
それでは初回の読み込み時から初回のインタラクション時へ問題を先送りするだけになってしまいます（それどころか、ユーザとの初回のインタラクション時に大きなレイテンシが生じるので、状況は悪化しています）。</p>
<p>この問題は、ユーザとの1回のインタラクションで、アプリケーション全体のダウンロードやブートストラップが行われないようにすれば解決です。
その代わり、インタラクションの処理に直接必要なコードやコンポーネントのみのダウンロード、ブートストラップ、再ハイドレーションを行えばよいのです。
そのため、きめ細かい遅延読み込みが必要になります。</p>
<p>これはイベントをHTMLやDOMへシリアライズすればすべて実現できます。
そうしなければ、テンプレートの読み込みを遅延させるのは不可能でしょう。
なぜなら、フレームワークはイベントの場所を特定するためにテンプレートをダウンロードする必要があるからです。</p>
<h2>非同期かつアウトオブオーダー方式によるコンポーネントのハイドレーション</h2>
<p>初回のインタラクションによるアプリケーション全体のダウンロードやブートストラップを避けるには、コンポーネントを非同期かつアウトオブオーダー方式で再ハイドレートする必要があります。</p>
<p>ここでいう非同期とは、レンダリングシステムがレンダリングを一時停止してコンポーネントのテンプレートを非同期にダウンロードし、それからレンダリングのプロセスを再開できるという意味です。
レンダリングプロセスがすべて完全な同期方式である既存のフレームワークとはとても対照的です。
レンダリングが同期方式である場合、非同期の遅延読み込みを挿入する余地はありません。その結果、すべてのテンプレートをレンダリングの呼び出し前に準備する必要があります。</p>
<p>既存の再ハイドレーション戦略にはもう1つ問題があります。
それは再ハイドレーションがルートコンポーネントから始まり、ルート以下のすべてのコンポーネントを同期方式で再ハイドレートすることです。
そのため、すべてのコンポーネントを同時に再ハイドレートしなければならず、あらゆるコンポーネントのダウンロードを強いられます。
その結果、初回のインタラクション時の処理時間が長くなります。
アウトオブオーダー方式のハイドレーションとは、各コンポーネントを他のコンポーネントとは独立して任意の順番で再ハイドレートできるという意味です。
これにより、Qwikはリクエストの処理に必要な最小限のコンポーネントのみを再ハイドレートすることが可能になります。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./path/MyComponent_template<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ... some content ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のケースでは、<code class="language-text">&lt;div&gt;</code>は<code class="language-text">MyComponent_template.ts</code>と紐づけられたコンポーネントを表しています。
Qwikは、コンポーネントを再レンダリングする必要があると判断した場合のみテンプレートをダウンロードするため、ダウンロードがさらに遅延されます。</p>
<p>再ハイドレーションがアウトオブオーダー方式でなければ、フレームワークはすべてのテンプレートを一度にダウンロードし、再ハイドレートしなければなりません。
その結果、初回のインタラクション時に、ダウンロードと実行による大きな負荷がかかります。</p>
<h2>レンダリングをイベントハンドラから分離</h2>
<p>Qwikに関して考慮が欠かせないポイントは、既存のあらゆるレンダリングシステムがイベントリスナーをテンプレートに埋め込んでいることです。
そのため、コンポーネントを再レンダリング（または再ハイドレート）する必要があるときに、ブラウザはすべてのリスナーを必要性にかかわらずダウンロードしなければなりません。
リスナーは複雑なコードに紐づいていることが多いので、ダウンロードされるコード量はさらに増加します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded eagerly
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikはイベントハンドラをテンプレートのコードから分離します。これはリスナーとテンプレートを別々に、必要に応じてダウンロードできることを意味します。</p>
<p><code class="language-text">MyComponent_template.ts</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token function">MyComponent_template</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded lazily
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">MyComponent_onClick.ts</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>イベントハンドラをテンプレートから分離しなければ、フレームワークはコンポーネントの再レンダリングに必要な量よりはるかに多くのコードをダウンロードしなければなりません。
さらに、イベントハンドラは複雑で、他の依存関係を持っていることが多いため、ダウンロードが必要なコード量は増加します。</p>
<h2>コンポーネントのステートのシリアライズ</h2>
<p>コンポーネントを再ハイドレートするプロセスの最も重要な部分は、コンポーネントのステートを復元することです。
既存のフレームワークにはステートをシリアライズする方法がありません。
コンポーネントのステートがどこにあるかを確定するための標準的な方法が存在しないからです。</p>
<p>Qwikはコンポーネントをいくつかの部分に分解します。</p>
<ul>
<li><em>props</em>：コンポーネントの単なるプロパティ。DOMに反映される。例えば<code class="language-text">&lt;counter min=&quot;0&quot; max=&quot;100&quot;/&gt;</code>のpropsは<code class="language-text">{min: 0, max: 100}</code>。</li>
<li><em>state</em>：コンポーネントの内部ステート。DOMにシリアライズできる。</li>
<li><em>transient state</em>：追加的なステートで、コンポーネントによるキャッシュは可能だが、シリアライズは不可能なものを指す。この情報は再計算する必要がある（例：コンポーネントとサーバが通信している間の一時的なプロミス）。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Conter_template<span class="token punctuation">"</span></span>
     <span class="token attr-name">:.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>{count: 42}<span class="token punctuation">'</span></span>
     <span class="token attr-name">min</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">max</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_incremente<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  42
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_decrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントがステートをシリアライズできない場合、特定のコンポーネントを独立に再ハイドレートするのは不可能でしょう（コンポーネントはどこでステートを取得するというのでしょうか？）。
その結果、フレームワークは、ステートの計算やダウンロードのための追加コードをサーバからダウンロードしなければなりません。
Qwikはこうした問題のすべてを<a href="/html-first-javascript-last-the-secret-to-web-speed/">DOM内にステートをシリアライズする</a>ことで回避します。</p>
<h2>アプリや共有ステートのシリアライズ</h2>
<p>コンポーネント内のみで有効なコンポーネントステートに加え、複数のコンポーネントで利用されるアプリケーションステートも存在します。
これもDOM内にシリアライズする必要があります。共有ステートは以下に分解できます。</p>
<ul>
<li><em>key</em>：あるステートをただ1つに特定するID。コンポーネント内でステートを参照するために利用される。</li>
<li><em>state</em>：複数のコンポーネントで共有されるステート。DOM内にシリアライズできる。</li>
<li><em>transient state</em>：アプリケーションによるキャッシュは可能だが、シリアライズは不可能な追加ステート。この情報は再計算が可能でなければならない。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span>
     <span class="token attr-name">:item:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Item<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>789</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Shoe<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>43.21<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>987</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Sock<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>12.34<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>アプリケーションのステートをシリアライズすることで、コンポーネントが同じ情報を複数の場所でレンダリングし、他のコンポーネントとコミュニケーションできます。
フレームワークが共有ステートを把握・管理しないと、フレームワークがステートの変更を認識できないため、コンポーネントの独立したハイドレーションが不可能になります（例えば、AngularとReactにはレンダリング関数に紐づけられた明確なステート管理機能がありません。その結果、アプリケーションのステートが変更されたときにアプリケーション全体を再レンダリングする以外に妥当な方法がなく、きめ細かい遅延読み込みが困難です）。</p>
<h2>アプリのステートとコンポーネントの間のリアクティブな関係</h2>
<p>ステートを把握するフレームワークの真のメリットは、フレームワークがステートとコンポーネントの関係を認識できる点にあります。
これが重要なのは、任意のステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要があるか把握できるためです。
あるいは、それ以上に重要なのは、ステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要がないかを把握できることでしょう。
例えば、ショッピングカートに商品を追加するときは、ショッピングカート内の商品の個数を表示するコンポーネントのみを再レンダリングすべきですが、これはページ全体のごく一部でしかありません。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Unrelated<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./ShoppingCart<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$cart<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   2 items
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AddItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>buy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikの目標は再ハイドレートするコンポーネントの数を最小限にすることです。
ユーザが<code class="language-text">&lt;button&gt;</code>をクリックすると、Qwikは<code class="language-text">./AddItem</code>をダウンロードし、<code class="language-text">cart:432</code>のアプリケーションステートを更新します。
さらにQwikは、<code class="language-text">bind:cart:432</code>を持つコンポーネントが、そのステートを利用している唯一のコンポーネントであり、したがって再ハイドレーションと再レンダリングが必要な唯一のコンポーネントであると判断します。
Qwikはページ上のほとんどのコンポーネントを除外できるため、きめ細かい遅延読み込みを維持できます。
どのコンポーネントがどのステートと関係しているかを把握できるという点は、他のフレームワークには存在しないとても重要な特徴です。
この特徴によって、アプリケーションの起動時やライフサイクル全体を通じたきめ細かい遅延読み込みが可能になります。</p>
<h2>コンポーネントの分離</h2>
<p>これまでQwikがどのようにコードのきめ細かい遅延読み込みをサポートするか説明してきました。
上記の仕組みがすべて機能するのは、Qwikがアプリケーション内のデータフローを認識しているからです。
Qwikはこの情報を、再ハイドレートする必要がないコンポーネントを取り除き、必要なコンポーネントのみを再ハイドレートするために利用します。
これが暗に意味するのは、Qwikがコンポーネントと他のコンポーネントの通信を認識する必要があるということです。
コンポーネントは他のコンポーネントと秘密の会話をしてはならないのです。</p>
<p>コンポーネントがステートを取得したことをQwikが把握できない場合、Qwikは、ステートが変更されたときにそのコンポーネントの再ハイドレーションや再レンダリングが必要であることを認識できません。
そのため、コンポーネントは自身の依存関係のリストをプロパティに明記する必要があります。</p>
<p>この明確なリストがないと、フレームワークは、ステートが変更された時点ですべてを再レンダリングしなければなりません。
その結果、アプリケーション全体のダウンロードとブートストラップが行われることになります。</p>
<h2>結論</h2>
<p>Webアプリケーションが遅延読み込みに対応した構造となるように、開発のアプローチを変える必要がある点は数多くあります。
ポイントは、現在のフレームワークはこの問題を解決する助けにならず、ときには悪化させるという点です（例えば、ページ全体の再ハイドレーション、同期方式のレンダリングなど）。
Qwikはきめ細かい遅延読み込みを実現し、どんなに大規模で複雑であっても1秒未満で読み込めるサイトやアプリを開発できます。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣]]></title><description><![CDATA[すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJ…]]></description><link>https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</link><guid isPermaLink="false">https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJavaScriptヒープに保持します。<a href="https://github.com/builderio/qwik">Qwik</a>のユニークな点は、ステートが属性としてDOMに保持されることです（リファレンスもクロージャもシリアライズして送受信するのは不可能ですが、文字列であるDOM属性なら可能です。これがresumability(再開性）のカギとなります）。</p>
<p>DOMにステートを保持することには、以下のように多くのユニークなメリットがあります。</p>
<ol>
<li>DOMはシリアライズの形式としてHTMLを使用します。ステートを文字列属性としてDOMに保持することで、アプリケーションをいつでもHTMLにシリアライズできます。HTMLを送信し、別のクライアントでDOMにデシリアライズすることが可能になります。デシリアライズされたDOMは、そこから再開できます。</li>
<li>各コンポーネントを他のコンポーネントとは独立して再開できます。このアウトオブオーダー方式の再ハイドレーションによって、アプリケーション全体の一部のみを再ハイドレートすることが可能であり、ユーザのアクションに応じてダウンロードしなければならないコード量が制限されます。これは従来のフレームワークとは全く異なる点です。</li>
<li>Qwikはステートレスなフレームワークです（アプリケーションのステートはすべて文字列としてDOMに保持されます）。ステートレスなコードはシリアライズ、送受信、再開が簡単です。各コンポーネントを独立に再ハイドレートすることも可能になります。</li>
<li>アプリケーションを（初回のレンダリング時だけでなく）いつでも何度でもシリアライズできます。</li>
</ol>
<p>例として、シンプルなCounterコンポーネントと、ステートのシリアライズの仕組みを見てみましょう（これはサーバサイドでレンダリングされたHTMLの出力結果であり、必ずしも開発者がこのようなコードを書くわけではありません）。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">::app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AppState<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">app-state:</span>1234</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{count: 321}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name">::.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{countStep: 5}<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span>app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state:1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_increment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
    321.
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_decrrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<ul>
<li><code class="language-text">::app-state</code>（アプリケーションステートのコード）：アプリケーションステートの変更コードをダウンロードできるURLを指します。ステートの更新コードは、ステートを変更する必要がある場合のみダウンロードされます。</li>
<li><code class="language-text">app-state:1234</code>（アプリケーションステートのインスタンス）：特定のアプリケーションのインスタンスへのポインタ。ステートをシリアライズすることで、アプリケーションはステートの再構築をやり直すのではなく、中断した所から再開できます。</li>
<li><code class="language-text">decl:template</code>（テンプレートの宣言）：コンポーネントのテンプレートをダウンロードできるURLを指します。コンポーネントのステートが変更され、再レンダリングする必要があるとQwikが判断するまで、テンプレートはダウンロードされません。</li>
<li><code class="language-text">on:q-render</code>（コンポーネントのレンダリングのスケジュール設定）：フレームワークは再レンダリングが必要なコンポーネントを追跡しなければなりません。これは通常、無効化されたコンポーネントの内部リストを保存することで行われます。Qwikでは、無効化されたコンポーネントのリストは、属性としてDOMに保存されます。その後、コンポーネントは<code class="language-text">q-render</code>イベントのブロードキャストを待ちます。</li>
<li><code class="language-text">::.=&quot;{countStep: 5}&quot;</code>（コンポーネントのインスタンスの内部ステート）：コンポーネントは、再ハイドレーション後も内部ステートを保持しなければならない場合があります。このステートはDOMに保持できます。コンポーネントは、再ハイドレートされた時点で、再開に必要なすべてのステートを保持しています。ステートの再構築は不要です。</li>
<li><code class="language-text">bind:app-state=&quot;state:1234&quot;</code>（共有アプリケーションステートへのリファレンス）：複数のコンポーネントが同じ共有アプリケーションステートを参照できるようにします。</li>
</ul>
<h2><code class="language-text">querySelectorAll</code>は強い味方</h2>
<p>フレームワークの一般的な役割の1つは、アプリケーションのステートが変更されたときに、どのコンポーネントの再レンダリングが必要か特定することです。
この作業が発生する理由はいくつかあります。
例えば、コンポーネントが明確に無効とされる場合や（<code class="language-text">markDirty()</code>）、アプリケーションの共有ステートの変更によりコンポーネントが暗黙に無効とされる場合などです。</p>
<p>上記の例では、<code class="language-text">count</code>が<code class="language-text">app-state:1234</code>をキーとしてアプリケーションステートに保持されています。
ステートが更新された場合、そのアプリケーションステートに依存するコンポーネントは無効化（再レンダリングのキュー）が必要です。
フレームワークはどのように更新すべきコンポーネントを把握するのでしょうか？</p>
<p>ほとんどのフレームワークの場合、その答えは、単純にルートコンポーネントからアプリケーション全体を再レンダリングすることです。
この戦略は、コンポーネントのテンプレートすべてをダウンロードする必要があるという残念な結果を生み、ユーザとのインタラクションのレイテンシに悪影響を及ぼします。</p>
<p>一部のフレームワークはリアクティブで、任意のステートが変更された場合に再レンダリングが必要なコンポーネントを追跡しています。
しかし、これはテンプレートを囲い込むクロージャの形式で記録されます（<a href="/death-by-closure-and-how-qwik-solves-it/">「クロージャによる死」</a>を参照）。
その結果、リアクティブな接続が初期化されるアプリケーションのブートストラップ時に、すべてのテンプレートをダウンロードしなければなりません。</p>
<p>Qwikはコンポーネントレベルでリアクティブです。
そのため、ルートからレンダリングを開始する必要はありません。
しかし、Qwikはリアクティブなリスナーをクロージャの形式で保持するのではなく、属性の形式でDOMに保持しているので、レンダリングを途中から再開できます。</p>
<p><code class="language-text">count</code>が更新されると、Qwikは以下の<code class="language-text">querySelectorAll</code>を実行し、どのコンポーネントを無効化する必要があるかを内部で判断します。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'bind\\:app-state\\:1234'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>markDirty<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>上記のクエリによって、Qwikはどのコンポーネントがステートに依存しているかを判断し、各コンポーネント上で<code class="language-text">markDirty()</code>を呼び出します。
<code class="language-text">markDirty()</code>はコンポーネントを無効化し、そのコンポーネントを再レンダリングが必要なコンポーネントのキューに追加します。
これは<code class="language-text">markDirty</code>の複数の呼び出しを1つのレンダリングパスに連結することで行われます。
レンダリングパスは<code class="language-text">requestAnimationFrame</code>を利用してスケジュールを設定します。
しかし、ほとんどのフレームワークとは異なり、Qwikはこのキューも属性としてDOMに保持します。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">requestAnimationFrame</code>はレンダリングのスケジュール設定に利用されます。
これは論理的に考えれば、コンポーネントが待っている<code class="language-text">q-render</code>イベントを<code class="language-text">requestAnimationFrame</code>がブロードキャストすることを意味します。
ここで再び<code class="language-text">querySelectorAll</code>の出番です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'on\\:q-render'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>jsxRender<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ブラウザにはブロードキャストイベント（イベントのバブリングの逆）が存在しませんが、<code class="language-text">querySelectorAll</code>を利用すれば、イベントのブロードキャストを受け取るべきコンポーネントをすべて特定できます。
さらに、<code class="language-text">jsxRender</code>関数を利用してUIを再レンダリングします。</p>
<p>ポイントは、Qwikがどの時点でもDOMの外部でステートを保持する必要がない点です。
あらゆるステートは属性としてDOMに保持され、自動的にHTMLにシリアライズされます。
つまり、いつでもアプリケーションのスナップショットをHTMLとして保存し、それを送信したり、デシリアライズしたりできるということです。アプリケーションは途中から自動的に再開されます。</p>
<p>Qwikはステートレスであり、それこそがQwikアプリケーションにresumableがある理由です。</p>
<h2>メリット</h2>
<p>アプリケーションがresumableであることは、フレームワークのステートのすべてをDOMエレメントに保持する明確なメリットです。
しかし、一見しただけでは分かりにくい、他のメリットもあります。</p>
<p>そのメリットとは、ビューポートの外側にあるコンポーネントのレンダリングをスキップできることです。
コンポーネントのレンダリングが必要かを判断するために<code class="language-text">q-render</code>イベントをブロードキャストすると、コンポーネントが表示されているかどうかを判断し、非表示コンポーネントのレンダリングを簡単にスキップできます。
また、レンダリングをスキップすれば、テンプレートなどのコードを一切ダウンロードする必要がありません。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0C5MyDdy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l7y32eh60iarvc277zl9.png"></p>
<p>ステートレスのもう1つのメリットは、アプリケーションが実行されている間にHTMLの遅延読み込みが可能であることです。
例えば、サーバは最初に表示される画面のレンダリングに必要なHTMLを送信する一方で、画面に表示されていない部分のHTMLをスキップできます。
ユーザは最初の画面でインタラクションを開始し、アプリケーションを使用することが可能です。
ユーザがスクロールし始めた時点で、アプリケーションは他のHTMLを読み込み、それをDOMの末尾に<code class="language-text">innerHTML</code>で挿入します。
Qwikはステートレスであるため、すでに実行されているアプリケーションに何の問題も発生させずに追加のHTMLを挿入できます。
Qwikが新たなHTMLを認識するのはインタラクションが行われたときであり、その時点までHTMLのハイドレーションは遅延されます。
こうしたユースケースは、現行世代のフレームワークで実現するのがとても難しいものです。</p>
<p>私たちはQwikの未来と、それが切り開くユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[クロージャによる死（とQwikによる解決方法）]]></title><description><![CDATA[世界中にQwikを紹介した前回の記事では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が…]]></description><link>https://postd.cc/death-by-closure-and-how-qwik-solves-it/</link><guid isPermaLink="false">https://postd.cc/death-by-closure-and-how-qwik-solves-it/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>世界中にQwikを紹介した<a href="/a-first-look-at-qwik-the-html-first-framework/">前回の記事</a>では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が現在の場所までどのようにたどり着いたかを理解しておくことが重要です。
現代のフレームワークはある前提のもとに成り立っており、
それが優れたTime to Interactive（TTI）スコアの実現を妨げているのですが、
その前提とはどのようなものなのでしょうか。
現行世代のフレームワークの現時点における限界を理解することで、
Qwikの設計思想がなぜ最初は驚くべきものに思えるのか、より深く知ることができるでしょう。</p>
<h2>TTIについて</h2>
<p>TTIは、URLに遷移してからページがインタラクティブになるまでの時間を測定したものです。
レスポンシブなサイトとしての体裁を整えるには、サーバーサイドレンダリング（SSR）が必須です。
この背景にある考え方は、サイトを素早く表示し、ユーザがクリックすればいいか判断できるようになるまでに、
アプリケーションが自身をブートし、すべてのリスナーをインストールするというものです。
そのためTTIは、実際にはフレームワークがDOMリスナーをインストールするのにかかる時間を測定していると言えます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--85XBH76v--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jlvs7wu983qt0846c2a1.png"></p>
<p>上の図では、ブートからインタラクティブになるまでの時間に焦点を当てています。
フレームワークがインタラクティブな状態に達するまでに実行すべきことすべてを理解できるよう、
インタラクティブになった時点からスタートして逆にたどってみましょう。</p>
<ol>
<li>フレームワークはリスナーがどこにあるかを知る必要があります。しかし、この情報はフレームワークが簡単に利用できるものではありません。リスナーはテンプレートに<code class="language-text">described</code>（記述）されています。</li>
<li>実は、筆者は<code class="language-text">described</code>よりも<code class="language-text">embedded</code>（埋め込み）という言葉のほうが適切だと考えています。情報が埋め込まれていると言えるのは、フレームワークが情報を簡単に利用できないからです。フレームワークは、リスナーのクロージャに到達するためにテンプレートを実行する必要があります。</li>
<li>テンプレートを実行するにはダウンロードしなければなりません。しかし、ダウンロードされたテンプレートには import が含まれており、これを読み込むためにさらに多くのコードのダウンロードが必要です。テンプレートはそのサブテンプレートをダウンロードする必要があります。</li>
<li>テンプレートの準備はできましたが、依然としてリスナーには到達していません。テンプレートの実行は、実際にはテンプレートとステートをマージすることを意味します。ステートがなければ、フレームワークはテンプレートを実行できず、リスナーにはたどり着けません。</li>
<li>ステートはダウンロードしたり、クライアント側で計算したりする必要があります。頻繁に計算をするということは、ステートを計算するためにさらに多くのコードをダウンロードする必要があることを意味します。</li>
</ol>
<p>すべてのコードがダウンロードされると、フレームワークはステートを計算し、そのステートをテンプレートにフィードすることが可能になります。
そして、ようやくリスナーのクロージャにたどり着き、クロージャをDOMにインストールできます。</p>
<p>インタラクティブなステートに至るには多くの作業が必要です。
現行世代のあらゆるフレームワークはこのように動作しています。
つまり、フレームワークがリスナーを発見してインストールするには、
結局はアプリケーションの大部分をダウンロードして実行しなければなりません。</p>
<h2>クロージャについて</h2>
<p>上記の問題の核は、コードをダウンロードするには大きな処理能力が必要であること、
そしてフレームワークがリスナーを発見し、ページがインタラクティブな状態になるまでに長いCPU時間がかかることです。
しかし、私たちはクロージャがコードとデータを囲い込むという性質を忘れています。
これはとても便利な特性であり、私たちがクロージャを気に入っている理由です。
しかし、これは同時にクロージャのすべてのデータとコードが、
クロージャの実行時に遅延して作成されるのではなく、
クロージャを作成した時点で利用可能でなければならないことも意味します。</p>
<p>例としてシンプルなJSXテンプレートを見てみましょう（ただし、他のテンプレートシステムにも同じ問題があります）。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>addToCart<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cart'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyBuyButton</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>cost<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    Price<span class="token operator">:</span> <span class="token punctuation">{</span>cost<span class="token punctuation">}</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">addToCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      Add to cart
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>クロージャによる死</h2>
<p>クロージャはコストが低いため、至るところで見られます。
しかし、クロージャは本当に低コストなのでしょうか。
その答えはイエスでもあり、ノーでもあります。
確かに、ランタイムにおいて短時間で作成できるという意味では低コストです。
しかし、コードを囲い込むために、クロージャがない場合より大幅に早くコードをダウンロードする必要があるという点では高コストです。
さらに、ツリーシェイキングを妨害するという意味でも高コストです。
そのため、筆者が「クロージャによる死」と呼ぶ状況が起きます。
クロージャはDOMに設置されるリスナーであり、実行される可能性がほとんどないコードを囲い込みます。</p>
<p>ページの「購入する」ボタンは複雑な割にしょっちゅうクリックされるようなものではありません。
それでも「購入する」ボタンは、関連するすべてのコードのダウンロードをしきりに促します。
これはクロージャがそのような仕組みになっているためです。</p>
<h2>QwikはリスナーのHTMLシリアライズを可能にする</h2>
<p>これまで、クロージャには隠れたコストがあるかもしれないと説明してきました。
こうしたコストはコードの頻繁なダウンロードという形で生じます。そのため、クロージャを作成し、ユーザとインタラクティブなWebサイトの間に介在させるのは困難です。</p>
<p>Qwikはリスナーの作成を可能な限り遅らせようとします。
これを実現するために、Qwikは以下のルールを掲げています。</p>
<ol>
<li>リスナーはHTMLにシリアライズできなければならない。</li>
<li>ユーザがリスナーとのインタラクションを行うまで、リスナーはコードを囲い込まない。</li>
</ol>
<p>これがどのように実現されるのか、実例で見てみましょう。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyComponent_click<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Click me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">MyComponent_click.ts</code>ファイルの内容は以下のとおりです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Clicked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のコードをご覧ください。
SSRはレンダリングプロセスの間にリスナーの場所を発見した後、
その情報を捨てるのではなく、リスナーを属性としてHTMLにシリアライズします。
そのため、クライアントはリスナーの場所を発見するためにテンプレートを再実行する必要がありません。
その代わりとして、Qwikは以下のアプローチをとります。</p>
<ol>
<li><code class="language-text">qwikloader.js</code>をページにインストールする。このファイルのサイズは1KB未満で、実行には1ミリ秒もかからない。ファイルがとても小さくHTMLに埋め込むのが最善の方法であるため、サーバーとのラウンドトリップが不要になる。</li>
<li><code class="language-text">qwikloader.js</code>は、1つのグローバルなイベントハンドラを登録し、バブリングを活用することで、すべてのイベントを同時にリッスンできる。addEventListenerの呼び出しが少なくなるため、インタラクティブな状態までの時間が短くなる。</li>
</ol>
<p>その結果が以下のとおりです。</p>
<ol>
<li>リスナーを発見するためにテンプレートをダウンロードする必要がない。リスナーは属性としてHTMLにシリアライズされる。</li>
<li>リスナーを取得するためにテンプレートを実行する必要がない。</li>
<li>テンプレートを実行するためにステートをダウンロードする必要がない。</li>
<li>すべてのコードが遅延され、ユーザがリスナーとのインタラクションを行うときにのみダウンロードされる。</li>
</ol>
<p>Qwikは現行世代のフレームワークによるブートストラップのプロセスを省略し、1つのグローバルなイベントリスナーで代替します。
この方法が最も優れているのは、アプリケーションのサイズに影響されないところです。
どんなにアプリが大規模で複雑になってもリスナーは1つだけです。
すべての情報がHTMLにシリアライズされているため、ダウンロードすべきブートストラップコードは常に一定で、その容量はアプリケーションの複雑性と無関係です。</p>
<p>まとめると、Qwikの背景にある基本的な考え方は再開性（resumability）です。
Qwikはサーバーの作業が中断された時点から作業を再開し、クライアント側が実行する必要があるファイルはわずか1KBです。
このコードはアプリケーションがどんなに大規模で複雑になっても変わりません。
これから数週間（訳注：原文では定期的に8記事まで公開されています）にわたって、
Qwikがどのように作業を再開し、ステートを管理し、コンポーネントを独立にレンダリングするかを見ていきます。お楽しみに。</p>
<p>私たちはQwikの未来や、Qwikが実現する新たな種類のユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwikの紹介 – HTMLファーストのフレームワーク]]></title><description><![CDATA[Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWe…]]></description><link>https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</link><guid isPermaLink="false">https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWeb Components、
そしてその間にあるすべてのフレームワークに至るまで、
さまざまなツールで同じサイトを生成できることです。
出力されるコードは速度が最適化されています。
私たちのツールで作成されたサイトは、手作業で作成されたサイトの大部分よりも高速です。
私たちはこれを心から誇りに思っています。
私たちの製品は、スピードがとても重要であるeコマースに焦点を当てています。</p>
<h2>優れたTime to Interactiveの実現は困難</h2>
<p>どんなにコードが最適化されていても、静的HTMLのみを提供していない限り、
eコマースサイトが<a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a>で100点中100点のスコアを達成するのは困難です。
そのため、ほとんどのeコマースサイトは20点程度の赤色スコアとなっています。
高速化に重点的に取り組む余裕がある特に優れたサイトだけが50～60点の黄色スコアを獲得できます。
Builder.ioを利用しても50～60点の黄色スコアを達成できるでしょう。
しかし、私たちはもっと点数を良くしたいのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--hNfE5FAv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5zttsnsvx80ic0y3v4wa.png"></p>
<h2>HTMLだけなら高速</h2>
<p>とはいえ、静的HTMLを提供すれば点数は良くなります。
ほぼ確実に100点中100点のスコアを獲得できるでしょう。
そもそもPageSpeed Insightsのスコアは、ページがインタラクティブになる前にブラウザが実行しなければならないコードの量に基づいて測定されます。
JavaScriptをまったく実行しないようにすれば、100点満点を獲得し、簡単に緑色スコアに到達できます。
しかし、この方法にはページが静的になるという問題があります。
Webページは動的なコンテンツを提供し、インタラクションに満ちた生き生きとしたものでなければなりません。
静的HTMLで高いスコアを獲得しつつ、同時にリッチなインタラクションを提供するにはどうすれば良いのでしょうか。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--VCPVUPTb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/inff3jmvl300d1yaxaya.png"></p>
<h2>Qwikの導入 – HTMLファーストのフレームワーク</h2>
<p>そこでQwikの登場です。
Qwikは、オープンソースで開発されている、DOM主体で resumable（再開可能な）Webアプリフレームワークです。
QwikはHTMLのサーバーサイドレンダリングの resumability（再開性）と、コードのきめ細かい遅延読み込みに重点を置くことで、
できる限り優れたTime to Interactiveを実現するように設計されています。
説明したいことが盛りだくさんで、今回のブログ記事だけではとてもカバーしきれません。
そこで、説明をいくつかのブログ記事に分割し、今後数週間にわたって投稿する予定です。
Qwikの基本的な目標は、ブラウザの遅延読み込み機能をできる限り活用し、JavaScriptを遅延させ、Time to Interactiveの指標を改善することです。
これは既存のフレームワークとはまさに対照的と言えます。
こうしたフレームワークは、サーバーサイドレンダリングとTime to Interactiveを、
その他すべての設計上の意思決定に影響する主な目標とは捉えておらず、
付け足し程度にしか考えていませんでした。
Qwikの目的は、どんなに遅いモバイル端末でも、Time to Interactiveをほんの一瞬にまで短縮することです。
私たちは、高速な静的ページをユーザに提供しつつ、インタラクティブ性も完全に維持したいと考えています。
つまり、一挙両得を目指しているのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--vNxZwFXl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dy3wa5ewpz9o9xoa87ys.png"></p>
<h2>replayable なフレームワークは作業が多すぎる</h2>
<p>ほとんどのeコマースサイトがPageSpeed Insightsで100点を取れないのには理由があります。
それは、どの既存のフレームワークもTime to Interactiveを念頭に置いて設計されていないということです。
これらのフレームワークは複雑なブートストラップのプロセスを持ち、
ページがインタラクティブになる前に多くのコードをダウンロード・実行する必要があります。
確かに、ほとんどのフレームワークはサーバーサイドレンダリングに対応しており、
初期コンテンツを素早く表示できます。
しかし、ページを再ハイドレートしてインタラクティブな状態にするには、
まずはページ上のすべてのテンプレートをダウンロードし、実行しなければなりません。
現在の既存のサイトが100点を取れずにいるのは、こうしたダウンロードや実行を行わなければならないせいです。
既存のフレームワークは、サイトをインタラクティブにするために、
サーバーサイドレンダリングにおけるすべての作業をクライアント側で再び実施する必要があるため、
replayable（再生型）であると言えます。
サイトが複雑になるにつれて、再生可能な状態を維持するためのコストも増えていきます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--PdQoT-lX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lqgpauzo2i23f3zhhke8.png"></p>
<h2>resumability が救世主に</h2>
<p>Qwikの背景にある基本的な考え方は resumability です。
Qwikはサーバーの作業が中断された時点から作業を再開できます。
クライアント側で実行するコードはほんの最小限です。
Qwikloaderは、サーバーサイドレンダリングによって生成された静的HTMLを取得し、レンダリングを再開します。
Qwikloaderのサイズは1KB未満で、実行に1ミリ秒もかかりません。
思わず前の文を読み直したくなるかもしれませんが、読み間違いではありません。
実行が必要なコードの量は驚くほど小さく、まばたきよりも短い時間で実行されます。
最も優れているのは、アプリケーションがどんなに大きくなっても、このコードが変わらないことです。
ユーザが最小限の部分でWebサイトとのインタラクションをしている間に、
サイトのその他すべてのインタラクティブな部分が遅れてダウンロードされます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ufFUjYds--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/550d4im90829stbvbvs0.png"></p>
<h2>もっと詳しく知る</h2>
<p>私たちが最も重視しているのは、この技術をお客様のために開発することです。
しかし、開発はオープンソースで行われるため、あらゆる人がどんな目的にも利用できます。
私たちはこの技術を汎用的なWebフレームワークとして設計する予定ですが、
お客様が必要とするものを最優先します。</p>
<p>読者の皆様は、もっと詳しい情報を知りたくてたまらないことでしょう。
そこで、皆様をStackBlitzのWebコンテナの<a href="https://stackblitz.com/edit/qwik-todo-demo">デモ</a>にご招待します。
素晴らしいことに、StackBlitzのスタッフはNode.jsをブラウザで実行する能力があり、
そのため私たちはフレームワークの重要な部分である、サーバーサイドレンダリングのデモを行うことができます（彼らに敬意を表します）。
オープンソースのリポジトリは<a href="https://github.com/builderio/qwik">こちら</a>です。
期待が大きくなりすぎないように言っておくと、リポジトリはあくまで概念実証の段階にあり、
多くの物事が時とともに変わると予想されるため、広く利用できる状態ではありません。
それでも、私たちは皆さんの考えを聞きたいと思っています。
ですから、ぜひ<a href="https://discord.gg/JHVpZmqSs4">Discordサーバーでのチャット</a>にご参加ください。</p>
<p>今後数週間（訳注：原文では定期的に8記事まで公開されています）で、
Qwikの背景にある多くのユニークなアイデアを詳しく解説し、
Qwikの仕組みと独自な点を説明していきます。お楽しみに。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item></channel></rss>