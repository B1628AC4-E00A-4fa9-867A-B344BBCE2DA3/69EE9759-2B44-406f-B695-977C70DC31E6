<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア]]></title><description><![CDATA[POSTD は、ニジボックスが運営する、エンジニアに向けたキュレーションメディアです。ニジボックスはWebサービスの企画、制作、開発、運用を一貫して担うリクルートの100%子会社です。 リクルートグループのオンラインサービスをはじめ、様々な業種・業界・業態のサービス開発を行っております。]]></description><link>https://postd.cc</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 03 Mar 2023 04:24:13 GMT</lastBuildDate><language>ja</language><atom:link href="https://postd.cc/feed/" rel="self" type="application/rss+xml"/><image><title>POSTD | ニジボックスが運営するエンジニアに向けたキュレーションメディア</title><link>https://postd.cc</link></image><item><title><![CDATA[Miško HeveryのQwik記事シリーズ]]></title><description><![CDATA[POSTDでは、DEV Communityで公開されているQwikシリーズ の翻訳記事を公開予定です。 翻訳記事の更新に合わせてこのページも更新されていきます。 シリーズ記事一覧 Qwikの紹介 –…]]></description><link>https://postd.cc/series-qwik/</link><guid isPermaLink="false">https://postd.cc/series-qwik/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:01:00 GMT</pubDate><content:encoded><![CDATA[<p>POSTDでは、DEV Communityで公開されている<a href="https://dev.to/mhevery/series/13467">Qwikシリーズ</a> の翻訳記事を公開予定です。</p>
<p>翻訳記事の更新に合わせてこのページも更新されていきます。</p>
<h2>シリーズ記事一覧</h2>
<ol>
<li><a href="/a-first-look-at-qwik-the-html-first-framework/">Qwikの紹介 – HTMLファーストのフレームワーク</a></li>
<li><a href="/death-by-closure-and-how-qwik-solves-it/">クロージャによる死（とQwikによる解決方法）</a></li>
<li><a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣</a></li>
<li><a href="/qwik-the-answer-to-optimal-fine-grained-lazy-loading/">Qwik：最適できめ細かい遅延読み込みを実現</a></li>
<li><a href="/how-to-score-100-on-google-pagespeed-insights-on-mobile/">モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには</a></li>
<li><a href="/your-bundler-is-doing-it-wrong/">既存のバンドラの手法は間違っている</a></li>
<li><a href="/how-we-cut-99-of-our-javascript-with-qwik-partytown/">QwikとPartytownでJavaScriptを99%削減する方法</a></li>
<li><a href="/introducing-qwik-starters-get-up-and-running-with-qwik-now/">Qwikスターターの紹介 – 今すぐQwikを起動・実行してみよう</a></li>
</ol>]]></content:encoded></item><item><title><![CDATA[Qwikスターターの紹介 – 今すぐQwikを起動・実行してみよう]]></title><description><![CDATA[コードを書いて新たな発見をするほど楽しいことはありません。
ついにの登場です。
どんなサイズでもリーンで高パフォーマンスなWebアプリを開発するための新たな方法をお試しください。
builder.i…]]></description><link>https://postd.cc/introducing-qwik-starters-get-up-and-running-with-qwik-now/</link><guid isPermaLink="false">https://postd.cc/introducing-qwik-starters-get-up-and-running-with-qwik-now/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:00:02 GMT</pubDate><content:encoded><![CDATA[<p>コードを書いて新たな発見をするほど楽しいことはありません。
ついに<code class="language-text">npm init qwik</code>の登場です。
どんなサイズでもリーンで高パフォーマンスなWebアプリを開発するための新たな方法をお試しください。
<a href="https://www.builder.io/">builder.io</a>のサイトも同じ技術で開発されており、<a href="https://www.builder.io/blog/how-we-cut-99-percent-js-with-qwik-and-partytown">PageSpeed Insights</a>で100点中100点を獲得しています。</p>
<p>QwikスターターCLIは、Qwikを試しに直接体験してみて、他のフレームワークとの違いを深く理解するためのシンプルなスターターです。

このCLIに含まれている例は次の4つで、近い将来に拡張される予定です。</p>
<ul>
<li><code class="language-text">starter</code>：基本的なHello Worldプログラム。</li>
<li><code class="language-text">starter-builder</code>：基本的なHello Worldプログラムをbuilder.ioの<a href="https://www.builder.io/c/docs/qwik-api">Qwik API</a>と統合したもの。</li>
<li><code class="language-text">starter-partytown</code>：基本的なHello Worldプログラム。<a href="https://github.com/BuilderIO/partytown">Partytown</a>を利用して、Web Workerで重いタスクを実行できることを明らかにします。</li>
<li><code class="language-text">todo</code>：古典的な<a href="https://todomvc.com/">TodoMVC</a>アプリケーション。</li>
</ul>
<h2>基本的なスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-starter
✔ Select a starter › Starter
✔ Select a server › Express

⭐️ Success! Project saved in qwik-starter directory

📟 Next steps:
   cd qwik-starter
   npm install
   npm start

> (cd qwik-starter; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--pTKj8XhI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F17ab71fc12be4fbb9a8b19415998995f%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-starter">StackBlitz</a>で試す</p>
<h2>Builder Qwik APIを利用するスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-builder
✔ Select a starter › Starter Builder
✔ Select a server › Express

⭐️ Success! Project saved in qwik-builder directory

📟 Next steps:
   cd qwik-builder
   npm install
   npm start

> (cd qwik-builder; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--pLn7Tx8D--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F8c4425a663a84a41a85555f53f2665fc%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-todo-builder">StackBlitz</a>で試す</p>
<h2>Partytownを利用するスターター</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-partytown
✔ Select a starter › Starter Partytown
✔ Select a server › Express

⭐️ Success! Project saved in qwik-partytown directory

📟 Next steps:
   cd qwik-partytown
   npm install
   npm start

> (cd qwik-partytown; npm install; npm start) </span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Z3-eRBUs--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252F135effed7c724979b0fe246bd9cc20ac%3Fformat%3Dwebp%26width%3D2000"></p>
<h2>古典的なTodoMVC</h2>
<div class="gatsby-highlight" data-language="shell-session"><pre style="counter-reset: linenumber NaN" class="language-shell-session line-numbers"><code class="language-shell-session"><span class="token output">> npm init qwik
💫 Let's create a Qwik project 💫

✔ Project name … qwik-todo
✔ Select a starter › Todo
✔ Select a server › Express

⭐️ Success! Project saved in qwik-todo directory

📟 Next steps:
   cd qwik-todo
   npm install
   npm start

> (cd qwik-todo; npm install; npm start)</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--jlVYtU6n--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://cdn.builder.io/api/v1/image/assets%252FYJIGb4i01jvw0SRdL5Bt%252Fc7c0ea671c4547ecb2cd7da50843b97f%3Fformat%3Dwebp%26width%3D2000"></p>
<p><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</p>
<h2>プロファイラで解析</h2>
<p>開発ツールを開き、上記の例をすべてプロファイラで解析してみてください。
メインスレッドでほとんど時間がかかっていないのが分かるでしょう。</p>
<p>皆さんのコーディングが楽しくなることを願っています。ぜひフィードバックをお寄せください。</p>
<ul>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[QwikとPartytownでJavaScriptを99%削減する方法]]></title><description><![CDATA[うれしいことに、builder.ioのホームページは今やモバイル端末でもPageSpeed Insightsで100点中100点をとれるようになりました。
これはQwikを導入したおかげです。 Qw…]]></description><link>https://postd.cc/how-we-cut-99-of-our-javascript-with-qwik-partytown/</link><guid isPermaLink="false">https://postd.cc/how-we-cut-99-of-our-javascript-with-qwik-partytown/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 03 Mar 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>うれしいことに、<a href="http://builder.io/">builder.io</a>のホームページは今やモバイル端末でも<a href="https://pagespeed.web.dev/report?url=https%3A%2F%2Fbuilder.io%2F">PageSpeed Insights</a>で100点中100点をとれるようになりました。
これは<a href="https://github.com/builderio/qwik">Qwik</a>を導入したおかげです。</p>
<p><a href="https://github.com/builderio/qwik">Qwik</a>はアプリケーションの規模に関係なく高いパフォーマンスを実現します。
上記のスコアは、以下の優れた技術によって達成されました。</p>
<ul>
<li><a href="https://github.com/builderio/qwik">Qwik</a>で提供されるページの起動に必要なJavaScriptは1KB未満</li>
<li>ホームページは画面上の領域のコンテンツに必要なHTMLのみを送信</li>
<li><a href="https://github.com/BuilderIO/partytown">Partytown</a>を利用し、すべてのサードパーティスクリプトをWeb Workerに移動</li>
<li><a href="https://builder.io/">builder.io</a>の視覚的なノーコードエディタを利用してサイトを作成</li>
</ul>
<p>Qwikは、数百のコンポーネントや数MBのコンテンツを有する大規模なサイトでも高速なパフォーマンスを実現します。
また、クライアントコンポーネントに移動できるインタラクティブなサーバーサイドコンポーネントも提供します。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aDEN_dzQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mfuty5116bna9h6xyawr.png"></p>
<h2>過去のスコア</h2>
<p>当社のストーリーはここから始まりました。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--CzQUpHAt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ol56o66cw8gpxsbxaixr.png"></p>
<p>注目すべき点は、サイトのパフォーマンスが平均的であることです。
GoogleのPageSpeed Insightsは、モバイル端末において、ページの読み込みが開始されてから、ユーザーがリンクをクリックして反応が返ってくるまでの時間を7.6秒と推定していました。
これは優れたユーザー体験とは言えません。
さらに、GoogleはPageSpeed InsightsのスコアをSEOランキングに反映しています。</p>
<p>スコアがいまひとつである理由は、サイトの起動時に大量のJavaScriptを実行する必要があるためです。
現在は静的サイトでも、メニューやインタラクティブコンテンツに加え、Google Tag Manager、Intercom、CRMサービスといったサードパーティの解析スクリプトを追加するために、多くのJavaScriptを搭載しています。</p>
<p>JavaScriptサイトの速度を遅くする主な要因は、サイト自体とサードパーティスクリプトの2つです。</p>
<p>低速化の第1の原因はフレームワークです。
現代のフレームワークは優れた開発者体験を提供し、Webサイトのインタラクティブ性を高めます。
しかし、その代わりに大規模なJavaScriptをダウンロードする必要があるうえに、サーバーで生成されたHTMLと、フレームワークが予測するDOMを照合しなければならないため、起動時間が遅くなります。
このプロセスは差分検出や再ハイドレーションと呼ばれており、あらゆるフレームワーク（Qwikを除く）はこの宿命から逃れられません。
差分検出や再ハイドレーションで重要なのは、フレームワークがリスナーをDOMにアタッチし、サイトをインタラクティブにする部分です。
これが理由で、差分検出や再ハイドレーションは可能な限り早くしなければなりません。
そうしないと、サイトが機能しなくなります（メニューやチャットウィジェットがないサイトを想像してみてください）。</p>
<p>低速化の第2の原因はサードパーティスクリプトです。
確かに、現実にはPageSpeed Insightsのスコアが良いデモサイトや「新築」のWebサイトが数多くありますが、ほとんどの場合、スコアが良い理由はサードパーティスクリプトがまだ搭載されていないからです。
当社のサイトに搭載されているサードパーティスクリプトをいくつか紹介します。</p>
<ul>
<li>Google Tag Manager：現在のあらゆるサイトにとって必須の存在です。利用状況に関する統計データを収集し、サイトの使われ方や、どう改善すれば良いかについて、マーケティング上の知見を得るために利用されます。Google Tag Managerは最初に実行され、PageSpeed Insightsにおけるサイトの基準タイム以上のCPU処理時間を単独で消費するため、スコアが低下します。</li>
<li>Intercom：顧客がサイトで開発者とリアルタイムでチャットし、質問をしたり、詳しい情報を聞いたりすることができます。</li>
<li>Twitter：当社の製品に関する感想はTwitterウィジェットに表示されます。ウィジェットを利用するにはTwitterのJavaScriptを読み込む必要があります。</li>
</ul>
<p>これらのスクリプトはすべて、サイトが読み込まれた時点で即座に実行され、上記の差分検出や再ハイドレーションのステップのためにCPUを奪い合うので、ユーザー体験が悪化します。</p>
<p>問題は開発者がこうした状況をほとんどコントロールできないことです。
マーケティングチームが必要とする解析機能やユーザーサービス機能を追加するには、サードパーティスクリプトを利用しなければなりません。
また、サイトの起動時に時間のかかる差分検出が求められる既存のフレームワークを利用する必要もあります。
開発者がコントロールできる部分は多くありません。
これが業界の現状であり、そのため標準的なアプローチでは誰もあまり良い結果を出せません。</p>
<p>QwikとPartytownは、この問題の解決を目指しています。</p>
<h2>現在のスコア</h2>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--aDEN_dzQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mfuty5116bna9h6xyawr.png"></p>
<table>
<thead>
<tr>
<th>指標</th>
<th>前</th>
<th>後</th>
<th>単位</th>
<th>%</th>
</tr>
</thead>
<tbody>
<tr>
<td>パフォーマンススコア</td>
<td>52</td>
<td>100</td>
<td>秒</td>
<td>92%</td>
</tr>
<tr>
<td>First Contentful Paint</td>
<td>3.4</td>
<td>1.1</td>
<td>秒</td>
<td>309%</td>
</tr>
<tr>
<td>Speed Index</td>
<td>3.4</td>
<td>1.1</td>
<td>秒</td>
<td>309%</td>
</tr>
<tr>
<td>Largest Contentful Paint（LCP）</td>
<td>3.8</td>
<td>1.2</td>
<td>秒</td>
<td>316%</td>
</tr>
<tr>
<td>Time to Interactive（TTI）</td>
<td>7.6</td>
<td>1.4</td>
<td>秒</td>
<td>543%</td>
</tr>
<tr>
<td>TTI – LCP（差）</td>
<td>3.8</td>
<td>0.3</td>
<td>秒</td>
<td>1,266%</td>
</tr>
<tr>
<td>Total Blocking Time</td>
<td>1,300</td>
<td>40</td>
<td>ミリ秒</td>
<td>3,250%</td>
</tr>
<tr>
<td>Cumulative Layout Shift</td>
<td>0</td>
<td>0</td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
<p>この数値はモバイル端末のものです。
モバイル端末はデスクトップに比べて、優れたパフォーマンスを達成するためのハードルがはるかに高くなります。</p>
<p>上記の表は、当社が現在、QwikとPartytownでどれだけのスコアを達成したかを示しています。
これは非常に大きな改善と言えます。
Time to Interactiveは7.6秒から1.2秒へ、Total Blocking Timeは1.3秒から40ミリ秒へ短縮されています。
JavaScriptの実行時間を短縮できた直接の要因は、フレームワークについてはQwik、サードパーティスクリプトについてはPartytownです。</p>
<p> <img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ky-SejuS--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/66w9x8saqkumy3nttv4d.png"></p>
<p>上記はQwikとPartytownを導入する前のパフォーマンスの解析結果です（モバイル端末のエミュレート）。</p>
<ul>
<li>ページの読み込みには1.8秒かかっています。</li>
<li>メインスレッドは、ほとんどの時間、「差分検出」（DOMリスナーを設置する場所を探す作業）で非常にビジーな状態です。</li>
<li>上記の結果、多くのフレームが落ちています。</li>
<li>メインスレッドが「差分検出」でビジーになる前に、JavaScriptコードを読み込むためのカスケードが生じています。</li>
</ul>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--NFv_raDZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4940z1i5ar81b1kq3340.png"></p>
<p>ここで、従来の起動時のパフォーマンスと、QwikとPartytownを導入した後のパフォーマンスを比較してみましょう。</p>
<ul>
<li>JavaScriptはダウンロードしていません。</li>
<li>ページの読み込みにかかった時間は0.5秒です。</li>
<li>メインスレッドは、ほぼアイドル状態です。</li>
<li>フレームはほとんど落ちていません。</li>
<li>Partytownの読み込みは後回しにされています。</li>
<li>サードパーティスクリプトは（メインスレッドではなく）Web Workerで実行されています。</li>
</ul>
<p>過去と現在のパフォーマンスには明らかな違いがあります。</p>
<p>重要なことは、QwikやPartytownのアルゴリズムが特別に優れているわけではないということです。
QwikやPartytownはほとんどのJavaScriptをメインスレッドから移動させて負担を軽減しており、それによってページを高速に読み込んでいます。
ただし、Qwikでは、たとえJavaScriptがほぼ存在しなくても、ページは完全にインタラクティブな状態に維持されます。
Qwikは「良いとこ取り」が可能なのです。JavaScriptのサイズを見てみましょう。</p>
<table>
<thead>
<tr>
<th>指標</th>
<th>最小化</th>
<th>圧縮</th>
</tr>
</thead>
<tbody>
<tr>
<td>ベースライン（メインスレッドのJavaScript）</td>
<td>1,800KB</td>
<td>326KB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Qwik + Partytown (Main Thread JS)</strong>*</td>
<td>3.5KB</td>
<td>2.5KB</td>
</tr>
<tr>
<td>-->パート：Qwikloader</td>
<td>.5KB</td>
<td>1KB</td>
</tr>
<tr>
<td>-->パート：Partytown confg</td>
<td>.5KB</td>
<td>1KB</td>
</tr>
<tr>
<td>-->パート：Partytown</td>
<td>2.5KB</td>
<td>1.5KB</td>
</tr>
<tr>
<td>===サイズの改善===</td>
<td>51,429%</td>
<td>13,000%</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Web WorkerのサードパーティJavaScript</td>
<td>219KB</td>
<td>82KB</td>
</tr>
<tr>
<td>-->パート：Zoominfo</td>
<td>1.5KB</td>
<td>1.3KB</td>
</tr>
<tr>
<td>-->パート：Google Tag Manager</td>
<td>167KB</td>
<td>60KB</td>
</tr>
<tr>
<td>-->パート：Google Analytics</td>
<td>50KB</td>
<td>21KB</td>
</tr>
<tr>
<td>-->パート：site-tracking</td>
<td>217KB</td>
<td>64KB</td>
</tr>
</tbody>
</table>
<p>メインスレッドのJavaScriptを1.8MBから3.5KBに縮小できました。これは素晴らしい成果です。</p>
<p>元のサイトのJavaScriptは1.8MBで、うち219KBは開発者がコントロールできないサードパーティスクリプトでした。
つまり、サイト自体のJavaScriptは1.6MBで、そこには再ハイドレーションが必要なフレームワーク、テンプレート、スタイリングが含まれます。
標準的なフレームワークを利用する場合、サイトはコンテンツを2回ダウンロードすることになります。
1回目はHTMLとして、2回目はJavaScriptとしてのダウンロードです。
二重のダウンロードが1.6MBのコードの主な要因です（圧縮すると大幅に減って244KBになるため、サイトのテンプレートであると分かります）。</p>
<p>こちらを基準として、QwikとPartytownを利用した場合の3.5KBと比較してみましょう（圧縮すると2.5KB）。
再度強調しますが、QwikとPartytownを利用すれば、メインスレッドで実行する必要があるJavaScriptはわずか3.5KBになります。
メインスレッドの仕事がないので、サイトの読み込みはとても高速になります。
もう1つのポイントは、どんなにサイトが複雑化しても3.5KBのサイズは変わらず、いわば「固定費」であることです。</p>
<p>サードパーティコードの実行に関する問題はまだ残っていますが、これらのコードはメインスレッドより優先順位が低いWeb Workerのスレッドに再配置されています。
サードパーティコードは全体でも220KBで、メインスレッドのパフォーマンスに影響を及ぼさずに役割を果たすことができます。</p>
<p>さらに、もう1つポイントがあります。先ほど述べたとおり、既存のフレームワークはサイトを2回ダウンロードする必要があります。
1回目はHTMLとして、2回目はJavaScriptとしてのダウンロードで、JavaScriptのサイズは1.6MBです。
このような場合にQwikは威力を発揮します。
Qwikは1.6MBのJavaScriptを複数の異なるチャンクに分割します。
そして、Qwikはユーザーインタラクションがあったときだけ、JavaScript全体の一部だけをダウンロードします。
Qwikはコンポーネントを順不同に、かつ遅延して再ハイドレーションできます。
そのため、ユーザーがページ上で何らかのインタラクションをするまで、JavaScriptはまったく必要ありません。
さらに、ハイドレーションがコンポーネントごとに独立しているため、ユーザーのインタラクション時にJavaScriptのごく一部をダウンロード・実行するだけで、インタラクトされたコンポーネントのみをハイドレートできます。</p>
<p>つまり、メリットは以下の2つです。</p>
<ol>
<li>ページの起動時に何もする必要がない。</li>
<li>再ハイドレーションの必要があるときでも、範囲を限定し、（ページ全体ではなく）1つのコンポーネントだけを再ハイドレートできる。</li>
</ol>
<p>最後に注目しておきたいのは、ページの大部分は静的なのでその部分のコンポーネントがハイドレートされることはなく、JavaScriptもまったくダウンロードされないという点です。</p>
<h2>Qwikとは？</h2>
<p>QwikはTime to Interactiveに焦点を当てた新しいタイプのWebフレームワークです。
Qwikには、サーバーで実行を開始し、HTMLへシリアライズし、クライアントに送信できるというResumability（再開性）があります。
クライアント側では、qwikloader.js（クライアント側で実行される1KB未満のJavaScript）がアイドル状態でユーザーのインタラクションを待っています。
ユーザーがインタラクトすると、Qwikはサーバーが処理を中断したところから実行を再開できます。
QwikにはResumabilityがあるので、起動時に差分検出をする必要がなく、ユーザーがインタラクトしたコンポーネントのみをハイドレートすればよいのです。
Qwikはサーバーでコンポーネントを作成し、それをクライアントへシームレスに移動できます。
これらすべてのプロセスによって、上記のとおり、アプリケーションは即座に利用可能になります。</p>
<h2>画面外領域のコンテンツを遅延読み込み</h2>
<p>QwikはすべてのステートをDOMに保持します。
これはQwik自体がステートレスであるという意味です。
ステートレス属性によって、画面外領域のコンテンツを遅延読み込みできます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o48jE9q6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/565yei3n8jydkkvs81yr.gif"> </p>
<p>上記は既存のフレームワークではとても困難ですが、Qwikなら朝飯前です。</p>
<h2>Partytownとは？</h2>
<p>PartytownはサードパーティスクリプトをWeb Workerに再配置できます。
サードパーティスクリプトは、サイトのTime to Interactiveを遅くする最大の原因になっていることがよくあります。</p>
<h2>次はどうなる？</h2>
<p>私たちは、Qwikを皆さんに早く届けるために尽力しています。
Qwikによってどんなに素晴らしいサイトを開発できるか、皆さん自身の目で確かめてください。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[既存のバンドラの手法は間違っている]]></title><description><![CDATA[最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、…]]></description><link>https://postd.cc/your-bundler-is-doing-it-wrong/</link><guid isPermaLink="false">https://postd.cc/your-bundler-is-doing-it-wrong/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>最近のバンドラは、アプリケーションコードのどの部分をいつ遅延読み込みするかを開発者が決めなければなりません。
開発者は以下のように、コードベースにdynamic importを挿入することによって、遅延読み込みをする場所とタイミングを決定します。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> chunk <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./my-chunk'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>chunk<span class="token punctuation">.</span>someSymbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>開発者は以下を行う必要があります。</p>
<ul>
<li>コードのどの部分が遅延読み込みに適しているかを判断します。</li>
<li>既存のアプリケーションワークフローとの互換性がある方法で遅延読み込みを実行します（遅延読み込みは本質的に非同期ですが、遅延読み込みを実行するための理想的な関数は同期型の可能性があるため、遅延読み込みコードを設置できる場所は限られます）。</li>
<li><code class="language-text">./my-chunk</code>にチャンク名を割り当てます。バンドラがチャンクに割り当てる名前や、チャンクを1つのアプリケーションにまとめる方法に影響を及ぼします。</li>
<li>何をチャンクに含めるかを判断します（例えば、<code class="language-text">symbolA</code>と<code class="language-text">symbolB</code>は同じチャンクに含めるべきか、別のチャンクに分けるべきか？）。</li>
</ul>
<p>ここで問題なのは、開発者はソースコードを書いている時点では、遅延読み込みするコードの選択が適切であるか、チャンクに適切なシンボルが存在するかが分からないということです。
この点は、アプリケーションを実際にデプロイし、現実に利用状況を観察してみないとはっきりしません。
例えば、設定ページはほとんどアクセスされないので、メインバンドルから除くべきかもしれません。
あるいは、通知セクションを遅延読み込みにしたところ、実際はユーザが最もよくアクセスするページだったため、ユーザ体験がかえって悪化している可能性もあります。</p>
<p>さらに悪いことに、ひとたび開発者が選択をすると、バンドラがそれを補うためにできることはほんの少しです。
バンドラは、まさに開発者が求めることをしなければなりません。
バンドラにもっと自由を与えるには、まったく新しい方法で問題を見る必要があります。</p>
<p>ポイントは、コードを書いている時点では最終的なバンドルがどうなるかが分からないため、どこにdynamic importを挿入すべきかを判断するための十分な情報がないことです。
一方、チャンクの理想的な姿を判断するための十分なデータが集まったときには、ソースコードはすでに書き上がっています。
さかのぼってdynamic importを挿入するのは、大きな手間になるかもしれません（あるいは、過剰な遅延読み込みによって、アプリを細かく分割しすぎる恐れもあります）。</p>
<p>私たちが求めているのは、チャンクの理想的な数を判断し、現実のユーザによるアプリケーションの利用状況に基づいてチャンク間でコードを移動できることです。
これを実行する際に、さかのぼってソースコードをリファクタリングする必要がないことが望ましいでしょう。
チャンクのレイアウトは、コードとしてコードベースに組み込むのではなく、設定情報としてバンドラに移すべきです。</p>
<p>さらに複雑なことに、最近のフレームワークはすべて同期方式のレンダリングパイプラインを採用しています。
そのため、非同期方式のdynamic importをアプリケーションに挿入するのがとても難しくなります。</p>
<p>最適な遅延読み込み戦略を追求するなら、上記の問題を解決する必要があります。</p>
<h2>Qwikの登場</h2>
<p>コンポーネントはQwikアプリケーションの基本的な構成要素です。
Qwikはコンポーネントを3つの部分に分割することを求めます。</p>
<ol>
<li><strong>ビュー</strong>：コンポーネントのビジュアル部分をレンダリングするJSXコードが含まれます。</li>
<li><strong>ステート</strong>ファクトリー：コンポーネントの新たなステートを作成するコードが含まれます。</li>
<li>イベント<strong>ハンドラ</strong>：コンポーネントの挙動やユーザとのインタラクションに利用されるコードが含まれます。</li>
</ol>
<h2>なぜコンポーネントを3つの部分に分割するのか？</h2>
<p>ほとんどのフレームワークは、ビュー、ステート、ハンドラのコードを1つにまとめています。
以下は、この働きを解説するために用意した擬似フレームワークのコードです。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> <span class="token punctuation">{</span>step<span class="token operator">?</span><span class="token operator">:</span>number<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>count<span class="token operator">:</span> <span class="token number">50</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> step <span class="token operator">=</span> props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">-</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">-</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> step<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">+</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>botton</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
 )
}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントのビュー、ステート、ハンドラがすべて一緒になっているのに注目してください。
これはそれらのすべて（ビュー、ステート、ハンドラ）を同時にダウンロード、パース、実行しなければならないことを意味します。
そのため、遅延読み込みはかなり制限されます。</p>
<p>ここで挙げた程度の例では大きな問題にならないかもしれませんが、上記のコードがもっと複雑になって、何KBものコードを一度にダウンロード、パース、実行する必要がある場合を想像してみてください。
その場合、ビュー、ステート、ハンドラを何としても一緒に読み込ませようとするのは良くないかもしれません。
それがなぜ問題なのかを、ユーザのよくある利用パターンを通して見ていきましょう。</p>
<p><strong>ユーザがコンポーネントをクリックしてインタラクトする：</strong></p>
<ul>
<li>一部の<code class="language-text">handler</code>だけが必要：ダウンロードしなければならないのは、トリガーされた特定のハンドラのみです。その他のハンドラはすべて不要です。</li>
<li><code class="language-text">view</code>は<strong>不要</strong>：ハンドラによる再レンダリングが行われない可能性や、異なるコンポーネントの再レンダリングが行われる可能性があるので、ビューは不要かもしれません。</li>
<li><code class="language-text">state factory</code>は<strong>不要</strong>：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>コンポーネントのステートが変更される：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は不要：コンポーネントが再ハイドレートされるため、ステートを初期化するためのコードは不要です。</li>
</ul>
<p><strong>親が新たなコンポーネントを作成する：</strong></p>
<ul>
<li><code class="language-text">handler</code>は<strong>不要</strong>：ハンドラを実行する必要はありません。</li>
<li><code class="language-text">view</code>は必要：コンポーネントを再レンダリングする必要があるため、ビューは必要です。</li>
<li><code class="language-text">state factory</code>は必要：コンポーネントが作成されるため、ステートを初期化するためのコードは必要です。</li>
</ul>
<p>上記の例は、それぞれのケースで必要なのがビュー、ステート、ハンドラ情報の一部のみであることを示しています。
問題は、3つの異なる情報がすべて一緒に埋め込まれているのに対し、それらがコンポーネントのライフサイクルにおいて異なるタイミングでしか利用されないことです。
最適なパフォーマンスを達成するには、コンポーネントに求められる役割に基づき、コンポーネントを部分ごとにダウンロード・実行する方法が必要です。
上記のコードでは、ご覧のとおり、コンポーネントを永久に分離できません。</p>
<h2>分割は簡単</h2>
<p>Qwikは、当面のタスクに必要なコードだけをダウンロード・実行することでこの問題を解決します。
上記の例のコードはシンプルですが、現実のコードはずっと複雑であることを忘れないでください。
さらに、コードが複雑になるとimportが増えることが多く（import自身もimportを必要とします）、コンポーネントのコードは一段と増加します。
この状況を「ツール」で解決することはできません。
コンポーネントをパーツ単位に分割し、必要に応じて遅延読み込みできるようにするための静的解析ツールを作成するのは不可能です。
開発者は、対応する部分ごとにコンポーネントを分割し、きめ細かい遅延読み込みを可能にしなければなりません。</p>
<p>そのために、Qwikはマーカー関数の<code class="language-text">qrlView</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を導入しています。</p>
<p>ファイル：<code class="language-text">my-counter.tsx</code></p>
<div class="gatsby-highlight" data-language="tsx"><pre style="counter-reset: linenumber NaN" class="language-tsx line-numbers"><code class="language-tsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>
 QComponent<span class="token punctuation">,</span>
 qComponent<span class="token punctuation">,</span>
 qrlView<span class="token punctuation">,</span>
 qrlHandler<span class="token punctuation">,</span>
 qrlState
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントの型を宣言し、プロパティとステートの形態を定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">Counter</span> <span class="token operator">=</span> QComponent<span class="token operator">&lt;</span><span class="token punctuation">{</span> step<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
                                   <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのステートファクトリーを宣言します。</span>
<span class="token comment">//これはステートを初期化するために新たなコンポーネントが作成される際に利用されます。</span>
<span class="token comment">//（再ハイドレーションでは利用されません。）</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlState</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのレンダリングに利用されるコンポーネントのビューを定義します。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlView</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>Counter_update<span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token punctuation">{</span> direction<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//コンポーネントのビューは、挙動を記述するハンドラを必要とする場合があります。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update
   <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qrlHandler</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token punctuation">,</span> <span class="token punctuation">{</span>direction<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>
       <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//最後にすべてを1つのコンポーネントにまとめます。</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token generic-function"><span class="token function">qComponent</span><span class="token generic class-name"><span class="token operator">&lt;</span>Counter<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> CounterState<span class="token punctuation">,</span>
 view<span class="token operator">:</span> CounterView<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>上記のコードは他のフレームワークに比べて冗長です。
しかし、コンポーネントを部分ごとに明確に分割するという手間をかけることで、きめ細かい遅延読み込みが可能になるというメリットが生まれます。</p>
<ul>
<li>開発者体験の観点から見て、コンポーネント当たりのオーバーヘッドはあまり変わらないことを忘れないでください。コンポーネントの複雑性が高まるにつれて、オーバーヘッドの増加は大きな問題ではなくなります。</li>
<li>この方式のメリットは、ツールによってコンポーネントを自由に複数のチャンクにパッケージ化し、必要に応じて遅延読み込みできる点です。</li>
</ul>
<h2>裏側で何が起きているのか</h2>
<p><code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>、<code class="language-text">qrlView</code>はいずれもQwik Optimizerのマーカーであり、自身への参照をQRLに変換する必要があることをツールに伝達します。
その結果、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">my-counter.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>qComponent<span class="token punctuation">,</span> qrlView<span class="token punctuation">,</span> qrlHandler<span class="token punctuation">,</span> qrlState<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       //              ^^^^^^^^^^^^^^^^^注目^^^^^^^^^^^^^^^^
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">export</span> <span class="token keyword">const</span> Counter <span class="token operator">=</span> <span class="token function">qComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
 state<span class="token operator">:</span> <span class="token string">'/chunk-abc#CounterState'</span><span class="token punctuation">,</span> <span class="token comment">// &lt;&lt;===注目</span>
 view<span class="token operator">:</span> <span class="token string">'/chunk-cde#CounterView'</span><span class="token punctuation">,</span>   <span class="token comment">// &lt;&lt;===注目</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>ソースファイルの変換に加え、Optimizerはビュー、ステート、ハンドラ間の静的参照をすべて削除します。
QwikはRollupのためのエントリーポイントファイルも作成します。
これらのエントリーポイントは上記のQRLに対応します。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> Counter_update <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">{</span> CounterView <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./my-counter'</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>重要なのは、いくつのエントリーファイルを作成するか、どのエクスポートをどのエントリーファイルと結びつけるかに関して、Qwikに大きな自由がある点です。
これは開発者が遅延読み込みする部分とそうでない部分の境界をまったく指定しないことによります。
その代わり、Qwikは、コードベースにたくさんの遅延読み込み境界（原文: lazy load boundaries）を導入するようにコードを書くよう開発者を導きます。
これによりQwikは、実際のアプリケーションの利用状況に基づき、最適なファイル配分を実現できます。
例えば、小規模なアプリケーションの場合はファイルを1つ作成し、アプリケーションの規模が大きくなるにつれて、エントリーファイルを増やすことができます。
また、特定の機能がめったに利用されない場合、その機能だけを単独のバンドルにすることもできます。</p>
<p>Rollupがエントリーファイルを処理すると、ファイルは次のようになります。</p>
<p><strong>ファイル</strong>：<code class="language-text">chunk-abc.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterState <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
 count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-pqr.js</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlHandler<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> Counter_update <span class="token operator">=</span> <span class="token function">qrlHandler</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state<span class="token punctuation">,</span> params</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
         state<span class="token punctuation">.</span>count <span class="token operator">+=</span> params<span class="token punctuation">.</span>direction <span class="token operator">*</span> <span class="token punctuation">(</span>props<span class="token punctuation">.</span>step <span class="token operator">||</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><strong>ファイル</strong>：<code class="language-text">chunk-cde.js</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> qrlView<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@builder.io/qwik'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> CounterView <span class="token operator">=</span> <span class="token function">qrlView</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">(</span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=-1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       -
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>state<span class="token punctuation">.</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token plain-text">
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/chunk-pqr#Counter_update?direction=1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
       +
     </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">
   </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>注目してほしいのは、Rollupがファイルの内容を展開してエントリーファイルにまとめ、不要なコードを削除し、理想的なサイズのバンドルを作成している点です。</p>
<h2>制約</h2>
<p>ツールが<code class="language-text">qComponent</code>、<code class="language-text">qrlState</code>、<code class="language-text">qrlHandler</code>を移動できるようにするため、これらのメソッドの利用は制約されています（すべての有効なJavaScriptプログラムが有効なQwikプログラムとは限りません）。
その制約とは、すべてのマーカー関数が<code class="language-text">export</code>の対象となるトップレベル関数でなければならないというものです。</p>
<p>無効なコードの例は次のとおりです。</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> someFn <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./some-place'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//トップレベルではないので無効</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> MyStateFactory <span class="token operator">=</span> <span class="token function">qrlState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">someFn</span><span class="token punctuation">(</span><span class="token punctuation">{</span> data<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//有効なimportなので問題なし</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>ツールにとっての選択肢</h2>
<p>アプリケーションを小さいファイルに分割しすぎて、ダウンロードのパフォーマンスに悪影響を与えてしまうのは、あり得ないことではありません（むしろ、とてもよくあることです）。
そのため、ツールではファイルをマージしてバンドルにすることを選択できます。
これは理想的な挙動と言えます。
アプリケーション全体の規模が比較的小さい（50KB未満の）場合、数百個ものファイルに分割するのは生産的ではないでしょう。</p>
<p>コード構造がきめ細かければ、ツールは常に、バンドルを大きくする（そして少なくする）ことを選択できます。
しかし、その逆は正しくありません。
コード構造が粗ければ、ツールがコードを分割するためにできることは何もありません。
Qwikは、開発者がアプリケーションを可能な限り小さいチャンクに分割し、ツールを利用して最適なバンドルのチャンクを発見する助けになります。
このように、Qwikはあらゆるサイズのアプリケーションに最適なパフォーマンスを提供できます。</p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[モバイルサイトのGoogle PageSpeed Insightsスコアを100点にするには]]></title><description><![CDATA[Google PageSpeed InsightsはWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いス…]]></description><link>https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</link><guid isPermaLink="false">https://postd.cc/how-to-score-100-on-google-pagespeed-insights-on-mobile/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Tue, 31 Jan 2023 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p><a href="https://developers.google.com/speed/pagespeed/">Google PageSpeed Insights</a>はWebサイトの知覚的な待機時間を測定できるツールです。
Googleはこのスコアを検索ランキングのアルゴリズムに活用すると公表しているため、良いスコアが必要不可欠です。</p>
<p>私たちは、モバイルサイトのPageSpeed Insightsスコアを100点にするために何が必要かを探ってきました。
この取り組みを始めたとき、デスクトップサイトのスコアはすでに100点でした。
しかし、現代のeコマースの主流はモバイルコマースであり、モバイルサイトでは60点台半ばのスコアしか獲得できていませんでした。
このブログ記事では、モバイルサイトでも100点を取るための方法を共有します。
多くの企業がデスクトップサイトで100点を獲得していますが、モバイルサイトで100点を取れることは滅多にありません。
それでは始めましょう。</p>
<p>Builder.ioは標準的なNext.jsサイトです。
サイト自体がBuilderコンテンツプラットフォームで実行されているため、画像サイズや事前読み込みなど、コンテンツに関するあらゆるベストプラクティスはすでに守られているはずです。
それでもスコアはわずか60点台にとどまっていました。なぜでしょうか？</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0DMRzttv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iy8vyp90ed82l4kmhshx.png"></p>
<p>その理由を探るために、スコアの内訳を見てみましょう。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--eTUcudeP--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aeaoni0mhgjyttr3utm5.png"></p>
<p>問題は以下の2つに分解できます。</p>
<ul>
<li>Total Blocking Time（TBT）とTime to Interactive（TTI）：JavaScriptによるページ上のブロッキング時間が長すぎる。</li>
<li>First Contentful Paint（FCP）とLargest Contentful Paint（LCP）：モバイルブラウザにとって、レンダリングが必要なページ上のコンテンツが多すぎる。</li>
</ul>
<p>そのため、以下を目指す必要があります。</p>
<ol>
<li>JavaScriptの量を減らす。</li>
<li>初回のレンダリング時のコンテンツ量を減らす。</li>
</ol>
<h2>なぜJavaScriptの量が増えるのか？</h2>
<p>私たちのホームページはほとんど静的なページです。
なぜJavaScriptが必要なのでしょうか？それはホームページがNext.jsサイトであり、つまりReactアプリケーションであるからです（ドラッグ&#x26;ドロップエディタによる出力をReactに変換するために<a href="https://github.com/BuilderIO/mitosis">Mitosis</a>を使用しています）。
サイトの大部分は静的ですが、JavaScriptが必要な要素が3つあります。</p>
<ol>
<li>ナビゲーションシステム：メニューにはインタラクティブ性が必要であり、したがってJavaScriptも必要。また、デスクトップとモバイル端末では異なるメニューが使用されている。</li>
<li>チャット用のウィジェットを読み込む必要がある。</li>
<li>Google Analyticsが必要。</li>
</ol>
<p>それぞれ詳しく見ていきましょう。</p>
<h2>アプリケーションのブートストラップ</h2>
<p>サイトはほとんど静的であるとはいえ、それでもアプリケーションです。
メニューを有効にするにはアプリケーションをブートストラップする必要があります。
具体的には、フレームワークは再ハイドレーションを実行する中でテンプレートをDOMと比較し、すべてのDOMリスナーをインストールする必要があります。
このプロセスによって、既存のフレームワークは<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable（再生型）</a>になります。
つまり、たとえページの95％が静的であっても、フレームワークはすべてのテンプレートをダウンロードし、リスナーが存在するかを判断するためにテンプレートを再実行しなければなりません。
これが意味するのは、最初にHTMLとして、次にJavaScriptのJSXとして、サイトが合計2回ダウンロードされるということです。</p>
<p>さらに悪いことに、再ハイドレーションのプロセスは低速です。
フレームワークはDOMの各ノードにアクセスし、仮想DOMとの差分を検出しなければならず、それに時間がかかります。
また、再ハイドレーションのプロセスはDOMリスナーのインストールと同じプロセスなので、遅延させることができません。
再ハイドレーションが遅延すると、メニューは動作しません。</p>
<p>上記は既存のあらゆるフレームワークの根本的な限界を説明したものです。
お分かりのとおり、こうしたフレームワークはすべて<a href="/a-first-look-at-qwik-the-html-first-framework/">replayable</a>です。
これは、既存のどんなフレームワークも、現実のモバイルサイトで100点を取れないという意味でもあります。
PageSpeed Insightsが想定しているモバイルサイトのHTMLとJavaScriptのコード量はごくわずかであり、それに対して現実のコードがあまりに多すぎるのです。</p>
<p>私たちは問題を根本的に考え直す必要があります。
サイトの大部分は静的なので、その部分のJavaScriptを再ダウンロードしたり、不要な部分の再ハイドレーションに時間をかけたりすべきではありません。
このような場面でこそ、<a href="https://github.com/builderio/qwik">Qwik</a>が真の意味で輝きます。
Qwikは<a href="https://github.com/builderio/qwik">replayableではなくresumable（再開型）</a>で、それがあらゆる違いを生み出します。
結果として、Qwikでは以下が不要になります。</p>
<ol>
<li>ページを読み込むときのブートストラップ</li>
<li>リスナーをどこに入れるべきか判断するためにDOMを探索すること</li>
<li>メニューを動かすためにJavaScriptをダウンロード・実行すること</li>
</ol>
<p>これらはすべて、サイトの読み込みを実行するためのJavaScriptをほとんど必要とせず、それでもサイトのインタラクティブ性を完全に維持できることを意味します。</p>
<h2>Intercom</h2>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--On4okiXm--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/v8v1uurp49y7nlkh7fr3.png"></p>
<p>Intercomは、私たちのサイトで実行されているサードパーティウィジェットで、私たちとお客様のインタラクションを可能にします。
このウィジェットをインストールする標準的な方法は、例えば以下のように、JavaScriptをHTMLに少しだけ追記することです。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">async</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://widget.intercom.io/widget/abcd1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">async</span> <span class="token attr-name">defer</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
<span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span><span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span></span></pre></div>
<p>しかし、上記のコードには2つの問題があります。</p>
<ol>
<li>ダウンロードと実行が必要なJavaScriptが増え、TBTとTTIに悪影響を及ぼす。</li>
<li>レイアウトシフトが発生し、CLSに悪影響を及ぼす可能性がある。その原因は、最初にウィジェット以外のUIがレンダリングされ、その後にJavaScriptのダウンロードと実行によってUIがウィジェットとともに再びレンダリングされるためである。
Qwikはそれら両方の問題を同時に解決します。</li>
</ol>
<p>まず、QwikはIntercomがウィジェットのレンダリングに使用するDOMを取得します。
次に、そのDOMが以下のように実際のページに挿入されます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app<span class="token punctuation">"</span></span> <span class="token attr-name">aria-live</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>polite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span>
    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-launcher intercom-launcher<span class="token punctuation">"</span></span>
    <span class="token attr-name">role</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>button<span class="token punctuation">"</span></span>
    <span class="token attr-name">tabIndex</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>{0}</span>
    <span class="token attr-name">arial-abel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Open Intercom Messenger<span class="token punctuation">"</span></span>
    <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>ui:boot_intercom<span class="token punctuation">'</span></span>
  <span class="token punctuation">></span></span>
    ...
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>intercom-lightweight-app-style<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">...</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>この方法のメリットは、ウィジェットがアプリケーションの残りの部分と同時に即座にレンダリングされることです。
ブラウザがIntercomのJavaScriptをダウンロードし、ウィジェットの作成を実行している間、遅延や画面のちらつきは発生しません。
その結果、ユーザ体験が改善され、Webサイトのブートストラップが高速化されます（モバイル端末の通信量も節約できます）。</p>
<p>ただし、ウィジェットがクリックされたことを検知する方法や、ユーザのインタラクションに応じてウィジェットのモックアップを実際のIntercomウィジェットに置き換える何らかのコードは依然として必要です。
これは<code class="language-text">on:click=&quot;ui:boot_intercom&quot;</code>属性によって実現できます。
この属性は、ユーザがウィジェットのモックアップをクリックした場合に、Qwikに<code class="language-text">boot_intercom.js</code>をダウンロードさせるものです。</p>
<p><code class="language-text">boot_intercom.js</code>の内容</p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'https://widget.intercom.io/widget/abcd1234'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">const</span> container <span class="token operator">=</span> element<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 <span class="token keyword">const</span> body <span class="token operator">=</span> container<span class="token punctuation">.</span>parentElement<span class="token punctuation">;</span>
 body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'boot'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> app_id<span class="token operator">:</span> <span class="token string">'abcd1234'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Intercom</span><span class="token punctuation">(</span><span class="token string">'show'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>このファイルは、実際のIntercomウィジェットをダウンロードし、モックアップを削除し、Intercomをブートストラップします。
こうした作業はすべて勝手に行われ、ユーザはウィジェットが入れ替わったことにまったく気づきません。</p>
<h2>Google Analytics</h2>
<p>これまで私たちはJavaScriptの遅延読み込みに取り組み、Webサイトのパフォーマンスを順調に改善してきました。
しかし、アナリティクスは別物です。
なぜなら、アナリティクスを遅延させることはできず、ただちにブートストラップが必要だからです。
アナリティクスをブートストラップするだけで、モバイルサイトのPageSpeed Insightsスコアで100点を取るのは難しくなります。
この問題を解決するために、<a href="https://github.com/adamdbradley/partytown">PartyTown</a>を利用して、Web WorkerでGoogle Analyticsを実行します。
詳しくは今後の記事で説明します。</p>
<h2>JavaScriptの遅延</h2>
<p>上記の処理は、Webサイトがダウンロード・実行しなければならないJavaScriptの量を約1KBに減らします。
実行にかかる時間はわずか1ミリ秒で、ほとんどゼロと言ってよいでしょう。
このようにJavaScriptを最小限にすることで、TBTとTTIのスコアが完璧になります。</p>
<h2>HTMLの遅延</h2>
<p>しかし、JavaScriptがほとんど存在しなくても、画面上の領域をレンダリングするためにクライアントに送信するHTMLの量を修正しない限り、依然としてモバイルサイトで100点は取れません。
FCPとLCPを改善するには、とにかくHTMLを最小限に減らさなければなりません。
それを実現する方法は、画面上の領域のHTMLのみを送信することです。</p>
<p>これは目新しいアイデアではありませんが、実行するのは骨が折れます。
アプリケーションを画面上の領域と画面外の領域に簡単に分割する方法がないため、既存のフレームワークでは困難です。
ここでは仮想DOMも役に立ちません。
たとえ表示されるのがほんの一部だとしても、アプリケーションは仮想DOM全体を生成するからです。
フレームワークは、サイトの一部が欠けていると再ハイドレーション時にサイト全体を再生成するため、初回のブートストラップ時の作業がさらに増えます。</p>
<p>理想的には、画面外の領域のHTMLは送信せず、画面上の領域のメニューシステムは完全にインタラクティブな状態に維持したいところです。
しかし実際には、現実のサイトでそのようなベストプラクティスが見られないことから分かるように、実現するのは困難です。難しすぎるので誰もやらないのです。</p>
<p>QwikはDOM主体であり、それがすべての違いを生み出しています。
まずページ全体がサーバでレンダリングされます。
その後、ページの中で送信する必要がない部分が特定され、削除されます。
ユーザのスクロールに応じて、残りの部分が遅れてダウンロードされ、ページに挿入されます。
QwikはステートレスでDOM主体のフレームワークであるため、この種のDOMの操作による影響を受けません。</p>
<p>これは私たちのサーバで、サイトの画面外の領域で遅延読み込みを実現している実際のコードです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">async</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vmSandbox<span class="token punctuation">.</span><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'./server-index'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> ServerIndexModule<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">serverIndex</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> lazyNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'section[lazyload=true]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> lazyHTML <span class="token operator">=</span> lazyNode<span class="token punctuation">.</span>innerHTML<span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
      <span class="token punctuation">(</span>lazyNode <span class="token keyword">as</span> HTMLElement<span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token string">'999em'</span><span class="token punctuation">;</span>
      lazyNode<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'on:document:scroll'</span><span class="token punctuation">,</span> <span class="token string">'ui:/lazy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>transpiledEsmFiles<span class="token punctuation">[</span><span class="token string">'lazy.js'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        export default (element) => {
          element.removeAttribute('on:document:scroll');
          element.style.height = null;
          element.innerHTML = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>lazyHTML<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">;
        };</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コードは簡潔で的確ですが、既存のどのフレームワークでも実現するのは困難でしょう。</p>
<p>以下は、画面外の領域を遅延読み込みするようにした実際のサイトです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o48jE9q6--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/565yei3n8jydkkvs81yr.gif"></p>
<p>当初、ページは画面外のコンテンツを読み込んでいません。
ユーザがスクロールすると、すぐにコンテンツが追加されます。
ほとんど一瞬でコンテンツが追加されるのは、複雑なコードを実行する必要がなく、高速で単純な<code class="language-text">innerHTML</code>だけで済むためです。</p>
<h2>実際に試す</h2>
<p>こちらのページを実際に体験してみてください：<a href="https://www.builder.io/?render=qwik">https://www.builder.io/?render=qwik</a> （<a href="https://developers.google.com/speed/pagespeed/insights/?url=https%3A%2F%2Fwww.builder.io%2F%3Frender%3Dqwik">PageSpeed Insights</a>のスコアもご覧ください）。
アナリティクスについてはまだ説明していませんが、近いうちに記事を投稿する予定です。</p>
<p>サイトは気に入っていただけましたか？
私たちは、お客様のサイトが超高速に利用できるものとなるように、Builder.ioのすべてのお客様にQwikを提供したいと考えています。
これは今まで見たことがないほど高速なプラットフォームになるはずです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Ii5M-zIi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2rgulo7ew94yp06dyevs.png"></p>
<p>この記事は面白かったでしょうか？もしそうならば、<a href="https://builder-io.rippling-ats.com/">私たちのチームに参加</a>して、一緒にWebの高速化を目指しませんか。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧</a>はこちらから参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwik：最適できめ細かい遅延読み込みを実現]]></title><description><![CDATA[Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけ…]]></description><link>https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</link><guid isPermaLink="false">https://postd.cc/qwik-the-answer-to-optimal-fine-grained-lazy-loading/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>Qwikは、JavaScriptの読み込みと実行を可能な限り遅延させ、ユーザのアクションがあった場合のみ実施することで、読み込みを最も高速化することを目指しています。
この処理は初回の読み込み時だけでなく、アプリケーションが続く限り行われます。
言い換えると、Qwikはきめ細かい遅延読み込みを追求しているのです。
「きめ細かい」とは、ユーザのアクションを処理するのに直接必要なコードのみがダウンロードされるという意味です。
この記事では、きめ細かい遅延読み込みを実現するために解決すべき技術的課題について探っていきます。</p>
<h2>リスナーをシリアライズ</h2>
<p>最も明確に解決すべき課題は初回のページ読み込みです。
この点に関しては、「<a href="/html-first-javascript-last-the-secret-to-web-speed/">HTMLを最初に、JavaScriptを最後に</a>」で対応策をすでに取り上げました。
ポイントは、イベントの名称とアクションをURLとしてシリアライズし、DOMの属性として保持することです。その後、最上位のグローバルなイベントハンドラがイベントをリッスンし、そのイベントに関連するコードをダウンロードできます。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>click me<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>このコードは、初回のページ読み込みで（1KBのローダを除いて）JavaScriptを一切読み込むことなく、上記の処理を実現します。
これにより初回読み込み時のTime to Interactiveの目標を達成できますが、新たな問題が生まれます。
私たちは、ユーザとの初回のインタラクション時にアプリケーション全体をダウンロードしたり、ブートストラップしたりしたくはありません。
それでは初回の読み込み時から初回のインタラクション時へ問題を先送りするだけになってしまいます（それどころか、ユーザとの初回のインタラクション時に大きなレイテンシが生じるので、状況は悪化しています）。</p>
<p>この問題は、ユーザとの1回のインタラクションで、アプリケーション全体のダウンロードやブートストラップが行われないようにすれば解決です。
その代わり、インタラクションの処理に直接必要なコードやコンポーネントのみのダウンロード、ブートストラップ、再ハイドレーションを行えばよいのです。
そのため、きめ細かい遅延読み込みが必要になります。</p>
<p>これはイベントをHTMLやDOMへシリアライズすればすべて実現できます。
そうしなければ、テンプレートの読み込みを遅延させるのは不可能でしょう。
なぜなら、フレームワークはイベントの場所を特定するためにテンプレートをダウンロードする必要があるからです。</p>
<h2>非同期かつアウトオブオーダー方式によるコンポーネントのハイドレーション</h2>
<p>初回のインタラクションによるアプリケーション全体のダウンロードやブートストラップを避けるには、コンポーネントを非同期かつアウトオブオーダー方式で再ハイドレートする必要があります。</p>
<p>ここでいう非同期とは、レンダリングシステムがレンダリングを一時停止してコンポーネントのテンプレートを非同期にダウンロードし、それからレンダリングのプロセスを再開できるという意味です。
レンダリングプロセスがすべて完全な同期方式である既存のフレームワークとはとても対照的です。
レンダリングが同期方式である場合、非同期の遅延読み込みを挿入する余地はありません。その結果、すべてのテンプレートをレンダリングの呼び出し前に準備する必要があります。</p>
<p>既存の再ハイドレーション戦略にはもう1つ問題があります。
それは再ハイドレーションがルートコンポーネントから始まり、ルート以下のすべてのコンポーネントを同期方式で再ハイドレートすることです。
そのため、すべてのコンポーネントを同時に再ハイドレートしなければならず、あらゆるコンポーネントのダウンロードを強いられます。
その結果、初回のインタラクション時の処理時間が長くなります。
アウトオブオーダー方式のハイドレーションとは、各コンポーネントを他のコンポーネントとは独立して任意の順番で再ハイドレートできるという意味です。
これにより、Qwikはリクエストの処理に必要な最小限のコンポーネントのみを再ハイドレートすることが可能になります。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./path/MyComponent_template<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ... some content ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のケースでは、<code class="language-text">&lt;div&gt;</code>は<code class="language-text">MyComponent_template.ts</code>と紐づけられたコンポーネントを表しています。
Qwikは、コンポーネントを再レンダリングする必要があると判断した場合のみテンプレートをダウンロードするため、ダウンロードがさらに遅延されます。</p>
<p>再ハイドレーションがアウトオブオーダー方式でなければ、フレームワークはすべてのテンプレートを一度にダウンロードし、再ハイドレートしなければなりません。
その結果、初回のインタラクション時に、ダウンロードと実行による大きな負荷がかかります。</p>
<h2>レンダリングをイベントハンドラから分離</h2>
<p>Qwikに関して考慮が欠かせないポイントは、既存のあらゆるレンダリングシステムがイベントリスナーをテンプレートに埋め込んでいることです。
そのため、コンポーネントを再レンダリング（または再ハイドレート）する必要があるときに、ブラウザはすべてのリスナーを必要性にかかわらずダウンロードしなければなりません。
リスナーは複雑なコードに紐づいていることが多いので、ダウンロードされるコード量はさらに増加します。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded eagerly
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikはイベントハンドラをテンプレートのコードから分離します。これはリスナーとテンプレートを別々に、必要に応じてダウンロードできることを意味します。</p>
<p><code class="language-text">MyComponent_template.ts</code></p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">export</span> <span class="token function">MyComponent_template</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_onClick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      rarely clicked => click handler downloaded lazily
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p><code class="language-text">MyComponent_onClick.ts</code></p>
<div class="gatsby-highlight" data-language="js"><pre style="counter-reset: linenumber NaN" class="language-js line-numbers"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>complexFunction<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./large-dependency'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">complexFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>イベントハンドラをテンプレートから分離しなければ、フレームワークはコンポーネントの再レンダリングに必要な量よりはるかに多くのコードをダウンロードしなければなりません。
さらに、イベントハンドラは複雑で、他の依存関係を持っていることが多いため、ダウンロードが必要なコード量は増加します。</p>
<h2>コンポーネントのステートのシリアライズ</h2>
<p>コンポーネントを再ハイドレートするプロセスの最も重要な部分は、コンポーネントのステートを復元することです。
既存のフレームワークにはステートをシリアライズする方法がありません。
コンポーネントのステートがどこにあるかを確定するための標準的な方法が存在しないからです。</p>
<p>Qwikはコンポーネントをいくつかの部分に分解します。</p>
<ul>
<li><em>props</em>：コンポーネントの単なるプロパティ。DOMに反映される。例えば<code class="language-text">&lt;counter min=&quot;0&quot; max=&quot;100&quot;/&gt;</code>のpropsは<code class="language-text">{min: 0, max: 100}</code>。</li>
<li><em>state</em>：コンポーネントの内部ステート。DOMにシリアライズできる。</li>
<li><em>transient state</em>：追加的なステートで、コンポーネントによるキャッシュは可能だが、シリアライズは不可能なものを指す。この情報は再計算する必要がある（例：コンポーネントとサーバが通信している間の一時的なプロミス）。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Conter_template<span class="token punctuation">"</span></span>
     <span class="token attr-name">:.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>{count: 42}<span class="token punctuation">'</span></span>
     <span class="token attr-name">min</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">max</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_incremente<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  42
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_decrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>コンポーネントがステートをシリアライズできない場合、特定のコンポーネントを独立に再ハイドレートするのは不可能でしょう（コンポーネントはどこでステートを取得するというのでしょうか？）。
その結果、フレームワークは、ステートの計算やダウンロードのための追加コードをサーバからダウンロードしなければなりません。
Qwikはこうした問題のすべてを<a href="/html-first-javascript-last-the-secret-to-web-speed/">DOM内にステートをシリアライズする</a>ことで回避します。</p>
<h2>アプリや共有ステートのシリアライズ</h2>
<p>コンポーネント内のみで有効なコンポーネントステートに加え、複数のコンポーネントで利用されるアプリケーションステートも存在します。
これもDOM内にシリアライズする必要があります。共有ステートは以下に分解できます。</p>
<ul>
<li><em>key</em>：あるステートをただ1つに特定するID。コンポーネント内でステートを参照するために利用される。</li>
<li><em>state</em>：複数のコンポーネントで共有されるステート。DOM内にシリアライズできる。</li>
<li><em>transient state</em>：アプリケーションによるキャッシュは可能だが、シリアライズは不可能な追加ステート。この情報は再計算が可能でなければならない。</li>
</ul>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span>
     <span class="token attr-name">:item:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Item<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>789</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Shoe<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>43.21<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">item:</span>987</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{name: <span class="token punctuation">'</span>Sock<span class="token punctuation">'</span> price: <span class="token punctuation">'</span>12.34<span class="token punctuation">'</span>}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  ...
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>アプリケーションのステートをシリアライズすることで、コンポーネントが同じ情報を複数の場所でレンダリングし、他のコンポーネントとコミュニケーションできます。
フレームワークが共有ステートを把握・管理しないと、フレームワークがステートの変更を認識できないため、コンポーネントの独立したハイドレーションが不可能になります（例えば、AngularとReactにはレンダリング関数に紐づけられた明確なステート管理機能がありません。その結果、アプリケーションのステートが変更されたときにアプリケーション全体を再レンダリングする以外に妥当な方法がなく、きめ細かい遅延読み込みが困難です）。</p>
<h2>アプリのステートとコンポーネントの間のリアクティブな関係</h2>
<p>ステートを把握するフレームワークの真のメリットは、フレームワークがステートとコンポーネントの関係を認識できる点にあります。
これが重要なのは、任意のステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要があるか把握できるためです。
あるいは、それ以上に重要なのは、ステートが変化したときに、フレームワークがどのコンポーネントを再ハイドレートする必要がないかを把握できることでしょう。
例えば、ショッピングカートに商品を追加するときは、ショッピングカート内の商品の個数を表示するコンポーネントのみを再レンダリングすべきですが、これはページ全体のごく一部でしかありません。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:cart:</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Cart<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{items: [<span class="token punctuation">'</span>item:789<span class="token punctuation">'</span>, <span class="token punctuation">'</span>item:987<span class="token punctuation">'</span>]}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Unrelated<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./ShoppingCart<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span><span class="token namespace">cart:</span>432</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$cart<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
   2 items
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AddItem<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>buy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<p>Qwikの目標は再ハイドレートするコンポーネントの数を最小限にすることです。
ユーザが<code class="language-text">&lt;button&gt;</code>をクリックすると、Qwikは<code class="language-text">./AddItem</code>をダウンロードし、<code class="language-text">cart:432</code>のアプリケーションステートを更新します。
さらにQwikは、<code class="language-text">bind:cart:432</code>を持つコンポーネントが、そのステートを利用している唯一のコンポーネントであり、したがって再ハイドレーションと再レンダリングが必要な唯一のコンポーネントであると判断します。
Qwikはページ上のほとんどのコンポーネントを除外できるため、きめ細かい遅延読み込みを維持できます。
どのコンポーネントがどのステートと関係しているかを把握できるという点は、他のフレームワークには存在しないとても重要な特徴です。
この特徴によって、アプリケーションの起動時やライフサイクル全体を通じたきめ細かい遅延読み込みが可能になります。</p>
<h2>コンポーネントの分離</h2>
<p>これまでQwikがどのようにコードのきめ細かい遅延読み込みをサポートするか説明してきました。
上記の仕組みがすべて機能するのは、Qwikがアプリケーション内のデータフローを認識しているからです。
Qwikはこの情報を、再ハイドレートする必要がないコンポーネントを取り除き、必要なコンポーネントのみを再ハイドレートするために利用します。
これが暗に意味するのは、Qwikがコンポーネントと他のコンポーネントの通信を認識する必要があるということです。
コンポーネントは他のコンポーネントと秘密の会話をしてはならないのです。</p>
<p>コンポーネントがステートを取得したことをQwikが把握できない場合、Qwikは、ステートが変更されたときにそのコンポーネントの再ハイドレーションや再レンダリングが必要であることを認識できません。
そのため、コンポーネントは自身の依存関係のリストをプロパティに明記する必要があります。</p>
<p>この明確なリストがないと、フレームワークは、ステートが変更された時点ですべてを再レンダリングしなければなりません。
その結果、アプリケーション全体のダウンロードとブートストラップが行われることになります。</p>
<h2>結論</h2>
<p>Webアプリケーションが遅延読み込みに対応した構造となるように、開発のアプローチを変える必要がある点は数多くあります。
ポイントは、現在のフレームワークはこの問題を解決する助けにならず、ときには悪化させるという点です（例えば、ページ全体の再ハイドレーション、同期方式のレンダリングなど）。
Qwikはきめ細かい遅延読み込みを実現し、どんなに大規模で複雑であっても1秒未満で読み込めるサイトやアプリを開発できます。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[HTMLを最初に、JavaScriptを最後に：Webを高速化する秘訣]]></title><description><![CDATA[すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJ…]]></description><link>https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</link><guid isPermaLink="false">https://postd.cc/html-first-javascript-last-the-secret-to-web-speed/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Fri, 23 Dec 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>すべてのフレームワークはステートを保持する必要があります。フレームワークはテンプレートを実行することでステートを構築します。ほとんどのフレームワークは、このステートをリファレンスやクロージャとしてJavaScriptヒープに保持します。<a href="https://github.com/builderio/qwik">Qwik</a>のユニークな点は、ステートが属性としてDOMに保持されることです（リファレンスもクロージャもシリアライズして送受信するのは不可能ですが、文字列であるDOM属性なら可能です。これがresumability(再開性）のカギとなります）。</p>
<p>DOMにステートを保持することには、以下のように多くのユニークなメリットがあります。</p>
<ol>
<li>DOMはシリアライズの形式としてHTMLを使用します。ステートを文字列属性としてDOMに保持することで、アプリケーションをいつでもHTMLにシリアライズできます。HTMLを送信し、別のクライアントでDOMにデシリアライズすることが可能になります。デシリアライズされたDOMは、そこから再開できます。</li>
<li>各コンポーネントを他のコンポーネントとは独立して再開できます。このアウトオブオーダー方式の再ハイドレーションによって、アプリケーション全体の一部のみを再ハイドレートすることが可能であり、ユーザのアクションに応じてダウンロードしなければならないコード量が制限されます。これは従来のフレームワークとは全く異なる点です。</li>
<li>Qwikはステートレスなフレームワークです（アプリケーションのステートはすべて文字列としてDOMに保持されます）。ステートレスなコードはシリアライズ、送受信、再開が簡単です。各コンポーネントを独立に再ハイドレートすることも可能になります。</li>
<li>アプリケーションを（初回のレンダリング時だけでなく）いつでも何度でもシリアライズできます。</li>
</ol>
<p>例として、シンプルなCounterコンポーネントと、ステートのシリアライズの仕組みを見てみましょう（これはサーバサイドでレンダリングされたHTMLの出力結果であり、必ずしも開発者がこのようなコードを書くわけではありません）。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">::app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./AppState<span class="token punctuation">"</span></span>
     <span class="token attr-name"><span class="token namespace">app-state:</span>1234</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{count: 321}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">decl:</span>template</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span>
       <span class="token attr-name">::.</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{countStep: 5}<span class="token punctuation">"</span></span>
       <span class="token attr-name"><span class="token namespace">bind:</span>app-state</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>state:1234<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_increment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>+5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
    321.
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./MyComponent_decrrement<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<ul>
<li><code class="language-text">::app-state</code>（アプリケーションステートのコード）：アプリケーションステートの変更コードをダウンロードできるURLを指します。ステートの更新コードは、ステートを変更する必要がある場合のみダウンロードされます。</li>
<li><code class="language-text">app-state:1234</code>（アプリケーションステートのインスタンス）：特定のアプリケーションのインスタンスへのポインタ。ステートをシリアライズすることで、アプリケーションはステートの再構築をやり直すのではなく、中断した所から再開できます。</li>
<li><code class="language-text">decl:template</code>（テンプレートの宣言）：コンポーネントのテンプレートをダウンロードできるURLを指します。コンポーネントのステートが変更され、再レンダリングする必要があるとQwikが判断するまで、テンプレートはダウンロードされません。</li>
<li><code class="language-text">on:q-render</code>（コンポーネントのレンダリングのスケジュール設定）：フレームワークは再レンダリングが必要なコンポーネントを追跡しなければなりません。これは通常、無効化されたコンポーネントの内部リストを保存することで行われます。Qwikでは、無効化されたコンポーネントのリストは、属性としてDOMに保存されます。その後、コンポーネントは<code class="language-text">q-render</code>イベントのブロードキャストを待ちます。</li>
<li><code class="language-text">::.=&quot;{countStep: 5}&quot;</code>（コンポーネントのインスタンスの内部ステート）：コンポーネントは、再ハイドレーション後も内部ステートを保持しなければならない場合があります。このステートはDOMに保持できます。コンポーネントは、再ハイドレートされた時点で、再開に必要なすべてのステートを保持しています。ステートの再構築は不要です。</li>
<li><code class="language-text">bind:app-state=&quot;state:1234&quot;</code>（共有アプリケーションステートへのリファレンス）：複数のコンポーネントが同じ共有アプリケーションステートを参照できるようにします。</li>
</ul>
<h2><code class="language-text">querySelectorAll</code>は強い味方</h2>
<p>フレームワークの一般的な役割の1つは、アプリケーションのステートが変更されたときに、どのコンポーネントの再レンダリングが必要か特定することです。
この作業が発生する理由はいくつかあります。
例えば、コンポーネントが明確に無効とされる場合や（<code class="language-text">markDirty()</code>）、アプリケーションの共有ステートの変更によりコンポーネントが暗黙に無効とされる場合などです。</p>
<p>上記の例では、<code class="language-text">count</code>が<code class="language-text">app-state:1234</code>をキーとしてアプリケーションステートに保持されています。
ステートが更新された場合、そのアプリケーションステートに依存するコンポーネントは無効化（再レンダリングのキュー）が必要です。
フレームワークはどのように更新すべきコンポーネントを把握するのでしょうか？</p>
<p>ほとんどのフレームワークの場合、その答えは、単純にルートコンポーネントからアプリケーション全体を再レンダリングすることです。
この戦略は、コンポーネントのテンプレートすべてをダウンロードする必要があるという残念な結果を生み、ユーザとのインタラクションのレイテンシに悪影響を及ぼします。</p>
<p>一部のフレームワークはリアクティブで、任意のステートが変更された場合に再レンダリングが必要なコンポーネントを追跡しています。
しかし、これはテンプレートを囲い込むクロージャの形式で記録されます（<a href="/death-by-closure-and-how-qwik-solves-it/">「クロージャによる死」</a>を参照）。
その結果、リアクティブな接続が初期化されるアプリケーションのブートストラップ時に、すべてのテンプレートをダウンロードしなければなりません。</p>
<p>Qwikはコンポーネントレベルでリアクティブです。
そのため、ルートからレンダリングを開始する必要はありません。
しかし、Qwikはリアクティブなリスナーをクロージャの形式で保持するのではなく、属性の形式でDOMに保持しているので、レンダリングを途中から再開できます。</p>
<p><code class="language-text">count</code>が更新されると、Qwikは以下の<code class="language-text">querySelectorAll</code>を実行し、どのコンポーネントを無効化する必要があるかを内部で判断します。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'bind\\:app-state\\:1234'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>markDirty<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>上記のクエリによって、Qwikはどのコンポーネントがステートに依存しているかを判断し、各コンポーネント上で<code class="language-text">markDirty()</code>を呼び出します。
<code class="language-text">markDirty()</code>はコンポーネントを無効化し、そのコンポーネントを再レンダリングが必要なコンポーネントのキューに追加します。
これは<code class="language-text">markDirty</code>の複数の呼び出しを1つのレンダリングパスに連結することで行われます。
レンダリングパスは<code class="language-text">requestAnimationFrame</code>を利用してスケジュールを設定します。
しかし、ほとんどのフレームワークとは異なり、Qwikはこのキューも属性としてDOMに保持します。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">on:</span>q-render</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>./Counter_template<span class="token punctuation">"</span></span> <span class="token attr-name">...</span> <span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">requestAnimationFrame</code>はレンダリングのスケジュール設定に利用されます。
これは論理的に考えれば、コンポーネントが待っている<code class="language-text">q-render</code>イベントを<code class="language-text">requestAnimationFrame</code>がブロードキャストすることを意味します。
ここで再び<code class="language-text">querySelectorAll</code>の出番です。</p>
<div class="gatsby-highlight" data-language="javascript"><pre style="counter-reset: linenumber NaN" class="language-javascript line-numbers"><code class="language-javascript"><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'on\\:q-render'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>jsxRender<span class="token punctuation">)</span><span class="token punctuation">;</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p>ブラウザにはブロードキャストイベント（イベントのバブリングの逆）が存在しませんが、<code class="language-text">querySelectorAll</code>を利用すれば、イベントのブロードキャストを受け取るべきコンポーネントをすべて特定できます。
さらに、<code class="language-text">jsxRender</code>関数を利用してUIを再レンダリングします。</p>
<p>ポイントは、Qwikがどの時点でもDOMの外部でステートを保持する必要がない点です。
あらゆるステートは属性としてDOMに保持され、自動的にHTMLにシリアライズされます。
つまり、いつでもアプリケーションのスナップショットをHTMLとして保存し、それを送信したり、デシリアライズしたりできるということです。アプリケーションは途中から自動的に再開されます。</p>
<p>Qwikはステートレスであり、それこそがQwikアプリケーションにresumableがある理由です。</p>
<h2>メリット</h2>
<p>アプリケーションがresumableであることは、フレームワークのステートのすべてをDOMエレメントに保持する明確なメリットです。
しかし、一見しただけでは分かりにくい、他のメリットもあります。</p>
<p>そのメリットとは、ビューポートの外側にあるコンポーネントのレンダリングをスキップできることです。
コンポーネントのレンダリングが必要かを判断するために<code class="language-text">q-render</code>イベントをブロードキャストすると、コンポーネントが表示されているかどうかを判断し、非表示コンポーネントのレンダリングを簡単にスキップできます。
また、レンダリングをスキップすれば、テンプレートなどのコードを一切ダウンロードする必要がありません。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--0C5MyDdy--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/l7y32eh60iarvc277zl9.png"></p>
<p>ステートレスのもう1つのメリットは、アプリケーションが実行されている間にHTMLの遅延読み込みが可能であることです。
例えば、サーバは最初に表示される画面のレンダリングに必要なHTMLを送信する一方で、画面に表示されていない部分のHTMLをスキップできます。
ユーザは最初の画面でインタラクションを開始し、アプリケーションを使用することが可能です。
ユーザがスクロールし始めた時点で、アプリケーションは他のHTMLを読み込み、それをDOMの末尾に<code class="language-text">innerHTML</code>で挿入します。
Qwikはステートレスであるため、すでに実行されているアプリケーションに何の問題も発生させずに追加のHTMLを挿入できます。
Qwikが新たなHTMLを認識するのはインタラクションが行われたときであり、その時点までHTMLのハイドレーションは遅延されます。
こうしたユースケースは、現行世代のフレームワークで実現するのがとても難しいものです。</p>
<p>私たちはQwikの未来と、それが切り開くユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る</li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<p>この記事はこれで終わりですが、私たちは今後数週間にわたって、Qwikとフロントエンドフレームワークの未来について記事を公開する予定です。お楽しみに。</p>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[クロージャによる死（とQwikによる解決方法）]]></title><description><![CDATA[世界中にQwikを紹介した前回の記事では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が…]]></description><link>https://postd.cc/death-by-closure-and-how-qwik-solves-it/</link><guid isPermaLink="false">https://postd.cc/death-by-closure-and-how-qwik-solves-it/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:01 GMT</pubDate><content:encoded><![CDATA[<p>世界中にQwikを紹介した<a href="/a-first-look-at-qwik-the-html-first-framework/">前回の記事</a>では、
多くの要素についてざっと触れるに留まり、詳細については後で説明するとお約束していました。
Qwikとその背景にある設計思想を知る前に、まず私たち（業界）が現在の場所までどのようにたどり着いたかを理解しておくことが重要です。
現代のフレームワークはある前提のもとに成り立っており、
それが優れたTime to Interactive（TTI）スコアの実現を妨げているのですが、
その前提とはどのようなものなのでしょうか。
現行世代のフレームワークの現時点における限界を理解することで、
Qwikの設計思想がなぜ最初は驚くべきものに思えるのか、より深く知ることができるでしょう。</p>
<h2>TTIについて</h2>
<p>TTIは、URLに遷移してからページがインタラクティブになるまでの時間を測定したものです。
レスポンシブなサイトとしての体裁を整えるには、サーバーサイドレンダリング（SSR）が必須です。
この背景にある考え方は、サイトを素早く表示し、ユーザがクリックすればいいか判断できるようになるまでに、
アプリケーションが自身をブートし、すべてのリスナーをインストールするというものです。
そのためTTIは、実際にはフレームワークがDOMリスナーをインストールするのにかかる時間を測定していると言えます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--85XBH76v--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jlvs7wu983qt0846c2a1.png"></p>
<p>上の図では、ブートからインタラクティブになるまでの時間に焦点を当てています。
フレームワークがインタラクティブな状態に達するまでに実行すべきことすべてを理解できるよう、
インタラクティブになった時点からスタートして逆にたどってみましょう。</p>
<ol>
<li>フレームワークはリスナーがどこにあるかを知る必要があります。しかし、この情報はフレームワークが簡単に利用できるものではありません。リスナーはテンプレートに<code class="language-text">described</code>（記述）されています。</li>
<li>実は、筆者は<code class="language-text">described</code>よりも<code class="language-text">embedded</code>（埋め込み）という言葉のほうが適切だと考えています。情報が埋め込まれていると言えるのは、フレームワークが情報を簡単に利用できないからです。フレームワークは、リスナーのクロージャに到達するためにテンプレートを実行する必要があります。</li>
<li>テンプレートを実行するにはダウンロードしなければなりません。しかし、ダウンロードされたテンプレートには import が含まれており、これを読み込むためにさらに多くのコードのダウンロードが必要です。テンプレートはそのサブテンプレートをダウンロードする必要があります。</li>
<li>テンプレートの準備はできましたが、依然としてリスナーには到達していません。テンプレートの実行は、実際にはテンプレートとステートをマージすることを意味します。ステートがなければ、フレームワークはテンプレートを実行できず、リスナーにはたどり着けません。</li>
<li>ステートはダウンロードしたり、クライアント側で計算したりする必要があります。頻繁に計算をするということは、ステートを計算するためにさらに多くのコードをダウンロードする必要があることを意味します。</li>
</ol>
<p>すべてのコードがダウンロードされると、フレームワークはステートを計算し、そのステートをテンプレートにフィードすることが可能になります。
そして、ようやくリスナーのクロージャにたどり着き、クロージャをDOMにインストールできます。</p>
<p>インタラクティブなステートに至るには多くの作業が必要です。
現行世代のあらゆるフレームワークはこのように動作しています。
つまり、フレームワークがリスナーを発見してインストールするには、
結局はアプリケーションの大部分をダウンロードして実行しなければなりません。</p>
<h2>クロージャについて</h2>
<p>上記の問題の核は、コードをダウンロードするには大きな処理能力が必要であること、
そしてフレームワークがリスナーを発見し、ページがインタラクティブな状態になるまでに長いCPU時間がかかることです。
しかし、私たちはクロージャがコードとデータを囲い込むという性質を忘れています。
これはとても便利な特性であり、私たちがクロージャを気に入っている理由です。
しかし、これは同時にクロージャのすべてのデータとコードが、
クロージャの実行時に遅延して作成されるのではなく、
クロージャを作成した時点で利用可能でなければならないことも意味します。</p>
<p>例としてシンプルなJSXテンプレートを見てみましょう（ただし、他のテンプレートシステムにも同じ問題があります）。</p>
<div class="gatsby-highlight" data-language="jsx"><pre style="counter-reset: linenumber NaN" class="language-jsx line-numbers"><code class="language-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span>addToCart<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cart'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyBuyButton</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>cost<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    Price<span class="token operator">:</span> <span class="token punctuation">{</span>cost<span class="token punctuation">}</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onclick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">addToCart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      Add to cart
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>
<h2>クロージャによる死</h2>
<p>クロージャはコストが低いため、至るところで見られます。
しかし、クロージャは本当に低コストなのでしょうか。
その答えはイエスでもあり、ノーでもあります。
確かに、ランタイムにおいて短時間で作成できるという意味では低コストです。
しかし、コードを囲い込むために、クロージャがない場合より大幅に早くコードをダウンロードする必要があるという点では高コストです。
さらに、ツリーシェイキングを妨害するという意味でも高コストです。
そのため、筆者が「クロージャによる死」と呼ぶ状況が起きます。
クロージャはDOMに設置されるリスナーであり、実行される可能性がほとんどないコードを囲い込みます。</p>
<p>ページの「購入する」ボタンは複雑な割にしょっちゅうクリックされるようなものではありません。
それでも「購入する」ボタンは、関連するすべてのコードのダウンロードをしきりに促します。
これはクロージャがそのような仕組みになっているためです。</p>
<h2>QwikはリスナーのHTMLシリアライズを可能にする</h2>
<p>これまで、クロージャには隠れたコストがあるかもしれないと説明してきました。
こうしたコストはコードの頻繁なダウンロードという形で生じます。そのため、クロージャを作成し、ユーザとインタラクティブなWebサイトの間に介在させるのは困難です。</p>
<p>Qwikはリスナーの作成を可能な限り遅らせようとします。
これを実現するために、Qwikは以下のルールを掲げています。</p>
<ol>
<li>リスナーはHTMLにシリアライズできなければならない。</li>
<li>ユーザがリスナーとのインタラクションを行うまで、リスナーはコードを囲い込まない。</li>
</ol>
<p>これがどのように実現されるのか、実例で見てみましょう。</p>
<div class="gatsby-highlight" data-language="html"><pre style="counter-reset: linenumber NaN" class="language-html line-numbers"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name"><span class="token namespace">on:</span>click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>MyComponent_click<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Click me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span></span></pre></div>
<p><code class="language-text">MyComponent_click.ts</code>ファイルの内容は以下のとおりです。</p>
<div class="gatsby-highlight" data-language="ts"><pre style="counter-reset: linenumber NaN" class="language-ts line-numbers"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'Clicked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code><span aria-hidden="true" class="line-numbers-rows" style="white-space: normal; width: auto; left: 0;"><span></span><span></span><span></span></span></pre></div>
<p>上記のコードをご覧ください。
SSRはレンダリングプロセスの間にリスナーの場所を発見した後、
その情報を捨てるのではなく、リスナーを属性としてHTMLにシリアライズします。
そのため、クライアントはリスナーの場所を発見するためにテンプレートを再実行する必要がありません。
その代わりとして、Qwikは以下のアプローチをとります。</p>
<ol>
<li><code class="language-text">qwikloader.js</code>をページにインストールする。このファイルのサイズは1KB未満で、実行には1ミリ秒もかからない。ファイルがとても小さくHTMLに埋め込むのが最善の方法であるため、サーバーとのラウンドトリップが不要になる。</li>
<li><code class="language-text">qwikloader.js</code>は、1つのグローバルなイベントハンドラを登録し、バブリングを活用することで、すべてのイベントを同時にリッスンできる。addEventListenerの呼び出しが少なくなるため、インタラクティブな状態までの時間が短くなる。</li>
</ol>
<p>その結果が以下のとおりです。</p>
<ol>
<li>リスナーを発見するためにテンプレートをダウンロードする必要がない。リスナーは属性としてHTMLにシリアライズされる。</li>
<li>リスナーを取得するためにテンプレートを実行する必要がない。</li>
<li>テンプレートを実行するためにステートをダウンロードする必要がない。</li>
<li>すべてのコードが遅延され、ユーザがリスナーとのインタラクションを行うときにのみダウンロードされる。</li>
</ol>
<p>Qwikは現行世代のフレームワークによるブートストラップのプロセスを省略し、1つのグローバルなイベントリスナーで代替します。
この方法が最も優れているのは、アプリケーションのサイズに影響されないところです。
どんなにアプリが大規模で複雑になってもリスナーは1つだけです。
すべての情報がHTMLにシリアライズされているため、ダウンロードすべきブートストラップコードは常に一定で、その容量はアプリケーションの複雑性と無関係です。</p>
<p>まとめると、Qwikの背景にある基本的な考え方は再開性（resumability）です。
Qwikはサーバーの作業が中断された時点から作業を再開し、クライアント側が実行する必要があるファイルはわずか1KBです。
このコードはアプリケーションがどんなに大規模で複雑になっても変わりません。
これから数週間（訳注：原文では定期的に8記事まで公開されています）にわたって、
Qwikがどのように作業を再開し、ステートを管理し、コンポーネントを独立にレンダリングするかを見ていきます。お楽しみに。</p>
<p>私たちはQwikの未来や、Qwikが実現する新たな種類のユースケースに大いに期待しています。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[Qwikの紹介 – HTMLファーストのフレームワーク]]></title><description><![CDATA[Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWe…]]></description><link>https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</link><guid isPermaLink="false">https://postd.cc/a-first-look-at-qwik-the-html-first-framework/</guid><category><![CDATA[開発手法・プロジェクト管理]]></category><category><![CDATA[パフォーマンス]]></category><pubDate>Thu, 24 Nov 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>Builder.ioは、強力なビジュアルエディタにより、開発者ではない人が超高速なサイトを開発・編集できるようにしています。
私たちのビジュアルエディタが優れている点の1つは、AngularからWeb Components、
そしてその間にあるすべてのフレームワークに至るまで、
さまざまなツールで同じサイトを生成できることです。
出力されるコードは速度が最適化されています。
私たちのツールで作成されたサイトは、手作業で作成されたサイトの大部分よりも高速です。
私たちはこれを心から誇りに思っています。
私たちの製品は、スピードがとても重要であるeコマースに焦点を当てています。</p>
<h2>優れたTime to Interactiveの実現は困難</h2>
<p>どんなにコードが最適化されていても、静的HTMLのみを提供していない限り、
eコマースサイトが<a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a>で100点中100点のスコアを達成するのは困難です。
そのため、ほとんどのeコマースサイトは20点程度の赤色スコアとなっています。
高速化に重点的に取り組む余裕がある特に優れたサイトだけが50～60点の黄色スコアを獲得できます。
Builder.ioを利用しても50～60点の黄色スコアを達成できるでしょう。
しかし、私たちはもっと点数を良くしたいのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--hNfE5FAv--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5zttsnsvx80ic0y3v4wa.png"></p>
<h2>HTMLだけなら高速</h2>
<p>とはいえ、静的HTMLを提供すれば点数は良くなります。
ほぼ確実に100点中100点のスコアを獲得できるでしょう。
そもそもPageSpeed Insightsのスコアは、ページがインタラクティブになる前にブラウザが実行しなければならないコードの量に基づいて測定されます。
JavaScriptをまったく実行しないようにすれば、100点満点を獲得し、簡単に緑色スコアに到達できます。
しかし、この方法にはページが静的になるという問題があります。
Webページは動的なコンテンツを提供し、インタラクションに満ちた生き生きとしたものでなければなりません。
静的HTMLで高いスコアを獲得しつつ、同時にリッチなインタラクションを提供するにはどうすれば良いのでしょうか。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--VCPVUPTb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/inff3jmvl300d1yaxaya.png"></p>
<h2>Qwikの導入 – HTMLファーストのフレームワーク</h2>
<p>そこでQwikの登場です。
Qwikは、オープンソースで開発されている、DOM主体で resumable（再開可能な）Webアプリフレームワークです。
QwikはHTMLのサーバーサイドレンダリングの resumability（再開性）と、コードのきめ細かい遅延読み込みに重点を置くことで、
できる限り優れたTime to Interactiveを実現するように設計されています。
説明したいことが盛りだくさんで、今回のブログ記事だけではとてもカバーしきれません。
そこで、説明をいくつかのブログ記事に分割し、今後数週間にわたって投稿する予定です。
Qwikの基本的な目標は、ブラウザの遅延読み込み機能をできる限り活用し、JavaScriptを遅延させ、Time to Interactiveの指標を改善することです。
これは既存のフレームワークとはまさに対照的と言えます。
こうしたフレームワークは、サーバーサイドレンダリングとTime to Interactiveを、
その他すべての設計上の意思決定に影響する主な目標とは捉えておらず、
付け足し程度にしか考えていませんでした。
Qwikの目的は、どんなに遅いモバイル端末でも、Time to Interactiveをほんの一瞬にまで短縮することです。
私たちは、高速な静的ページをユーザに提供しつつ、インタラクティブ性も完全に維持したいと考えています。
つまり、一挙両得を目指しているのです。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--vNxZwFXl--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dy3wa5ewpz9o9xoa87ys.png"></p>
<h2>replayable なフレームワークは作業が多すぎる</h2>
<p>ほとんどのeコマースサイトがPageSpeed Insightsで100点を取れないのには理由があります。
それは、どの既存のフレームワークもTime to Interactiveを念頭に置いて設計されていないということです。
これらのフレームワークは複雑なブートストラップのプロセスを持ち、
ページがインタラクティブになる前に多くのコードをダウンロード・実行する必要があります。
確かに、ほとんどのフレームワークはサーバーサイドレンダリングに対応しており、
初期コンテンツを素早く表示できます。
しかし、ページを再ハイドレートしてインタラクティブな状態にするには、
まずはページ上のすべてのテンプレートをダウンロードし、実行しなければなりません。
現在の既存のサイトが100点を取れずにいるのは、こうしたダウンロードや実行を行わなければならないせいです。
既存のフレームワークは、サイトをインタラクティブにするために、
サーバーサイドレンダリングにおけるすべての作業をクライアント側で再び実施する必要があるため、
replayable（再生型）であると言えます。
サイトが複雑になるにつれて、再生可能な状態を維持するためのコストも増えていきます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--PdQoT-lX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/lqgpauzo2i23f3zhhke8.png"></p>
<h2>resumability が救世主に</h2>
<p>Qwikの背景にある基本的な考え方は resumability です。
Qwikはサーバーの作業が中断された時点から作業を再開できます。
クライアント側で実行するコードはほんの最小限です。
Qwikloaderは、サーバーサイドレンダリングによって生成された静的HTMLを取得し、レンダリングを再開します。
Qwikloaderのサイズは1KB未満で、実行に1ミリ秒もかかりません。
思わず前の文を読み直したくなるかもしれませんが、読み間違いではありません。
実行が必要なコードの量は驚くほど小さく、まばたきよりも短い時間で実行されます。
最も優れているのは、アプリケーションがどんなに大きくなっても、このコードが変わらないことです。
ユーザが最小限の部分でWebサイトとのインタラクションをしている間に、
サイトのその他すべてのインタラクティブな部分が遅れてダウンロードされます。</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ufFUjYds--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/550d4im90829stbvbvs0.png"></p>
<h2>もっと詳しく知る</h2>
<p>私たちが最も重視しているのは、この技術をお客様のために開発することです。
しかし、開発はオープンソースで行われるため、あらゆる人がどんな目的にも利用できます。
私たちはこの技術を汎用的なWebフレームワークとして設計する予定ですが、
お客様が必要とするものを最優先します。</p>
<p>読者の皆様は、もっと詳しい情報を知りたくてたまらないことでしょう。
そこで、皆様をStackBlitzのWebコンテナの<a href="https://stackblitz.com/edit/qwik-todo-demo">デモ</a>にご招待します。
素晴らしいことに、StackBlitzのスタッフはNode.jsをブラウザで実行する能力があり、
そのため私たちはフレームワークの重要な部分である、サーバーサイドレンダリングのデモを行うことができます（彼らに敬意を表します）。
オープンソースのリポジトリは<a href="https://github.com/builderio/qwik">こちら</a>です。
期待が大きくなりすぎないように言っておくと、リポジトリはあくまで概念実証の段階にあり、
多くの物事が時とともに変わると予想されるため、広く利用できる状態ではありません。
それでも、私たちは皆さんの考えを聞きたいと思っています。
ですから、ぜひ<a href="https://discord.gg/JHVpZmqSs4">Discordサーバーでのチャット</a>にご参加ください。</p>
<p>今後数週間（訳注：原文では定期的に8記事まで公開されています）で、
Qwikの背景にある多くのユニークなアイデアを詳しく解説し、
Qwikの仕組みと独自な点を説明していきます。お楽しみに。</p>
<ul>
<li><a href="https://stackblitz.com/edit/qwik-todo-demo">StackBlitz</a>で試す</li>
<li><a href="https://github.com/builderio/qwik">github.com/builderio/qwik</a>でスターを送る </li>
<li><a href="https://twitter.com/QwikDev">@QwikDev</a> と<a href="https://twitter.com/builderio">@builderio</a>をフォロー</li>
<li><a href="https://discord.gg/JHVpZmqSs4">Discord</a>でチャット</li>
<li><a href="https://builder-io.rippling-ats.com/">builder.io</a>の採用情報</li>
</ul>
<h2>シリーズ記事一覧</h2>
<div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p><a href="/series-qwik/">シリーズ記事一覧はこちら</a>から参照できます。</p></div></div>]]></content:encoded></item><item><title><![CDATA[人材マネジメント🤯]]></title><description><![CDATA[初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いてお…]]></description><link>https://postd.cc/managing-people/</link><guid isPermaLink="false">https://postd.cc/managing-people/</guid><category><![CDATA[キャリア・働き方]]></category><category><![CDATA[開発組織]]></category><pubDate>Fri, 14 Oct 2022 00:00:00 GMT</pubDate><content:encoded><![CDATA[<p>初めて会社を起業する人のほとんどは、集団をマネジメントする方法を学ぶ間に、創業当初の従業員を燃え尽き症候群にさせてしまうと思います。
筆者のアドバイスがそのようなケースを減らせるなら、ここに書いておく価値があるでしょう。</p>
<p>筆者は小規模なチームやスタートアップ企業のマネージャーのためにこの記事を書きました。
ほとんどのアドバイスは、大規模な企業のマネジメントには当てはまらないのではないかと思います。
なお、急成長している企業に入社する人への全般的なアドバイスについては<a href="https://klinger.io/posts/joining-hypergrowth-startups-%F0%9F%98%AC">こちら</a>をご覧ください。</p>
<p><strong>筆者について</strong></p>
<ul>
<li>
<p>中・小規模のエンジニアリングチームを数チーム管理した経験あり</p>
<ul>
<li><a href="https://beondeck.com/">On Deck</a>のCTO</li>
<li>CoinListの元エンジニアリング担当VP</li>
<li>AngelListの元リモート責任者</li>
<li>Product Huntの元CTO</li>
</ul>
</li>
</ul>
<p><strong>それでは始めましょう。</strong></p>
<h2>マネージャーはすべての失敗に責任を負う</h2>
<p>分かります……とても前向きなスタートですよね👀</p>
<ul>
<li>チームを怒る意味は全くありません</li>
<li>
<p>あなたはプロセスと人材に責任を負います</p>
<ul>
<li>あなたは常にチームより多くの情報を持っていたはずです</li>
</ul>
</li>
<li>
<p>失敗に至るプロセスを生んだのはあなたです</p>
<ul>
<li>あるいは、誤った人材を採用した（または解雇しなかった）のもあなたです</li>
</ul>
</li>
<li>結局、すべてはあなたの責任です</li>
</ul>
<h2>プロセスを管理し、人を導く</h2>
<ul>
<li>
<p>なぜかは分かりませんが、多くの人にとって、「人材のマネジメント」とは部下の仕事をコントロールしなければならないという意味になるようです</p>
<ul>
<li>彼らはマイクロマネジメントに陥り、目標やスケジュールだけでなく、仕事のやり方まで管理しています</li>
<li>あなたがマイクロマネジメントをする時間があるなら、大抵の場合、あなたの代わりにもっと人件費が安くて能力が低い人を採用し、その人に仕事をさせれば良いのです</li>
</ul>
</li>
<li>
<p>筆者が思うに、こうした行動は、マネージャの役割に関する誤解に起因しています</p>
<ul>
<li>あなたの仕事は人を管理することではありません</li>
<li>しかし、プロセスを管理し、人を導くことができます</li>
</ul>
</li>
<li>マネージャーは、仕事をどのように行うべきか、各メンバーの権限の範囲はどこからどこまでか、どのようにキャリアを形成するか、そしてこれらすべてをどのように議論し、変更できるかに関して、プロセスを管理します</li>
<li>
<p>さらに、手本を示し、共感することで人を導きます</p>
<ul>
<li>メンバーは目標、不安やモチベーションを持っています。仕事以外に問題を抱えていることもよくあります</li>
<li>仮に相手が逆の立場だったら、どう行動してほしいかを考えて行動しましょう</li>
</ul>
</li>
</ul>
<h2>プロセスとは期待を明確にしたもの</h2>
<ul>
<li>
<p>多くの人は「プロセス」に関する責任をなんとか逃れようとしています</p>
<ul>
<li>そのため「プロセスは多過ぎない方が良い」などと言います</li>
<li>筆者の私見では、これも誤解です</li>
</ul>
</li>
<li>
<p>プロセスとは、人々の行動を複雑な鎖のように結びつけ、膨大な手間を負わせるものではありません</p>
<ul>
<li>プロセスとは期待を明確にしたものです</li>
<li>例えば、「誰も作業を邪魔されないように、毎朝全員で〇〇をする」のようにシンプルなものでも構いません</li>
<li>少数のとても明確なプロセスを定め、それが守られるようにしましょう</li>
</ul>
</li>
</ul>
<h2>意思決定と意見</h2>
<ul>
<li>
<p>あらゆる議論、プロジェクト、問題や状況において、誰が意思決定するのかを明確にする必要があります</p>
<ul>
<li>他の人は意見を付け加えるにすぎません</li>
<li>理想的には、その後にフォローアップする（あるいはその仕事のリーダーとなる）人が意思決定をすべきです</li>
<li>それ以外は全員、意見を追加するだけです</li>
<li>「地位」や給与が高い人も例外ではありません</li>
</ul>
</li>
<li>
<p>マネージャーは意思決定を急に止めるためのハンドブレーキを握っています</p>
<ul>
<li>この力は文字どおりハンドブレーキのように扱いましょう</li>
<li>自動車の運転を想像してください。車を止めなければならないのに、ドライバーが反応しなければ、ハンドブレーキを引く必要があります。その結果、反動でダメージが生じるでしょう</li>
<li>絶対に必要なときにのみハンドブレーキを引き、その後に状況をどう修正するか議論します</li>
</ul>
</li>
<li>
<p>採用は意思決定スキルの優劣に基づいて判断します</p>
<ul>
<li>解雇も意思決定スキルの優劣に基づいて判断します</li>
<li>優れた意思決定スキルには他人の意見を聞くことが含まれます</li>
<li>疑問に思う場合は、意思決定者を最初から信頼できるか考えてみてください</li>
</ul>
</li>
</ul>
<h2>当事者意識</h2>
<ul>
<li>
<p>従業員が問題に対して完全な当事者意識を持つようにするのは困難です</p>
<ul>
<li>しかし、それが目標です</li>
<li>それがふさわしくない従業員なら解雇もできます</li>
</ul>
</li>
<li>
<p>フィードバックを提供し、支援しましょう</p>
<ul>
<li>従業員を信頼し、失敗を認めてください（損害を許容できる範囲で）</li>
<li>失敗を「従業員のレベルアップ」と捉えましょう</li>
</ul>
</li>
<li>
<p>最悪なのは、あなたが何度も介入し、従業員が仕事と自分を無関係と感じるようになることです</p>
<ul>
<li>彼らは当事者意識を持たず、言われたことをするだけのドローンになってしまいます</li>
<li>それがあなたの目的なら、人件費が安くて能力が低い人を採用すれば良いでしょう</li>
</ul>
</li>
</ul>
<h2>堂々巡りを避ける</h2>
<ul>
<li>
<p>プロセスを定めるときは、堂々巡りを避けましょう</p>
<ul>
<li>例えば、何かについてフィードバックを提供するときは、相手が言われたとおりにするか、あるいはそれができない理由を答えるだろうと考えてください</li>
<li>承認されることを期待してはいけません</li>
<li>誰もそんなことをしている暇はありません</li>
</ul>
</li>
</ul>
<h2>信頼</h2>
<ul>
<li>
<p>自分が神経質になっているのは、他人の仕事と自分の不安のどちらが原因かを常によく考えましょう</p>
<ul>
<li>他人があなたの感情の面倒を見る必要があるでしょうか？</li>
</ul>
</li>
<li>
<p>物事がうまくいっているときは、人を信頼するのは簡単です</p>
<ul>
<li>本当に難しいのは、物事がうまくいかないときです</li>
<li>状況に対するいら立ちと、人に対するいら立ちを常に区別しましょう</li>
</ul>
</li>
<li>
<p>「距離を置け」と言っているのではありません</p>
<ul>
<li>輪に加わり、目標を定め、意見を表明すべきですが、課題への対処はチームに任せるべきです。ただし、必要に応じてハンドブレーキを使いましょう</li>
</ul>
</li>
</ul>
<h2>率直な共有を通じて信頼を築く</h2>
<ul>
<li>
<p>従業員があなたの仕事を信頼するようになるための最も簡単な方法は、何も要求されなくても、成果を率直に共有することです</p>
<ul>
<li>従業員が探すだろうと思う場所に、すべてを利用可能な状態で置いておきましょう</li>
<li>従業員からの要求を待ってはなりません。ほとんどの従業員は要求をしないからです</li>
</ul>
</li>
</ul>
<h2>信頼は0か1ではない</h2>
<ul>
<li>
<p>私たちは信頼を0か1と考えがちです</p>
<ul>
<li>誰かを信頼するか、信頼しないかのどちらかということです</li>
</ul>
</li>
<li>
<p>しかし、これは正しくありません</p>
<ul>
<li>時とともに、信頼する人や、その人の何をどのように信頼するかは変わります</li>
</ul>
</li>
<li>
<p>信頼はシステム化できるものだと考えましょう</p>
<ul>
<li>例えば、チームの新しいメンバーにはどのような信頼を与えますか？</li>
<li>最初の数週間や1か月はどのような仕事をすることを求めますか？</li>
</ul>
</li>
</ul>
<h2>自律と放任を混同しない</h2>
<ul>
<li>筆者は、人材を採用した後は「好きなようにさせている」という創業者によく会います</li>
<li>これは原則としては正しいものの、従業員の成功を支援する責任から解放されることにはなりません</li>
</ul>
<h2>多層的な意思決定</h2>
<ul>
<li>
<p>会社では、さまざまな階層の人々が、仕事をするうえでお互いに頼りあっています</p>
<ul>
<li>CEOがプロダクトマネージャーの優先順位を認識していなければ、彼らは仕事ができません</li>
</ul>
</li>
<li>
<p>自分の仕事を社内の他人に押し付けてはなりません</p>
<ul>
<li>自分の仕事より楽しそうだからという理由だけで、他人の仕事に踏み込むこともやめましょう</li>
</ul>
</li>
</ul>
<h2>乱射型マネジメントを避ける</h2>
<ul>
<li>
<p>ミーティングで自分の意見やアイデアを手当たり次第にぶつけてはなりません</p>
<ul>
<li>あなたは経緯を十分に理解していない可能性が高く、大抵の場合、課題を最後までフォローする当事者になることはないからです</li>
</ul>
</li>
<li>
<p>単なる意見であって、意思決定ではないことを明確にしてください</p>
<ul>
<li>ただし、「創業者（またはマネージャー）の意見」がほとんどの従業員にとって大きな力を持つことを理解しましょう</li>
<li>一般的に非同期コミュニケーションでは声の「ニュアンス」が伝わりにくいため、<a href="https://klinger.io/posts/fyi-how-founders-can-avoid-drive-by-management">fyi（for your opinion 訳注：ご参考までに）タグ</a>を利用しましょう</li>
</ul>
</li>
</ul>
<p>ところで、筆者はこれを乱射型マネジメントと呼んでいます。なぜなら、グループで議論しているところにマネージャーがやってきて、銃を乱射するように要求、変更指示、アイデアを投げかけ、混乱、パニック、カオスを生み出した後、悲惨な状況を残して去っていくからです。</p>
<h2>フィードバックを提供する</h2>
<ul>
<li>人×文脈 = 成果</li>
<li>
<p>筆者の経験では、優れた人材でも、環境が悪いと不十分な成果しか出せないことがあります</p>
<ul>
<li>一方、とても平凡な人材でも、環境が素晴らしければチーム全体を上回る成果をあげることもあります</li>
</ul>
</li>
<li>
<p>フィードバックをする際、通常はその人自身よりも経緯について客観的に議論するほうが簡単です</p>
<ul>
<li>現在の問題の原因となったのはどのような状況ですか？</li>
<li>何が変わりましたか？現在何が必要とされていますか？</li>
</ul>
</li>
<li>
<p>若手エンジニアが仕事について行けていない場合</p>
<ul>
<li>それはエンジニア自身の責任ですか？それとも、チームは今の時点では、現在、若手が仕事を覚えるための役に立っていないのでしょうか？</li>
<li>すぐに問題になることはありませんが、いずれは解決するか、能力不足を受け入れる（解雇する）ことが必要です</li>
</ul>
</li>
<li>
<p>本番環境で大きなインシデントが発生した場合</p>
<ul>
<li>そもそも、なぜそのような事態が起きたのですか？</li>
<li>エンジニアリングチームは何に注目していましたか？</li>
<li>問題を回避するためのプロセスは導入されていましたか？</li>
<li>プロセスを導入する必要はありますか？</li>
<li>インシデントを起こした従業員に責任はありません</li>
<li>チーム全体が他の優先課題に注目していたからです</li>
<li>
<p>それは適切な理由（リリースへのプレッシャーなど）によるものでしたか？</p>
<ul>
<li>それとも不適切な理由（知識の不足など）によるものでしたか？</li>
</ul>
</li>
</ul>
</li>
<li>
<p>あなたが採用した人材は、モチベーションが高く、最善を尽くそうとしていると常に想定しましょう</p>
<ul>
<li>そうでない人材は解雇しましょう</li>
</ul>
</li>
</ul>
<h2>解雇は決してサプライズであってはならない</h2>
<ul>
<li>
<p>従業員にとって、解雇は決してサプライズであってはなりません</p>
<ul>
<li>状況が変わり、新たな要件が生じたことを伝える必要があります</li>
</ul>
</li>
<li>
<p>通常、従業員を解雇する理由は状況の変化です</p>
<ul>
<li>例えば、会社が変化したとき、</li>
<li>役職に求められるものが変化したときや、</li>
<li>誤った採用基準を定めていたことに気づいたときです</li>
<li>大抵の場合、責任は従業員よりもあなたにあります</li>
</ul>
</li>
<li>
<p>従業員は、自分の努力が新たな要件に足りるものであってほしいと願うかもしれません</p>
<ul>
<li>それでも、あなたが彼らを解雇しようとするときは理解を示すでしょう</li>
</ul>
</li>
</ul>
<h2>解雇を先延ばししない</h2>
<ul>
<li>従業員を解雇すると決定したら、すぐに行動しましょう</li>
<li>
<p>従業員をゾンビのような状態で雇い続けていることはよくあります</p>
<ul>
<li>「彼を解雇すべきだ」</li>
<li>そう思っても解雇しないのです</li>
<li>従業員のためになりません</li>
<li>
<p>従業員はおそらく今の環境に満足していないでしょう</p>
<ul>
<li>評価が低く、</li>
<li>良い仕事もできないからです</li>
</ul>
</li>
<li>
<p>大抵の場合、あなたが解雇を避けるのは自分のためです</p>
<ul>
<li>なぜなら、誰かを解雇するのは良い気分ではないからです</li>
<li>自分の感情や未来を、従業員の感情や未来より気にすることはやめるべきです</li>
</ul>
</li>
</ul>
</li>
<li>
<p>面談を設定し、解雇を伝えます</p>
<ul>
<li>最初に余計なおしゃべりをするのはやめましょう</li>
<li>本題を率直に切り出し、次のステップを明確にしましょう</li>
<li>必ず真剣な事実として伝えます</li>
<li>解雇を伝えるときには、あなたの感情や問題は重要ではないことを忘れないでください</li>
</ul>
</li>
<li>
<p>その後、従業員が新たな仕事を探せるように支援します</p>
<ul>
<li>従業員はかつてキャリアをあなたに委ねたのですから、その信頼を維持しましょう</li>
</ul>
</li>
<li>
<p>最後に：一部の国では、従業員を解雇するのに月によっては数日かかる場合もあります</p>
<ul>
<li>どちらにせよ、解雇のプロセスを主体的に管理し、あなたを信頼している人に敬意を持って接するようにしましょう</li>
<li>彼らはあなたのチームにキャリアを委ねたのです</li>
<li>ほとんどの場合、従業員が去るのは自らの責任ではなく、状況の変化によるものです</li>
<li>彼らが自分に適した新しい仕事を見つけられるように支援しましょう</li>
</ul>
</li>
</ul>
<h2>明確 > 不明確</h2>
<ul>
<li>
<p>ミーティング後の明確な意思決定</p>
<ul>
<li>明確な意思決定がなされていない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>明確な責任者</p>
<ul>
<li>明確な責任者がいない場合は、その事実を明確にしましょう</li>
</ul>
</li>
<li>
<p>全員の意見を聞く</p>
<ul>
<li>誰が意思決定するかを明確にしましょう</li>
<li>意思決定の内容も明確にします</li>
</ul>
</li>
<li>などなど</li>
</ul>
<h2>ベストプラクティス：「現実は正しい」という認識から始める</h2>
<ul>
<li>
<p>チームやプロセスの中でベストプラクティスや変化を求めるときは、まずは既存の自然に生まれたものに必ず注目しましょう</p>
<ul>
<li>優れた人材を採用していれば、通常は彼らが自然と解決策を探し始めています</li>
<li>その解決策は適切でしょうか？もしそうなら明確にしましょう</li>
<li>「現実は正しい」という認識が重要です</li>
<li>もし適切でないなら、それを変える方法について議論しましょう</li>
</ul>
</li>
</ul>
<h2>会社は数カ月ごとにリファクタリングされるものと考える</h2>
<ul>
<li>
<p>急成長しているスタートアップ企業は、3～6カ月ごとに事業の進め方を社内でリファクタリングする必要があります</p>
<ul>
<li>現在必要な最低限の変化のみに取り組みましょう</li>
</ul>
</li>
<li>
<p>決定的な最終バージョンは存在しません</p>
<ul>
<li>あなたは会社のプロセスに対して常に不満を感じ続けるでしょう</li>
<li>伸び悩みに直面しない限り、成長痛は続くはずです</li>
</ul>
</li>
<li>
<p>コードをリファクタリングするときと同じ原則を適用しましょう</p>
<ul>
<li>以下の点に気を付けてください</li>
<li>まずは小規模な隔離された環境でテストする</li>
<li>ピアレビューを行う</li>
<li>すべてを一度に変えようとしない</li>
<li>オーバーエンジニアリングを回避する</li>
<li>などなど</li>
</ul>
</li>
</ul>
<h2>燃え尽き症候群</h2>
<ul>
<li>よくある誤解は、燃え尽き症候群は働き過ぎが原因というものです</li>
<li>
<p>実際の原因は、仕事をコントロールできない、自分が影響を与えられていないと感じることです</p>
<ul>
<li>仕事がほとんどないにもかかわらず、従業員（あるいは自分）が燃え尽きる場合があることを忘れないでください</li>
</ul>
</li>
<li>
<p>従業員が自らの影響をコントロールできるようにするには、どうすれば良いのでしょうか？</p>
<ul>
<li>どうすれば従業員と周囲の混沌とした状況の間に境界線を引けるのでしょうか？</li>
</ul>
</li>
</ul>
<h2>混乱を生み出す人間はそれに気づきにくい</h2>
<ul>
<li>
<p>創業者のよくある不満は、チームが変化について来られないというものです</p>
<ul>
<li>創業者は、大抵は変化に至る背景をよく理解し、変化の前段階を把握しています。また最も重要な点として、創業者は変化をコントロールできます</li>
<li>従業員はそうではありません</li>
</ul>
</li>
</ul>
<h2>自分の部下よりもマネージャーに多くのことを要求すべし</h2>
<ul>
<li>
<p>基本的に、失敗はチームの責任ではなく、マネージャーの責任です</p>
<ul>
<li>物事に関する率直な意見をマネージャーと個人的に共有しましょう</li>
</ul>
</li>
<li>基本的に、マネージャーが意思決定できるように信頼すべきです</li>
<li>
<p>マネージャーは結果に対する説明責任を負います</p>
<ul>
<li>すべての失敗に責任があります</li>
<li>しかし、成功はマネージャーの手柄ではありません</li>
<li>成功はチームの手柄です</li>
</ul>
</li>
<li>
<p>マネージャーは、可能なときはいつでも、成功を一人占めするのではなくチームにスポットライトを当てるべきです</p>
<ul>
<li>ポイントは簡単です。チームに与える権限を増やすとともに、チームが輝くための方法を増やしましょう</li>
</ul>
</li>
</ul>
<p>気分が明るくなるような結論ですね😬</p>
<p>とにかく……この記事が誰かの役に立つことを願っています🙏</p>
<p>当然、筆者が見逃していることも数多くあるでしょう。ですから、<a href="https://twitter.com/andreasklinger">twitter</a>でお気軽にご質問ください。また、この記事を改善するためのアイデアがあれば、<a href="https://github.com/andreasklinger/klinger-io">プルリクエストをお送りください</a>。</p>
<p>この記事が気に入ったら<a href="https://twitter.com/intent/tweet?text=Managing%20People%20an%20article%20by%20%40andreasklinger%3A%20https%3A%2F%2Fklinger.io%2Fposts%2Fmanaging-people-%25F0%259F%25A4%25AF">シェアしていただけると幸いです</a>。</p>
<p>追伸：<a href="https://www.notion.so/odteam/Product-Engineer-Playbook-859b2c4c95f849788554f1749d038c6f">筆者のチーム</a>は人材を募集中です</p>]]></content:encoded></item></channel></rss>